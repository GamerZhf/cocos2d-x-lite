require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"AudioMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd2df2LGO/FCOJQCrG5T+a4t', 'AudioMgr');
// Scripts\Manager\AudioMgr.js

"use strict";

//音乐管理器
var M = cc.Class({

    properties: {
        bgmVolume: 1.0,
        sfxVolume: 1.0
    },

    // use this for initialization
    init: function init() {
        var t = cc.sys.localStorage.getItem("gbmVolume");
        if (t != null) {
            this.setBGMVolume(t);
        } else {
            this.setBGMVolume(1.0);
        }

        var t = cc.sys.localStorage.getItem("sfxVolume");
        if (t != null) {
            this.setSFXVolume(t);
        } else {
            this.setSFXVolume(1.0);
        }

        var self = this;
        cc.game.on(cc.game.EVENT_HIDE, function () {
            console.log("cc.audioEngine.pauseAll");
            self.save();
            cc.audioEngine.pauseAll();
        });

        cc.game.on(cc.game.EVENT_SHOW, function () {
            console.log("cc.audioEngine.resumeAll");
            cc.audioEngine.resumeAll();
        });
    },

    play: function play(clipName, name, loop) {
        var clipname = "_" + clipName;
        if (!this[clipname]) {
            var self = this;
            cc.loader.loadRes('Sound/' + clipName, cc.AudioClip, function (err, clip) {
                self[clipname] = clip;
                cc.audioEngine[name](self[clipname], loop);
            });
        } else {
            cc.audioEngine[name](this[clipname], loop);
        }
    },

    playBGM: function playBGM(clipName) {
        if (this.bgmName != clipName) {
            this.bgmName = clipName;
            this.play(clipName, "playMusic", true);
        }
    },

    playSFX: function playSFX(clipName) {
        if (this.sfxVolume > 0) {
            this.play(clipName, "playEffect", false);
        }
    },

    setBGMVolume: function setBGMVolume(value) {
        this.bgmVolume = value;
        cc.audioEngine.setMusicVolume(value);
    },

    getBGMVolume: function getBGMVolume() {
        return this.bgmVolume;
    },

    setSFXVolume: function setSFXVolume(value) {
        this.sfxVolume = value;
        cc.audioEngine.setEffectsVolume(value);
    },

    getSFXVolume: function getSFXVolume() {
        return this.sfxVolume;
    },

    pauseAll: function pauseAll() {
        this.isPause = true;
        cc.audioEngine.pauseAll();
    },

    resumeAll: function resumeAll() {
        this.isPause = false;
        cc.audioEngine.resumeAll();
    },

    save: function save() {
        cc.sys.localStorage.setItem("gbmVolume", this.bgmVolume);
        cc.sys.localStorage.setItem("sfxVolume", this.sfxVolume);
    }

});

cc.audiomanager = new M();

cc._RF.pop();
},{}],1:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":2}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"CardMoveEvent":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'e54abXhmzNCsJ+pA9pty28+', 'CardMoveEvent');
// Scripts\Gui\CardMoveEvent.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...

        parentNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onAnimCompleted: function onAnimCompleted(num) {
        this.parentNode.getComponent("UIPokerGame").onAnimCompleted(num);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"ChatBubble":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fb85fG/wFtIZ6gsoDziwHyw', 'ChatBubble');
// Scripts\Gui\Widget\ChatBubble.js

'use strict';

cc.Class({
    extends: cc.Component,

    properties: {
        text: cc.Label,
        face: cc.Animation,
        faceSprite: cc.Sprite
    },

    // use this for initialization
    onLoad: function onLoad() {
        var self = this;
    },

    showText: function showText(msg) {
        this.node.width = 200;
        this.text.node.active = true;
        this.face.node.active = false;
        this.text.string = msg;
        cc.log('test:' + msg);
    },
    showFace: function showFace(id) {
        this.node.width = 200;
        this.text.node.active = false;
        this.face.node.active = true;
        this.face.play("face_" + id);
        // this.face.spriteFrame = cc.gamemanager.createFace(id)
        // cc.log('this.face.spriteFrame:' + this.face.spriteFrame)
    },
    showVoice: function showVoice(data) {
        this.node.width = 80;
        cc.log('cc.gamemanager.speakSprite:' + cc.gamemanager.speakSprite);
        this.faceSprite.spriteFrame = cc.gamemanager.speakSprite;
        this.face.stop();
        this.text.node.active = false;
        this.face.node.active = true;
        cc.immanager.playRecord(data);
    }
});

cc._RF.pop();
},{}],"ConfigManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd4e15rene1Jw5lBLEELzsz9', 'ConfigManager');
// Scripts\Manager\ConfigManager.js

"use strict";

//保存一些客户端配置

var M = cc.Class({

        ctor: function ctor() {

                this.testClient = true;
                this.version = "1.6";

                if (cc.sys.isMobile) {
                        if (this.testClient) {
                                this.serverIP = "119.23.43.19"; //"119.23.71.237" 
                        } else {
                                this.serverIP = "119.23.71.237"; //"119.23.71.237" 
                        }
                } else {
                        if (this.testClient) {
                                this.serverIP = "119.23.43.19"; //"119.23.71.237" 
                        } else {
                                this.serverIP = "119.23.71.237"; //"119.23.71.237" 
                        }
                }
                this.serverPort = 7000;

                this.nickName1 = ["花呆▲", "紫殇", "夏殇", "凉生", "泉眼", "こ鬽蔹", "无范", "┉雪兔", "素顔", "破曉丶", "╮淩亂", "痴心°"];

                this.nickName2 = ["嘦您", "嘟嘟", "陌殇〆", "失心", "苦撑", "笑靥", "心凉゛", "殤城〤", "土豪", "魅瞳づ"];

                this.wndScale = cc.view.getFrameSize().height / 720;

                cc.log("getFrameSize: ", cc.view.getFrameSize().width, cc.view.getFrameSize().height);

                //房间头像位置(从自己开始逆时针方向，除自己外最多五名玩家)
                var scale = this.wndScale;
                var sx = cc.view.getFrameSize().width / 2;
                this.headIconPos = [[cc.v2(0, 188)], //2人
                [cc.v2(300 / scale, 160), cc.v2(-300 / scale, 160)], //3人
                [cc.v2((sx - 50) / scale, -40), cc.v2(0, 188), cc.v2((-sx + 50) / scale, -40)], //4人
                [cc.v2((sx - 50) / scale, -40), cc.v2(300 / scale, 150), cc.v2(-300 / scale, 150), cc.v2((-sx + 50) / scale, -40)] //5人
                ];

                this.yunyin_sdk_id = 1001664;

                //牌型图片配置
                this.pokerFlopCfg = [{ "name": "乌龙", "sound_male": "M_wulong", "sound_female": "F_wulong", "texres": "Textures/PokerStyle/wulong" }, { "name": "对子", "sound_male": "M_duizi", "sound_female": "F_duizi", "texres": "Textures/PokerStyle/duizi" }, { "name": "两对", "sound_male": "M_liangdui", "sound_female": "F_liangdui", "texres": "Textures/PokerStyle/liangdui" }, { "name": "三条", "sound_male": "M_santiao", "sound_female": "F_santiao", "texres": "Textures/PokerStyle/santiao" }, { "name": "顺子", "sound_male": "M_shunzi", "sound_female": "F_shunzi", "texres": "Textures/PokerStyle/shunzi" }, { "name": "同花", "sound_male": "M_tonghua", "sound_female": "F_tonghua", "texres": "Textures/PokerStyle/tonghua" }, { "name": "葫芦", "sound_male": "M_hulu", "sound_female": "F_hulu", "texres": "Textures/PokerStyle/hulu" }, { "name": "铁支", "sound_male": "M_tiezhi", "sound_female": "F_tiezhi", "texres": "Textures/PokerStyle/tiezhi" }, { "name": "同花顺", "sound_male": "M_tonghuashun", "sound_female": "F_tonghuashun", "texres": "Textures/PokerStyle/tonghuashun" }, { "name": "五同", "sound_male": "wutong", "sound_female": "wutong", "texres": "Textures/PokerStyle/wutong" }];

                //特殊牌型图片配置
                this.specialFlopCfg = [{ "name": "无", "sound_male": "none", "sound_female": "none", "texres": "Textures/PokerStyle/wulong" }, { "name": "三同花", "sound_male": "M_santonghua", "sound_female": "F_santonghua", "texres": "Textures/PokerStyle/santonghua" }, { "name": "三顺子", "sound_male": "M_sanshunzi", "sound_female": "F_sanshunzi", "texres": "Textures/PokerStyle/sanshunzi" }, { "name": "六对半", "sound_male": "M_liuduiban", "sound_female": "F_liuduiban", "texres": "Textures/PokerStyle/liuduiban" }, { "name": "五对三条", "sound_male": "wuduisantiao", "sound_female": "wuduisantiao", "texres": "Textures/PokerStyle/wuduisantiao" }, { "name": "四套三条", "sound_male": "sitaosantiao", "sound_female": "sitaosantiao", "texres": "Textures/PokerStyle/sitaosantiao" }, { "name": "凑一色", "sound_male": "couyise", "sound_female": "couyise", "texres": "Textures/PokerStyle/couyise" }, { "name": "全小", "sound_male": "quanxiao", "sound_female": "quanxiao", "texres": "Textures/PokerStyle/quanxiao" }, { "name": "全大", "sound_male": "quanda", "sound_female": "quanda", "texres": "Textures/PokerStyle/quanda" }, { "name": "三套炸弹", "sound_male": "santaozhadan", "sound_female": "santaozhadan", "texres": "Textures/PokerStyle/santaozhadan" }, { "name": "三同花顺", "sound_male": "santonghuashun", "sound_female": "santonghuashun", "texres": "Textures/PokerStyle/santonghuashun" }, { "name": "十二皇族", "sound_male": "shierhuangzu", "sound_female": "shierhuangzu", "texres": "Textures/PokerStyle/shierhuangzu" }, { "name": "一条龙", "sound_male": "yitiaolong", "sound_female": "yitiaolong", "texres": "Textures/PokerStyle/yitiaolong" }, { "name": "清龙", "sound_male": "qinglong", "sound_female": "qinglong", "texres": "Textures/PokerStyle/qinglong" }];

                this.upercaseFigure = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];

                this.summarypos = [[cc.v2(-130, 58), cc.v2(130, 58)], [cc.v2(-260, 58), cc.v2(0, 58), cc.v2(260, 58)], [cc.v2(-390, 58), cc.v2(-130, 58), cc.v2(130, 58), cc.v2(390, 58)], [cc.v2(-510, 58), cc.v2(-255, 58), cc.v2(0, 58), cc.v2(255, 58), cc.v2(510, 58)]];

                //牌型名字（2,3墩5张牌)
                this.t5Name = ["五同", "同花顺", "铁支", "葫芦", "同花", "顺子", "三条", "两对", "对子", "乌龙"];
                this.t3Name = ["三条", "对子", "乌龙"];

                //打枪角度, cc.v2.x 旋转角度  cc.v2.y scaleX
                this.dqAngle = [];
                this.dqAngle[3] = [[cc.v2(0, 1), cc.v2(-48, 1), cc.v2(0, -1)], [cc.v2(-126, -1), cc.v2(0, 1), cc.v2(-70, -1)], [cc.v2(61, 1), cc.v2(0, 1), cc.v2(0, 1)]];

                this.dqAngle[4] = [[cc.v2(0, 1), cc.v2(0, 1), cc.v2(-50, 1), cc.v2(0, -1)], [cc.v2(-70, -1), cc.v2(0, 1), cc.v2(-10, -1), cc.v2(-36, -1)], [cc.v2(-125, -1), cc.v2(65, 1), cc.v2(0, 1), cc.v2(-65, -1)], [cc.v2(65, 1), cc.v2(35, 1), cc.v2(10, 1), cc.v2(0, 1)]];

                this.dqAngle[5] = [[cc.v2(0, 1), cc.v2(0, 1), cc.v2(-15, 1), cc.v2(22, -1), cc.v2(0, -1)], [cc.v2(-70, -1), cc.v2(0, 1), cc.v2(6, -1), cc.v2(-16, -1), cc.v2(-38, -1)], [cc.v2(-104, -1), cc.v2(90, 1), cc.v2(0, 1), cc.v2(-39, -1), cc.v2(-59, -1)], [cc.v2(98, 1), cc.v2(69, 1), cc.v2(35, 1), cc.v2(0, 1), cc.v2(-90, -1)], [cc.v2(73, 1), cc.v2(30, 1), cc.v2(16, 1), cc.v2(-14, 1), cc.v2(0, 1)]];

                //机器人头像icon
                this.robotHeadIcons = ["Textures/robotheads/1", "Textures/robotheads/2", "Textures/robotheads/3", "Textures/robotheads/4", "Textures/robotheads/5", "Textures/robotheads/6", "Textures/robotheads/7", "Textures/robotheads/8", "Textures/robotheads/9", "Textures/robotheads/10"];
        }
});

cc.configmanager = new M();

cc._RF.pop();
},{}],"DataManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2307bIa+iBNorYNK5W+/1D1', 'DataManager');
// Scripts\Manager\DataManager.js

"use strict";

//数据管理器，存储全局数据
var M = cc.Class({

    ctor: function ctor() {
        this.nickName1 = ["上官", "欧阳", "东方", "端木", "独孤", "司马", "南宫", "夏侯", "诸葛", "皇甫", "长孙", "宇文", "轩辕", "东郭", "子车", "东阳", "子言"];

        this.nickName2 = ["雀圣", "赌侠", "赌圣", "稳赢", "不输", "好运", "自摸", "有钱", "土豪"];

        //主人物基本数据
        this.mainPlayerData = {};
        this.mainPlayerData.cuid = 0, this.mainPlayerData.nick_name = "", this.mainPlayerData.penid = "";
        this.mainPlayerData.sex = 0;
        this.mainPlayerData.url = null;
        this.gmNotice = null;

        this.headURL = [];

        //字体
        this.winFnt = null;
        this.loseFnt = null;
        this.hasOpenNotice = false;
    },

    dispachMsg: function dispachMsg(name, data) {
        if (typeof this[name] == 'function') {
            this[name](data);
        }
    },

    PublicProto_S_Notice: function PublicProto_S_Notice(data) {
        if (data.type == 1) {
            cc.guimanager.msgBox(data.text);
        } else if (data.type == 2) {
            this.gmNotice = data.text;
        } else if (data.type == 3) {
            this.notice = data.text;
        }
    },

    saveRoomSetting: function saveRoomSetting(setting) {
        this.roomSetting = setting;
    },
    getRoomSetting: function getRoomSetting() {
        return this.roomSetting;
    },

    getUserOpenId: function getUserOpenId() {
        var id = cc.sys.localStorage.getItem("userOpenId");
        if (id == null) {
            var num = Math.floor(Math.random() * 1000000000);
            id = num.toString();
            cc.sys.localStorage.setItem("userOpenId", id);
        }
        return id;
    },

    createRandomName: function createRandomName() {
        var nickName1 = cc.configmanager.nickName1;
        var nickName2 = cc.configmanager.nickName2;
        return nickName1[Math.floor(Math.random() * (nickName1.length - 1))] + nickName2[Math.floor(Math.random() * (nickName2.length - 1))];
    },

    getNickName: function getNickName() {
        var nickname = cc.sys.localStorage.getItem("userNickName");
        if (nickname == null) {
            nickname = this.createRandomName();
            cc.sys.localStorage.setItem("userNickName", nickname);
        }
        return nickname;
    },

    getRobotHeadIcon: function getRobotHeadIcon() {
        var allheads = cc.configmanager.robotHeadIcons;
        if (!allheads || allheads.length == 0) {
            return "";
        }

        var idx = Math.floor(Math.random() * allheads.length);
        if (idx >= 0 && idx < allheads.length) {
            return allheads[idx];
        }
        return allheads[0];
    },

    copyToClipboard: function copyToClipboard(strText) {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("org/cocos2dx/javascript/AppActivity", "copyToClipboard", "(Ljava/lang/String;)I", strText);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("AppController", "copyToClipboard:", strText);
        } else {
            cc.log('该平台不支持复制:' + strText);
        }
    },

    loadHeadImg: function loadHeadImg(url, sp) {

        if (!sp || !url || url == "") return;

        //加载本地图片
        if (url.indexOf("Textures/robotheads/") != -1) {
            cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
                sp.spriteFrame = spriteFrame;
            });
        }

        if (!cc.sys.isMobile) return;

        var text = null;
        if (this.headURL) {
            for (var i = 0; i < this.headURL.length; ++i) {
                if (this.headURL[i].url == url) {
                    text = this.headURL[i].spriteFrame;
                    break;
                }
            }
        } else {
            this.headURL = [];
        }
        if (text) {
            sp.spriteFrame = text;
        } else {
            var self = this;
            cc.loader.load({ url: url, type: 'png' }, function (err, tex) {
                var frame = new cc.SpriteFrame(tex);
                sp.spriteFrame = frame;
                self.headURL.push({
                    url: url,
                    spriteFrame: frame
                });
            });
        }
    },

    setScoreFont: function setScoreFont(win, label) {
        label.isSystemFontUsed = false;
        label.fontSize = 32;

        if (win) {
            if (cc.datamanager.winFnt) {
                label.font = cc.datamanager.winFnt;
            } else {
                cc.loader.loadRes('Fonts/winfont', function (error, res) {
                    if (error) {
                        cc.log('Error: ' + error);return;
                    }
                    cc.datamanager.winFnt = res;
                    label.font = cc.datamanager.winFnt;
                });
            }
        } else {
            if (cc.datamanager.loseFnt) {
                label.font = cc.datamanager.loseFnt;
            } else {
                cc.loader.loadRes('Fonts/losefont', function (error, res) {
                    if (error) {
                        cc.log('Error: ' + error);return;
                    }
                    cc.datamanager.loseFnt = res;
                    label.font = cc.datamanager.loseFnt;
                });
            }
        }
    }
});

cc.datamanager = new M();

cc._RF.pop();
},{}],"GameManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ba526NcqlNN2qgcNxBxFSq7', 'GameManager');
// Scripts\Manager\GameManager.js

"use strict";

//游戏管理器，进入房间后的数据和逻辑管理
var M = cc.Class({

    ctor: function ctor() {
        this._players = []; //房间玩家信息，包括自己

        this.initDefaultPokers();

        //this._currentMatchIdx = 0;      //服务器发来的当前第几局【和客户端的局数不一样】

        this._currentRounds = 0; //当前是第几局,客户端保存的当前局

        this.normalProcess = false; //标记是否正常流程还是掉线后再上线流程（正常流程在房间要点准备）

        //自己的状态
        this._selfStatus = 0;

        //其他人的最低状态
        this._otherStatus = 0;

        this.coin = 0; //金币数量
        this.diamond = 0; //水晶数量

        this.matchRanks = []; //保存每局结束玩家的积分数据
    },

    initDefaultPokers: function initDefaultPokers() {
        this._myPokerValues = [];
        //this._myPokerValues.push([18,42,8,7,6,5,38,26,17,25,37,21,19]);   //我手上的十三张牌, 第0局测试数据
    },

    dispachMsg: function dispachMsg(name, data) {
        if (typeof this[name] == 'function') {
            this[name](data);
        }
    },

    //创建或加入房间返回成功
    PublicProto_S_G13_RoomAttr: function PublicProto_S_G13_RoomAttr(msg) {
        if (msg.room_code != 0) {
            this.room_info = msg;
            this.gameStart();
        }
    },

    //刷新房间玩家数据
    PublicProto_S_G13_PlayersInRoom: function PublicProto_S_G13_PlayersInRoom(msg) {
        cc.log("收到加入房间消息 size =" + msg.players.length, "rounds = ", msg.rounds);
        this._players = msg.players;
        cc.guimanager.dispachMsg("onPlayerInRoom", this._players);

        this._otherStatus = 5;
        var selfCuid = cc.datamanager.mainPlayerData.cuid;
        for (var i = 0; i < msg.players.length; ++i) {

            var pdata = msg.players[i];
            var rank = { "cuid": pdata.cuid, "rank": pdata.rank };

            if (!this.matchRanks[msg.rounds]) {
                this.matchRanks[msg.rounds] = [];
            }
            this.matchRanks[msg.rounds].push(rank);

            if (pdata.cuid.eq(selfCuid)) {
                this._selfStatus = pdata.status;
                continue;
            }

            if (pdata.status < this._otherStatus) {
                this._otherStatus = pdata.status;
            }
        }
    },

    //获取当前局玩家的积分数据
    getCurMatchRank: function getCurMatchRank(cuid) {
        if (!this.matchRanks || !this.matchRanks[this._currentRounds]) {
            return 0;
        }

        var data = this.matchRanks[this._currentRounds];
        for (var i = 0; i < data.length; ++i) {
            if (data[i].cuid.eq(cuid)) {
                return data[i].rank;
            }
        }
        return 0;
    },

    //刷新玩家货币数据
    PublicProto_S_PlayerBasicData: function PublicProto_S_PlayerBasicData(msg) {
        this.coin = msg.money1;
        this.diamond = msg.money;
        cc.guimanager.dispachMsg("refreshMainPlayerMoney");
    },

    getPlayer: function getPlayer(id) {
        cc.log("this._players.length:" + this._players.length);
        if (this._players) {
            for (var i = 0; i < this._players.length; ++i) {
                if (this._players[i].cuid.eq(id)) {
                    return this._players[i];
                }
            }
        }
        return null;
    },

    mainPlayer: function mainPlayer() {
        return this.getPlayer(cc.datamanager.mainPlayerData.cuid);
    },

    //游戏开始调用
    gameStart: function gameStart() {
        if (this.room_info && cc.director.getScene().name == "Main") {
            cc.scenemanager.loadPokerGameScene();

            if (!this.speakSprite) {
                var self = this;
                cc.loader.loadRes('Textures/speak', cc.SpriteFrame, function (err, spriteFrame) {
                    self.speakSprite = spriteFrame;
                });
            }
            // this._faces = []
            // var self = this
            // for (var i = 1; i <= 15; ++i)
            // {
            //     (function(){
            //     var index = i
            //     var s = self
            //     var func = function(err,sf){
            //         s._faces[index - 1] = sf
            //     }
            //     cc.loader.loadRes('Textures/expression' + index,cc.SpriteFrame,func)
            //     })()
            // }
        }
    },

    //游戏结束调用
    gameOver: function gameOver() {

        cc.log("gameOver调用！！gameOver调用！！gameOver调用！！gameOver调用！！");

        this.room_info = null;
        this._players = [];
        this._currentRounds = 0;
        this.initDefaultPokers();
        this.allRoundsData = [];

        this.normalProcess = false;
        this._selfStatus = 0;
        this._otherStatus = 0;
        this.matchRanks = [];
        // for (var i = 0; i < this._faces.length; ++i)
        // {
        //     if (this._faces[i])
        //     {
        //         cc.loader.releaseAsset(this._faces[i])
        //     }
        // }
        // this._faces = null
    },

    // createFace:function(faceid){
    //     if (this._faces && faceid <= this._faces.length)
    //     {
    //         var prefab = this._faces[faceid - 1]
    //         cc.log('prefab:' + prefab)
    //         return cc.instantiate(prefab)
    //     }
    //     return null
    // },

    //获取当前局的13张牌
    getCurMathPokers: function getCurMathPokers() {
        var pokers = this._myPokerValues[this._currentRounds];
        if (!pokers) {
            return [];
        } else {
            return pokers;
        }
    },

    _printArray: function _printArray(a) {
        var str = "";
        for (var i = 0; i < a.length; ++i) {
            str += a[i].toString() + "  ";
        }
        cc.log(str);
    },

    //收到发牌消息
    PublicProto_S_G13_HandOfMine: function PublicProto_S_G13_HandOfMine(msg) {
        cc.log("收到发牌消息, 牌数量 = " + msg.cards.length);
        this._printArray(msg.cards);

        if (msg.cards.length != 13) {
            cc.log("牌数据不对！");
            return;
        }

        cc.log("第" + msg.rounds + "局");

        var len = this._myPokerValues.length;

        this._myPokerValues[msg.rounds] = msg.cards;

        if (this._currentRounds == 0) {
            this._currentRounds = msg.rounds;
        }

        if (this.normalProcess == true && len == 0) {
            //开始第一把
            cc.guimanager.dispachMsg("newMatchStart");
        }
    },

    //收到总结算消息
    PublicProto_S_G13_AllRounds: function PublicProto_S_G13_AllRounds(msg) {
        cc.log("收到总结算消息");

        this.allRoundsData = msg.players;
    },

    //新的一局
    nextMatch: function nextMatch() {
        if (this._currentRounds > this.room_info.attr.rounds) {
            cc.guimanager.msgBox("牌局结束");
            return;
        }
        this._currentRounds++;
        var root = cc.find("UIPokerGame");
        root.getComponent("UIPokerGame").newMatchStart();
    },

    //投票协议
    PublicProto_S_G13_AbortGameOrNot: function PublicProto_S_G13_AbortGameOrNot(msg) {
        this.voteInfo = msg;
        cc.guimanager.showOrOpenUI('UIVote');
    },

    //投票失败
    PublicProto_S_G13_VoteFailed: function PublicProto_S_G13_VoteFailed(msg) {
        cc.guimanager.closeByName('UIVote');
        var name = cc.gamemanager.getPlayer(msg.opponent).name;
        cc.guimanager.msgBox('玩家:'.concat(name, ',不同意,投票未通过,游戏继续。'));
    },

    giveup: function giveup(event) {
        var msg = cc.netmanager.msg("PublicProto.C_G13_GiveUp");
        cc.netmanager.send(msg);
    },

    //是否在练习房间
    isPracticeRoom: function isPracticeRoom() {
        return this.room_info && this.room_info.robot;
    }

});

cc.gamemanager = new M();

cc._RF.pop();
},{}],"GameResult":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0819cPL4HJGvYNThxflGW47', 'GameResult');
// Scripts\Gui\GameResult.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        time: cc.Label,
        count: cc.Label,
        bigJsPanel: cc.Prefab,
        timecd: cc.RichText
    },

    // use this for initialization
    onLoad: function onLoad() {

        this.cd = 120;
        this.node.runAction(cc.repeatForever(cc.sequence(cc.delayTime(1.0), cc.callFunc(function (target, param) {
            param.cd = param.cd - 1;

            var roomAttr = cc.gamemanager.room_info.attr;
            param.timecd.string = "<color=#FF0000>" + param.cd.toString() + "</c>秒后自动离开";
            if (param.cd == 0) {
                param.close();
            }
        }, this, this))));
    },

    initializeGameResult: function initializeGameResult(data) {

        var playerNum = cc.gamemanager.room_info.attr.player_size;
        this.count.string = cc.gamemanager.room_info.attr.rounds.toString() + "局";

        if (!data) {
            return;
        }

        var biggestScore = -10000;
        var smallSocre = 10000;
        var panelList = [];

        var container = this.node.getChildByName("container");
        var poses = cc.configmanager.summarypos[playerNum - 2];
        for (var i = 0; i < playerNum; ++i) {
            var node = cc.instantiate(this.bigJsPanel);
            var com = node.getComponent("bigJsPanel");
            com.init(data[i]);

            node.position = cc.v2(0, 0);
            node.parent = container;
            //node.position = poses[i]
            panelList.push(com);

            var rank = data[i].rank;
            if (rank > biggestScore) {
                biggestScore = rank;
            }
            if (rank < smallSocre) {
                smallSocre = rank;
            }

            if (cc.datamanager.mainPlayerData.cuid.eq(data[i].cuid)) {
                if (rank > 0) {
                    cc.audiomanager.playSFX("win");
                } else if (rank < 0) {
                    cc.audiomanager.playSFX("lose");
                }
            }
        }

        //curwidth = frameheight/720*1280
        //sacle = framewidth/curwidth = framewidth/(1280*frameheigth/720)
        var scale = cc.view.getFrameSize().width / (1.8 * cc.view.getFrameSize().height);
        container.scale = scale;

        for (var i = 0; i < playerNum; ++i) {
            panelList[i].setState(false, false);
            if (data[i].rank == biggestScore && biggestScore > 0) {
                panelList[i].setState(true, false);
            }
            //if(data[i].rank == smallSocre && smallSocre < 0){
            //    panelList[i].setState(false, true)
            //}
        }

        this.time.string = this.getNowFormatDate().toString();
    },

    share: function share() {
        cc.guimanager.open('UIShare', function (panel) {
            panel.setType(1);
        });
    },

    close: function close() {

        if (!cc.gamemanager.isPracticeRoom()) {
            var msg = cc.netmanager.msg("PublicProto.C_G13_GiveUp");
            cc.netmanager.send(msg);
        }

        this.node.destroy();
        cc.scenemanager.loadMainScene();
    },

    getNowFormatDate: function getNowFormatDate() {
        var date = new Date();
        var seperator1 = "-";
        var seperator2 = ":";
        var month = date.getMonth() + 1;
        var strDate = date.getDate();
        if (month >= 1 && month <= 9) {
            month = "0" + month;
        }
        if (strDate >= 0 && strDate <= 9) {
            strDate = "0" + strDate;
        }
        var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + " " + date.getHours() + seperator2 + date.getMinutes() + seperator2 + date.getSeconds();
        return currentdate;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"GuiManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bc58aNIfmBAPaAtobwrO1iF', 'GuiManager');
// Scripts\Manager\GuiManager.js

'use strict';

var M = cc.Class({

    ctor: function ctor() {
        this.panels = {};
    },

    dispachMsg: function dispachMsg(name, msgdata) {
        for (var key in this.panels) {
            var list = this.panels[key];
            if (list) {
                for (var i = 0; i < list.length; ++i) {
                    var p = list[i];
                    if (typeof p[name] == 'function') {
                        p[name](msgdata);
                    }
                }
            }
        }
    },

    open: function open(name, call, bvisible) {
        var self = this;

        cc.loader.loadRes('Gui/' + name, function (err, prefab) {
            if (prefab != null) {
                cc.log("prefab load success ", prefab);
                var obj = cc.instantiate(prefab);
                obj.parent = cc.director.getScene();
                var panel = obj.getComponent(cc.uipanel);
                var list = self.panels[name];
                cc.log('open list:' + list);
                if (!list) {
                    cc.log('add list:' + name);
                    list = [];
                    self.panels[name] = list;
                }

                panel.onCreate();
                if (bvisible == undefined) panel.setVisible(true);else {
                    panel.setVisible(bvisible);
                }

                //特殊处理层级
                if (name == "UIVote" || name == "UIMessageBox" || name == "UIWaiting") {
                    if (panel && panel.node) {
                        panel.node.zIndex = 10;
                    }
                }

                list.push(panel);

                if (call != null) //放在self.panels add之后，目的为了callback内可以dispatch message
                    call(panel);

                return panel;
            } else {
                cc.log('open panel fail:' + name);
            }
        });
    },

    showOrOpenUI: function showOrOpenUI(name) {
        var panel = this.getByName(name);
        if (panel) {
            panel.setVisible(true);
        } else {
            this.open(name, null, true);
        }
    },

    msgBox: function msgBox(msg, func) {
        cc.audiomanager.playSFX("msgbox");
        this.open('UIMessageBox', function (panel) {
            panel.setMessage(msg);
            panel.setCall(func);
        });
    },

    msgBoxWithCancel: function msgBoxWithCancel(msg, func, cancelfunc) {
        cc.audiomanager.playSFX("msgbox");
        this.open("UIMessageBox", function (panel) {
            panel.setMessage(msg);
            panel.setCall(func);
            panel.setCancelCall(cancelfunc);
        });
    },

    wait: function wait(msg) {
        cc.log(msg);
        this.open('UIWaiting', function (panel) {
            panel.setMessage(msg);
        });
    },

    closeWait: function closeWait() {
        this.closeByName('UIWaiting');
    },

    destroyPanel: function destroyPanel(panel) {
        if (panel && panel.node) {
            panel.onClose();
            panel.node.destroy();

            cc.log("destroyPanel destroyPanel destroyPanel");
        }
    },

    close: function close(panel) {
        for (var key in this.panels) {
            var list = this.panels[key];
            if (list) {
                for (var i = list.length - 1; i >= 0; --i) {
                    if (list[i] == panel) {
                        this.destroyPanel(panel);
                        cc.log("after destroy panel", list, list.leng);
                        cc.log('list.count:' + list.length);
                        list.splice(i, 1);
                        cc.log('splice list.count:' + list.length);
                        this.panels[key] = list;
                        return;
                    }
                }
            }
        }
    },

    getByName: function getByName(panelName) {
        var list = this.panels[panelName];
        cc.log('getByName');
        if (list) {
            if (list.length > 0) {
                return list[0];
            }
        }
        return null;
    },

    closeByName: function closeByName(panelName) {
        var list = this.panels[panelName];
        cc.log('begin closeByname:' + panelName);
        if (list) {
            for (var i = 0; i < list.length; ++i) {
                this.destroyPanel(list[i]);
            }
            this.panels[panelName] = [];
        }
    },

    closeAll: function closeAll() {
        if (this.panels) {
            for (var key in this.panels) {
                cc.log('key:' + key);
                var list = this.panels[key];
                cc.log('list:' + list);
                if (list) {
                    cc.log('list.length:' + list.length);
                    for (var i = 0; i < list.length; ++i) {
                        cc.log('destroyPanel:' + list.length);
                        this.destroyPanel(list[i]);
                    }
                }
            }
            this.panels = {};
        }
        cc.log('out!');
    }
});
cc.guimanager = new M();

cc._RF.pop();
},{}],"HeadInfo":[function(require,module,exports){
"use strict";
cc._RF.push(module, '712d2FwdWlDrb8zoVyT1G6D', 'HeadInfo');
// Scripts\Gui\Widget\HeadInfo.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    onClickHead: function onClickHead() {
        cc.log("onClickHead  ", this.node.cuid);

        var pokersort = cc.find("UIPokerGame/PokerSort");
        if (pokersort) {
            return;
        }

        if (this.node.cuid && this.node.cuid != 0) {
            var player = cc.gamemanager.getPlayer(this.node.cuid);
            if (player != null) {
                cc.guimanager.open("UIUserIp", function (panel) {
                    panel.setUserInfo(player);
                });
            }
        }
    },

    onClickUIMainHead: function onClickUIMainHead() {
        var pokersort = cc.find("UIPokerGame/PokerSort");
        if (pokersort) {
            return;
        }

        var playerData = {};
        playerData.cuid = cc.datamanager.mainPlayerData.cuid;
        playerData.name = cc.datamanager.mainPlayerData.nick_name;
        playerData.imgurl = cc.datamanager.mainPlayerData.url;
        playerData.ipstr = cc.datamanager.mainPlayerData.ipstr;
        cc.guimanager.open("UIUserIp", function (panel) {
            panel.setUserInfo(playerData);
        });
    }

});

cc._RF.pop();
},{}],"IMManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '547ddsUQMJPQYDrIA5KcdTB', 'IMManager');
// Scripts\Manager\IMManager.js

'use strict';

var M = cc.Class({

    properties: {},

    init: function init() {
        if (!this.hasInit) {
            cc.log('immanager init begin');
            var me = cc.datamanager.mainPlayerData;
            this.im = yunvasdk.IMDispatchMsgNode.getInstance();
            if (this.im) {
                this.im.initSDK(cc.configmanager.yunyin_sdk_id);
                this.im.cpLogin(me.nick_name, String(me.cuid));
                this.im.setListener(this.onMessage, this);
                this.hasInit = true;
                this.setCall(function (data) {

                    //上传成功
                    var msg = cc.netmanager.msg("PublicProto.C_SendChat");
                    msg.type = 2;
                    msg.data_text = data.url;
                    cc.netmanager.send(msg);

                    // cc.immanager.im.playRecord()

                    this.playRecord();
                }, function () {
                    //停止录制
                });
                cc.log('immanager init!');
            } else {
                cc.log('immanager create fail!');
            }
        }
    },

    clear: function clear() {
        this.hasInit = false;
    },

    onMessage: function onMessage(data) {
        var self = this;
        cc.info('收到语音消息:' + data);
        var rsp = JSON.parse(data);
        switch (rsp.name) {
            case "YVSDK_UPLOAD_COMPLETED":
                //上传成功
                {
                    if (self._onUpload) {
                        self._onUpload(rsp);
                    }
                }
                break;
            case "YVSDK_STOP_RECORD":
                {
                    if (self._onStopRecord) self._onStopRecord(rsp);
                }
                break;
            case "YVSDK_PLAY_COMPLETED":
                {
                    self.onPlayCompleted();
                }
                break;
        }
    },

    onPlayCompleted: function onPlayCompleted() {
        var panel = cc.guimanager.getByName('UIPokerGame');
        if (panel) {
            panel.onPlayCompleted();
        }
        cc.audiomanager.resumeAll();
    },

    setCall: function setCall(onUpload, onStopRecord) {
        this._onUpload = onUpload;
        this._onStopRecord = onStopRecord;
    },

    startRecord: function startRecord() {
        this.im.startRecord();
    },

    stopRecord: function stopRecord(cancel) {
        this.isCancel = cancel;
        this.im.stopRecord();
        if (cancel) {
            cc.audiomanager.resumeAll();
        }
    },
    playRecord: function playRecord(url) {
        if (!cc.scenemanager.isPokerGameScene()) return;
        cc.audiomanager.pauseAll();

        if (url) {
            this.im.playFromUrl(url);
        } else {
            this.im.playRecord();
        }
    }
});

cc.immanager = new M();

cc._RF.pop();
},{}],"MainGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0975fZx1UJEDqmd0lBtMyYs', 'MainGame');
// Scripts\Gui\MainGame.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RF.pop();
},{}],"NetManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ba6d9dJZGBATpJFt+e5rKLY', 'NetManager');
// Scripts\Manager\NetManager.js

'use strict';

var M = cc.Class({
  ctor: function ctor() {
    require('long');
    require('bytebuffer');
    this.ProtoBuf = require('protobuf');
    this.handler = [];
    this.firstLogin = true;
  },

  init: function init() {

    if (cc.sys.isMobile) {
      var agent = anysdk.agentManager;
      this.user_plugin = agent.getUserPlugin();
      // this.user_plugin.removeListener();
      this.user_plugin.setListener(this.onUserResult, this);

      this.share_plugin = agent.getSharePlugin();
      // this.share_plugin.removeListener();
      this.share_plugin.setListener(this.onShareResult, this);
    }

    this.messages = {};
    var self = this;
    this.loadProto('Proto/client', function (builder) {
      self.buildMessage(builder, 'PublicProto.C_Login');
      self.buildMessage(builder, 'PublicProto.S_LoginRet');
      self.buildMessage(builder, 'PublicProto.S_PlayerBasicData');
      self.buildMessage(builder, 'PublicProto.S_Notice');
      self.buildMessage(builder, 'PublicProto.C_SendChat');
      self.buildMessage(builder, 'PublicProto.S_Chat');
      self.buildMessage(builder, 'PublicProto.CS_Heartbeat');
      self.buildMessage(builder, 'PublicProto.C_G13_JionGame');
      self.buildMessage(builder, 'PublicProto.C_G13_CreateGame');
      self.buildMessage(builder, 'PublicProto.S_G13_PlayersInRoom');
      self.buildMessage(builder, 'PublicProto.S_G13_RoomAttr');
      self.buildMessage(builder, 'PublicProto.C_G13_GiveUp');
      self.buildMessage(builder, 'PublicProto.S_G13_VoteFailed');
      self.buildMessage(builder, 'PublicProto.S_G13_AbortGameOrNot');
      self.buildMessage(builder, 'PublicProto.C_G13_VoteFoAbortGame');
      self.buildMessage(builder, 'PublicProto.S_G13_PlayerQuited');
      self.buildMessage(builder, 'PublicProto.C_G13_ReadyFlag');
      self.buildMessage(builder, 'PublicProto.S_G13_HandOfMine');
      self.buildMessage(builder, 'PublicProto.C_G13_BringOut');
      self.buildMessage(builder, 'PublicProto.S_G13_AllHands');
      self.buildMessage(builder, 'PublicProto.S_G13_AllRounds');
      self.buildMessage(builder, 'PublicProto.C_G13_ReqGameHistoryCount');
      self.buildMessage(builder, 'PublicProto.S_G13_GameHistoryCount');
      self.buildMessage(builder, 'PublicProto.C_G13_ReqGameHistoryDetial');
      self.buildMessage(builder, 'PublicProto.S_G13_GameHistoryDetial');
      self.buildMessage(builder, 'PublicProto.C_G13_SimulationRound');
      self.buildMessage(builder, 'PublicProto.S_G13_CalcRoundSimulationRet');
      self.buildMessage(builder, 'PublicProto.S_ServerVersion');
    });
    this.loadProtoID();

    cc.game.on(cc.game.EVENT_SHOW, function () {
      var _self = self;
      self.clear_net_check();
      var scheduler = cc.director.getScheduler();
      scheduler.schedule(function () {
        if (!_self.recvTime) {
          _self.close();
        } else {
          this.clear_net_check();
        }
      }, _self, 0, 0, 1, false);
      _self.sendTime = new Date();
      _self.sendHeartbeat();
    });

    this.serverInfo = {
      apple_review: true
    };
  },

  clear_net_check: function clear_net_check() {
    this.sendTime = null;
    this.recvTime = null;
    cc.director.getScheduler().unscheduleAllForTarget(this);
  },

  startHeartbeat: function startHeartbeat() {
    this.clear_net_check();
    var self = this;
    cc.director.getScheduler().schedule(function () {
      cc.log("30秒发送一个无效数据keepalive");
      self.sendHeartbeat();
    }, this, 30);
  },

  PublicProto_CS_Heartbeat: function PublicProto_CS_Heartbeat(msg) {
    if (this.sendTime) {
      this.recvTime = new Date();
    }
  },

  sendHeartbeat: function sendHeartbeat() {
    var msg = cc.netmanager.msg("PublicProto.CS_Heartbeat");
    cc.netmanager.send(msg);
  },

  stopHeartbeat: function stopHeartbeat() {
    cc.director.getScheduler().unscheduleAllForTarget(this);
  },

  isWXInstall: function isWXInstall() {
    if (!this.user_plugin) {
      return false;
    }
    if (cc.sys.os == cc.sys.OS_IOS) return this.user_plugin.isWXInstall();else if (cc.sys.os == cc.sys.OS_ANDROID) return true;else return false;
  },

  onUserResult: function onUserResult(code, msg) {
    switch (code) {
      case anysdk.UserActionResultCode.kInitSuccess:
        //初始化成功
        this.user_plugin_init_success = true;
        break;
      case anysdk.UserActionResultCode.kLoginSuccess:
        //登录成功
        this.loginSuccess = true;

        var data = JSON.parse(msg);
        if (data) {
          this.loginGame(1, data);
          this.weixinData = data;
          cc.sys.localStorage.setItem("weixinData", msg);
        } else {
          cc.guimanager.msgBox('Login Fail!');
        }
        break;
      // case anysdk.UserActionResultCode.kLogoutSuccess:
      //           this.firstLogin = true
      //           this.reconnect()
      //     break;
      // case anysdk.UserActionResultCode.kLogoutFail:
      //     cc.guimanager.msgBox("Loginout Fail!")
      //     this.firstLogin = true
      //     this.reconnect()
      //     break;
      case anysdk.UserActionResultCode.kInitFail:
        //初始化 SDK 失败回调
        //SDK 初始化失败，游戏相关处理
        this.user_plugin_init_success = false;
        // cc.guimanager.msgBox("kInitFail")
        break;
      case anysdk.UserActionResultCode.kLoginNetworkError:
        //登陆网络出错回调
        cc.guimanager.msgBox("UserActionResultCode.kLoginNetworkError");
        break;
      case anysdk.UserActionResultCode.kLoginCancel:
        //登陆取消回调
        cc.guimanager.msgBox("登陆取消!");
        break;
      case anysdk.UserActionResultCode.kLoginFail:
        //登陆失败回调
        {
          cc.guimanager.msgBox('微信未安装!');
          break;
        }
    }
  },

  onShareResult: function onShareResult(code, msg) {
    cc.log("share result, resultcode:" + code + ", msg: " + msg);
    switch (code) {
      case anysdk.ShareResultCode.kShareSuccess:
        break;
      case anysdk.ShareResultCode.kShareFail:
        cc.guimanager.msgBox('分享失败！错误代码:' + code);
        break;
      case anysdk.ShareResultCode.kShareCancel:
        break;
      case anysdk.ShareResultCode.kShareNetworkError:
        cc.guimanager.msgBox('网络错误！');
        break;
    }
  },

  loadProto: function loadProto(path, call) {
    var self = this;
    cc.loader.loadRes(path, function (err, proto) {
      var builder = self.ProtoBuf.protoFromString(proto);
      call(builder);
    });
  },

  buildMessage: function buildMessage(builder, name) {
    this.messages[name] = builder.build(name);
  },

  loadProtoID: function loadProtoID() {
    var self = this;
    cc.loader.loadRes('Proto/protoid', function (err, protoid) {
      self.id_name_map = JSON.parse(protoid);
    });
  },

  id_name_convert: function id_name_convert(id_or_name) {
    return this.proto_id_name_map[id_or_name];
  },

  connect: function connect(ip, port, func) {
    cc.guimanager.wait('正在连接,请稍后...');
    if (!this.jbsocket) this.jbsocket = new JBSocket();

    this.jbsocket.onopen = function () {
      func(true);
    };

    var self = this;
    this.jbsocket.onerror = function (data) {
      if (data.errorid == JBSocket.ConnectError) func(false);else {
        // self.dispach('dispachMsg','onNetError',data.errorid);
        cc.log('error:');
        self.stopHeartbeat();
        self.close();
      }
    };
    this.jbsocket.onmessage = function (data) {
      cc.log('data.msgid:' + data.msgid);
      self.dispachMsg(data.msgid, data.msg);
    };
    this.jbsocket.connect(ip, port);

    this.serverIP = ip;
    this.serverPort = port;
  },

  reconnect: function reconnect() {
    if (this.jbsocket) {
      // this.jbsocket.close()
    }
    this.jbsocket = null;

    var _this = this;
    this.connect(cc.configmanager.serverIP, cc.configmanager.serverPort, function (isConnect) {
      cc.guimanager.closeWait();
      var self = _this;
      if (!isConnect) {
        cc.guimanager.msgBox('连接失败,点击确定重试!', function () {
          self.reconnect();
        });
      } else {
        self.startHeartbeat();
        //连接成功 ,准备登陆
        if (!self.firstLogin) {
          self.login(self.loginType);
        }
      }
    });
  },

  gotoLoginScene: function gotoLoginScene() {
    if (this.firstLogin) {
      this.firstLogin = false;
      cc.scenemanager.loadLoginScene();
    }
  },
  //
  PublicProto_S_ServerVersion: function PublicProto_S_ServerVersion(msg) {

    this.serverInfo = msg;
    if (msg.version != cc.configmanager.version) {
      if (cc.netmanager.serverInfo.strict_version) {
        cc.guimanager.msgBox('您当前版本与服务器不匹配，请下载最新客户端！', function () {
          if (cc.sys.os == cc.sys.OS_IOS) {
            cc.Application.getInstance().openURL(cc.netmanager.serverInfo.ios_app_url);
          } else if (cc.sys.os == cc.sys.OS_ANDROID) {
            cc.Application.getInstance().openURL(cc.netmanager.serverInfo.android_app_url);
          }
          return true;
        });
      } else {
        var self = this;
        cc.guimanager.msgBox('您当前版本与服务器不匹配，请下载最新客户端！', function () {
          self.gotoLoginScene();
          return false;
        });
      }
    } else {
      this.gotoLoginScene();
    }
  },

  //登陆返回
  PublicProto_S_LoginRet: function PublicProto_S_LoginRet(msg) {
    if (msg.ret_code == 1) {
      cc.datamanager.mainPlayerData.cuid = msg.cuid;
      cc.datamanager.mainPlayerData.ipstr = msg.ipstr;
      cc.log('重连成功!');
    }
    cc.datamanager.mainData = msg;
  },

  checkWeixin: function checkWeixin() {
    var data = cc.sys.localStorage.getItem("weixinData");
    if (data && data != "") {
      return true;
    }
    return false;
  },

  login: function login(type) {

    if (cc.sys.isMobile && type != 0) {
      this.user_plugin.login();
      // this.weixinData = cc.sys.localStorage.getItem("weixinData")
      // if (!this.weixinData || this.weixinData == "")
      // {
      //   if (this.user_plugin_init_success)
      //   {
      //     this.user_plugin.login()
      //   }
      //   else
      //   {
      //     cc.guimanager.msgBox("AnySDK 未初始化!")
      //   }
      // }
      // else
      // {
      //   this.user_plugin.login()
      //   // this.weixinData = JSON.parse(this.weixinData)
      //   // if (this.weixinData)
      //   // {
      //   //   this.loginGame(1,this.weixinData)
      //   // }
      //   // else
      //   // {
      //   //   cc.sys.localStorage.setItem('weixinData',"")
      //   //   this.weixinData = null
      //   //   this.loginOut()
      //   // }
      // }
    } else {
      this.loginGame(0, {
        access_token: 'xxxxx',
        user_info: {
          openid: cc.datamanager.getUserOpenId(),
          nickname: cc.datamanager.getNickName(),
          headimgurl: ""
        }
      });
    }
  },

  loginGame: function loginGame(type, weixin) {
    this.loginType = type;
    var msg = cc.netmanager.msg('PublicProto.C_Login');
    msg.login_type = type;
    msg.openid = weixin.user_info.openid;
    msg.token = weixin.access_token;
    msg.nick_name = weixin.user_info.nickname;
    msg.imgurl = weixin.user_info.headimgurl;
    cc.netmanager.send(msg);

    cc.datamanager.mainPlayerData.nick_name = msg.nick_name;
    cc.datamanager.mainPlayerData.openid = msg.openid;
    cc.datamanager.mainPlayerData.sex = weixin.user_info.sex;
    cc.datamanager.mainPlayerData.url = weixin.user_info.headimgurl;
  },

  loginOut: function loginOut() {
    this.weixinData = null;
    cc.sys.localStorage.setItem('weixinData', "");
    if (this.user_plugin && this.user_plugin.logout) {
      this.user_plugin.logout();
    }
    if (this.jbsocket) this.jbsocket.close();
    this.jbsocket = null;
    this.firstLogin = true;
    this.reconnect();
  },

  onDisconnect: function onDisconnect() {
    //重连
    var self = this;
    cc.guimanager.msgBox('网络断开,点击确定尝试重连!', function () {
      self.reconnect();
    });
  },

  //关闭网络
  close: function close() {
    this.stopHeartbeat();
    if (this.jbsocket) {
      this.jbsocket.close();
      this.jbsocket = null;
      cc.log('onDisconnect');
      this.onDisconnect();
    }
  },

  //分发消息
  dispachMsg: function dispachMsg(msgid, msg) {
    var msgname = this.id_name_map[String(msgid)];
    var msgdata = this.messages[msgname].decode(msg);
    var msghandlername = msgname.replace('.', '_');

    cc.log('recv:' + msgname);
    if (typeof this[msghandlername] == 'function') {
      this[msghandlername](msgdata);
    }
    this.dispach("dispachMsg", msghandlername, msgdata);
  },

  dispach: function dispach(funcname, name, data) {
    for (var i = 0; i < this.handler.length; ++i) {
      this.handler[i][funcname](name, data);
    }
  },

  //申请一个 msg
  msg: function msg(msgname) {
    var message = this.messages[msgname];
    if (message) {
      var ret = new message();
      ret.__msgid = this.id_name_map[msgname];
      return ret;
    }
    return null;
  },

  //发送msg
  send: function send(msg) {
    cc.log("send state: " + this.jbsocket);
    if (this.jbsocket) {
      var id = msg.__msgid;
      cc.log('send message id:' + id);
      this.jbsocket.send(id, new Uint8Array(msg.toBuffer()));
    }
  },

  registerHandler: function registerHandler(handler) {
    var self = this;
    if (handler != null && typeof handler.dispachMsg == 'function') {
      self.handler.push(handler);
    }
  },

  screenShoot: function screenShoot(func) {
    if (!cc.sys.isNative) return;

    var dirpath = jsb.fileUtils.getWritablePath() + 'ScreenShoot/';
    if (!jsb.fileUtils.isDirectoryExist(dirpath)) {
      jsb.fileUtils.createDirectory(dirpath);
    }
    var scale = 0.5;
    var name = 'ScreenShoot.jpg';
    var filepath = dirpath + name;
    if (jsb.fileUtils.isFileExist(filepath)) jsb.fileUtils.removeFile(filepath);
    var size = cc.winSize;
    var rt = cc.RenderTexture.create(size.width * scale, size.height * scale, 2, 0x88F0);
    var scene = cc.director.getScene();
    scene._sgNode.addChild(rt);
    rt.setVisible(false);

    cc.director.setContentScaleFactor(scale);
    rt.begin();
    scene._sgNode.visit();
    rt.end();
    cc.log('dirpath:' + dirpath);
    rt.saveToFile('ScreenShoot/' + name, 0, true, function () {
      cc.director.setContentScaleFactor(1);
      //  if (cc.sys.os == cc.sys.OS_ANDROID) 
      //  {
      //   var dstFile="/sdcard/ScreenShoot.png";
      //   jsb.fileUtils.copyFile(filepath,dstFile);
      //   filepath = dstFile
      // }

      cc.log('save succ');
      rt.removeFromParent();
      if (func) {
        func(filepath);
      }
    });
  },

  getShareIcon: function getShareIcon() {
    var path = jsb.fileUtils.getWritablePath() + 'shareIcon.jpg';
    if (!jsb.fileUtils.isFileExist(path)) {
      var data = jsb.fileUtils.getDataFromFile(cc.url.raw("resources/Textures/shareIcon.jpg"));
      if (data) {
        jsb.fileUtils.writeDataToFile(data, path);
      } else {
        // cc.guimanager.msgBox('share failed!')
      }
    }
    return path;
  },

  shareimgToWeiXin: function shareimgToWeiXin(imgPath, sharTo) {
    var info = {
      title: "斗阵游十三水",
      text: "欢迎来到斗阵十三水，让我们一起斗阵游吧！",
      url: cc.datamanager.mainData.share_link,
      mediaType: '1',
      shareTo: sharTo,
      imagePath: imgPath,
      thumbSize: '127',
      thumbImage: imgPath
    };
    if (cc.sys.os == cc.sys.OS_ANDROID) {
      info.imgPath = this.getShareIcon();
      info.thumbImage = info.imgPath;
      cc.log('info.thumbImage:' + info.thumbImage);
    }

    this.share_plugin.share(info);
  },

  shareScreenToWeiXinRing: function shareScreenToWeiXinRing() {
    if (cc.sys.isMobile) {
      var self = this;
      this.screenShoot(function (filepath) {
        self.shareimgToWeiXin(filepath, '1');
      });
    }
  },
  shareScreenToWeiXinFriend: function shareScreenToWeiXinFriend() {
    if (cc.sys.isMobile) {
      var self = this;
      this.screenShoot(function (filepath) {
        self.shareimgToWeiXin(filepath, '0');
      });
    }
  },

  shareURLToWeiXin: function shareURLToWeiXin(title, text, shareTo) {
    if (!title) title = "斗阵十三水";
    if (!text) text = "欢迎来到斗阵十三水，让我们一起斗阵游吧！";
    var info = {
      title: title,
      text: text,
      url: cc.datamanager.mainData.share_link,
      mediaType: '2',
      shareTo: shareTo,
      thumbSize: '57',
      thumbImage: 'AppIcon57x57.png'
    };

    if (cc.sys.os == cc.sys.OS_ANDROID) {
      info.thumbImage = this.getShareIcon();
      cc.log('info.thumbImage:' + info.thumbImage);
    }

    this.share_plugin.share(info);
  },

  shareToWeiXinRing: function shareToWeiXinRing(title, text) {
    this.shareURLToWeiXin(title, text, '1');
  },

  shareToWeixinFriend: function shareToWeixinFriend(title, text) {
    this.shareURLToWeiXin(title, text, '0');
  }
});
cc.netmanager = new M();

cc._RF.pop();
},{"bytebuffer":"bytebuffer","long":"long","protobuf":"protobuf"}],"PokerDun":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bd08azbTshARrMGZEuQdkuw', 'PokerDun');
// Scripts\Gui\PokerDun.js

"use strict";

//PokerSort界面三墩牌

cc.Class({
    extends: cc.Component,

    properties: {
        btnLabel: cc.Label,
        duntype: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    init: function init(ps) {
        this.pokerSort = ps;

        this.cardValues = [];
        this.cardNodes = [];
        var cn = this.node.getChildByName("cards");

        cc.log("初始pokerdun childcount= ", cn.childrenCount);
        for (var i = 0; i < cn.childrenCount; ++i) {
            this.cardNodes.push(cn.children[i]);
            this.cardValues.push(0);
        }
    },

    _getEmptyHoleNumber: function _getEmptyHoleNumber() {
        var num = 0;
        for (var i = 0; i < this.cardValues.length; ++i) {
            if (this.cardValues[i] == 0) {
                ++num;
            }
        }
        return num;
    },

    _getFirstEmptyHoleIdx: function _getFirstEmptyHoleIdx() {
        for (var i = 0; i < this.cardValues.length; ++i) {
            if (this.cardValues[i] == 0) {
                return i;
            }
        }
        return -1;
    },

    //刷新按钮文字状态
    _refreshButtonText: function _refreshButtonText() {
        var num = this._getEmptyHoleNumber();
        if (num != this.cardValues.length) {
            this.btnLabel.string = "清除";
            this.btnLabel.node.color = new cc.Color(105, 0, 3);
            cc.PokerUtil.replaceSprite("Textures/red88BTN", this.btnLabel.node.parent);
        } else {
            this.btnLabel.string = "放入";
            this.btnLabel.node.color = new cc.Color(96, 73, 0);
            cc.PokerUtil.replaceSprite("Textures/yellow88BTN", this.btnLabel.node.parent);
        }
    },

    //清除扑克图片
    _clearPokerSprite: function _clearPokerSprite(node) {

        var sprite = node.getComponent(cc.Sprite);
        sprite.spriteFrame = null;

        var url = "Textures/Fight/topdunback";
        if (this.duntype == 2) {
            url = "Textures/Fight/middledunback";
        } else if (this.duntype == 3) {
            url = "Textures/Fight/botdunback";
        }
        cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
            var sprite = node.getComponent(cc.Sprite);
            sprite.spriteFrame = spriteFrame;
        });
    },

    isFull: function isFull() {
        return 0 == this._getEmptyHoleNumber();
    },

    clearDun: function clearDun() {
        var crCards = [];
        for (var i = 0; i < this.cardValues.length; ++i) {
            if (this.cardValues[i] != 0) {
                crCards.push(this.cardValues[i]);
                this.cardValues[i] = 0;
            }
        }
        cc.audiomanager.playSFX("xuanpai");
        this.pokerSort.onFallbackCard(crCards);
        for (var i = 0; i < this.cardNodes.length; ++i) {
            this._clearPokerSprite(this.cardNodes[i]);
        }
        this.pokerSort._refreshSendBtnState();

        this._refreshButtonText();
    },

    onclick_PushBtn: function onclick_PushBtn(event, type) {

        var emptyNum = this._getEmptyHoleNumber();
        cc.log("空位置= ", emptyNum);
        if (emptyNum != this.cardValues.length && type != -1) {
            //清除当前墩所有牌,只要有一张牌都清除

            this.clearDun();
        } else {
            //放入已选中的牌
            var selLen = this.pokerSort._selectedPoker.length;
            cc.log("emptyNum: ", emptyNum, "selectLength: ", selLen);
            if (emptyNum < selLen || selLen == 0) {
                cc.log("选择的牌数量太多");
                return;
            }
            cc.audiomanager.playSFX("xuanpai");
            for (var i = 0; i < selLen; ++i) {
                var val = this.pokerSort._selectedPoker[i];
                var idx = this._getFirstEmptyHoleIdx();
                if (idx != -1) {
                    this.cardValues[idx] = val;
                    cc.PokerUtil.replacePokerSprite(val, this.cardNodes[idx]);
                }
            }
            this.pokerSort.onPutdownCard();
            if (type != -1) {
                this.pokerSort.autoPutLeftCard();
            }
        }

        this._refreshButtonText();
    },

    onClick_PokerHole: function onClick_PokerHole(event, idx) {
        if (idx < 0 || idx >= this.cardNodes.length) {
            return;
        }

        var val = this.cardValues[idx];
        if (val != 0) {
            cc.audiomanager.playSFX("xuanpai");
            this.pokerSort.onFallbackCard([val]);
            this.cardValues[idx] = 0;
            this._clearPokerSprite(this.cardNodes[idx]);
            this.pokerSort._refreshSendBtnState();
        }

        var emptyNum = this._getEmptyHoleNumber();
        var selLen = this.pokerSort._selectedPoker.length;
        if (val == 0 && selLen != 0 && selLen <= emptyNum) {
            cc.audiomanager.playSFX("xuanpai");
            if (selLen == 1) {
                var selVal = this.pokerSort._selectedPoker[0];
                this.cardValues[idx] = selVal;
                cc.PokerUtil.replacePokerSprite(selVal, this.cardNodes[idx]);
            } else {
                for (var i = 0; i < selLen; ++i) {
                    var ix = this._getFirstEmptyHoleIdx();
                    if (ix != -1) {
                        var selVal = this.pokerSort._selectedPoker[i];
                        this.cardValues[ix] = selVal;
                        cc.PokerUtil.replacePokerSprite(selVal, this.cardNodes[ix]);
                    }
                }
            }

            this.pokerSort.onPutdownCard();
            this.pokerSort.autoPutLeftCard();
        }

        this._refreshButtonText();
    },

    clearPokers: function clearPokers() {
        var values = [];
        for (var i = 0; i < this.cardNodes.length; ++i) {
            if (this.cardValues[i] != 0) {
                this._clearPokerSprite(this.cardNodes[i]);
                values.push(this.cardValues[i]);
                this.cardValues[i] = 0;
            }
        }
        this.pokerSort.onFallbackCard(values);
        this._refreshButtonText();
    }

});

cc._RF.pop();
},{}],"PokerFlop":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4aa02SHwA5J/YHD3/WAPCTa', 'PokerFlop');
// Scripts\Gui\PokerFlop.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        topNode: cc.Node,
        middleNode: cc.Node,
        bottomNode: cc.Node,
        styleNode: cc.Node,

        dankongNode: cc.Node,
        shouqiangNode: cc.Node,
        jgqNode: cc.Node,

        _pokerData: null //13张牌(1,2,3墩顺序)
    },

    // use this for initialization
    onLoad: function onLoad() {
        //this._allPokerValues = [52,51,50,49,48,47,46,45,44,43,42,41,40]
    },

    //data来自S_G13_AllHands消息
    initPokerValues: function initPokerValues(data) {
        this._pokerData = data;
    },

    resetState: function resetState() {
        for (var i = 0; i < this.topNode.childrenCount; ++i) {
            var nd = this.topNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
        for (var i = 0; i < this.middleNode.childrenCount; ++i) {
            var nd = this.middleNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
        for (var i = 0; i < this.bottomNode.childrenCount; ++i) {
            var nd = this.bottomNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
        this.styleNode.active = false;
    },

    //翻第一墩牌
    topFlopAction: function topFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.topNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.topNode.children[i]);
            }
            param.styleNode.active = true;

            if (param._pokerData.dun0.brand == 3) {
                //冲三
                cc.PokerUtil.replaceSprite("Textures/PokerStyle/chongsan", param.styleNode);
                cc.audiomanager.playSFX("M_chongsan");
            } else {
                var cfg = cc.configmanager.pokerFlopCfg[param._pokerData.dun0.brand];
                cc.PokerUtil.replaceSprite(cfg.texres, param.styleNode);
                cc.audiomanager.playSFX(cfg.sound_male);
            }
        }, this, param), cc.delayTime(0.6));
    },

    //翻第二墩牌
    middleFlopAction: function middleFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.middleNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i + 3];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.middleNode.children[i]);
            }

            var cfg = cc.configmanager.pokerFlopCfg[param._pokerData.dun1.brand];
            param.styleNode.active = true;

            if (param._pokerData.dun1.brand == 6) {
                //中墩葫芦
                cc.PokerUtil.replaceSprite("Textures/PokerStyle/zhongdunhulu", param.styleNode);
                cc.audiomanager.playSFX("M_zhongdunhunlu");
            } else {
                cc.PokerUtil.replaceSprite(cfg.texres, param.styleNode);
                cc.audiomanager.playSFX(cfg.sound_male);
            }
        }, this, param), cc.delayTime(0.6));
    },

    //翻第三墩牌
    bottomFlopAction: function bottomFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.bottomNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i + 8];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.bottomNode.children[i]);
            }

            var cfg = cc.configmanager.pokerFlopCfg[param._pokerData.dun2.brand];
            param.styleNode.active = true;
            cc.PokerUtil.replaceSprite(cfg.texres, param.styleNode);
            cc.audiomanager.playSFX(cfg.sound_male);
        }, this, param), cc.delayTime(0.6));
    },

    //翻特殊牌型
    specialFlopAction: function specialFlopAction(param) {
        return cc.callFunc(function (target, param) {
            for (var i = 0; i < param.topNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.topNode.children[i]);
            }

            for (var i = 0; i < param.middleNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i + 3];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.middleNode.children[i]);
            }

            for (var i = 0; i < param.bottomNode.childrenCount; ++i) {
                var pokerVal = param._pokerData.cards[i + 8];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.bottomNode.children[i]);
            }

            param.styleNode.active = true;
            var cfg = cc.configmanager.specialFlopCfg[Math.floor(param._pokerData.spec.brand / 10)];
            if (null != cfg) {
                cc.PokerUtil.replaceSprite(cfg.texres, param.styleNode);
                cc.audiomanager.playSFX(cfg.sound_male);
            }
        }, this, param);
    },

    //播放弹孔动画
    startDanKongAnim: function startDanKongAnim() {
        this.dankongNode.active = true;
        this.dankongNode.getComponent(cc.Animation).play();
    },

    endDanKongAnim: function endDanKongAnim() {
        this.dankongNode.active = false;
    },

    //播放打枪动画
    startDaQiangAnim: function startDaQiangAnim() {
        this.shouqiangNode.active = true;
        this.shouqiangNode.getComponent(cc.Animation).play();
    },

    endDaQiangAnim: function endDaQiangAnim() {
        this.shouqiangNode.active = false;
    },

    setState: function setState(show) {
        var nodeName = ["top", "middle", "bottom"];
        for (var i = 0; i < nodeName.length; ++i) {
            var nd = this.node.getChildByName(nodeName[i]);
            if (nd) {
                nd.active = show;
            }
        }
        var pai = this.node.getChildByName("pai");
        if (pai) {
            pai.active = !show;
        }
    }
});

cc._RF.pop();
},{}],"PokerList":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4b7307CmeVHsZbpKkNZL3la', 'PokerList');
// Scripts\Gui\PokerList.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    resetState: function resetState() {
        for (var i = 0; i < this.node.childrenCount; ++i) {
            var nd = this.node.children[i];
            nd.active = false;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PokerSelectHandler":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9d716g4wEJIZpBXwjMuOp28', 'PokerSelectHandler');
// Scripts\Gui\PokerSelectHandler.js

"use strict";

//处理滑动选择
if (cc.PokerSelectHandler == undefined) {
    cc.PokerSelectHandler = cc.Class({

        ctor: function ctor() {
            this._clear();
        },

        _clear: function _clear() {
            this.startNode = null;
            this.endNode = null;
            this.selectNodes = [];

            this.lastFocusNode = null;
        },

        touchStart: function touchStart(node) {
            this.lastFocusNode = node;
        },

        touchMove: function touchMove(node) {
            if (node == this.lastFocusNode) {
                return;
            }
        },

        touchEnd: function touchEnd(node) {
            this.endNode = node;
        }

    });
}

cc._RF.pop();
},{}],"PokerSelect":[function(require,module,exports){
"use strict";
cc._RF.push(module, '3b47a4kgtxMBrjGDVwvwKDi', 'PokerSelect');
// Scripts\Gui\PokerSelect.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isSelected: false,
        _pokerVal: 0,
        _pokerIndex: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        /*
        if(cc.sys.os == cc.sys.OS_ANDROID || cc.sys.os == cc.sys.OS_IOS){
            this.node.on(cc.Node.EventType.TOUCH_START, this._onSelect);
            this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onMove);
             this.node.on(cc.Node.EventType.TOUCH_END, this._onMoveEnd);
        }else{
            this.node.on(cc.Node.EventType.MOUSE_DOWN, this._onSelect);
            this.node.on(cc.Node.EventType.MOUSE_MOVE, this._onMove);
            this.node.on(cc.Node.EventType.MOUSE_UP, this._onMoveEnd);
        }
        */
    },

    _onSelect: function _onSelect(event) {
        var component = event.currentTarget.getComponent("PokerSelect");
        var pokerSort = cc.find("UIPokerGame/PokerSort").getComponent("PokerSort");
        if (!component._isSelected) {
            component.moveOut(event.currentTarget);
            pokerSort.selectCard(component._pokerVal);
        } else {
            component.moveBack(event.currentTarget);
            pokerSort.unselectCard(component._pokerVal);
        }
        pokerSort._lastFocusPoker = event.currentTarget;
        pokerSort._focusBegin = true;

        pokerSort.log.string = "_onSelect " + pokerSort._focusBegin.toString() + " " + component._pokerIndex.toString();
    },

    _onMove: function _onMove(event) {

        var pokerSort = cc.find("UIPokerGame/PokerSort").getComponent("PokerSort");
        if (pokerSort._focusBegin == false) {
            return;
        }

        var target = pokerSort._selectPoker(event.getLocation());

        if (target != null) {
            var component = target.getComponent("PokerSelect");
            pokerSort.log.string = "_onMove " + pokerSort._focusBegin.toString() + " " + component._pokerIndex.toString();

            if (target == pokerSort._lastFocusPoker) {
                return;
            }

            pokerSort._lastFocusPoker = target;

            if (!component._isSelected) {
                component.moveOut(target);
                pokerSort.selectCard(component._pokerVal);
            } else {
                component.moveBack(target);
                pokerSort.unselectCard(component._pokerVal);
            }
        }
    },

    _onMoveEnd: function _onMoveEnd(event) {
        var component = event.currentTarget.getComponent("PokerSelect");
        var pokerSort = cc.find("UIPokerGame/PokerSort").getComponent("PokerSort");
        pokerSort._focusBegin = false;

        pokerSort.log.string = "_onMoveEnd " + pokerSort._focusBegin.toString() + " " + component._pokerIndex.toString();
    },

    moveOut: function moveOut(node) {
        this._isSelected = true;
        node.runAction(cc.moveBy(0.06, cc.p(0, 24)));
    },

    moveBack: function moveBack(node) {
        this._isSelected = false;
        node.runAction(cc.moveBy(0.06, cc.p(0, -24)));
    },

    setPokerValue: function setPokerValue(val) {
        this._pokerVal = val;
        cc.PokerUtil.replacePokerSprite(val, this.node);
        /*
        var sprite = this.node.getComponent(cc.Sprite);
        var url = cc.PokerUtil.getPokerSpritePath(val);
        cc.log(url);
        cc.loader.loadRes(url, cc.SpriteFrame, function(err, spriteFrame){
            cc.log(url, spriteFrame, sprite)
            sprite.spriteFrame = spriteFrame;
        })
        */
    },

    setPokerIndex: function setPokerIndex(idx) {
        this._pokerIndex = idx;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PokerSort":[function(require,module,exports){
"use strict";
cc._RF.push(module, '60027OfYfZM9aft31kToOk+', 'PokerSort');
// Scripts\Gui\PokerSort.js

"use strict";

require('UIPanel');
require("PokerSelectHandler");
cc.Class({
    extends: cc.uipanel,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        pokerSelectPrefab: cc.Prefab,
        sortTypeLabel: cc.Label,
        topBtnLabel: cc.Label,
        middleBtnLabel: cc.Label,
        bottomBtnLabel: cc.Label,
        cardList: cc.Node,
        confirmBtn: cc.Node,
        //autoTypeContainer: cc.Node,
        scrollview_recommend: cc.Node,
        scrollview_free: cc.Node,
        freeBtn: cc.Node,
        recommandBtn: cc.Node,
        specialBtn: cc.Node,
        log: cc.Label,
        resetAllBtn: cc.Node,
        specailPanel: cc.Prefab,

        topDunNode: cc.Node,
        midDunNode: cc.Node,
        botDunNode: cc.Node,

        _top: [],
        _middle: [],
        _bottom: [],
        _pokerList: null,
        _currentSortType: 1, //默认按大小排序

        _freePoker: null,

        //_pokerSelectHandler: null,

        _lastFocusPoker: null, //当前抽出的牌
        _focusBegin: false, //是否滑动开始

        _curOpType: 1 },

    // use this for initialization
    onLoad: function onLoad() {
        this.initPokers();
        this.initFreeSort();
        //this._pokerSelectHandler = new cc.PokerSelectHandler();

        var laout = this.node.getChildByName("New Layout");

        if (cc.sys.os == cc.sys.OS_ANDROID || cc.sys.os == cc.sys.OS_IOS) {
            this.cardList.on(cc.Node.EventType.TOUCH_START, function (event) {
                this._onTouchBegin(event);
            }.bind(this));
            this.cardList.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
                this._onTouchMove(event);
            }.bind(this));
            this.cardList.on(cc.Node.EventType.TOUCH_END, function (event) {
                this._onTouchEnd(event);
            }.bind(this));

            laout.on(cc.Node.EventType.TOUCH_START, function (event) {
                this.clickback(event);
            }.bind(this));
        } else {
            this.cardList.on(cc.Node.EventType.MOUSE_DOWN, function (event) {
                this._onTouchBegin(event);
            }.bind(this));
            this.cardList.on(cc.Node.EventType.MOUSE_MOVE, function (event) {
                this._onTouchMove(event);
            }.bind(this));
            this.cardList.on(cc.Node.EventType.MOUSE_UP, function (event) {
                this._onTouchEnd(event);
            }.bind(this));

            laout.on(cc.Node.EventType.MOUSE_DOWN, function (event) {
                this.clickback(event);
            }.bind(this));
        }

        this.topDun = this.topDunNode.getComponent("PokerDun");
        this.topDun.init(this);

        this.middleDun = this.midDunNode.getComponent("PokerDun");
        this.middleDun.init(this);

        this.bottomDun = this.botDunNode.getComponent("PokerDun");
        this.bottomDun.init(this);
    },

    initPokers: function initPokers() {
        this._pokerList = [];
        this._unselectPoker = cc.gamemanager.getCurMathPokers(); //未放入的13张牌
        this._selectedPoker = []; //选择准备放入的牌

        //var width = cc.configmanager.wndScale * 60
        this._currentSortType = 1;
        cc.PokerUtil.sortPoker(this._currentSortType, this._unselectPoker);
        //var totalSize = (this._unselectPoker.length - 1) * 60 / 2;
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            //var selectPoker = cc.instantiate(this.pokerSelectPrefab);
            var selectPoker = this.cardList.children[i];
            selectPoker.active = true;
            var script = selectPoker.getComponent("PokerSelect");

            var pokerVal = this._unselectPoker[i];
            script.setPokerValue(pokerVal);
            script.setPokerIndex(i);

            //selectPoker.parent = this.cardList;
            //selectPoker.position = cc.v2(-totalSize+i*60, 0);
            this._pokerList.push(selectPoker);
        }
        //var scale = cc.configmanager.wndScale
        //this.cardList.setScale(scale, scale)

        //检测是否有特殊牌型

        var curPokers = cc.gamemanager.getCurMathPokers();
        for (var i = 0; i < cc.PokerUtil.specialGroup.length; ++i) {
            var ret = cc.PokerUtil.specialGroup[i](curPokers);
            if (ret != null) {
                cc.log("检测到有特殊牌型!!! type= ", i);
                this._specialCard = ret;
                this._specialCardType = i;
                this.specialBtn.active = true;
                this.showSpecialWnd();
                break;
            }
        }
    },

    //显示特殊牌型提示
    showSpecialWnd: function showSpecialWnd() {
        if (!this._specialCard || !this._specialCardType) {
            return;
        }

        var specialWnd = cc.instantiate(this.specailPanel);
        specialWnd.parent = this.node;
        specialWnd.position = cc.v2(0, 0);
        specialWnd.getComponent("UISpecialCard").setSpeical(this, this._specialCardType, this._specialCard);
    },

    //将留下的牌重新排序
    _resetPokers: function _resetPokers() {
        this._resetPokersState();
        var index = 0;
        cc.PokerUtil.sortPoker(this._currentSortType, this._unselectPoker);
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            var pokerVal = this._unselectPoker[i];
            if (pokerVal != 0) {
                var node = this._pokerList[index];
                index = index + 1;
                node.active = true;
                var script = node.getComponent("PokerSelect");
                script.setPokerValue(pokerVal);
            }
        }
        for (var i = index; i < this._pokerList.length; ++i) {
            this._pokerList[i].active = false;
        }
    },

    //把牌设回初始位置
    _resetPokersState: function _resetPokersState() {
        for (var i = 0; i < this._pokerList.length; ++i) {
            var node = this._pokerList[i];
            var script = node.getComponent("PokerSelect");
            if (script._isSelected == true) {
                script.moveBack(node);
            }
        }
    },

    _refreshSendBtnState: function _refreshSendBtnState() {
        var visible = this.topDun.isFull() && this.middleDun.isFull() && this.bottomDun.isFull();
        this.confirmBtn.active = visible;
        this.resetAllBtn.active = visible;
    },

    _reCalculateFreeSort: function _reCalculateFreeSort() {

        if (this._curOpType == 1) {
            this.initFreeSort();
        }
    },

    onClick_Sort: function onClick_Sort() {
        if (this._currentSortType == 1) {
            this._currentSortType = 2;
            this.sortTypeLabel.string = "大小排序";
        } else {
            this._currentSortType = 1;
            this.sortTypeLabel.string = "花色排序";
        }
        this.clearSelectPoker();
        this._resetPokers();
    },

    //发送选择好的牌
    onClick_Confirm: function onClick_Confirm(event) {

        if (!this.topDun.isFull() || !this.middleDun.isFull() || !this.bottomDun.isFull) {
            cc.log("牌墩未满就要出牌了？");
            return;
        }

        var _top = this.topDun.cardValues;
        var _mid = this.middleDun.cardValues;
        var _bot = this.bottomDun.cardValues;

        //判断相公
        if (cc.PokerUtil.isMessire(_top, _mid, _bot)) {
            cc.guimanager.msgBox("相公啦！请重新选牌");
            return;
        }

        var cards = [];
        for (var i = 0; i < _top.length; ++i) {
            cards.push(_top[i]);
        }
        for (var i = 0; i < _mid.length; ++i) {
            cards.push(_mid[i]);
        }
        for (var i = 0; i < _bot.length; ++i) {
            cards.push(_bot[i]);
        }

        if (!cc.gamemanager.isPracticeRoom()) {
            //非练习房
            var msg = cc.netmanager.msg("PublicProto.C_G13_BringOut");

            msg.cards = cards;
            msg.special = false;
            cc.netmanager.send(msg);

            var pg = this.node.parent.getComponent("UIPokerGame").showWaitState();
        } else {
            //练习房间
            var round = cc.gamemanager._currentRounds;
            cc.robot.sendPlayerInRoom(round, 4, 4);
            cc.robot.sendAllHands(false, cards);
        }

        this.node.destroy();
        this.setParentTitleShow(true);
    },

    setParentTitleShow: function setParentTitleShow(show) {
        if (this.node.parent) {
            var com = this.node.parent.getComponent("UIPokerGame");
            if (com) {
                com.setTitleShow(show);
            }
        }
    },

    //初始化自由摆牌
    initFreeSort: function initFreeSort(event) {

        if (this._curOpType == 2) {
            //先清除上面三墩牌
            this.topDun.clearPokers();
            this.middleDun.clearPokers();
            this.bottomDun.clearPokers();
        }

        this._curOpType = 1;

        this.scrollview_free.active = true;
        this.scrollview_recommend.active = false;

        this.cardList.active = true;

        this.recommandBtn.active = true;
        this.freeBtn.active = false;
        this._recommandPoker = null;

        //上次选中的牌型
        this._lastSelCardType = -1;
        this._lastSelCardIdx = -1;

        var con = this.scrollview_free.getChildByName("view").getChildByName("content");
        this._freePoker = cc.PokerUtil.getFreeStylePokerSet(this.getLeftCard());
        for (var i = 0; i < this._freePoker.length; ++i) {
            var data = this._freePoker[i];
            var btn = con.children[i].getComponent("cc.Button");
            var label = con.children[i].children[0].getComponent(cc.Label);

            con.children[i].children[1].active = false;
            //con.children[i].getComponents(cc.Sprite)[0].spriteFrame.getTexture().setAliasTexParameters()

            label.string = data.name;
            btn.disabledColor = new cc.Color(255, 255, 255, 255);

            if (data.value.length > 0) {
                cc.PokerUtil.replaceSprite("Textures/paixingBTN", btn);
                btn.interactable = true;
            } else {
                cc.PokerUtil.replaceSprite("Textures/jianpan", btn);
                btn.interactable = false;
            }
        }
    },

    //一键摆牌
    onClick_RecommendPokerBtn: function onClick_RecommendPokerBtn(event) {
        function printArr(a, name) {
            var str = name;
            for (var i = 0; i < a.length; ++i) {
                str += a[i] + ", ";
            }
            cc.log(str);
        }

        function printArr2(a) {
            var str = "";
            for (var i = 0; i < a.length; ++i) {
                str += "t:" + a[i].type + " v:" + a[i].value + "  , ";
            }
            cc.log(str);
        }

        this.scrollview_free.active = false;
        this.scrollview_recommend.active = true;

        this.recommandBtn.active = false;
        this.freeBtn.active = true;
        this._freePoker = null;

        this._curOpType = 2;

        //先清除上面三墩牌
        //if(this._curOpType == 1){
        this.topDun.clearPokers();
        this.middleDun.clearPokers();
        this.bottomDun.clearPokers();
        //}

        //优化一下：只算一次
        if (this._recommandPoker == null) {
            var ret = cc.PokerUtil.getRecommendPokerSet(this.getLeftCard());
            cc.log("一键摆盘一键摆盘 ", ret.length);
            for (var i = 0; i < ret.length; ++i) {
                var config = cc.configmanager.pokerFlopCfg;
                cc.log(ret[i].top.type, ret[i].middle.type, ret[i].bottom.type);
                //printArr2(ret[i].top.card)
                //printArr2(ret[i].middle.card)
                //printArr2(ret[i].bottom.card)
            }

            this._recommandPoker = [];
            this._recSelIdx = -1;
            var t5Name = cc.configmanager.t5Name;
            var t3Name = cc.configmanager.t3Name;

            var con = this.scrollview_recommend.getChildByName("view").getChildByName("content");
            var idx = 0;
            for (var i = 0; i < ret.length; ++i) {
                var data = ret[i];

                if (data.top.type != -1 && data.middle.type != -1 && data.bottom.type != -1) {
                    this._recommandPoker.push(data);
                    var strname = t3Name[data.top.type] + " " + t5Name[data.middle.type] + " " + t5Name[data.bottom.type];

                    cc.log(strname);

                    con.children[idx].active = true;
                    con.children[idx].children[0].getComponent(cc.Label).string = strname;
                    con.children[idx].children[1].active = false;
                    idx++;
                }
            }

            for (var i = idx; i < con.childrenCount; ++i) {
                con.children[i].children[0].getComponent(cc.Label).string = "";
                con.children[i].active = false;
            }
        }
    },

    //自由选牌按钮点击
    onClick_FreeSelectBtn: function onClick_FreeSelectBtn(event, index) {

        this.clearSelectPoker();
        this._resetPokersState();

        if (this._curOpType == 1) {
            if (index < 0 || index >= this._freePoker.length) {
                cc.log("click _freePoker data error!");
                return;
            }

            var con = this.scrollview_free.getChildByName("view").getChildByName("content");
            if (this._lastSelCardType > -1 && this._lastSelCardType < con.childrenCount) {
                con.children[this._lastSelCardType].children[1].active = false;
            }

            if (this._lastSelCardType == index) {
                ++this._lastSelCardIdx;
                if (this._lastSelCardIdx >= this._freePoker[index].value.length) {
                    this._lastSelCardIdx = 0;
                }
            } else {
                this._lastSelCardType = index;
                this._lastSelCardIdx = 0;
            }

            if (this._lastSelCardType > -1 && this._lastSelCardType < con.childrenCount) {
                con.children[this._lastSelCardType].children[1].active = false; //true  只是暂时不需要
            }

            if (this._freePoker.length > index) {
                var freePk = this._freePoker[index].value[this._lastSelCardIdx];
                cc.log(freePk.length);
                for (var i = 0; i < freePk.length; ++i) {
                    var pv = freePk[i];
                    cc.log("pv.type", pv.type, "pv.value", pv.value);
                    for (var j = 0; j < this._pokerList.length; ++j) {
                        var node = this._pokerList[j];
                        var script = node.getComponent("PokerSelect");
                        if (script._pokerVal == pv.type * 13 + pv.value && !script._isSelected) {
                            script.moveOut(node);
                            this.selectCard(script._pokerVal);
                            break;
                        }
                    }
                }
            }
        } else if (this._recommandPoker != null) {
            if (index < 0 || index >= this._recommandPoker.length) {
                cc.log("click _recommandPoker data error!");
                return;
            }

            cc.log("选中recommend ", index, this._recommandPoker.length);

            var con = this.scrollview_recommend.getChildByName("view").getChildByName("content");
            if (this._recSelIdx > -1 && this._recSelIdx < con.childrenCount) {
                con.children[this._recSelIdx].children[1].active = false;
            }

            //if(this._recSelIdx == index){
            //    return
            //}

            this._recSelIdx = index;
            var dat = this._recommandPoker[index];

            if (this._recSelIdx > -1 && this._recSelIdx < con.childrenCount) {
                con.children[this._recSelIdx].children[1].active = false; //true 只是暂时不需要
            }

            this.topDun.clearPokers();
            this.middleDun.clearPokers();
            this.bottomDun.clearPokers();

            //var top = cc.PokerUtil.cardsEncode(dat.top.card)
            //cc.log("select top size = ", top.length)
            this._selectedPoker = dat.top.card.slice();
            this.topDun.onclick_PushBtn(null, -1);

            //var mid = cc.PokerUtil.cardsEncode(dat.middle.card)
            //cc.log("select mid size = ", mid.length)
            this._selectedPoker = dat.middle.card.slice();
            this.middleDun.onclick_PushBtn(null, -1);

            //var bot = cc.PokerUtil.cardsEncode(dat.bottom.card)
            //cc.log("select bottom size = ", bot.length)
            this._selectedPoker = dat.bottom.card.slice();
            this.bottomDun.onclick_PushBtn(null, -1);

            this._selectedPoker = [];
        }
    },

    //自动放入剩下的牌
    autoPutLeftCard: function autoPutLeftCard() {
        cc.log("自动放入");
        var leftcard = this.getLeftCard();
        if (leftcard.length == 0 || leftcard.length > 5) {
            return;
        }

        var fullnum = 0;
        var notfulldun = [];
        var duns = [this.topDun, this.middleDun, this.bottomDun];
        for (var i = 0; i < duns.length; ++i) {
            if (duns[i].isFull()) {
                fullnum++;
            } else {
                notfulldun.push(duns[i]);
            }
        }
        cc.log("自动放入  ", fullnum, notfulldun.length);
        if (fullnum == 2 && notfulldun.length == 1) {
            this._selectedPoker = leftcard.slice();
            notfulldun[0].onclick_PushBtn(null, -1);
            this._selectedPoker = [];
        }
    },

    //发送特殊牌型
    sendSpecialCard: function sendSpecialCard() {

        var cards = [];

        if (this._specialCard.top != null) {
            if (this._specialCard.top.length != 3 || this._specialCard.middle.length != 5 || this._specialCard.bottom.length != 5) {
                cc.log("特殊牌型判断错误！！！");
                return;
            }
            cards = cards.concat(this._specialCard.top, this._specialCard.middle, this._specialCard.bottom);
        } else {
            cards = cc.gamemanager.getCurMathPokers().slice();
        }

        cc.log("发送特殊牌型!!!!!");
        cc.PokerUtil.printPokerEncode(cards);

        if (!cc.gamemanager.isPracticeRoom()) {
            var msg = cc.netmanager.msg("PublicProto.C_G13_BringOut");
            msg.cards = cards;
            msg.special = true;
            cc.netmanager.send(msg);
        } else {
            var round = cc.gamemanager._currentRounds;
            cc.robot.sendPlayerInRoom(round, 4, 4);
            cc.robot.sendAllHands(true, cards);
        }

        var pg = this.node.parent.getComponent("UIPokerGame").showWaitState();
        this.node.destroy();
        this.setParentTitleShow(true);
    },

    //选择特殊牌型
    selSpecialCard: function selSpecialCard(event) {
        if (this._specialCard == null) {
            return;
        }

        this.showSpecialWnd();
    },

    //重置三墩牌
    resetThreeDun: function resetThreeDun() {
        if (this._curOpType == 2) {
            this.onClick_RecommendPokerBtn();
            this.topDun._refreshButtonText();
            this.middleDun._refreshButtonText();
            this.bottomDun._refreshButtonText();
        } else {
            this.topDun.clearDun();
            this.middleDun.clearDun();
            this.bottomDun.clearDun();
        }
    },

    selectCard: function selectCard(val) {
        cc.log("select: " + val);
        this._selectedPoker.push(val);
    },

    unselectCard: function unselectCard(val) {
        for (var i = 0; i < this._selectedPoker.length; ++i) {
            if (this._selectedPoker[i] == val) {
                this._selectedPoker.splice(i, 1);
            }
        }
        cc.log("unselect: " + val + ", already unselect num: " + this._selectedPoker.length);
    },

    //当有牌放入牌墩触发事件
    onPutdownCard: function onPutdownCard() {
        for (var i in this._unselectPoker) {
            var index = this._selectedPoker.indexOf(this._unselectPoker[i]);
            if (index != -1) {
                this._selectedPoker.splice(index, 1);
                this._unselectPoker[i] = 0;
            }
        }
        this._selectedPoker = [];

        //将留下的牌重新显示
        this._resetPokers();

        //重新计算牌型
        this._reCalculateFreeSort();

        this._refreshSendBtnState();
    },

    //当把牌从牌墩撤回来触发事件
    onFallbackCard: function onFallbackCard(cards) {
        for (var i = 0; i < cards.length; ++i) {
            for (var j = 0; j < this._unselectPoker.length; ++j) {
                if (this._unselectPoker[j] == 0) {
                    this._unselectPoker[j] = cards[i];
                    break;
                }
            }
        }
        this._selectedPoker = [];

        //将留下的牌重新显示
        this._resetPokers();

        //重新计算牌型
        this._reCalculateFreeSort();

        this._refreshSendBtnState();
    },

    getLeftCard: function getLeftCard() {
        var ret = [];
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            if (this._unselectPoker[i] != 0) {
                ret.push(this._unselectPoker[i]);
            }
        }
        cc.log("getLeftCard size = ", ret.length);
        return ret;
    },

    clearSelectPoker: function clearSelectPoker() {
        this._selectedPoker = [];
    },

    //是否在target size区域内
    _isInTarget: function _isInTarget(target, point) {
        if (target == null) {
            return false;
        }

        var locationInNode = target.convertToNodeSpace(point);
        var size = target.getContentSize();
        var rect = new cc.rect(0, 0, size.width, size.height);

        //rect.x  =   -size.width/2
        //rect.y  =   -size.height/2

        if (cc.rectContainsPoint(rect, locationInNode)) {
            return true;
        }
        return false;
    },

    //选择牌
    _selectPoker: function _selectPoker(point) {
        for (var i = this._pokerList.length - 1; i >= 0; --i) {
            var target = this._pokerList[i];
            if (target.active && this._isInTarget(target, point)) {
                return target;
            }
        }
        return null;
    },

    _onTouchBegin: function _onTouchBegin(event) {
        if (this._focusBegin == true) {
            return;
        }

        var target = this._selectPoker(event.getLocation());
        if (target != null) {
            var component = target.getComponent("PokerSelect");
            if (!component._isSelected) {
                component.moveOut(target);
                this.selectCard(component._pokerVal);
            } else {
                component.moveBack(target);
                this.unselectCard(component._pokerVal);
            }
            this._lastFocusPoker = target;
            this._focusBegin = true;
        } else {
            this.clickback();
        }
    },

    _onTouchMove: function _onTouchMove(event) {
        if (this._focusBegin == false) {
            return;
        }

        var target = this._selectPoker(event.getLocation());

        if (target != null) {
            var component = target.getComponent("PokerSelect");

            if (target == this._lastFocusPoker) {
                return;
            }

            this._lastFocusPoker = target;

            if (!component._isSelected) {
                component.moveOut(target);
                this.selectCard(component._pokerVal);
            } else {
                component.moveBack(target);
                this.unselectCard(component._pokerVal);
            }
        }
    },

    _onTouchEnd: function _onTouchEnd(event) {
        this._focusBegin = false;
        this._lastFocusPoker = null;
    },

    clickback: function clickback(event) {
        this.clearSelectPoker();
        this._resetPokersState();
    }
});

cc._RF.pop();
},{"PokerSelectHandler":"PokerSelectHandler","UIPanel":"UIPanel"}],"PokerUtils":[function(require,module,exports){
"use strict";
cc._RF.push(module, '101ac+LJ2hPvIGflq7FJ34a', 'PokerUtils');
// Scripts\Manager\PokerUtils.js

"use strict";

var M = cc.Class({
	ctor: function ctor() {},

	/*
 扑克牌描述
     花色：  黑桃 3  、红桃 2 、 梅花 1 、方块 0
     牌点数： 2 ~ A == 1 ~ 13
     牌数值 = (花色 * 13 + 点数 - 1 )
 */

	_getPokerSpritePath: function _getPokerSpritePath(pokerVal) {
		return "Textures/Poker/" + pokerVal.toString();
	},

	//设置扑克牌图片
	replacePokerSprite: function replacePokerSprite(pokerVal, node) {
		var sprite = node.getComponent(cc.Sprite);
		var url = cc.PokerUtil._getPokerSpritePath(pokerVal);
		cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
			sprite.spriteFrame = spriteFrame;
		});
	},

	//设置扑克牌图片
	replaceSprite: function replaceSprite(path, node) {
		var sprite = node.getComponent(cc.Sprite);
		cc.loader.loadRes(path, cc.SpriteFrame, function (err, spriteFrame) {
			sprite.spriteFrame = spriteFrame;
		});
	},

	//返回牌花色和点数
	_getCardType: function _getCardType(x) {
		var ret = {};
		ret.x = (x - 1) / 13;
		ret.y = (x - 1) % 13;
		return ret;
	},

	//单张扑克解码
	singleCardsDecode: function singleCardsDecode(c) {
		var ret = {};
		ret.type = Math.floor((c - 1) / 13);
		ret.value = c - ret.type * 13;
		return ret;
	},

	//单张扑克编码
	singleCardsEncode: function singleCardsEncode(o) {
		return o.type * 13 + o.value;
	},

	//扑克解码
	cardsDecode: function cardsDecode(cArr) {
		var arr = [];
		for (var i = 0; i < cArr.length; ++i) {
			var c = {};
			c.type = Math.floor((cArr[i] - 1) / 13);
			c.value = cArr[i] - c.type * 13;
			arr.push(c);
		}
		return arr;
	},

	//扑克编码
	cardsEncode: function cardsEncode(cArr) {
		var arr = [];
		for (var i = 0; i < cArr.length; ++i) {
			var c = cArr[i];
			arr.push(c.type * 13 + c.value);
		}
		return arr;
	},

	_copyArray: function _copyArray(arr) {
		var ret = [];
		for (var i = 0; i < arr.length; ++i) {
			ret.push(arr[i]);
		}return ret;
	},

	//删除扑克: a, b中删除同样的元素
	_delCards: function _delCards(src, del) {
		var a = cc.PokerUtil._copyArray(src);
		var b = cc.PokerUtil._copyArray(del);

		if (b.length == 0) {
			return a;
		}
		for (var i = a.length - 1; i >= 0; --i) {
			for (var j = 0; j < b.length; ++j) {
				if (a[i] == b[j]) {
					a.splice(i, 1);
					b.splice(j, 1);
				}
			}
		}
		return a;
	},

	//获取普通组合牌型 cArr: 传入未解码的牌数值数组
	getGroupCards: function getGroupCards(cArr) {
		var tmpArr = cc.PokerUtil._copyArray(cArr);
		cc.PokerUtil.sortPoker(1, tmpArr);
		var decodeArr = cc.PokerUtil.cardsDecode(tmpArr);

		var wlArr = [],
		    dzArr = [],
		    stArr = [],
		    tzArr = [],
		    wtArr = [],
		    sArr = [],
		    szArr = [];
		var sz_n = 0;
		var num = decodeArr.length;

		var same = [];
		var notsame = [];

		var alldz = [];

		for (var i = num - 1; i >= 0;) {
			var last = decodeArr[i];

			--i;
			var find = false;
			while (i >= 0 && last.value == decodeArr[i].value) {
				find = true;
				same.push(last);
				last = decodeArr[i];
				--i;
			}
			if (find) {
				same.push(last);

				if (same.length > 1) {
					if (same.length == 2) dzArr.push([same[1], same[0]]);
					if (same.length == 3) stArr.push([same[2], same[1], same[0]]);
					if (same.length == 4) tzArr.push([same[3], same[2], same[1], same[0]]);
					if (same.length == 5) wtArr.push([same[4], same[3], same[2], same[1], same[0]]);
				}

				for (var idx = 0; idx < same.length; ++idx) {
					alldz.push(same[idx]);
				}

				same = [];
			}
			notsame.push(last);
		}

		if (notsame.length > 0) {
			for (var i = notsame.length - 1; i >= 0;) {
				var last = notsame[i];

				--i;
				var tmp = [];
				while (i >= 0 && last.value == notsame[i].value + 1) {
					tmp.push(last);
					last = notsame[i];
					--i;
				}
				tmp.push(last);
				if (tmp.length >= 5) {
					szArr.push(tmp);
				} else {
					for (var j = 0; j < tmp.length; ++j) {
						var ele = tmp[j];
						var fnd = false;
						for (var m = 0; m < alldz.length; ++m) {
							if (alldz[m].type == ele.type && alldz[m].value == ele.value) {
								fnd = true;
								break;
							}
						}
						if (fnd == false) {
							wlArr.push(tmp[j]);
						}
					}
				}
			}
		}

		//dzArr.reverse()
		//stArr.reverse()
		//tzArr.reverse()
		//wtArr.reverse()
		wlArr.reverse();

		var ret = [];
		ret.push(wlArr, dzArr, stArr, tzArr, szArr, decodeArr, wtArr);
		return ret;
	},

	//乌龙（三张）
	wulongThree: function wulongThree(cards) {
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    cardsArr = [];
		for (var i = wlArr.length - 1; i >= 2; --i) {
			cardsArr.push([wlArr[i], wlArr[i - 1], wlArr[i - 2]]);
		}
		return cardsArr;
	},

	//一对（三张）
	yiduiThree: function yiduiThree(cards) {
		var cardsArr = [];
		if (cards.length < 3) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 0 && wlArr.length > 0) {
			for (var i = dzArr.length - 1; i >= 0; --i) {
				cardsArr.push([dzArr[i][0], dzArr[i][1], wlArr[0]]);
			}
		}
		return cardsArr;
	},

	//三条(三张)
	santiao: function santiao(cards) {
		var cardsArr = [];
		if (cards.length < 3) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var stArr = cArr[2];
		for (var i = stArr.length - 1; i >= 0; --i) {
			cardsArr.push(stArr[i]);
		}
		return cardsArr;
	},

	//乌龙(五张)
	wulongFive: function wulongFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0];
		if (wlArr.length > 4) {
			for (var i = wlArr.length - 1; i >= 4; --i) {
				var arr = [wlArr[i], wlArr[3], wlArr[2], wlArr[1], wlArr[0]];
				var cflag = false;
				for (var j = 1; j < arr.length; ++j) {
					if (arr[j].type != arr[j - 1].type) {
						//看乌龙花色是否一样,排除清一色
						cflag = true;
						break;
					}
				}
				if (cflag) {
					//不是同花色
					cflag = false;
					for (var j = 1; j < arr.length; ++j) {
						if (arr[j].value != arr[j - 1].value + 1) {
							cflag = true; //看是否是顺子
							break;
						}
					}
					//A2345
					if (cflag && arr[0].value == 13 && arr[1].value == 4 && arr[2].value == 3 && arr[3].value == 2 && arr[4].value == 1) cflag = false;

					if (cflag) {
						cardsArr.push(arr);
					}
				}
			}
		}
		return cardsArr;
	},

	//一对（五张）
	yiduiFive: function yiduiFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 0) {
			if (wlArr.length > 2) {
				for (var i = dzArr.length - 1; i >= 0; --i) {
					cardsArr.push([dzArr[i][0], dzArr[i][1], wlArr[2], wlArr[1], wlArr[0]]);
				}
			} else if (dzArr.length > 3) {
				//乌龙不够，拆对子
				for (var i = dzArr.length - 1; i >= 3; --i) {
					cardsArr.push([dzArr[i][1], dzArr[i][0], dzArr[2][1], dzArr[1][1], dzArr[0][1]]);
				}
			}
		}
		return cardsArr;
	},

	//两对（五张)
	liangdui: function liangdui(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 1 && wlArr.length > 0 || dzArr.length > 2) {
			var i = dzArr.length;
			var condition = 1;
			if (wlArr.length == 0) {
				condition = 2; //没有乌龙要拆一对
			}
			for (var j = dzArr.length - 1; j >= condition; --j) {
				if (wlArr.length == 0) {
					cardsArr.push([dzArr[j][0], dzArr[j][1], dzArr[0][0], dzArr[0][1], dzArr[1][0]]);
				} else {
					cardsArr.push([dzArr[j][0], dzArr[j][1], dzArr[0][0], dzArr[0][1], wlArr[0]]);
				}
			}
		}
		return cardsArr;
	},

	//三条（五张）：三条+两单张
	santiaoFive: function santiaoFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1],
		    stArr = cArr[2];
		if (stArr.length > 0) {
			if (wlArr.length > 1) {
				for (var i = stArr.length - 1; i >= 0; --i) {
					//三条+乌龙
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], wlArr[1], wlArr[0]]);
				}
			} else if (dzArr.length > 1) {
				//三条+拆对子(三条+对子=葫芦  不属于三条)
				for (var i = stArr.length - 1; i >= 0; --i) {
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], dzArr[1][0], dzArr[0][0]]);
				}
			} else if (stArr.length > 2) {
				//只有三条，要拆两个三条当俩单张
				for (var i = stArr.length - 1; i >= 2; --i) {
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], stArr[1][0], stArr[0][0]]);
				}
			}
		}
		return cardsArr;
	},

	//顺子（五张）: 花色不同的顺子

	/*
 shunzi: function(cards){
 	var cardsArr = [];
 	if(cards.length < 5)
 		return cardsArr;
 	var cArr = cc.PokerUtil.getGroupCards(cards);
 	var wlArr=cArr[0], dzArr=cArr[1], szArr=cArr[4], decodeArr=cArr[5];
 	var szCards=[], vCards=[];
 
 	for(var i = decodeArr.length-1; i >= 0; --i){
 		var o = decodeArr[i];
 		if((i > 0 && o.value == decodeArr[i-1].value) 
 		   || (szCards.length > 0 && szCards[szCards.length-1].value == decodeArr[i].value)){
 
 		   }else{
 			   szCards.push(o);
 			   vCards[o.value] = i;
 		   }
 	}
 	//A2345
 	if(szArr.length > 0){
 		var i = szArr.length-1
 		while(i >= 0){
 			var l = szArr[i].length-1;
 			while(l > 3){
 				var sArr = [szArr[i][l],szArr[i][l-1],szArr[i][l-2],szArr[i][l-3],szArr[i][l-4]];
 				var cflag = false;
 				for(var n = 1; n < sArr.length; ++n){
 					if(sArr[n].type != sArr[n-1].type){
 						cflag = true;
 						break;
 					}
 				}
 				if(cflag){
 					sArr.reverse()
 					cardsArr.push(sArr);
 				}
 				l--;
 			}
 			i--;
 		}
 	}
 	cardsArr.reverse()
 	return cardsArr;
 },
 */

	//顺子（五张）: 花色不同的顺子
	shunzi: function shunzi(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		function has(a) {
			return a.length >= 1;
		}

		var tmpArr = cc.PokerUtil._copyArray(cards);
		cc.PokerUtil.sortPoker(1, tmpArr);
		var decodeArr = cc.PokerUtil.cardsDecode(tmpArr);

		var pl = [];
		for (var i = 0; i < 13; ++i) {
			pl[i] = [];
		}

		for (var i = 0; i < decodeArr.length; ++i) {
			var val = 13 - decodeArr[i].value;
			if (val >= 0 && val < 13) {
				pl[val].push(decodeArr[i]);
			}
		}
		if (pl.length >= 5) {
			var AKQJX = false;
			for (var j = 0; j < pl.length - 4; ++j) {
				var yes = true;
				var yesArr = [];
				for (var m = 0; m < 5; ++m) {
					if (pl[m + j].length == 0) {
						yes = false;
						break;
					} else {
						yesArr.push(pl[m + j][0]);
					}
				}
				if (yes) {
					if (j == 0) {
						//AKQJX
						cardsArr.push(yesArr);
						AKQJX = true;
					} else {
						cardsArr.push(yesArr);
					}
				}
			}

			//再检查A2345
			if (has(pl[0]) && has(pl[12]) && has(pl[11]) && has(pl[10]) && has(pl[9])) {
				if (AKQJX) {
					cardsArr.splice(1, 0, [pl[0][0], pl[12][0], pl[11][0], pl[10][0], pl[9][0]]);
				} else {
					cardsArr.splice(0, 0, [pl[0][0], pl[12][0], pl[11][0], pl[10][0], pl[9][0]]);
				}
			}
		}

		return cardsArr;
	},

	//葫芦：三张相同+一对
	hulu: function hulu(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var dzArr = cArr[1],
		    stArr = cArr[2];
		if (stArr.length > 0) {
			if (dzArr.length > 0) {
				for (var i = stArr.length - 1; i >= 0; --i) {
					for (var j = 0; j < dzArr.length; ++j) {
						cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], dzArr[j][0], dzArr[j][1]]);
					}
				}
			} else {
				//没有对子  拆对子
				for (var i = stArr.length - 1; i >= 0; --i) {
					for (var l = 0; l < stArr.length; ++l) {
						if (l >= i) break;

						cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], stArr[l][0], stArr[l][1]]);
					}
				}
			}
		}
		return cardsArr;
	},

	//铁支：四带一
	tiezhi: function tiezhi(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1],
		    stArr = cArr[2],
		    tzArr = cArr[3];
		if (tzArr.length > 0) {
			if (wlArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], wlArr[0]]);
				}
			} else if (dzArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], dzArr[0][0]]);
				}
			} else if (stArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], stArr[0][0]]);
				}
			} else if (tzArr.length > 1) {
				for (var i = tzArr.length - 1; i >= 1; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], tzArr[0][0]]);
				}
			}
		}
		return cardsArr;
	},

	//五同
	wutong: function wutong(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = cc.PokerUtil.getGroupCards(cards);
		var wtArr = cArr[6];
		if (wtArr.length > 0) {
			for (var i = wtArr.length - 1; i >= 0; --i) {
				cardsArr.push(wtArr[i]);
			}
		}
		return cardsArr;
	},

	//获取花色
	getSuit: function getSuit(cards) {
		var arr = [[], [], [], []];
		for (var i = 0; i < cards.length; ++i) {
			var suit = cards[i].type;
			arr[suit].push(cards[i]);
		}
		return arr;
	},

	//删除相同点数
	delSamePoint: function delSamePoint(cArr) {
		var arr = [],
		    cardsArr = [];
		for (var i = 0; i < cArr.length; ++i) {
			if (arr[cArr[i].value] == null) {
				arr[cArr[i].value] = true;
				cardsArr.push(cArr[i]);
			}
		}
		return cardsArr;
	},

	//同花顺
	tonghuashun: function tonghuashun(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var suitArr = cc.PokerUtil.getSuit(cArr[5]);

		for (var i = 3; i >= 0; --i) {
			var sArr = cc.PokerUtil.delSamePoint(suitArr[i]);
			if (sArr.length > 4) {
				//cc.PokerUtil.sortPoker(1, sArr)

				if (sArr[0].value == 13 && sArr[1].value == 12 && sArr[2].value == 11 && sArr[3].value == 10 && sArr[4].value == 9) {
					//A K Q J 10
					cardsArr.push([sArr[0], sArr[1], sArr[2], sArr[3], sArr[4]]);
				}
				var len = sArr.length;
				if (sArr[0].value == 13 && sArr[len - 4].value == 4 && sArr[len - 3].value == 3 && sArr[len - 2].value == 2 && sArr[len - 1].value == 1) {
					//A 2 3 4 5
					cardsArr.push([sArr[0], sArr[len - 1], sArr[len - 2], sArr[len - 3], sArr[len - 4]]);
				}
				for (var j = 0; j < sArr.length - 4; ++j) {
					if (sArr[j].value != 13) {
						if (sArr[j].value == sArr[j + 1].value + 1 && sArr[j + 1].value == sArr[j + 2].value + 1 && sArr[j + 2].value == sArr[j + 3].value + 1 && sArr[j + 3].value == sArr[j + 4].value + 1) {
							cardsArr.push([sArr[j], sArr[j + 1], sArr[j + 2], sArr[j + 3], sArr[j + 4]]);
						}
					}
				}
			}
		}
		return cardsArr;
	},

	//同花(包括同一色的对子)
	tonghua: function tonghua(cards) {

		function __dz(arr) {
			var dz = [];
			var ndz = [];

			for (var i = 0; i < arr.length;) {
				if (i < arr.length - 1 && arr[i].value == arr[i + 1].value) {
					dz.push([arr[i], arr[i + 1]]);
					i += 2;
				} else {
					ndz.push(arr[i]);
					i++;
				}
			}
			return { "dznum": dz.length, "dz": dz, "ndz": ndz };
		}

		var cardsArr = [];
		if (cards.length < 5) {
			return cardsArr;
		}

		var dzNumArr = [];
		var cArr = cc.PokerUtil.getGroupCards(cards);
		var suitArr = cc.PokerUtil.getSuit(cArr[5]);
		for (var i = 3; i >= 0; --i) {
			var sArr = suitArr[i];
			if (sArr.length > 4) {
				dzNumArr.push(__dz(sArr));
			}
		}

		dzNumArr.sort(function (x, y) {
			return x.dznum > y.dznum;
		});

		var liangdui = [];
		var yidui = [];
		var wld = [];
		for (var e = dzNumArr.length - 1; e >= 0; --e) {
			var ttt = dzNumArr[e];
			if (ttt.dznum >= 2) {
				if (ttt.ndz.length > 0) {
					//两对+一个
					for (var i = 0; i < ttt.dznum - 1; ++i) {
						for (var j = i + 1; j < ttt.dznum; ++j) {
							liangdui.push([ttt.dz[i][0], ttt.dz[i][0], ttt.dz[j][0], ttt.dz[j][1], ttt.ndz[ttt.ndz.length - 1]]);
						}
					}
				} else {
					//对子太多拆对子
					for (var i = 0; i < ttt.dznum - 2; ++i) {
						for (var j = i + 1; j < ttt.dznum - 1; ++j) {
							liangdui.push([ttt.dz[i][0], ttt.dz[i][0], ttt.dz[j][0], ttt.dz[j][1], ttt.dz[ttt.dz.length - 1][0]]);
						}
					}
				}
			} else if (ttt.dznum == 1) {
				var len = ttt.ndz.length;
				for (var l = 0; l < len - 2; ++l) {
					yidui.push([ttt.dz[0][0], ttt.dz[0][1], ttt.ndz[l], ttt.ndz[len - 2], ttt.ndz[len - 1]]);
				}
			} else {
				var len = ttt.ndz.length;
				for (var l = 0; l < len - 4; ++l) {
					wld.push([ttt.ndz[l], ttt.ndz[len - 4], ttt.ndz[len - 3], ttt.ndz[len - 2], ttt.ndz[len - 1]]);
				}
			}
		}

		liangdui.sort(function (x, y) {
			if (x[0].value > y[0].value) {
				return true;
			} else if (x[0].value == y[0].value) {
				if (x[2].value > y[2].value) {
					return true;
				} else if (x[2].value == y[2].value) {
					return x[4].value > y[4].value;
				}
			}
			return false;
		});

		yidui.sort(function (x, y) {
			if (x[0].value > y[0].value) {
				return true;
			} else if (x[0].value == y[0].value) {
				for (var i = 2; i < 5; ++i) {
					return x[i].value > y[i].value;
				}
			}
			return false;
		});

		wld.sort(function (x, y) {
			for (var i = 0; i < 5; ++i) {
				return x[i].value > y[i].value;
			}
		});

		cardsArr = cardsArr.concat(liangdui.reverse());
		cardsArr = cardsArr.concat(yidui.reverse());
		cardsArr = cardsArr.concat(wld.reverse());

		return cardsArr;
	},

	//给牌排序 sorttype: 1 大小排序 2 花色排序(牌值排序)
	sortPoker: function sortPoker(sorttype, cardlist) {
		//cc.log("========================================", sorttype)
		if (sorttype == 2) {
			cardlist.sort(function (x, y) {
				//数字越大在前
				if (x < y) return 1;
				if (x > y) return -1;
				return 0;
			});
		} else if (sorttype == 1) {
			cardlist.sort(function (x, y) {
				//var xcard = [ (x-1)/13, (x-1)%13 ];
				//var ycard = [ (y-1)/13, (y-1)%13 ];
				var xcard = cc.PokerUtil.singleCardsDecode(x);
				var ycard = cc.PokerUtil.singleCardsDecode(y);

				if (xcard.value < ycard.value) return 1;
				if (xcard.value > ycard.value) return -1;

				if (xcard.type < ycard.type) return 1;
				if (xcard.type > ycard.type) return -1;
				return 0;
			});
		}
	},

	//比较指定牌型i下：第二墩 和 第一墩 是否相公 : 是相公了 返回true
	//i: 第二墩牌型数字(0-10), a: 第二墩牌
	//b: 第一墩牌 
	//j: 表示第二墩牌的牌型(有可能第二墩有多种牌型，一般默认第一个牌型最大，所以j一般选0)

	isMessireThree: function isMessireThree(i, a, b, j) {

		//三条Five 和 三条three 比较
		if (i == 6) {
			if (a[2].value < b[2].value) {
				return true;
			}
		}

		//一对Five 和 一对three 比较
		if (i == 8) {
			if (a[0].value == b[0].value) {
				if (a[2].value < b[2].value) {
					return true;
				}
			} else if (a[0].value < b[0].value) {
				return true;
			}
		}

		//乌龙Five 和 乌龙three  比较
		if (i == 9) {
			if (a[0].value == b[0].value) {
				if (a[1].value == b[1].value) {
					if (a[2].value < b[2].value) {
						return true;
					}
				} else if (a[1].value < b[1].value) {
					return true;
				}
			} else if (a[0].value < b[0].value) {
				return true;
			}
		}
		return false;
	},

	_getDuizi: function _getDuizi(arr) {
		var dz = [];
		for (var i = 0; i < arr.length - 1;) {
			if (i < arr.length - 1 && arr[i] == arr[i + 1]) {
				dz.push([arr[i], arr[i + 1]]);
				i += 2;
			} else {
				i++;
			}
		}
		return dz;
	},

	//牌型一样情况下
	//比较指定牌型i下：第三墩 和 第二墩 是否相公  是相公返回true
	//i: 第三墩牌型(0-10)， 比较当前i牌型下a,b是否相公
	//a: 第三墩牌
	//b: 第二墩牌
	isMessireFive: function isMessireFive(i, a, b) {
		var v = [],
		    s = [];
		for (var q = 0; q < 5; ++q) {
			v.push(a[q].value);
			s.push(b[q].value);
		}
		v.sort(function (x, y) {
			return x < y;
		});
		s.sort(function (x, y) {
			return x < y;
		});

		if (i == 0 || i == 2) //五同或者四带一(铁支)
			{
				return v[2] < s[2];
			} else if (i == 3) //葫芦(三带二)
			{
				if (v[2] == s[2]) {
					if (v[0] == v[2] && s[0] == s[2]) {
						//三个都在前
						return v[3] < s[3];
					}
					if (v[0] == v[2] && s[2] == s[4]) {
						//三个在前段， 三个在后端
						return v[3] < s[0];
					}
					if (v[2] == v[4] && s[0] == s[2]) {
						return v[0] < s[3];
					}
					if (v[2] == v[4] && s[2] == s[4]) {
						return v[0] < s[0];
					}
				}
				return v[2] < s[2];
			} else if (i == 4) //同花(多一色有对子的还要比较对子)
			{
				var vdz = cc.PokerUtil._getDuizi(v);
				var sdz = cc.PokerUtil._getDuizi(s);

				cc.log("BBBBBBBBBBBBBBBBBBBB   ", vdz.length, sdz.length);

				if (vdz.length == sdz.length) {
					if (vdz.length > 0) {
						//对子数量相同
						for (var i = vdz.length - 1; i >= 0; --i) {
							if (sdz[i][0] > vdz[i][0]) {
								return true;
							}
						}
						return false;
					}

					if (vdz.length == 0) {
						//没有对子
						for (var j = 0; j < 5; ++j) {
							if (v[j] == s[j]) {
								continue;
							}
							return v[j] < s[j];
						}
					}
				} else {
					//对子数量更多
					if (vdz.length < sdz.length) {
						return true;
					}
				}

				return false;
			} else if (i == 1 || i == 5 || i == 9) //同花顺、顺子、乌龙
			{
				for (var j = 0; j < 5; ++j) {
					if (v[j] == s[j]) {
						continue;
					}
					return v[j] < s[j];
				}
				return false;
			} else if (i == 6 || i == 7 || i == 8) //三条、两对、一对
			{
				var dz_1 = [],
				    dz_2 = [],
				    wl_1 = [],
				    wl_2 = [];
				for (var j = 0; j < 5; ++j) {
					if (j < 4 && v[j] == v[j + 1] || v[j] == dz_1[dz_1.length - 1]) {
						dz_1.push(v[j]);
					} else {
						wl_1.push(v[j]);
					}

					if (j < 4 && s[j] == s[j + 1] || s[j] == dz_2[dz_2.length - 1]) {
						dz_2.push(s[j]);
					} else {
						wl_2.push(s[j]);
					}
				}

				//最大的对子相同
				if (dz_1[0] == dz_2[0]) {
					if (i == 6) //santiao
						{
							if (wl_1[0] == wl_2[0]) {
								return wl_1[1] < wl_2[1];
							} else {
								return wl_1[0] < wl_2[0];
							}
						} else if (i == 7) {
						//liangdui
						if (dz_1[2] == dz_2[2]) {
							return wl_1[0] < wl_2[0];
						} else {
							return dz_1[2] < dz_2[2];
						}
					} else if (i == 8) {
						//yidui
						for (var m = 2; m < 5; ++m) {
							if (wl_1[m] < wl_2[m]) {
								return true;
							}
						}
					}
				} else if (dz_1.length > 0 && dz_2.length > 0) {
					cc.log("dz_1[0] =" + dz_1[0], "  dz_2[0] = " + dz_2[0]);
					return dz_1[0] < dz_2[0];
				}
			}
		return false;
	},

	//获取自由摆牌组合
	getFreeStylePokerSet: function getFreeStylePokerSet(cardsArr) {
		var cArr = cc.PokerUtil.getGroupCards(cardsArr);

		//顺子
		var szArr = cc.PokerUtil.shunzi(cardsArr);

		//同花顺
		var thsArr = cc.PokerUtil.tonghuashun(cardsArr);

		//同花
		var thArr = cc.PokerUtil.tonghua(cardsArr);

		//葫芦
		var hlArr = cc.PokerUtil.hulu(cardsArr);

		//wutong
		var wtArr = cc.PokerUtil.wutong(cardsArr);

		//santiao
		var stArr = cArr[2];

		//duizi
		var dzArr = cArr[1].reverse();

		//liangdui
		var ldArr = [];
		if (dzArr.length >= 2) {
			for (var i = 0; i < dzArr.length; ++i) {
				for (var j = i + 1; j < dzArr.length; ++j) {
					ldArr.push([dzArr[i][0], dzArr[i][1], dzArr[j][0], dzArr[j][1]]);
				}
			}
		}

		//tiezhi
		var tzArr = cArr[3];

		var names = ["对子", "两对", "三条", "顺子", "同花", "葫芦", "铁支", "同花顺", "五同"];
		var cardtype = [dzArr, ldArr, stArr, szArr, thArr, hlArr, tzArr, thsArr, wtArr];
		var ret = [];

		for (var i = 0; i < cardtype.length; ++i) {
			var dt = {};
			dt.name = names[i];
			dt.value = cardtype[i];
			ret.push(dt);
		}
		return ret;
	},

	//获取推荐三墩牌组合
	getRecommendPokerSet: function getRecommendPokerSet(cardsArr) {
		function printArr(a, name) {
			var str = name;
			for (var i = 0; i < a.length; ++i) {
				str += a[i] + ", ";
			}
			cc.log(str);
		}
		var t5Group = cc.PokerUtil.t5Group;
		var t3Group = cc.PokerUtil.t3Group;
		var cArr = [],
		    existArr = [],
		    cNameArr = [];

		printArr(cardsArr, "总牌：");
		for (var i = 0; i < t5Group.length - 1; ++i) //不检查乌龙，先找第一个5张组合，从大往小
		{
			var ccArr = cc.PokerUtil._copyArray(cardsArr);
			var cards_1 = t5Group[i](ccArr); //第三墩5张牌

			cc.log("NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN  ", cards_1.length);

			for (var l = 0; l < cards_1.length; ++l) {
				cc.log("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  ", l);
				cc.log("找到第三顿牌型： =============================================", i);
				cc.log("cards_1  cards_1 cards_1 length ", i, cards_1.length);
				var breakfor = false;
				for (var n = 0; n < t5Group.length; ++n) {
					var tmpCards_1 = cc.PokerUtil.cardsEncode(cards_1[l]);
					printArr(tmpCards_1, "encode牌：");
					var sArr = cc.PokerUtil._delCards(ccArr, tmpCards_1);
					printArr(sArr, "剩下牌： ");
					var cards_2 = t5Group[n](sArr); //第二墩5张牌

					if (cards_2.length > 0) {
						cc.log("找到第二顿派性：-------------------", n);
						cc.log("cards_2 cards_2 cards_2 cards_2 length ", n, cards_2.length);
						if (n < i) {
							breakfor = true;
							break;
						}
						for (var j = 0; j < cards_2.length; ++j) {
							var cflag = false;
							if (i == n) {
								//2,3墩牌型一样
								cflag = cc.PokerUtil.isMessireFive(i, cards_1[l], cards_2[j]);

								if (cflag) {
									cc.log("相公啦相公啦相公啦相公啦相公啦: ", i);
								}
							}
							if (!cflag) {
								var tmpCards_2 = cc.PokerUtil.cardsEncode(cards_2[j]);
								var tArr = cc.PokerUtil._delCards(sArr, tmpCards_2); //第一墩3张牌
								cc.log(tArr, "第二次剩下牌：");
								for (var k = 0; k < cc.PokerUtil.t3Group.length; ++k) {
									var cards_3 = cc.PokerUtil.t3Group[k](tArr);
									var cflag2 = false;

									if (cards_3.length > 0) {
										if (k == 0 && n < 6 || k == 1 && n < 8 || k == 2 && n < 9) {
											cflag2 = true;
										}
										if (k == 0 && n == 6 || k == 1 && n == 8 || k == 2 && n == 9) {

											var fl = cc.PokerUtil.isMessireThree(n, cards_2[j], cards_3[0], 0);
											/*
           											var tttt = cc.PokerUtil.cardsEncode(cards_2[j])
           											var jjj = cc.PokerUtil.cardsEncode(cards_3[0])
           											cc.log("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM      ", fl, k, n)
           											printArr(tttt, "参数一： " )
           											printArr(jjj, "参数二： " )
           */
											cflag2 = fl == false;
										}
									}

									if (cflag2) {
										if (existArr[1000 * i + 100 * n + k] == null) {
											var cardres = { "top": { "card": [], "type": -1 }, "middle": { "card": [], "type": -1 }, "bottom": { "card": [], "type": -1 } };
											cardres.top.card = cc.PokerUtil.cardsEncode(cards_3[0].slice());
											cardres.top.type = k;
											cardres.middle.card = cc.PokerUtil.cardsEncode(cards_2[j].slice());
											cardres.middle.type = n;
											cardres.bottom.card = cc.PokerUtil.cardsEncode(cards_1[l].slice());
											cardres.bottom.type = i;
											cArr.push(cardres);
											existArr[1000 * i + 100 * n + k] = true;

											//只找五个吧
											if (cArr.length >= 5) {
												return cArr;
											}
										}
									}
								}
							}
						}
					}
				}
				if (breakfor) {
					break;
				}
			}
		}
		return cArr;
	},

	//计算得分
	//allhands: S_G13_AllHands消息
	calculateScore: function calculateScore(allhands) {

		//是否是特殊牌型
		function isSpecial(card) {
			if (card.spec.brand == 0) {
				return false;
			}
			return true;
		}

		//算牌型得分，还没算打枪和全垒打
		//cars: 当前墩牌S_G13_AllHands.BrandInfo
		//idx: 第几墩
		//isSpecial: 是否是特殊牌型
		function getScore(cards, idx, isSpecial) {
			var score = 1;
			if (!isSpecial) {
				if (idx == 1 && cards.brand == 3) {
					//冲三
					score += 2;
				}
				if (idx == 2 && cards.brand == 6) {
					//中墩葫芦
					score += 1;
				}
				if (cards.brand == 9) {
					if (idx == 2) {
						score += 19;
					} //中墩五同
					if (idx == 3) {
						score += 9;
					} //尾墩五同	
				}
				if (cards.brand == 8) {
					if (idx == 2) {
						score += 9;
					} //中墩同花顺
					if (idx == 3) {
						score += 4;
					} //尾墩同花顺
				}
				if (cards.brand == 7) {
					if (idx == 2) {
						score += 7;
					} //中墩铁支
					if (idx == 3) {
						score += 3;
					} //尾墩铁支
				}
			} else {
				score = 0;
				var br = Math.floor(cards.brand / 10);
				if (br == 13) {
					//青龙
					var ytl = cc.gamemanager.room_info.attr.yi_tiao_long;
					score += 104 * ytl;
				}
				if (br == 12) {
					//一条龙
					var ytl = cc.gamemanager.room_info.attr.yi_tiao_long;
					score += 52 * ytl;
				}
				if (br == 11) {
					score += 26;
				} //十二皇子
				if (br == 10) {
					score += 26;
				} //三同花顺
				if (br == 9) {
					score += 26;
				} //三炸弹
				if (br >= 1 && br <= 8) {
					score += 6;
				} //其他特殊牌型
			}
			return score;
		}

		//比较两墩牌
		//card1: 牌型和点数 spe1:是否是特殊牌型
		//card2: 牌型和点数 spe2:是否是特殊牌型
		function compareCard(card1, spe1, card2, spe2) {
			if (spe1 && !spe2) {
				return 1;
			}
			if (!spe1 && !spe2) {
				if (card1.brand > card2.brand) {
					return 1;
				} else if (card1.brand == card2.brand) {
					if (card1.point > card2.point) {
						return 1;
					} else if (card1.point == card2.point) {
						return 0;
					}
				}
			} else if (spe1 && spe2) {
				var a = card1.brand % 10;
				var b = card2.brand % 10;
				if (a > b) {
					return 1;
				} else if (a == b) {
					return 0;
				} else {
					return -1;
				}
			}
			return -1;
		}

		function newBrandInfo(cuid) {
			var brand = {};
			brand.cuid = cuid;
			brand.score = { "top": 0, "middle": 0, "bottom": 0, "spe": 0, "special": 0, "quanleida": 0 };
			brand.daqianglist = [];
			brand.quanleida = false;
			return brand;
		}

		var ret = [];
		for (var i = 0; i < allhands.players.length; ++i) {
			//每个玩家一个newBrandInfo数组，保存自己赢的数据
			ret.push(newBrandInfo(allhands.players[i].cuid));
		}

		//保存胜利的玩家id

		var players = allhands.players;
		for (var i = 0; i < players.length; ++i) {
			var data1 = players[i];
			var spe1 = isSpecial(data1);

			var large = [];
			for (var j = 0; j < players.length; ++j) {
				var data2 = players[j];
				var spe2 = isSpecial(data2);

				if (i == j) {
					continue;
				}

				//特殊牌型大
				var la = {};
				//var cmp = compareCard(data1.spec, spe1, data2.spec, spe2)
				if (spe1) {
					var sc = getScore(data1.spec, 0, true);
					ret[i].score.special += sc;

					//特殊牌型分数不加到打枪分数了
					//ret[i].score.spe += sc //三墩都大
					//ret[j].score.spe -= sc 
					//la.idx = j
					//la.score = sc*2
					//large.push(la)
					continue;
				}

				//一般牌型
				var tmb = 0;
				var tbmScore = 0;
				var cmp = compareCard(data1.dun0, spe1, data2.dun0, spe2);
				if (cmp == 1) {
					var sc = getScore(data1.dun0, 1, spe1);
					ret[i].score.top += sc;
					ret[j].score.top -= sc;
					tmb++;
					tbmScore += sc;
				}

				cmp = compareCard(data1.dun1, spe1, data2.dun1, spe2);
				if (cmp == 1) {
					var sc = getScore(data1.dun1, 2, spe1);
					ret[i].score.middle += sc;
					ret[j].score.middle -= sc;
					tmb++;
					tbmScore += sc;
				}

				cmp = compareCard(data1.dun2, spe1, data2.dun2, spe2);
				if (cmp == 1) {
					var sc = getScore(data1.dun2, 3, spe1);
					ret[i].score.bottom += sc;
					ret[j].score.bottom -= sc;
					tmb++;
					tbmScore += sc;
				}

				if (tmb == 3) {
					//打枪
					if (cc.gamemanager.room_info.attr.da_qiang == 3) {
						//加三道
						ret[i].score.spe += 3;
						ret[j].score.spe -= 3;
						la.score = tbmScore + 3;
					} else if (cc.gamemanager.room_info.attr.da_qiang == 2) {
						//双倍
						ret[i].score.spe += tbmScore;
						ret[j].score.spe -= tbmScore;
						la.score = tbmScore * 2;
					}

					la.idx = j;
					large.push(la);
				}
			}

			//全垒打(两人以上才能全垒打)
			if (large.length == players.length - 1 && players.length > 2) {
				if (cc.gamemanager.room_info.attr.quan_lei_da == true) {
					ret[i].quanleida = true;
					for (var m = 0; m < large.length; ++m) {
						ret[i].score.quanleida += large[m].score;
						ret[large[m].idx].score.quanleida -= large[m].score;
					}
				}
			} else {
				//打枪
				for (var n = 0; n < large.length; ++n) {
					//ret[i].score.spe += large[n].score
					//ret[large[n].idx].score.spe -= large[n].score
					ret[i].daqianglist.push(players[large[n].idx].cuid);
				}
			}
		}

		return ret;
	},

	//判断是否相公
	isMessire: function isMessire(top, middle, bottom) {
		var toptype = -1,
		    midtype = -1,
		    bottype = -1;
		var toparr = [],
		    midarr = [],
		    botarr = [];

		for (var i = 0; i < cc.PokerUtil.t3Group.length; ++i) {
			var arr = cc.PokerUtil.t3Group[i](top);
			if (arr && arr.length > 0) {
				toptype = i;
				toparr = arr[0];
				break;
			}
		}

		for (var i = 0; i < cc.PokerUtil.t5Group.length; ++i) {
			var arr = cc.PokerUtil.t5Group[i](middle);
			if (arr && arr.length > 0 && midtype == -1) {
				midtype = i;
				midarr = arr[0];
			}

			var brr = cc.PokerUtil.t5Group[i](bottom);
			if (brr && brr.length > 0 && bottype == -1) {
				bottype = i;
				botarr = brr[0];
			}

			if (midtype != -1 && bottype != -1) {
				break;
			}
		}

		function printArr(a, s) {
			var str = s;
			for (var i = 0; i < a.length; ++i) {
				str += a[i].type.toString() + " - " + a[i].value.toString() + ", ";
			}
			cc.log(str);
		}

		cc.log("三墩牌所属的类型：", toptype, midtype, bottype);
		printArr(toparr, "第一墩牌：");
		printArr(midarr, "第二墩牌：");
		printArr(botarr, "第三墩牌：");

		if (toptype == 0 && midtype > 6 || toptype == 1 && midtype > 8) {
			cc.log("1,2墩相公");
			return true;
		}
		if (toptype == 0 && midtype == 6 || toptype == 1 && midtype == 8 || toptype == 2 && midtype == 9) {
			if (cc.PokerUtil.isMessireThree(midtype, midarr, toparr, 0)) {
				cc.log("1,2相公", midtype);
				return true;
			}
		}

		//compare 2dun and 3dun
		if (midtype < bottype) {
			cc.log("2,3相公", midtype, bottype);
			return true;
		} else if (midtype == bottype) {
			if (cc.PokerUtil.isMessireFive(bottype, botarr, midarr)) {
				cc.log("2,3墩相公", bottype);
				return true;
			}
		}
		return false;
	},

	////////////////////////////////////////////////////////////////////////////
	//特殊牌型判断  

	//14.	三同花：中墩、尾墩为同花，头墩为三张同花色的牌
	isSanTongHua: function isSanTongHua(cards) {
		var tmp = cc.PokerUtil._copyArray(cards);
		var thArr = cc.PokerUtil.tonghua(tmp);
		for (var i = 0; i < thArr.length; ++i) {
			var a = cc.PokerUtil.cardsEncode(thArr[i]);
			var b = cc.PokerUtil._delCards(tmp, a);

			var thArr2 = cc.PokerUtil.tonghua(b);
			for (var j = 0; j < thArr2.length; ++j) {
				var c = cc.PokerUtil.cardsEncode(thArr2[j]);
				var d = cc.PokerUtil._delCards(b, c);

				var suit = cc.PokerUtil.getSuit(cc.PokerUtil.cardsDecode(d));
				for (var m = 0; m < 4; ++m) {
					if (suit[m].length == 3) {
						var ret = {};
						ret.top = d.slice();
						ret.middle = c.slice();
						ret.bottom = a.slice();
						return ret;
					}
				}
			}
		}
		return null;
	},

	//13.	三顺子：中墩、尾墩为顺子，头墩为三张连续的牌
	isSanShunZi: function isSanShunZi(cards) {
		var tmp = cc.PokerUtil._copyArray(cards);
		var thArr = cc.PokerUtil.shunzi(tmp);
		for (var i = 0; i < thArr.length; ++i) {
			var a = cc.PokerUtil.cardsEncode(thArr[i]);
			var b = cc.PokerUtil._delCards(tmp, a);

			var thArr2 = cc.PokerUtil.shunzi(b);
			for (var j = 0; j < thArr2.length; ++j) {
				var c = cc.PokerUtil.cardsEncode(thArr2[j]);
				var d = cc.PokerUtil._delCards(b, c);

				var e = cc.PokerUtil.cardsDecode(d);

				if (e[0].value == e[1].value + 1 && e[1].value == e[2].value + 1 || e[0].value == 13 && e[1].value == 2 && e[2].value == 1) {
					var ret = {};
					ret.top = d.slice();
					ret.middle = c.slice();
					ret.bottom = a.slice();
					return ret;
				}
			}
		}
		return null;
	},

	//12.	六对半：十三张牌由六个对子加一张其他单牌组成。
	isLiuDuiBan: function isLiuDuiBan(cards) {
		var tmp = cc.PokerUtil.getGroupCards(cards);
		if (tmp[1].length == 6 //6对
		|| tmp[1].length + 2 * tmp[3].length == 6 //四对+铁支
		) {
				return {};
			}
		return null;
	},

	//11.	五对三条：十三张牌由五个对子加一组三条组成
	isWuDuiSanTiao: function isWuDuiSanTiao(cards) {
		var tmp = cc.PokerUtil.getGroupCards(cards);
		if (tmp[1].length == 5 && tmp[2].length == 1) {
			return {};
		}
		return null;
	},

	//10.	四套三条：十三张牌由四组三条组成加一张单牌
	isSiSanTiao: function isSiSanTiao(cards) {
		var tmp = cc.PokerUtil.getGroupCards(cards);
		if (tmp[2].length == 4) {
			return {};
		}
		return null;
	},

	//9.	凑一色：十三张牌花色均为红色或者黑色
	isCouYiCe: function isCouYiCe(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		var s = cc.PokerUtil.getSuit(a);
		if (s[0].length + s[2].length == cards.length) {
			//全红
			return {};
		}
		if (s[1].length + s[3].length == cards.length) {
			//全黑
			return {};
		}
		return null;
	},

	//8.	全小：十三张牌都是2、3、4、5、6、7、8，不论花色
	isQuanXiao: function isQuanXiao(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		for (var i = 0; i < a.length; ++i) {
			if (a[i].value < 0 || a[i].value > 7) {
				return null;
			}
		}
		return {};
	},

	//7.	全大：十三张牌都是8、9、10、J、Q、K、A，不论花色
	isQuanDa: function isQuanDa(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		for (var i = 0; i < a.length; ++i) {
			if (a[i].value < 7 || a[i].value > 13) {
				return null;
			}
		}
		return {};
	},

	//6.	三套炸弹：共三组铁支和任意1张其他单牌组成的牌
	isSanZhaDan: function isSanZhaDan(cards) {
		var a = cc.PokerUtil.getGroupCards(cards);
		if (a[3].length == 3) {
			return {};
		}
		return null;
	},

	//5.	三同花顺：中墩、尾墩均为同花顺，头墩为三张花色相同且连续的牌
	isSanTongHuaShun: function isSanTongHuaShun(cards) {
		var tmp = cc.PokerUtil._copyArray(cards);
		var thArr = cc.PokerUtil.tonghuashun(tmp);
		for (var i = 0; i < thArr.length; ++i) {
			var a = cc.PokerUtil.cardsEncode(thArr[i]);
			var b = cc.PokerUtil._delCards(tmp, a);

			var thArr2 = cc.PokerUtil.tonghuashun(b);
			for (var j = 0; j < thArr2.length; ++j) {
				var c = cc.PokerUtil.cardsEncode(thArr2[j]);
				var d = cc.PokerUtil._delCards(b, c);

				cc.PokerUtil.sortPoker(1, d);
				var e = cc.PokerUtil.cardsDecode(d);
				if (e[0].type == e[1].type && e[1].type == e[2].type && e[0].value == e[1].value + 1 && e[1].value == e[2].value + 1 || e[0].value == 13 && e[1].value == 2 && e[2].value == 1) {
					var ret = {};
					ret.top = d.slice();
					ret.middle = c.slice();
					ret.bottom = a.slice();
					return ret;
				}
			}
		}
		return null;
	},

	//4.	十二皇族：十三张牌均是AKQJ
	isShierHuangzu: function isShierHuangzu(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		for (var i = 0; i < a.length; ++i) {
			var b = a[i].value;
			if (b != 13 && b != 12 && b != 11 && b != 10) {
				return null;
			}
		}
		return {};
	},

	//3.	一条龙：不同花色，A到K各一张的十三张牌
	isYiTiaoLong: function isYiTiaoLong(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		var sign = [];
		for (var i = 0; i < a.length; ++i) {
			var v = a[i].value;
			if (sign[v] == true) {
				return null;
			}
			sign[v] = true;
		}
		return {};
	},

	//2.	清龙：同一种花色，A到K各一张的十三张牌
	isQingLong: function isQingLong(cards) {
		var a = cc.PokerUtil.cardsDecode(cards);
		var sign = [];
		var typenum = 0,
		    lasttype = -1;
		for (var i = 0; i < a.length; ++i) {
			var v = a[i].value;
			if (sign[v] == true) {
				return null;
			}
			sign[v] = true;
			if (lasttype == -1) {
				lasttype = a[i].type;
			} else if (a[i].type != lasttype) {
				return null;
			}
		}
		return {};
	},

	//打印扑克牌
	printPoker: function printPoker(arr) {
		var str = "";

		var suitStr = ["方", "梅", "红", "黑"];
		var pk = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];

		for (var i = 0; i < arr.length; ++i) {
			var val = arr[i];

			var st = suitStr[val.type];
			var va = pk[val.value];
			str += st + va + " ";
		}

		cc.log(str);
	},

	printPokerEncode: function printPokerEncode(arr) {
		var encodeArr = cc.PokerUtil.cardsDecode(arr);
		cc.PokerUtil.printPoker(encodeArr);
	}
});

cc.PokerUtil = new M();

//第二墩、第三墩比较规则(5张牌)
cc.PokerUtil.t5Group = [];

cc.PokerUtil.t5Group[0] = cc.PokerUtil.wutong;
cc.PokerUtil.t5Group[1] = cc.PokerUtil.tonghuashun;
cc.PokerUtil.t5Group[2] = cc.PokerUtil.tiezhi;
cc.PokerUtil.t5Group[3] = cc.PokerUtil.hulu;
cc.PokerUtil.t5Group[4] = cc.PokerUtil.tonghua;
cc.PokerUtil.t5Group[5] = cc.PokerUtil.shunzi;
cc.PokerUtil.t5Group[6] = cc.PokerUtil.santiaoFive;
cc.PokerUtil.t5Group[7] = cc.PokerUtil.liangdui;
cc.PokerUtil.t5Group[8] = cc.PokerUtil.yiduiFive;
cc.PokerUtil.t5Group[9] = cc.PokerUtil.wulongFive;

//第一墩比较规则(3张牌)
cc.PokerUtil.t3Group = [];
cc.PokerUtil.t3Group[0] = cc.PokerUtil.santiao;
cc.PokerUtil.t3Group[1] = cc.PokerUtil.yiduiThree;
cc.PokerUtil.t3Group[2] = cc.PokerUtil.wulongThree;

//特殊牌型判断
cc.PokerUtil.specialGroup = [];
cc.PokerUtil.specialGroup[0] = cc.PokerUtil.isQingLong;
cc.PokerUtil.specialGroup[1] = cc.PokerUtil.isYiTiaoLong;
cc.PokerUtil.specialGroup[2] = cc.PokerUtil.isShierHuangzu;
cc.PokerUtil.specialGroup[3] = cc.PokerUtil.isSanTongHuaShun;
cc.PokerUtil.specialGroup[4] = cc.PokerUtil.isSanZhaDan;
cc.PokerUtil.specialGroup[5] = cc.PokerUtil.isQuanDa;
cc.PokerUtil.specialGroup[6] = cc.PokerUtil.isQuanXiao;
cc.PokerUtil.specialGroup[7] = cc.PokerUtil.isCouYiCe;
cc.PokerUtil.specialGroup[8] = cc.PokerUtil.isSiSanTiao;
cc.PokerUtil.specialGroup[9] = cc.PokerUtil.isWuDuiSanTiao;
cc.PokerUtil.specialGroup[10] = cc.PokerUtil.isLiuDuiBan;
cc.PokerUtil.specialGroup[11] = cc.PokerUtil.isSanShunZi;
cc.PokerUtil.specialGroup[12] = cc.PokerUtil.isSanTongHua;

cc._RF.pop();
},{}],"RecordItem":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ac4e8kDqfZOy5gNHmkkHDcu', 'RecordItem');
// Scripts\Gui\RecordItem.js

'use strict';

cc.Class({
    extends: cc.Component,

    properties: {
        spriteS: cc.SpriteFrame,
        spriteY: cc.SpriteFrame,
        spriteP: cc.SpriteFrame,
        icon: cc.Sprite,
        roomid: cc.Label,
        myScore: cc.Label,
        player_1: cc.Label,
        player_2: cc.Label,
        player_3: cc.Label,
        player_4: cc.Label,
        time: cc.Label
    },

    setData: function setData(data) {
        if (data) {
            this.node.active = true;
            this.roomid.string = data.roomid.toString();
            if (data.rank == 0) {
                this.myScore.node.color = cc.Color.WHITE;
                this.icon.spriteFrame = this.spriteP;
            } else if (data.rank > 0) {
                this.myScore.node.color = cc.Color.YELLOW;
                this.icon.spriteFrame = this.spriteY;
            } else {
                this.myScore.node.color = cc.Color.RED;
                this.icon.spriteFrame = this.spriteS;
            }
            this.myScore.string = '\n' + data.rank;
            for (var i = 1; i <= 4; ++i) {
                if (data.opps.length >= i) {
                    var op = data.opps[i - 1];
                    this["player_" + i.toString()].string = op.name.concat('\n', op.rank.toString(), '\n', op.cuid.toString());
                } else {
                    this["player_" + i.toString()].string = "无";
                }
            }

            var date = new Date();
            date.setTime(data.time * 1000);
            this.time.string = date.Format("yyyy-MM-dd\nhh:mm:ss");
        } else {
            this.node.active = false;
        }
    }
});

cc._RF.pop();
},{}],"SceneManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5c8f0oxxLpE/6xiGrgxAiIh', 'SceneManager');
// Scripts\Manager\SceneManager.js

'use strict';

var M = cc.Class({

    isPokerGameScene: function isPokerGameScene() {
        return this.currentScene == "PokerGame";
    },

    loadScene: function loadScene(name, call) {
        if (this.currentScene != name) {
            cc.guimanager.closeAll();
            cc.guimanager.open('UILoading', function (panel) {
                var loadSceneCall = call;
                var sceneName = name;
                cc.director.loadScene(sceneName, function () {
                    if (loadSceneCall) loadSceneCall();
                });
            });
            this.currentScene = name;
        }
    },

    loadMainScene: function loadMainScene() {
        var sceneSelf = this;
        this.loadScene('Main', function () {
            cc.log('loadMainScene');
            if (cc.gamemanager.room_info) {
                cc.gamemanager.gameStart();
            } else {
                cc.log("open UIMain");
                var self = sceneSelf;
                cc.guimanager.open('UIMain', function () {
                    self.afterSceneLoad();
                });
            }
        });
    },

    loadLoginScene: function loadLoginScene() {
        cc.log('loadlogin');
        var sceneSelf = this;
        this.loadScene('Login', function () {
            var self = sceneSelf;
            cc.guimanager.open('UILogin', function () {
                self.afterSceneLoad();
            });
        });
    },

    loadPokerGameScene: function loadPokerGameScene() {
        cc.log("LoadPokerGameScene");
        var sceneSelf = this;
        this.loadScene("PokerGame", function () {
            var self = sceneSelf;
            cc.guimanager.open("UIPokerGame", function () {
                self.afterSceneLoad();
            });
        });
    },

    afterSceneLoad: function afterSceneLoad() {
        cc.guimanager.closeByName('UILoading');
    }
});

cc.scenemanager = new M();

cc._RF.pop();
},{}],"ScoreSummary":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd2465wQtiFL5YRCYWgpAWqG', 'ScoreSummary');
// Scripts\Gui\ScoreSummary.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        scoreLabel: cc.Label,
        smJsPanel: cc.Prefab,
        specialJsPanel: cc.Prefab,
        label: cc.Label,
        timecd: cc.RichText,
        container: cc.Node,
        match: cc.Label,
        titleImg: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        //this.scoreLabel.string = this.getNowFormatDate().toString()
        this.scoreLabel.string = "房间号：" + cc.gamemanager.room_info.room_id.toString();

        this.cd = 30;

        this.node.runAction(cc.repeatForever(cc.sequence(cc.delayTime(1.0), cc.callFunc(function (target, param) {
            param.cd = param.cd - 1;

            var roomAttr = cc.gamemanager.room_info.attr;
            if (cc.gamemanager._currentRounds >= roomAttr.rounds) {
                param.timecd.string = "<color=#FF0000>" + param.cd.toString() + "</c>秒后显示总结算";
            } else {
                param.timecd.string = "<color=#FF0000>" + param.cd.toString() + "</c>秒后自动开始下一局";
            }
            if (param.cd == 0) {
                param.nextMatch();
            }
        }, this, this))));
    },

    getNowFormatDate: function getNowFormatDate() {
        var date = new Date();
        var seperator1 = "-";
        var seperator2 = ":";
        var month = date.getMonth() + 1;
        var strDate = date.getDate();
        if (month >= 1 && month <= 9) {
            month = "0" + month;
        }
        if (strDate >= 0 && strDate <= 9) {
            strDate = "0" + strDate;
        }
        var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + " " + date.getHours() + seperator2 + date.getMinutes() + seperator2 + date.getSeconds();
        return currentdate;
    },

    initialize: function initialize(indata) {

        var AllHandsData = indata.serverdata;
        var scoreSummary = indata.clientdata;

        var selfData = cc.datamanager.mainPlayerData;

        //var container = this.node.getChildByName("container")
        var playerNum = cc.gamemanager.room_info.attr.player_size;
        //var poses = cc.configmanager.summarypos[playerNum-2]
        for (var i = 0; i < playerNum; ++i) {
            var node = null;
            if (AllHandsData[i].spec.brand != 0) {
                node = cc.instantiate(this.specialJsPanel);
            } else {
                node = cc.instantiate(this.smJsPanel);
            }
            if (node) {
                node.position = cc.v2(0, 0);
                node.getComponent("smJsPanel").initCard(AllHandsData[i], scoreSummary[i]);
                node.parent = this.container;
            }
            //node.position = poses[i]

            if (AllHandsData[i].cuid.eq(selfData.cuid)) {
                if (AllHandsData[i].rank > 0) {
                    cc.PokerUtil.replaceSprite("Textures/singlewin", this.titleImg);
                } else if (AllHandsData[i].rank < 0) {
                    cc.PokerUtil.replaceSprite("Textures/singlelose", this.titleImg);
                } else {
                    cc.PokerUtil.replaceSprite("Textures/singlepj", this.titleImg);
                }
            }
        }

        //var scale = cc.view.getFrameSize().width / (1.8*cc.view.getFrameSize().height)
        //container.scale = scale

        this.match.string = "第" + cc.gamemanager._currentRounds.toString() + "局";
        if (cc.gamemanager._currentRounds >= cc.gamemanager.room_info.attr.rounds) {
            this.label.string = "总结算";
        }
    },

    share: function share() {
        cc.guimanager.open('UIShare', function (panel) {
            panel.setType(1);
        });
    },

    nextMatch: function nextMatch() {
        var roomAttr = cc.gamemanager.room_info.attr;
        var pgame = cc.find("UIPokerGame").getComponent("UIPokerGame");

        if (cc.gamemanager._currentRounds >= roomAttr.rounds) {
            this.node.destroy();

            if (cc.gamemanager.isPracticeRoom()) {
                //练习场要模拟发送总结算消息
                cc.robot.sendAllRoundsSummary();
            }
            pgame.showGameResult();
        } else {
            this.node.destroy();

            if (cc.gamemanager.isPracticeRoom()) {
                //练习场要模拟发送下一局牌信息
                var round = cc.gamemanager._currentRounds + 1;
                cc.robot.sendPlayerInRoom(round, 3, 3);
                cc.robot.sendHandleOfMine(round);
            }
            cc.gamemanager.nextMatch();
        }
    },

    setScore: function setScore(score) {}
    //this.scoreLabel.getComponent(cc.Label).string = score.toString()


    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"ShopItem":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'c53e83gER1EiKyRDpugV92f', 'ShopItem');
// Scripts\Gui\Widget\ShopItem.js

'use strict';

cc.Class({
    extends: cc.Component,

    properties: {
        discount: cc.Node,
        discountText: cc.Label,
        img: cc.Sprite,
        moneyText: cc.Label,
        diamondText: cc.Label
    },

    //diamon discount price id image
    setData: function setData(data) {
        this.itemData = data;
        this.diamondText.string = String(data.diamond);
        if (data.discount > 0) {
            this.discount.active = true;
            this.discountText.string = '内赠{0}%'.format(data.discount);
        } else {
            data.discount.active = false;
        }
        this.moneyText.string = String(data.price);
        cc.loader.loadRes('Textures/' + data.image, cc.SpriteFrame, function (err, spriteFrame) {
            this.img.spriteFrame = spriteFrame;
        });
    },

    buy: function buy() {
        /// this.itemData.id
        //TODO:购买
    }
});

cc._RF.pop();
},{}],"UIChat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5b754Of9BtJELRQHB13mt6Z', 'UIChat');
// Scripts\Gui\UIChat.js

'use strict';

require('UIPanel');

cc.Class({
    extends: cc.uipanel,

    properties: {
        chatPage: cc.Node,
        facePage: cc.Node,
        chatBack: cc.Node,
        editBox: cc.EditBox,
        chatContent: cc.Node
    },

    onTouchBg: function onTouchBg() {
        this.setVisible(false);
    },

    onCreate: function onCreate() {
        var self = this;
        this.chatBack.on(cc.Node.EventType.TOUCH_START, function (event) {
            event.stopPropagationImmediate();
        });
        var self = this;
        cc.loader.loadRes('Gui/Widget/ChatSplit', function (err, splitPrefab) {
            self.splitPrefab = splitPrefab;
            cc.loader.loadRes('Gui/Widget/ChatItem', function (err, chatItemPrefab) {
                self.chatItemPrefab = chatItemPrefab;
            });
        });
        this._super();
    },

    onClose: function onClose() {
        if (this.splitPrefab) cc.loader.releaseAsset(this.splitPrefab);
        if (this.chatItemPrefab) cc.loader.releaseAsset(this.chatItemPrefab);
        this._super();
    },

    isReady: function isReady() {
        return this.splitPrefab && this.chatItemPrefab;
    },

    onChackChatpage: function onChackChatpage() {
        this.chatPage.active = true;
        this.facePage.active = false;
    },
    onCheckFacepage: function onCheckFacepage() {
        this.chatPage.active = false;
        this.facePage.active = true;
    },

    popBullet: function popBullet(msg) {
        var panel = cc.guimanager.getByName('UIPokerGame');
        if (panel) {
            cc.log('test');
            panel.showChat(cc.datamanager.mainPlayerData.cuid, msg);
        }
        this.setVisible(false);
    },
    sendChat: function sendChat() {
        var str = this.editBox.string;
        if (str.length > 0) {
            var msg = cc.netmanager.msg("PublicProto.C_SendChat");
            msg.type = 0;
            msg.data_text = str;
            cc.netmanager.send(msg);

            this.addChat(cc.gamemanager.mainPlayer(), str);
            this.editBox.string = "";
            this.popBullet(msg);
        }
    },

    addChat: function addChat(player, text) {
        if (player && this.isReady()) {
            //添加到聊天列表
            var split = cc.instantiate(this.splitPrefab);
            var item = cc.instantiate(this.chatItemPrefab);
            var str = '<color=#00ff00>'.concat(player.name, ':</c><color=#ffefbe>', text, '</c>');
            item.getComponent(cc.RichText).string = str;
            item.parent = this.chatContent;
            item.position = cc.p(11, 12);

            split.parent = this.chatContent;
            split.position = cc.p(219, 1);
        }
    },

    PublicProto_S_Chat: function PublicProto_S_Chat(msg) {
        if (msg.content.type == 0) {
            var player = cc.gamemanager.getPlayer(msg.cuid);
            if (player) {
                this.addChat(player, msg.content.data_text);
            }
        }
    },

    sendFace: function sendFace(event, id) {
        var msg = cc.netmanager.msg("PublicProto.C_SendChat");
        msg.type = 1;
        msg.data_int = parseInt(id);
        cc.netmanager.send(msg);

        this.popBullet(msg);
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UICreateRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b4589LqpfVHLZMcyKcdxlFe', 'UICreateRoom');
// Scripts\Gui\UICreateRoom.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        createBtn: cc.Button,
        quanleidaToggle: cc.Toggle,
        fivePlayer: cc.Toggle,
        gameLabel: cc.Label,
        roundNode: cc.Node
    },

    onCreate: function onCreate() {
        this.bgOpaque = 230;
        this.init();
        this._super();
    },

    init: function init() {

        var setting = cc.datamanager.getRoomSetting();
        if (!setting) {
            //默认设置
            var v = cc.datamanager.mainData.price_list[0];
            if (!v) {
                v = "10";
            } else {
                v = String(v.rounds);
            }
            setting = {
                isQuanLeiDa: false,
                checks: [["0", "0", "52"], ["1", "0", v], ["2", "0", "10"], ["3", "0", "3"], ["4", "0", "1"], ["5", "1", "4"]]
            };
        }
        this.roomSetting = setting;
        var groups = this.node.getComponentsInChildren(cc.ToggleGroup);
        for (var i = 0; i < groups.length; ++i) {
            var items = groups[i].toggleItems;
            var index = parseInt(setting.checks[i][1]);

            for (var j = 0; j < items.length; ++j) {
                var check = items[j].node.name == 'toggle' + (index + 1);
                items[j].isChecked = check;
            }
        }
        this.updateMoney();
        this.quanleidaToggle.isChecked = setting.isQuanLeiDa;
        this.onGameTypeChange(this.roomSetting.checks[0][1] == 1);
    },

    activeFivePlayer: function activeFivePlayer(bActive) {
        this.fivePlayer.node.active = bActive;
    },

    onGameTypeChange: function onGameTypeChange(special) {
        this.activeFivePlayer(special);
        if (!special && this.roomSetting.checks[5][1] == 0) {
            this.roomSetting.checks[5][1] = 1;
            this.roomSetting.checks[5][2] = 4;
        }
        if (!special) {
            this.gameLabel.string = '52张牌（4色A-K十三张）';
        } else {
            this.gameLabel.string = '65张牌 (4色牌加1色黑桃牌A-K)';
        }
    },

    updateMoney: function updateMoney() {
        var price = cc.datamanager.mainData.price_list;
        var count = this.roundNode.childrenCount;
        for (var i = 0; i < count; ++i) {
            if (i < price.length) {
                var node = this.roundNode.children[i];
                var str = "";
                var money = price[i].money;
                if (this.roomSetting.checks[2][2] == "10" || this.roomSetting.checks[2][2] == "12") {
                    money = money * parseInt(this.roomSetting.checks[5][2]);
                }
                if (node.getComponent(cc.Toggle).isChecked) {
                    str = '<color=#FFFFFF>'.concat(String(price[i].rounds), '局(', String(money), '钻)          </c>');
                } else {
                    str = '<color=#88A2C3>'.concat(String(price[i].rounds), '局(', String(money), '钻)          </c>');
                }
                node.active = true;
                var msg = node.getChildByName('label').getComponent(cc.RichText);
                msg.string = str;
            } else {
                node.active = false;
            }
        }
    },

    onCheck: function onCheck(toggle, param) {
        cc.audiomanager.playSFX("click");
        var items = toggle.toggleGroup.toggleItems;
        for (var i = 0; i < items.length; ++i) {
            toggle = items[i];
            if (toggle.isChecked) {
                var strs = param.split(',');
                var row = parseInt(strs[0]);
                this.roomSetting.checks[row] = strs;
                var index = parseInt(strs[1]);
                if (row == 0) {
                    this.onGameTypeChange(index == 1);
                } else if (row == 1) {
                    strs[2] = String(cc.datamanager.mainData.price_list[index].rounds);
                    this.roomSetting.checks[row] = strs;
                } else if (row == 2) {
                    this.updateMoney();
                } else if (row == 5) {
                    if (index == 3) this.onCheckQuanLeiDa(this.quanleidaToggle);
                    this.updateMoney();
                }
            }
            var label = toggle.node.getChildByName('label').getComponent(cc.RichText);
            var str = label.string.replace(/\#[0-9A-Fa-f]*/, toggle.isChecked ? '#FFFFFF' : '#88A2C3');
            label.string = str;
        }
    },

    onCheckQuanLeiDa: function onCheckQuanLeiDa(toggle) {
        cc.audiomanager.playSFX("click");
        if (this.roomSetting.checks[5][1] == 3) toggle.isChecked = false;
        this.roomSetting.isQuanLeiDa = toggle.isChecked;
    },

    onCreateRoom: function onCreateRoom() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_CreateGame');
        msg.play_type = parseInt(this.roomSetting.checks[0][2]);
        msg.rounds = parseInt(this.roomSetting.checks[1][2]);
        msg.payor = parseInt(this.roomSetting.checks[2][2]);
        msg.da_qiang = parseInt(this.roomSetting.checks[3][2]);
        msg.yi_tiao_long = parseInt(this.roomSetting.checks[4][2]);
        msg.player_size = parseInt(this.roomSetting.checks[5][2]);
        msg.quan_lei_da = this.roomSetting.isQuanLeiDa;

        cc.log("msg.play_type:" + msg.play_type);
        cc.log("msg.yi_tiao_long:" + msg.yi_tiao_long);
        cc.log("msg.quan_lei_da:" + msg.quan_lei_da);

        cc.log('param:this.roomSetting.checks[0]:' + this.roomSetting.checks[0]);
        cc.netmanager.send(msg);
        cc.datamanager.saveRoomSetting(this.roomSetting);
        this.close();
    },

    PublicProto_S_G13_RoomAttr: function PublicProto_S_G13_RoomAttr(msg) {
        if (msg.room_code == 0) {
            //TODO:创建失败

        }
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIGm":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ee2bcBGKcpEK6aY/VoAACCG', 'UIGm');
// Scripts\Gui\UIGm.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        weixinLabel_0: cc.Label,
        weixinLabel_1: cc.Label,
        weixinLabel_2: cc.Label
    },

    onCreate: function onCreate() {

        this.weixinLabels = [this.weixinLabel_0, this.weixinLabel_1, this.weixinLabel_2];
        this.weixinNums = [cc.datamanager.mainData.wechat1, cc.datamanager.mainData.wechat2, cc.datamanager.mainData.wechat3];

        for (var i = 0; i < this.weixinLabels.length; ++i) {
            this.weixinLabels[i].string = this.weixinNums[i];
        }
        this._super();
    },

    copy: function copy(event, strId) {
        cc.datamanager.copyToClipboard(this.weixinNums[parseInt(strId)]);
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIHelp":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1e7e4wIuVBNJJMWAE51Zwze', 'UIHelp');
// Scripts\Gui\UIHelp.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {}

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIJoinRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, '973adVbE99DMqXsT6KyvjKG', 'UIJoinRoom');
// Scripts\Gui\UIJoinRoom.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        btnClose: cc.Button,
        btnComfire: cc.Button,
        spCursor: cc.Node,
        curIndex: 0
    },

    updateCursor: function updateCursor() {
        if (this.curIndex < 0) this.curIndex = 0;
        if (this.curIndex < 6) {
            var room = this.node.getChildByName('roomid');
            this.spCursor.parent = room.children[this.curIndex];
            this.spCursor.position = cc.p(0, 0);
        }

        this.btnClose.interactable = this.isfull();
    },

    getValue: function getValue(node) {
        return node.getChildByName('num').getComponent(cc.Label).string;
    },

    getRoomID: function getRoomID() {
        var room = this.node.getChildByName('roomid');
        var cs = room.children;
        var ids = [];
        for (var i = 0; i < room.childrenCount; ++i) {
            ids[i] = this.getValue(cs[i]);
        }
        return parseInt(ids.join(""));
    },

    setValue: function setValue(node, str) {
        node.getChildByName('num').getComponent(cc.Label).string = str;
    },

    setCurIndexValue: function setCurIndexValue(str) {
        if (!this.isfull()) {
            var room = this.node.getChildByName('roomid');
            this.setValue(room.children[this.curIndex], str);
        }
    },

    isfull: function isfull() {
        return this.curIndex == 6;
    },

    resetValue: function resetValue() {
        var room = this.node.getChildByName('roomid');
        var cs = room.children;
        for (var i = 0; i < this.curIndex; ++i) {
            this.setValue(cs[i], "");
        }
        this.curIndex = 0;
        this.updateCursor();
    },

    deleteValue: function deleteValue() {
        if (this.curIndex >= 0) {
            --this.curIndex;
            if (this.curIndex < 0) this.curIndex = 0;
            this.setCurIndexValue("");
            this.updateCursor();
        }
    },

    inputValue: function inputValue(num) {
        if (!this.isfull()) {
            this.setCurIndexValue(num);
            ++this.curIndex;
            this.updateCursor();
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var keyboard = this.node.getChildByName('keyboard');
        var cs = keyboard.children;
        for (var i = 0; i < keyboard.childrenCount; ++i) {
            var btn = cs[i].getComponent(cc.Button);
            var self = this;
            btn.node.on('click', function (event) {
                var node = event.target;
                if (node.name == "btn_reset") {
                    self.resetValue();
                } else if (node.name == "btn_delete") {
                    self.deleteValue();
                } else {
                    self.inputValue(node.getChildByName('num').getComponent(cc.Label).string);
                }
            });
        }
        this.btnClose.interactable = this.isfull();
    },

    onClick_btnClose: function onClick_btnClose() {
        this.close();
    },

    onclick_btnComfire: function onclick_btnComfire() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_JionGame');
        msg.room_id = this.getRoomID();
        cc.netmanager.send(msg);
        console.log('require join room:' + msg.room_id);
        this.close();
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UILoading":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1d080/CwUFAFqE2IaSGu+Ux', 'UILoading');
// Scripts\Gui\UILoading.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    onCreate: function onCreate() {
        this.bgOpaque = 255;
        this._super();
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UILogin":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fe480vPekNN7KUEzU8UAhgP', 'UILogin');
// Scripts\Gui\UILogin.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        btnWXLogin: cc.Button,
        btnGuestLogin: cc.Button,

        prefabSummary: cc.Prefab,
        txtVersion: cc.Label
    },

    // use this for initialization
    onCreate: function onCreate() {
        if (cc.configmanager.testClient) {
            this.txtVersion.string = cc.configmanager.version;
        } else {
            this.txtVersion.string = cc.configmanager.version;
        }
        if (!cc.sys.isMobile) {
            this.btnWXLogin.node.active = false;
        } else {
            if (!cc.netmanager.serverInfo.apple_review) {
                this.btnGuestLogin.node.active = false;
            } else {
                if (cc.netmanager.isWXInstall()) {
                    this.btnGuestLogin.node.active = false;
                } else {
                    this.btnWXLogin.node.active = false;
                }
            }
        }
        cc.audiomanager.playBGM('background');

        if (cc.netmanager.isWXInstall() && cc.netmanager.checkWeixin()) {
            this.login(1);
        }
        this._super();

        /*
                var node = cc.instantiate(this.prefabSummary)
                node.parent = this.node
                node.position = cc.v2(0, 0); 
        
        
                var com = node.getComponent("ScoreSummary")
                var container = node.getChildByName("container")
        
                for(var i = 0; i < 4; ++i)
                {
                    cc.log(i)
                    var nd = cc.instantiate(com.smJsPanel)
                    
                    nd.position = cc.v2(0,0)
                    //nd.getComponent("smJsPanel").initCard(AllHandsData[i], scoreSummary[i])
                    nd.parent = container
        
                    cc.log("========", com.smJsPanel, nd, nd.parent)
                   // nd.position = poses[i]
                }
        
                cc.log("cc.view.getFrameSize().width = ", cc.view.getFrameSize().width)
                var scale = cc.view.getFrameSize().width / (1.8*cc.view.getFrameSize().height)
                container.scale = scale
        */
    },

    setIP: function setIP(event) {
        var ip = event.string;
        if (ip != "") {
            cc.configmanager.serverIP = ip;
            cc.log('IP:' + ip);
        }
    },

    lockUI: function lockUI(bLock) {
        return;
        var interactable = !bLock;
        this.btnWXLogin.interactable = interactable;
        this.btnGuestLogin.interactable = interactable;

        //TO:转菊花 
    },

    login: function login(type) {
        this.lockUI(true);
        cc.netmanager.login(type);
    },

    //wechat login
    onClick_btnWXLogin: function onClick_btnWXLogin(event) {

        this.login(1);
    },

    //返回协议 
    PublicProto_S_LoginRet: function PublicProto_S_LoginRet(msg) {
        this.lockUI(false);

        if (msg.ret_code == 1) {

            cc.scenemanager.loadMainScene();
        } else {
            cc.guimanager.msgBox("登录失败,错误代码:" + msg.ret_code);
            cc.netmanager.loginOut();
        }
    },

    onMessageError: function onMessageError(errorid) {
        this.lockUI(false);
    },

    //guest login
    onClick_btnGuestLogin: function onClick_btnGuestLogin() {
        this.login(0);
    },

    //xieyi 
    onClick_Xieyi: function onClick_Xieyi() {}

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIMain":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bcb68jCR6NKyZZhF+bNoMrU', 'UIMain');
// Scripts\Gui\UIMain.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        funcNode: cc.Node,
        nameLabel: cc.Label,
        noticeNode: cc.Node,
        noticeMask: cc.Node,
        noticeText: cc.Label,
        openidText: cc.Label,
        coinText: cc.Label,
        diamondText: cc.Label,
        moveSpeed: 20,
        headIcon: cc.Sprite,
        headNode: cc.Node
    },

    // use this for initialization
    onCreate: function onCreate() {
        cc.log("name = " + cc.datamanager.mainPlayerData.nick_name);
        this.nameLabel.string = cc.datamanager.mainPlayerData.nick_name;
        this.openidText.string = "ID: " + cc.datamanager.mainPlayerData.cuid.toString();
        cc.audiomanager.playBGM('background');
        this._super();
        cc.gamemanager.gameStart();

        this.headNode.cuid = cc.datamanager.mainPlayerData.cuid;
        cc.datamanager.loadHeadImg(cc.datamanager.mainPlayerData.url, this.headIcon);

        this.refreshMainPlayerMoney();
        this.noticeTime = 0;

        if (cc.datamanager.notice) {
            this.noticeText.string = cc.datamanager.notice;
        }

        if (!cc.datamanager.hasOpenNotice) {
            cc.guimanager.open("UINotice");
            cc.datamanager.hasOpenNotice = true;
        }
    },

    update: function update(dt) {
        this.funcNode.scaleY = this.funcNode.width / 840.0;
    },

    PublicProto_S_Notice: function PublicProto_S_Notice(data) {

        if (data.type == 3) {
            this.noticeText.string = data.text;
        }
    },

    refreshMainPlayerMoney: function refreshMainPlayerMoney() {
        this.coinText.string = cc.gamemanager.coin.toString();
        this.diamondText.string = cc.gamemanager.diamond.toString();
    },

    log: function log(str) {
        cc.log(str);
    },

    openLianxiRoom: function openLianxiRoom() {
        cc.robot.reset();
        cc.robot.createPracticeRoom();
        cc.robot.sendPlayerInRoom(0, 0, 2);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIMessageBox":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0b815ePDI1Gx46kTYrIvfWD', 'UIMessageBox');
// Scripts\Gui\UIMessageBox.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        msgText: cc.Label,
        okBtn: cc.Node,
        cancelBtn: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    setMessage: function setMessage(msg) {
        this.msgText.string = msg;
    },

    setCall: function setCall(call) {
        this.call = call;
    },

    setCancelCall: function setCancelCall(call) {
        this.cancelCall = call;
        this.okBtn.position = cc.v2(-120, -111);
        this.cancelBtn.active = true;
    },

    onOkey: function onOkey() {
        if (this.call) {
            if (!this.call()) {
                this.close();
            }
        } else {
            this.close();
        }
    },

    onCancelKey: function onCancelKey() {
        if (this.cancelCall) {
            this.cancelCall();
        }
        this.close();
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UINotice":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4ef4dTBL2VHV5Z7HFbNfVNc', 'UINotice');
// Scripts\Gui\UINotice.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        title: cc.RichText,
        webview: cc.RichText,
        shuming: cc.RichText,
        riqi: cc.RichText
    },

    onCreate: function onCreate() {
        //发送请求公告的消息
        if (cc.datamanager.gmNotice) {
            var strs = cc.datamanager.gmNotice.split("$$$");
            if (strs.length > 0) this.title.string = strs[0];
            if (strs.length > 1) this.webview.string = strs[1];
            if (strs.length > 2) this.shuming.string = strs[2];
            if (strs.length > 3) this.riqi.string = strs[3];
        }
        this._super();
    },

    onBtnCloseClicked: function onBtnCloseClicked() {
        this.close();
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIPanel":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f6431fstrhNK5MN2iz1NYLe', 'UIPanel');
// Scripts\Gui\UIPanel.js

'use strict';

if (cc.uipanel == undefined) {
    cc.log('uipanel init');
    cc.uipanel = cc.Class({
        extends: cc.Component,
        properties: {
            bgOpaque: 200
        },
        ctor: function ctor() {
            this.isModel = true;
        },
        setVisible: function setVisible(bVisible) {
            this.node.active = bVisible;
            if (bVisible) {
                this.onShow();
            } else {
                this.onHide();
            }
        },

        onCreate: function onCreate() {
            if (this.isModel) {
                var self = this;
                cc.loader.loadRes('Gui/ModalBg', function (err, prefab) {
                    self.bg = cc.instantiate(prefab);
                    self.bg.parent = self.node;
                    self.bg.setSiblingIndex(0);
                    cc.log('self.bg.opacity:' + self.bg.opacity);
                    self.bg.opacity = self.bgOpaque;
                    cc.log('self.bg.opacity:' + self.bg.opacity);

                    self.bg.on(cc.Node.EventType.TOUCH_START, function (event) {
                        self.onTouchBg();
                        event.stopPropagationImmediate();
                    });
                });
            }
        },

        onTouchBg: function onTouchBg() {},

        onClose: function onClose() {
            if (this.bg) {
                this.bg.off(cc.Node.EventType.TOUCH_START);
            }
        },

        onShow: function onShow() {},

        onHide: function onHide() {},

        close: function close() {
            cc.log("close");
            cc.guimanager.close(this);
        },

        openUI: function openUI(event, name) {
            cc.guimanager.open(name);
        },
        showOrOpenUI: function showOrOpenUI(event, name) {
            cc.guimanager.showOrOpenUI(name);
        },
        select: function select(parentNode, index) {
            var count = parentNode.childrenCount;
            var cs = parentNode.children;
            for (var i = 0; i < count; ++i) {
                cs[i].active = i == index;
            }
        },
        showComingSoonDlg: function showComingSoonDlg(event) {
            cc.guimanager.msgBox('功能暂未开放，敬请期待！');
        }
    });
}

cc._RF.pop();
},{}],"UIPokerGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '663f4GkXdFOZILOqkauFXod', 'UIPokerGame');
// Scripts\Gui\UIPokerGame.js

"use strict";

cc.Class({
    extends: cc.uipanel,

    properties: {
        originPoker: cc.Node,
        movePoker: cc.Node,
        prefabHeadIcon: cc.Prefab,
        prefabPokerSort: cc.Prefab,
        prefabPokerList: cc.Prefab,
        prefabPokerFlop: cc.Prefab,
        roomNum: cc.Label,
        myHeadIcon: cc.Node,
        startAnimation: cc.Node,
        recordBtn: cc.Node,
        recordPanel: cc.Node,

        prefabJiesuan: cc.Prefab,
        prefabBigJiesuan: cc.Prefab,
        prefabWaitMatch: cc.Prefab,

        prefabPlayer2: cc.Prefab,
        prefabPlayer3: cc.Prefab,
        prefabPlayer4: cc.Prefab,
        prefabPlayer5: cc.Prefab,

        jiesuanTop: cc.Node,
        jiesuanMidel: cc.Node,
        jiesuanBotttom: cc.Node,
        jiesuanDaqiang: cc.Node,

        quanleidaNode: cc.Node,
        waitLabel: cc.Node,

        timeLabel: cc.Label,

        shareBtn: cc.Button,
        _pokerList: null,
        _headIcons: null,
        _pokerFlops: null,
        _curShuffleIdx: 0,
        _playerHeads: null,
        _kaishibipai: null,
        _matchPointLabel: null,
        _optionLabel: null
    },

    // use this for initialization
    onCreate: function onCreate() {
        this._pokerList = [];

        var self = this;
        this.bubblePrefab = cc.loader.loadRes('Gui/Widget/ChatBubble', function (err, prefab) {
            self.bubblePrefab = prefab;
        });

        this.recordBtn.on(cc.Node.EventType.TOUCH_START, function (event) {
            self.onStartRecord();
        });
        this.recordBtn.on(cc.Node.EventType.TOUCH_CANCEL, function (event) {
            self.onCancelRecord();
        });
        this.recordBtn.on(cc.Node.EventType.TOUCH_END, function (event) {
            self.onStopRecord();
        });

        this._kaishibipai = cc.find("UIPokerGame/kaishibipai");
        this._matchPointLabel = cc.find("UIPokerGame/title/matchPoint");
        this._optionLabel = cc.find("UIPokerGame/title/option");
        this._prefabPlayers = [this.prefabPlayer2, this.prefabPlayer3, this.prefabPlayer4, this.prefabPlayer5];

        this.roomNum.string = cc.gamemanager.room_info.room_id;
        this.initRoom(cc.gamemanager.room_info.attr.player_size);
        this.onPlayerInRoom(cc.gamemanager._players);
        cc.audiomanager.playBGM('background');
        this._super();

        cc.log("初始化立牌界面，初始化立牌界面，初始化立牌界面，");
        this.initOnlineState();
        cc.gamemanager.normalProcess = true;
        cc.immanager.init();

        this.lastUpdateTime = 0;
        this.updateTime();
    },

    onClose: function onClose() {
        if (this.bubblePrefab) cc.loader.releaseAsset(this.bubblePrefab);
        cc.gamemanager.gameOver();
        this._super();
    },

    initRoom: function initRoom(playerNum) {
        if (playerNum == null) return;
        if (playerNum == 1) playerNum = 2;

        cc.log("init room, palyer number = " + playerNum);
        if (playerNum <= 1 || playerNum > 5) {
            return;
        }

        var obj = cc.instantiate(this._prefabPlayers[playerNum - 2]);
        obj.parent = this.node;

        //玩家头像
        this._playerHeads = obj.getChildByName("heads").children;
        cc.log("this._playerHeads size = " + this._playerHeads.length);

        //发牌图片
        this._pokerList = [];
        var parentNode = cc.find("UIPokerGame/Pokers");
        this._pokerList.push(parentNode.children[0]);
        var playersNode = obj.getChildByName("Pokers");
        for (var i = 0; i < playersNode.childrenCount; ++i) {
            this._pokerList.push(playersNode.children[i]);
        }
        cc.log("this._pokerList size = " + this._pokerList.length);

        //比牌
        this._pokerFlops = []; //该数组包括自己
        var flopParent = cc.find("UIPokerGame/PokerFlops");
        this._pokerFlops.push(flopParent.children[0]); //自己的
        var flopNode = obj.getChildByName("PokerFlops");
        for (var i = 0; i < flopNode.childrenCount; ++i) {
            this._pokerFlops.push(flopNode.children[i]);
        }
        cc.log("this._pokerFlops size = " + this._pokerFlops.length);
        this.refreshNewMatchState();
    },

    setPokerListShow: function setPokerListShow(visible) {
        for (var i = 0; i < this._pokerList.length; ++i) {
            this._pokerList[i].active = visible;
        }
    },

    //掉线后处理
    initOnlineState: function initOnlineState() {

        cc.log(cc.gamemanager.normalProcess, cc.gamemanager._selfStatus, cc.gamemanager._currentRounds);

        if (cc.gamemanager.normalProcess == false) {

            //选牌时掉线，直接显示选牌界面
            if (cc.gamemanager._selfStatus == 3 && cc.gamemanager._currentRounds != 0) {
                var pokerSort = cc.instantiate(this.prefabPokerSort);
                pokerSort.parent = this.node;
                pokerSort.position = cc.v2(0, 0);

                this.setPokerListShow(false);
                this.setPokerFlopShow(true);
            }

            //我已出牌，但桌上还有其他人未出牌，显示等待中
            if (cc.gamemanager._selfStatus == 4 && cc.gamemanager._otherStatus == 3) {
                this.showWaitState();
                this.setPokerListShow(false);
                this.setPokerFlopShow(true);
            }
        }
    },

    setPokerFlopShow: function setPokerFlopShow(visible) {
        for (var i = 0; i < this._pokerFlops.length; ++i) {
            this._pokerFlops[i].active = visible;
        }
    },

    //新的一局开始刷新数据
    refreshNewMatchState: function refreshNewMatchState() {
        for (var i = 0; i < this._pokerList.length; ++i) {
            var node = this._pokerList[i];
            node.getComponent("PokerList").resetState();
        }

        for (var i = 0; i < this._pokerFlops.length; ++i) {
            var node = this._pokerFlops[i];
            node.getComponent("PokerFlop").resetState();
        }
        this.setPokerListShow(false);
        this.setPokerFlopShow(false);
        this._curShuffleIdx = 0;

        var roomAttr = cc.gamemanager.room_info.attr;
        var ptLabel = cc.gamemanager._currentRounds + "/" + roomAttr.rounds;
        this._matchPointLabel.getComponent(cc.Label).string = ptLabel;

        var optionLabel = "支付:";
        if (roomAttr.payor == 10) {
            optionLabel = optionLabel + "房主";
        } else if (roomAttr.payor == 11) {
            optionLabel = optionLabel + "分摊";
        } else if (roomAttr.payor == 12) {
            optionLabel = optionLabel + "大赢家";
        }
        if (roomAttr.da_qiang == 2) {
            optionLabel = optionLabel.concat(",", String(roomAttr.player_size), "人游戏,打枪翻倍");
        } else {
            optionLabel = optionLabel.concat(",", String(roomAttr.player_size), "人游戏,打枪+", String(roomAttr.da_qiang), "道");
        }

        if (roomAttr.quan_lei_da) {
            optionLabel = optionLabel + ",全垒打";
        }

        if (roomAttr.play_type == 65) {
            optionLabel = optionLabel + ',多一色';
        } else {
            optionLabel = optionLabel + ',普通';
        }

        this._optionLabel.getComponent(cc.Label).string = optionLabel;
    },

    _refreshHeadInfo: function _refreshHeadInfo(node, data) {
        if (node == null) return;

        var icon = node.getChildByName("icon");
        var deficon = node.getChildByName("default");

        if (data == null || parseInt(data.cuid) == 0) {
            icon.active = false;
            deficon.active = true;
        } else {
            icon.active = true;
            deficon.active = false;

            node.cuid = data.cuid;

            var label = icon.getChildByName("name");
            if (label != null) {
                label.getComponent(cc.Label).string = data.name;
            }

            var coin = icon.getChildByName("coinnum");
            var rank = cc.gamemanager.getCurMatchRank(data.cuid);
            if (coin != null) {
                coin.getComponent(cc.Label).string = rank.toString();
            }

            var prepare = icon.getChildByName("yizhunbei");
            if (prepare != null) {
                //prepare.active = (data.status == 2);
                if (data.status == 2) {
                    prepare.active = true;
                    cc.PokerUtil.replaceSprite("Textures/Fight/yizhunbeiTXT", prepare);
                } else if (data.status == 3) {
                    prepare.active = true;
                    cc.PokerUtil.replaceSprite("Textures/lipaizhongTXT", prepare);
                } else {
                    prepare.active = false;
                }
            }
            //玩家头像
            var icon = icon.getChildByName("headICON");
            if (icon) {
                // cc.guimanager.msgBox("data.imgurl:" + data.imgurl)
                cc.datamanager.loadHeadImg(data.imgurl, icon.getComponent(cc.Sprite));
            }
        }
    },

    //刷新头像下面的积分
    _refreshHeadScore: function _refreshHeadScore() {
        function ___getCoinNode(parnode) {
            return parnode.getChildByName("icon").getChildByName("coinnum");
        }

        if (this.myHeadIcon.cuid && this.myHeadIcon.cuid) {
            var myscore = cc.gamemanager.getCurMatchRank(this.myHeadIcon.cuid);
            var nd = ___getCoinNode(this.myHeadIcon);
            if (nd && nd.getComponent(cc.Label)) {
                nd.getComponent(cc.Label).string = myscore.toString();
            }
        }

        for (var i = 0; i < this._playerHeads.length; ++i) {
            var header = this._playerHeads[i];
            if (header && header.cuid) {
                var score = cc.gamemanager.getCurMatchRank(header.cuid);
                var nd = ___getCoinNode(header);
                if (nd && nd.getComponent(cc.Label)) {
                    nd.getComponent(cc.Label).string = score.toString();
                }
            }
        }
    },

    getHeader: function getHeader(cuid) {
        if (this.myHeadIcon.cuid && cuid.eq(this.myHeadIcon.cuid)) return this.myHeadIcon;
        for (var i = 0; i < this._playerHeads.length; ++i) {
            var header = this._playerHeads[i];
            if (header && header.cuid && cuid.eq(header.cuid)) {
                return header;
            }
        }
        cc.guimanager.msgBox("数据错误getHeader" + cuid.toString() + " - " + this._playerHeads.length);
        return null;
    },

    getFlop: function getFlop(cuid) {
        for (var i = 0; i < this._pokerFlops.length; ++i) {
            var flop = this._pokerFlops[i];
            if (flop && flop.cuid && cuid.eq(flop.cuid)) {
                return flop;
            }
        }

        cc.guimanager.msgBox("数据错误getFlop" + cuid.toString() + " - " + this._pokerFlops.length);
        return null;
    },

    showWaitState: function showWaitState() {
        if (this.waitStateNode == null) {
            this.waitStateNode = cc.instantiate(this.prefabWaitMatch);
            this.waitStateNode.parent = this.node;
            this.waitStateNode.position = cc.v2(0, 0);
        }
    },

    onPlayerInRoom: function onPlayerInRoom(playersdata) {

        //有时候会出现进入房间，initRoom还未调用
        if (this._playerHeads == null) {
            this.initRoom(cc.gamemanager.room_info.attr.player_size);
        }

        cc.log("onPlayerInRoom length = " + playersdata.length);
        if (playersdata.length == 0) {
            return;
        }

        var sortdata = [];
        var selfIdx = 0;

        var selfData = cc.datamanager.mainPlayerData;
        for (var i = 0; i < playersdata.length; ++i) {
            if (playersdata[i].cuid.eq(selfData.cuid)) {
                selfIdx = i;
                //cc.find("UIPokerGame/startBtn").active = (playersdata[i].status == 0);
                cc.log("我的状态： " + playersdata[i].status);
                var startBtn = cc.find("UIPokerGame/startBtn");
                startBtn.active = playersdata[i].status < 2;
                this._refreshHeadInfo(this.myHeadIcon, playersdata[i]);
                this._pokerFlops[0].cuid = playersdata[i].cuid;
                break;
            }
        }

        var existPlayerNum = 0;
        var waitPlayerNum = 0;
        for (var i = 0; i < playersdata.length; ++i) {
            if (!playersdata[i].cuid.eq(0)) {
                existPlayerNum++;
            }

            if (playersdata[i].status == 2) {
                waitPlayerNum++;
            }
        }

        this.waitLabel.active = waitPlayerNum == 1;

        this.shareBtn.node.active = existPlayerNum != cc.gamemanager.room_info.attr.player_size;

        for (var i = selfIdx + 1; i < playersdata.length; ++i) {
            sortdata.push(playersdata[i]);
        }
        for (var i = 0; i < selfIdx; ++i) {
            sortdata.push(playersdata[i]);
        }

        var i = 0;
        for (; i < sortdata.length; ++i) {
            var node = this._playerHeads[i];
            this._refreshHeadInfo(node, sortdata[i]);
            this._pokerFlops[i + 1].cuid = sortdata[i].cuid;
        }

        for (; i < this._playerHeads.length; ++i) {
            var node = this._playerHeads[i];
            this._refreshHeadInfo(node, null);
            this._pokerFlops[i + 1].cuid = 0;
        }
        /*
                var already = 0
                var alreadyIdx = []
        
                sortdata.splice(0, 0, playersdata[selfIdx])
                for(var j = 0; j < sortdata.length; ++j){
                    if(sortdata[j].status == 4){
                        ++already
                        alreadyIdx.push(j)
                    }
                }
                if(already == sortdata.length) //所有人都理好牌了
                {
                    for(var i = 0; i < this._pokerFlops.length; ++i){
                        this._pokerFlops[i].getComponent("PokerFlop").setState(true)
                    }
                }
                else
                {
                    for(var i = 0; i < this._pokerFlops.length; ++i){
                        if(alreadyIdx.indexOf(i) != -1){
                            this._pokerFlops[i].getComponent("PokerFlop").setState(false)
                        }else{
                            this._pokerFlops[i].getComponent("PokerFlop").setState(true)
                        }
                    }
                }
        */
    },

    showChat: function showChat(cuid, content) {
        cc.log(cuid);
        var header = this.getHeader(cuid);
        if (header) {
            if (header && header.bubble) {
                header.bubble.destroy();
                header.bubble = null;
            }

            cc.log("this.bubblePrefab:" + this.bubblePrefab);
            if (!header.bubble && this.bubblePrefab) {
                header.bubble = cc.instantiate(this.bubblePrefab);
                header.bubble.parent = cc.director.getScene();

                if (header == this.myHeadIcon) {
                    header.bubble.position = header.convertToWorldSpace(cc.p(50, 0));
                } else if (this._playerHeads.length > 2 && this._playerHeads[0] == header) {
                    header.bubble.position = header.convertToWorldSpace(cc.p(0, 50));
                    header.bubble.scaleX = -1;

                    var c = header.bubble.getComponent('ChatBubble');
                    c.text.node.scaleX = -1;
                    c.face.node.scaleX = -1;
                } else {
                    header.bubble.position = header.convertToWorldSpace(cc.p(100, 50));
                }
            }

            if (header.bubble) {
                var buller = header.bubble.getComponent("ChatBubble");
                if (content.type == 0) {
                    buller.showText(content.data_text);
                } else if (content.type == 1) {
                    buller.showFace(content.data_int);
                } else if (content.type == 2) {
                    header.bubble.url = content.data_text;
                    buller.showVoice(content.data_text);
                }
                if (content.type != 2) {
                    var scheduler = cc.director.getScheduler();
                    scheduler.unscheduleAllForTarget(buller);
                    scheduler.schedule(function () {
                        if (buller) {
                            buller.node.destroy();
                            header.bubble = null;
                        }
                    }, buller, 0, 0, 3, false);
                }
            }
        }
    },

    onPlayCompleted: function onPlayCompleted() {

        if (!this.clearVoiceBubble(this.myHeadIcon)) {
            for (var i = 0; i < this._playerHeads.length; ++i) {
                var header = this._playerHeads[i];
                if (this.clearVoiceBubble(header)) {
                    break;
                }
            }
        }
    },

    clearVoiceBubble: function clearVoiceBubble(header) {
        if (header && header.bubble && header.bubble.url) {
            header.bubble.destroy();
            header.bubble = null;
            return true;
        }
        return false;
    },

    //聊天消息
    PublicProto_S_Chat: function PublicProto_S_Chat(msg) {
        this.showChat(msg.cuid, msg.content);
    },

    giveup: function giveup(event) {

        cc.audiomanager.playSFX("tuichufangjian");

        if (!cc.gamemanager.isPracticeRoom()) {
            var roomNum = 0;
            for (var i = 0; i < cc.gamemanager._players.length; ++i) {
                if (cc.gamemanager._players[i].cuid != 0) {
                    roomNum++;
                }
            }
            if (roomNum == 1) {
                cc.guimanager.msgBoxWithCancel("现在退出房间不扣除费用，是否退出？", function () {
                    cc.gamemanager.giveup();
                }, null);
            } else {
                cc.guimanager.msgBoxWithCancel("你是否确定离开房间？", function () {
                    cc.gamemanager.giveup();
                }, null);
            }
        } else {
            cc.guimanager.msgBoxWithCancel("你确定要退出练习房吗？", function () {
                cc.scenemanager.loadMainScene();
            }, null);
        }
    },

    PublicProto_S_G13_PlayerQuited: function PublicProto_S_G13_PlayerQuited(msg) {
        cc.scenemanager.loadMainScene();
    },

    //开始新的一局
    newMatchStart: function newMatchStart() {

        this.refreshNewMatchState();

        //刷新头像下的积分
        this._refreshHeadScore();

        var action = cc.sequence(cc.delayTime(0.7), cc.callFunc(function (target, param) {
            var self = target.getComponent("UIPokerGame");
            self.startAnimation.active = false;
            self.startAnimation.getComponent(cc.Animation).stop();
            self.fapai();
        }, this));

        this._kaishibipai.active = false;
        this.startAnimation.active = true;
        this.startAnimation.getComponent(cc.Animation).play("startani");
        this.node.runAction(action);
    },

    clickStartBtn: function clickStartBtn() {
        if (!cc.gamemanager.isPracticeRoom()) {
            //发送准备消息
            cc.find("UIPokerGame/startBtn").active = false;
            var msg = cc.netmanager.msg('PublicProto.C_G13_ReadyFlag');
            msg.ready = true;
            cc.netmanager.send(msg);
        } else {
            //第一局
            cc.robot.sendPlayerInRoom(1, 3, 3);
            cc.robot.sendHandleOfMine(1);
        }

        cc.audiomanager.playSFX('GAME_START');
    },

    fapai: function fapai() {
        this.setPokerListShow(true);
        this.originPoker.active = true;
        this.movePoker.active = true;
        var aniName = "ac_cardmove" + cc.gamemanager.room_info.attr.player_size;
        cc.log("播放动画： ", aniName);
        this.movePoker.getComponent(cc.Animation).play(aniName);

        var cardlist = this._pokerList[0];
        var pokers = cc.gamemanager.getCurMathPokers();
        cc.log("cardlist.childrenCount = " + cardlist.childrenCount);
        for (var i = 0; i < cardlist.childrenCount; ++i) {
            var card = cardlist.children[i];
            var val = pokers[i];
            //cc.log("poker value  " + val)
            cc.PokerUtil.replacePokerSprite(val, card);
        }
    },

    //发牌event结束打开PokerSort选牌界面
    onAnimCompleted: function onAnimCompleted(index) {
        if (index < 1 || index > 5) {
            return;
        }
        cc.audiomanager.playSFX('fapai');
        //console.log([index, this._curShuffleIdx, this._pokerList[index-1].childrenCount ]);
        this._pokerList[index - 1].children[this._curShuffleIdx].active = true;

        if (index == cc.gamemanager.room_info.attr.player_size) {
            this._curShuffleIdx++;
            var aniName = "ac_cardmove" + cc.gamemanager.room_info.attr.player_size;
            this.movePoker.getComponent(cc.Animation).play(aniName);
        }
        if (this._curShuffleIdx >= 12) {
            this.movePoker.getComponent(cc.Animation).stop();
            this.movePoker.active = false;
            this.originPoker.active = false;

            //打开选牌界面
            var pokerSort = cc.instantiate(this.prefabPokerSort);
            //var pokerSort = cc.guimanager.open("PokerSort")
            pokerSort.parent = this.node;
            pokerSort.position = cc.v2(0, 0);

            this.setTitleShow(false);

            //this._pokerList[0].active = false;
            this.setPokerListShow(false);
            this.setPokerFlopShow(true);
        }
    },

    beginFlop: function beginFlop(target, param) {

        param._kaishibipai.active = false;
        //cc.PokerUtil.replaceSprite("Textures/Fight/toudunbpTXT", param._kaishibipai)
        //cc.audiomanager.playSFX("M_kaishibipailingsheng")
        //cc.find("UIPokerGame/jiesuan").active = true

        this.myHeadIcon.getChildByName("icon").getChildByName("yizhunbei").active = false;
        for (var i = 0; i < this._playerHeads.length; ++i) {
            var node = this._playerHeads[i];
            node.getChildByName("icon").getChildByName("yizhunbei").active = false;
        }
    },

    //显示总结算页面
    showGameResult: function showGameResult() {
        var node = cc.instantiate(this.prefabBigJiesuan);
        node.parent = this.node;
        node.position = cc.v2(0, 0);
        node.getComponent("GameResult").initializeGameResult(cc.gamemanager.allRoundsData);
    },

    endFlop: function endFlop(target, param) {
        param._kaishibipai.active = false;
        //cc.find("UIPokerGame/jiesuan").active = false
        //cc.PokerUtil.replaceSprite("Textures/Fight/kaishibipaiTXT", param._kaishibipai)

        param.jiesuanTop.active = false;
        param.jiesuanMidel.active = false;
        param.jiesuanBotttom.active = false;
        param.jiesuanDaqiang.active = false;

        //打开结算页面
        var roomAttr = cc.gamemanager.room_info.attr;
        var mycuid = cc.datamanager.mainPlayerData.cuid;
        var com = cc.find("UIPokerGame").getComponent("UIPokerGame");

        /*
                if(cc.gamemanager._currentRounds >= roomAttr.rounds)
                {
                    var node = cc.instantiate(this.prefabBigJiesuan)
                    node.parent = this.node
                    node.position = cc.v2(0, 0); 
                    node.getComponent("GameResult").initializeGameResult(cc.gamemanager.allRoundsData)
                }
                else
        */
        {
            var node = cc.instantiate(this.prefabJiesuan);
            node.parent = com.node;
            node.position = cc.v2(0, 0);

            var alldata = {};
            alldata.serverdata = com._AllHandsData;
            alldata.clientdata = com._curScoreSummary;

            node.getComponent("ScoreSummary").initialize(alldata);

            for (var i = 0; i < com._AllHandsData.length; ++i) {
                if (mycuid.eq(com._AllHandsData[i].cuid)) {
                    //node.getComponent("ScoreSummary").setScore(com._AllHandsData[i].rank)
                    var myscore = com._AllHandsData[i].rank;
                    if (myscore > 0) {
                        cc.audiomanager.playSFX("win");
                    } else if (myscore < 0) {
                        cc.audiomanager.playSFX("lose");
                    }
                    break;
                }
            }
            /*
                        cc.guimanager.open("ScoreSummary", function(panel){  
                            cc.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", com, com._curScoreSummary)
                           
                            cc.guimanager.dispachMsg("initialize", alldata)
                            cc.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                            for(var i = 0; i < com._AllHandsData.length; ++i){
                            if(mycuid.eq(com._AllHandsData[i].cuid)){
                                cc.guimanager.dispachMsg("setScore", com._AllHandsData[i].rank)
                                break
                            }
                        }   
                    })
            */
        }
    },

    //第一墩比完事件
    topFlopEnd: function topFlopEnd(target, param) {
        //cc.PokerUtil.replaceSprite("Textures/Fight/zhongdunbpTXT", param._kaishibipai)
        param.jiesuanTop.active = true;
    },

    //第二墩比完事件
    middleFlopEnd: function middleFlopEnd(target, param) {
        //cc.PokerUtil.replaceSprite("Textures/Fight/weidunbpTXT", param._kaishibipai)
        param.jiesuanMidel.active = true;
    },

    //第三墩比完事件 
    bottomFlopEnd: function bottomFlopEnd(target, param) {
        param.jiesuanBotttom.active = true;
        param.jiesuanDaqiang.active = true;
    },

    _scoreStr: function _scoreStr(num) {
        if (num < 0) {
            return num.toString();
        } else if (num > 0) {
            return "+" + num.toString();
        } else {
            return "0";
        }
    },

    _setScore: function _setScore(node, name, num) {
        var lb = node.getChildByName(name).getComponent(cc.Label);
        if (lb) {
            lb.string = this._scoreStr(num);
            cc.datamanager.setScoreFont(num >= 0, lb);
        }
    },

    _refreshDunScore: function _refreshDunScore(datalist) {
        var selfData = cc.datamanager.mainPlayerData;
        for (var i = 0; i < datalist.length; ++i) {
            var data = datalist[i];
            if (selfData.cuid.eq(data.cuid)) {
                this._setScore(this.jiesuanTop, "score", data.score.top);
                this._setScore(this.jiesuanMidel, "score", data.score.middle);
                this._setScore(this.jiesuanBotttom, "score", data.score.bottom);
                this._setScore(this.jiesuanDaqiang, "score", data.score.spe);
            }
        }
    },

    //全垒打action
    _quanleidaFunc: function _quanleidaFunc(target, param) {
        cc.audiomanager.playSFX("daqiang_zidan");

        var self = param[0];
        var cuid = param[1];

        self.quanleidaNode.zIndex = 10;
        self.quanleidaNode.active = true;
        self.quanleidaNode.getComponent(cc.Animation).play();

        for (var i = 0; i < self._pokerFlops.length; ++i) {
            var flop = self._pokerFlops[i];
            if (flop && !cuid.eq(flop.cuid)) {
                flop.getComponent("PokerFlop").startDanKongAnim();
            }
        }
    },

    //打枪
    _daqiangFunc: function _daqiangFunc(target, param) {
        var self = param[0];
        var scuid = param[1];
        var dcuid = param[2];
        cc.audiomanager.playSFX("daqiang_zidan");

        var sidx = 0;
        var didx = 0;
        var sflop = null;

        for (var i = 0; i < self._pokerFlops.length; ++i) {
            var flop = self._pokerFlops[i];
            if (flop && flop.cuid && scuid.eq(flop.cuid)) {
                flop.getComponent("PokerFlop").startDaQiangAnim();
                sidx = i;
                sflop = flop;
            }

            if (flop && flop.cuid && dcuid.eq(flop.cuid)) {
                flop.getComponent("PokerFlop").startDanKongAnim();
                didx = i;
            }
        }

        var angleArr = null;
        var room_num = cc.gamemanager.room_info.attr.player_size;
        if (room_num == 3) {
            angleArr = cc.configmanager.dqAngle[3];
        } else if (room_num == 4) {
            angleArr = cc.configmanager.dqAngle[4];
        } else if (room_num == 5) {
            angleArr = cc.configmanager.dqAngle[5];
        }

        if (angleArr && sflop && angleArr[sidx][didx]) {
            var ag = angleArr[sidx][didx];
            var nd = sflop.getChildByName("shouqiang");
            if (nd) {
                nd.rotation = ag.x;
                nd.scaleX = ag.y;
            }
        }
    },

    //打枪结束
    _daqangEnd: function _daqangEnd(target, param) {
        for (var i = 0; i < param._pokerFlops.length; ++i) {
            var flop = param._pokerFlops[i];
            if (flop) {
                flop.getComponent("PokerFlop").endDanKongAnim();
                flop.getComponent("PokerFlop").endDaQiangAnim();
            }
        }
    },

    //收到结算牌消息，开始走比牌流程
    PublicProto_S_G13_AllHands: function PublicProto_S_G13_AllHands(msg) {
        if (msg.players.length != cc.gamemanager.room_info.attr.player_size) {
            cc.log("收到结算牌数据错误");
            return;
        }

        function CopyActionArray(dstArr, srcArr) {
            for (var i = 0; i < srcArr.length; ++i) {
                dstArr.push(srcArr[i]);
            }
        }

        if (this.waitStateNode != null) {
            this.waitStateNode.destroy();
            this.waitStateNode = null;
        }

        cc.log("开始计算得分");
        var ret = cc.PokerUtil.calculateScore(msg);
        this._curScoreSummary = ret;

        this._refreshDunScore(this._curScoreSummary);

        //在练习场要保存数据
        if (cc.gamemanager.isPracticeRoom()) {
            cc.robot.saveMatchResult(ret);
        }

        //for(var i = 0; i < ret.length; ++i)
        //{
        //   cc.log(ret[i].score.top, ret[i].score.middle, ret[i].score.bottom, ret[i].score.spe)
        //}

        cc.log("结束计算比分");

        cc.audiomanager.playSFX("M_kaishibipailingsheng");

        this._AllHandsData = msg.players;

        //对牌三墩进行排序
        for (var i = 0; i < msg.players.length; ++i) {
            if (msg.players[i].spec.brand == 0) {
                //非特殊牌型
                var c = msg.players[i].cards;
                var tp = [c[0], c[1], c[2]];
                var mp = [c[3], c[4], c[5], c[6], c[7]];
                var bo = [c[8], c[9], c[10], c[11], c[12]];

                var rt = [];
                var tb = msg.players[i].dun0.brand;
                if (tb == 3) {
                    rt = cc.PokerUtil.santiao(tp);
                } else if (tb == 1) {
                    rt = cc.PokerUtil.yiduiThree(tp);
                } else if (tb == 0) {
                    rt = cc.PokerUtil.wulongThree(tp);
                }
                if (rt.length > 0 && rt[0].length == 3) {
                    var ca = cc.PokerUtil.cardsEncode(rt[0]);
                    this._AllHandsData[i].cards[0] = ca[0];
                    this._AllHandsData[i].cards[1] = ca[1];
                    this._AllHandsData[i].cards[2] = ca[2];
                }

                var mb = msg.players[i].dun1.brand;
                var mret = cc.PokerUtil.t5Group[9 - mb](mp);
                if (mret.length > 0 && mret[0].length == 5) {
                    var ca = cc.PokerUtil.cardsEncode(mret[0]);
                    this._AllHandsData[i].cards[3] = ca[0];
                    this._AllHandsData[i].cards[4] = ca[1];
                    this._AllHandsData[i].cards[5] = ca[2];
                    this._AllHandsData[i].cards[6] = ca[3];
                    this._AllHandsData[i].cards[7] = ca[4];
                }

                var bb = msg.players[i].dun2.brand;
                var bret = cc.PokerUtil.t5Group[9 - bb](bo);
                if (bret.length > 0 && bret[0].length == 5) {
                    var ca = cc.PokerUtil.cardsEncode(bret[0]);
                    this._AllHandsData[i].cards[8] = ca[0];
                    this._AllHandsData[i].cards[9] = ca[1];
                    this._AllHandsData[i].cards[10] = ca[2];
                    this._AllHandsData[i].cards[11] = ca[3];
                    this._AllHandsData[i].cards[12] = ca[4];
                }
            }
        }

        var actions = [],
            action1 = [],
            action2 = [],
            action3 = [];

        actions.push(cc.sequence(cc.delayTime(1), cc.callFunc(this.beginFlop, this, this)));

        var specials = [];
        for (var i = 0; i < msg.players.length; ++i) {
            var playerdata = msg.players[i];
            var node = this.getFlop(playerdata.cuid);

            if (playerdata.spec.brand == 0) {
                //非特殊牌型
                if (node && node.getComponent("PokerFlop")) {
                    var compoent = node.getComponent("PokerFlop");
                    compoent.initPokerValues(playerdata);
                    action1.push(compoent.topFlopAction(compoent));
                    action2.push(compoent.middleFlopAction(compoent));
                    action3.push(compoent.bottomFlopAction(compoent));
                }
            } else {
                //特殊牌型
                var s = {};
                s.data = playerdata;
                s.node = node;
                specials.push(s);
            }
        }

        CopyActionArray(actions, action1);
        actions.push(cc.sequence(cc.callFunc(this.topFlopEnd, this, this), cc.delayTime(0.2)));

        CopyActionArray(actions, action2);
        actions.push(cc.sequence(cc.callFunc(this.middleFlopEnd, this, this), cc.delayTime(0.2)));

        CopyActionArray(actions, action3);
        actions.push(cc.sequence(cc.callFunc(this.bottomFlopEnd, this, this), cc.delayTime(0.2)));

        //播完普通比较后播特殊牌型
        if (specials.length > 0) {
            for (var i = 0; i < specials.length; ++i) {
                var node = specials[i].node;
                if (node && node.getComponent("PokerFlop")) {
                    var compoent = node.getComponent("PokerFlop");
                    compoent.initPokerValues(specials[i].data);
                    actions.push(compoent.specialFlopAction(compoent));
                    actions.push(cc.delayTime(0.5));
                }
            }
        }

        //开始打枪动画
        var quanleidaAct = null;
        var daqiangAct = [];
        for (var j = 0; j < ret.length; ++j) {
            var brand = ret[j];
            if (brand.quanleida == true) {
                if (quanleidaAct == null) {
                    quanleidaAct = cc.sequence(cc.callFunc(function () {
                        cc.audiomanager.playSFX("M_quanleida");
                    }, this), cc.delayTime(1.0), cc.callFunc(this._quanleidaFunc, this, [this, brand.cuid]), cc.delayTime(3), cc.callFunc(function (target, param) {
                        param.quanleidaNode.active = false;
                        param.quanleidaNode.getComponent(cc.Animation).stop();
                        param._daqangEnd(target, param);
                    }, this, this));
                } else {
                    cc.log("出错了，怎么会有多个全垒打~~~");
                }
            }
            if (brand.daqianglist.length > 0) {
                for (var m = 0; m < brand.daqianglist.length; ++m) {
                    //cc.log("===============", this, brand.cuid, brand.daqianglist[m])
                    daqiangAct.push(cc.sequence(cc.callFunc(function () {
                        cc.audiomanager.playSFX("M_daqiang");
                    }, this), cc.delayTime(0.5), cc.callFunc(this._daqiangFunc, this, [this, brand.cuid, brand.daqianglist[m]]), cc.delayTime(0.8), cc.callFunc(this._daqangEnd, this, this)));
                }
            }
        }

        if (quanleidaAct != null) {
            actions.push(quanleidaAct);
        }

        if (daqiangAct.length > 0) {
            CopyActionArray(actions, daqiangAct);
        }

        actions.push(cc.callFunc(this.endFlop, this, this));
        this._kaishibipai.active = true;
        cc.log("开始播放动画");
        this.node.runAction(cc.sequence(actions));
    },

    stopRecord: function stopRecord(cancel) {
        cc.log('结束录音...');
        if (this.isStartRecord) {
            this.recordPanel.active = false;
            this.isStartRecord = false;
            cc.immanager.stopRecord(cancel);
            // cc.audiomanager.resumeAll()
        }
    },

    update: function update(dt) {
        if (this.isStartRecord) {
            var dtTime = (new Date() - this.startRecordTime) / 1000;
            if (dtTime >= 15) {
                this.stopRecord(false);
            }
        }
        this.lastUpdateTime += dt;
        if (this.lastUpdateTime >= 1) {
            this.updateTime();
            this.lastUpdateTime -= 1;
        }
    },

    onStartRecord: function onStartRecord() {
        this.startRecordTime = new Date();
        this.recordPanel.active = true;
        this.isStartRecord = true;

        cc.log('开始录音...');
        cc.audiomanager.pauseAll();
        cc.immanager.startRecord();
    },

    onCancelRecord: function onCancelRecord() {
        this.stopRecord(true);
    },

    onStopRecord: function onStopRecord() {
        this.stopRecord(false);
    },

    setTitleShow: function setTitleShow(show) {
        var node = this.node.getChildByName("title");
        if (node) {
            node.active = show;
        }
    },

    updateTime: function updateTime() {

        var date = new Date();
        this.timeLabel.string = date.Format("yyyy-MM-dd hh:mm:ss");
    },

    share: function share() {
        var player = cc.datamanager.mainPlayerData;

        var room_info = cc.gamemanager.room_info;
        var attr = room_info.attr;
        var title = '斗阵十三水('.concat(String(attr.player_size), '人场)');
        var text = '【房号:'.concat(String(room_info.room_id), '】【局数:', attr.rounds, '局】');
        cc.log("attr.play_type :" + attr.play_type);
        if (attr.play_type == 65) {
            text = text + '【多一色玩法】';
        } else {
            text = text + '【普通玩法】';
        }

        if (attr.payor == 10) {
            text = text + '【庄家支付】';
        } else if (attr.payor == 11) {
            text = text + '【均摊支付】';
        } else if (attr.payor == 12) {
            text = text + '【大赢家支付】';
        }

        if (attr.da_qiang == 3) {
            text = text + '【打枪+3道】';
        } else {
            text = text + '【打枪双倍】';
        }

        if (attr.quan_lei_da) {
            text = text + '【全垒打】';
        }
        cc.netmanager.shareToWeixinFriend(title, text);
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {
});

cc._RF.pop();
},{}],"UIRecord":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0fa48+gsWRPraSKV6NQ9PXE', 'UIRecord');
// Scripts\Gui\UIRecord.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        pageID: 0,
        items: cc.Node,
        totalTodayLabel: cc.Label,
        scoreTodayLable: cc.Label,
        totalWeekLabel: cc.Label,
        scoreWeekLabel: cc.Label,
        btnUp: cc.Button,
        btnDown: cc.Button
    },

    onCreate: function onCreate() {
        var msg = cc.netmanager.msg("PublicProto.C_G13_ReqGameHistoryCount");
        cc.netmanager.send(msg);

        //请求排名
        this._super();
    },

    requirePage: function requirePage(event, page) {
        this.lockButton(true);
        var msg = cc.netmanager.msg("PublicProto.C_G13_ReqGameHistoryDetial");
        msg.page = this.page + parseInt(page);
        cc.netmanager.send(msg);
        this.page = msg.page;
        cc.log("page:" + this.page);
    },

    PublicProto_S_G13_GameHistoryCount: function PublicProto_S_G13_GameHistoryCount(msg) {

        this.totalTodayLabel.string = String(msg.today_game);
        this.scoreTodayLable.string = String(msg.today_rank);
        this.totalWeekLabel.string = String(msg.week_game);
        this.scoreWeekLabel.string = String(msg.week_rank);

        this.msgData = msg;

        this.maxPage = Math.ceil(msg.total / 4);
        if (this.maxPage > 0) {
            this.page = 0;
            this.requirePage(null, 0);
        }
    },

    lockButton: function lockButton(lock) {
        if (lock) {
            this.btnUp.interactable = false;
            this.btnDown.interactable = false;
        } else {
            if (this.page < this.maxPage - 1) {
                this.btnDown.interactable = true;
            }
            if (this.page > 0) {
                this.btnUp.interactable = true;
            }
        }
    },

    PublicProto_S_G13_GameHistoryDetial: function PublicProto_S_G13_GameHistoryDetial(msg) {
        cc.log("msg.items:" + msg.items.length);
        for (var i = 0; i < 4; ++i) {
            var child = this.items.getChildByName(i.toString());
            if (child) {
                var item = child.getComponent('RecordItem');
                if (item) {
                    item.setData(msg.items[i]); //msg.history[i])
                }
            }
        }
        this.lockButton(false);
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UISetting":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f67d7lo/1dD4IGPp1qXvxwc', 'UISetting');
// Scripts\Gui\UISetting.js

"use strict";

cc.Class({
    extends: cc.uipanel,

    properties: {
        musicBar: cc.ProgressBar,
        effectBar: cc.ProgressBar,
        musicSlider: cc.Slider,
        effectSlider: cc.Slider,
        musicIcon: cc.Node,
        effectIcon: cc.Node,
        btnLabel: cc.Label
    },

    onCreate: function onCreate() {
        var bgValue = cc.audiomanager.getBGMVolume();
        this.setMusicPer(bgValue);
        this.upateMusic(bgValue);

        var efValue = cc.audiomanager.getSFXVolume();
        this.setEffectPer(efValue);
        this.upateEffect(efValue);

        if (cc.scenemanager.isPokerGameScene()) {
            this.btnLabel.string = "退出房间";
        } else {
            this.btnLabel.string = "切换账号";
        }

        this._super();
    },

    onClose: function onClose() {
        cc.audiomanager.save();
        this._super();
    },

    updateIcon: function updateIcon(iconNode, value) {
        this.select(iconNode, value);
    },

    upateMusic: function upateMusic(progress) {
        this.musicBar.progress = progress;
        if (progress == 0) {
            this.updateIcon(this.musicIcon, 0);
        } else {
            this.updateIcon(this.musicIcon, 1);
        }
    },

    upateEffect: function upateEffect(progress) {
        this.effectBar.progress = progress;
        if (progress == 0) {
            this.updateIcon(this.effectIcon, 0);
        } else {
            this.updateIcon(this.effectIcon, 1);
        }
    },

    onMusicChange: function onMusicChange(target) {
        var progress = target.progress;
        this.upateMusic(progress);
        cc.audiomanager.setBGMVolume(progress);
    },

    onEffectChange: function onEffectChange(target) {
        var progress = target.progress;
        this.upateEffect(progress);
        cc.audiomanager.setSFXVolume(progress);
    },

    onChangeUID: function onChangeUID() {
        if (cc.scenemanager.isPokerGameScene()) {
            //cc.gamemanager.giveup()
            var node = cc.find("UIPokerGame");
            if (node && node.getComponent("UIPokerGame")) {
                node.getComponent("UIPokerGame").giveup();
            }
        } else {
            //TODO:切换账号
            cc.netmanager.loginOut();
        }
        this.close();
    },

    setMusicPer: function setMusicPer(value) {
        value = Math.min(1, Math.max(value, 0));
        this.musicSlider.progress = value;
        // this.musicBar.progress = value
        // cc.log('setMusicPer:' + value)
    },

    setEffectPer: function setEffectPer(value) {
        value = Math.min(1, Math.max(value, 0));
        this.effectSlider.progress = value;
        // this.effectBar.progress = value
        // cc.log('setEffectPer:' + value)
    }

});

cc._RF.pop();
},{}],"UIShare":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9bc3fNKZTFIiJvboQ0rzzOw', 'UIShare');
// Scripts\Gui\UIShare.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {},

    beforShare: function beforShare() {
        this.close();
    },

    setType: function setType(type) {
        this.shareType = type;
    },

    ShareToRing: function ShareToRing() {
        this.beforShare();
        if (this.shareType == 1) {
            cc.netmanager.shareScreenToWeiXinRing();
        } else {
            cc.netmanager.shareToWeiXinRing();
        }
    },

    ShareToFriend: function ShareToFriend() {
        this.beforShare();

        if (this.shareType == 1) {
            cc.netmanager.shareScreenToWeiXinFriend();
        } else {
            cc.netmanager.shareToWeixinFriend();
        }
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIShop":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd175d8u1JVLZKSO/fFIu6nv', 'UIShop');
// Scripts\Gui\UIShop.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UISpecialCard":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'e4400OrSYJNtq+xpMdHb9pF', 'UISpecialCard');
// Scripts\Gui\UISpecialCard.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        msgText: cc.Label,
        okBtn: cc.Node,
        cancelBtn: cc.Node,
        img: cc.Sprite
    },

    setSpeical: function setSpeical(com, id, pokerData) {
        this._specialCard = pokerData;
        this._parentCom = com;

        var cfg = cc.configmanager.specialFlopCfg[13 - id];
        if (cfg) {
            var spr = this.img;
            cc.loader.loadRes(cfg.texres, cc.SpriteFrame, function (err, spriteFrame) {
                spr.spriteFrame = spriteFrame;
            });
        }
    },

    onOK: function onOK() {

        this._parentCom.sendSpecialCard();

        //this.close()
        this.node.destroy();
    },

    onCancel: function onCancel() {
        //this.close()
        this.node.destroy();
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIUserIp":[function(require,module,exports){
"use strict";
cc._RF.push(module, '8754713XHdE44uCMzj/Whxd', 'UIUserIp');
// Scripts\Gui\UIUserIp.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        nameLabel: cc.Label,
        idLabel: cc.Label,
        ipLabel: cc.Label,
        headNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    setUserInfo: function setUserInfo(playerdata) {
        this.nameLabel.string = playerdata.name;
        this.idLabel.string = "ID:  " + playerdata.cuid.toString();
        this.ipLabel.string = "IP:  " + playerdata.ipstr.toString();
        cc.datamanager.loadHeadImg(playerdata.imgurl, this.headNode.getComponent(cc.Sprite));
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIVote":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6cccdKTYeNItrfjbosiV8kz', 'UIVote');
// Scripts\Gui\UIVote.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        tip: cc.RichText,
        btns: cc.Node,
        voteItems: cc.Node
    },

    onShow: function onShow() {
        var info = cc.gamemanager.voteInfo;
        this.remain_seconds = info.remain_seconds;
        var d = new Date();
        this.update_start_time = d.getTime() / 1000;
        this.voteSponsorName = cc.gamemanager.getPlayer(info.sponsor).name;
        if (!this.isSchedule) {
            this.updateTime();
            var s = cc.director.getScheduler();
            var self = this;
            s.schedule(function () {
                self.updateTime();
            }, this.node, 1, this.remain_seconds, 1, false);
            this.isSchedule = true;
        }

        this.updateVote(info);
    },

    onClose: function onClose() {
        this.stopUpdateTime();
        this._super();
    },

    updateTime: function updateTime() {
        var d = new Date();
        cc.log('this.remain_seconds:' + this.remain_seconds);
        var time = Math.max(0, Math.floor(this.remain_seconds - (d.getTime() / 1000 - this.update_start_time)));

        this.tip.string = '<color=#00ff00>玩家<color=#0fffff>'.concat(this.voteSponsorName, '</color>申请解散房间 (剩余<color=#0fffff>', String(time), '</color>秒,超时未同意默认同意)</c>');
        if (time == 0) {
            this.stopUpdateTime();
        }
    },

    stopUpdateTime: function stopUpdateTime() {
        if (this.isSchedule) {
            var s = cc.director.getScheduler();
            s.unscheduleAllForTarget(this.node);
            this.isSchedule = null;
        }
    },

    updateVote: function updateVote(info) {
        //更新投票
        var count = this.voteItems.childrenCount;
        var cs = this.voteItems.children;
        var myuid = cc.datamanager.mainPlayerData.cuid;
        for (var i = 0; i < count; ++i) {
            if (i < info.votes.length) {
                if (myuid.eq(info.votes[i].cuid)) {
                    this.btns.active = info.votes[i].vote == 0;
                }
                this.updateVoteItem(cs[i], info.votes[i]);
                cs[i].active = true;
            } else {
                cs[i].active = false;
            }
        }
    },

    voteToString: function voteToString(vote) {
        if (vote == 0) {
            return '<color=#598BD0>等待投票</c>';
        } else if (vote == 1) {
            return '<color=#6ED901>同意</c>';
        } else if (vate == 2) {
            return '<color=#ff0000>拒绝</c>';
        }
    },

    updateVoteItem: function updateVoteItem(item, info) {
        var nameNode = item.getChildByName('name');
        var stateNode = item.getChildByName('state');
        var stateLabel = stateNode.getComponent(cc.RichText);
        nameNode.getComponent(cc.Label).string = cc.gamemanager.getPlayer(info.cuid).name;
        stateLabel.string = this.voteToString(info.vote);
    },

    refuse: function refuse() {
        //拒绝
        var msg = cc.netmanager.msg('PublicProto.C_G13_VoteFoAbortGame');
        msg.vote = 2;
        cc.netmanager.send(msg);
        this.btns.active = false;
    },

    agree: function agree() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_VoteFoAbortGame');
        msg.vote = 1;
        cc.netmanager.send(msg);
        this.btns.active = false;
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIWaiting":[function(require,module,exports){
"use strict";
cc._RF.push(module, '40765Z24V9DG58uVcxGqysf', 'UIWaiting');
// Scripts\Gui\UIWaiting.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        waitLabel: cc.Label
    },

    setMessage: function setMessage(msg) {
        this.waitLabel.string = msg;
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"bigJsPanel":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'e0d6dCFZxRA9oqbc4pKXxl7', 'bigJsPanel');
// Scripts\Gui\Widget\bigJsPanel.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        username: cc.Label,
        winnum: cc.Label,
        daqiangnum: cc.Label,
        quanleidanum: cc.Label,
        zongfen: cc.Label,
        winstate: cc.Node,
        losestate: cc.Node,
        touxiang: cc.Node,
        userid: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    _scoreStr: function _scoreStr(num) {

        if (num < 0) {
            return num.toString();
        } else if (num > 0) {
            return "+" + num.toString();
        } else {
            return "0";
        }
    },

    _setScore: function _setScore(lb, num) {
        lb.string = this._scoreStr(num);
        cc.datamanager.setScoreFont(num >= 0, lb);
    },


    init: function init(data) {
        var player = cc.gamemanager.getPlayer(data.cuid);
        if (player != null) {
            this.username.string = player.name;
            cc.datamanager.loadHeadImg(player.imgurl, this.touxiang.getComponent(cc.Sprite));
        }
        this.winnum.string = data.win.toString();
        this.daqiangnum.string = data.daqiang.toString();
        this.quanleidanum.string = data.quanleida.toString();
        //this.zongfen.string = data.rank.toString()
        this.userid.string = data.cuid.toString();

        this._setScore(this.zongfen, data.rank);
    },

    setState: function setState(win, lose) {
        this.winstate.active = win;
        this.losestate.active = lose;
    }
});

cc._RF.pop();
},{}],"bytebuffer":[function(require,module,exports){
"use strict";
cc._RF.push(module, '370a1Icrw1Ltpqrh3NzRfir', 'bytebuffer');
// Scripts\Lib\bytebuffer.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 Backing buffer: ArrayBuffer, Accessor: Uint8Array
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/bytebuffer.js for details
*/
(function (k, m) {
  if ("function" === typeof define && define.amd) define(["long"], m);else if ("function" === typeof require && "object" === (typeof module === "undefined" ? "undefined" : _typeof(module)) && module && module.exports) {
    var r = module,
        s;try {
      s = require("long");
    } catch (u) {}s = m(s);r.exports = s;
  } else (k.dcodeIO = k.dcodeIO || {}).ByteBuffer = m(k.dcodeIO.Long);
})(undefined, function (k) {
  function m(a) {
    var b = 0;return function () {
      return b < a.length ? a.charCodeAt(b++) : null;
    };
  }function r() {
    var a = [],
        b = [];return function () {
      if (0 === arguments.length) return b.join("") + w.apply(String, a);1024 < a.length + arguments.length && (b.push(w.apply(String, a)), a.length = 0);Array.prototype.push.apply(a, arguments);
    };
  }function s(a, b, c, d, f) {
    var l;l = 8 * f - d - 1;var g = (1 << l) - 1,
        e = g >> 1,
        h = -7;f = c ? f - 1 : 0;var k = c ? -1 : 1,
        p = a[b + f];f += k;c = p & (1 << -h) - 1;p >>= -h;for (h += l; 0 < h; c = 256 * c + a[b + f], f += k, h -= 8) {}l = c & (1 << -h) - 1;c >>= -h;for (h += d; 0 < h; l = 256 * l + a[b + f], f += k, h -= 8) {}if (0 === c) c = 1 - e;else {
      if (c === g) return l ? NaN : Infinity * (p ? -1 : 1);l += Math.pow(2, d);c -= e;
    }return (p ? -1 : 1) * l * Math.pow(2, c - d);
  }function u(a, b, c, d, f, l) {
    var g,
        e = 8 * l - f - 1,
        h = (1 << e) - 1,
        k = h >> 1,
        p = 23 === f ? Math.pow(2, -24) - Math.pow(2, -77) : 0;l = d ? 0 : l - 1;var m = d ? 1 : -1,
        n = 0 > b || 0 === b && 0 > 1 / b ? 1 : 0;b = Math.abs(b);isNaN(b) || Infinity === b ? (b = isNaN(b) ? 1 : 0, d = h) : (d = Math.floor(Math.log(b) / Math.LN2), 1 > b * (g = Math.pow(2, -d)) && (d--, g *= 2), b = 1 <= d + k ? b + p / g : b + p * Math.pow(2, 1 - k), 2 <= b * g && (d++, g /= 2), d + k >= h ? (b = 0, d = h) : 1 <= d + k ? (b = (b * g - 1) * Math.pow(2, f), d += k) : (b = b * Math.pow(2, k - 1) * Math.pow(2, f), d = 0));for (; 8 <= f; a[c + l] = b & 255, l += m, b /= 256, f -= 8) {}d = d << f | b;for (e += f; 0 < e; a[c + l] = d & 255, l += m, d /= 256, e -= 8) {}a[c + l - m] |= 128 * n;
  }var h = function h(a, b, c) {
    "undefined" === typeof a && (a = h.DEFAULT_CAPACITY);"undefined" === typeof b && (b = h.DEFAULT_ENDIAN);"undefined" === typeof c && (c = h.DEFAULT_NOASSERT);if (!c) {
      a |= 0;if (0 > a) throw RangeError("Illegal capacity");b = !!b;c = !!c;
    }this.buffer = 0 === a ? v : new ArrayBuffer(a);this.view = 0 === a ? null : new Uint8Array(this.buffer);this.offset = 0;this.markedOffset = -1;this.limit = a;this.littleEndian = b;this.noAssert = c;
  };h.VERSION = "5.0.1";h.LITTLE_ENDIAN = !0;h.BIG_ENDIAN = !1;h.DEFAULT_CAPACITY = 16;h.DEFAULT_ENDIAN = h.BIG_ENDIAN;h.DEFAULT_NOASSERT = !1;h.Long = k || null;var e = h.prototype;Object.defineProperty(e, "__isByteBuffer__", { value: !0, enumerable: !1, configurable: !1 });var v = new ArrayBuffer(0),
      w = String.fromCharCode;h.accessor = function () {
    return Uint8Array;
  };h.allocate = function (a, b, c) {
    return new h(a, b, c);
  };h.concat = function (a, b, c, d) {
    if ("boolean" === typeof b || "string" !== typeof b) d = c, c = b, b = void 0;for (var f = 0, l = 0, g = a.length, e; l < g; ++l) {
      h.isByteBuffer(a[l]) || (a[l] = h.wrap(a[l], b)), e = a[l].limit - a[l].offset, 0 < e && (f += e);
    }if (0 === f) return new h(0, c, d);b = new h(f, c, d);for (l = 0; l < g;) {
      c = a[l++], e = c.limit - c.offset, 0 >= e || (b.view.set(c.view.subarray(c.offset, c.limit), b.offset), b.offset += e);
    }b.limit = b.offset;b.offset = 0;return b;
  };h.isByteBuffer = function (a) {
    return !0 === (a && a.__isByteBuffer__);
  };h.type = function () {
    return ArrayBuffer;
  };h.wrap = function (a, b, c, d) {
    "string" !== typeof b && (d = c, c = b, b = void 0);if ("string" === typeof a) switch ("undefined" === typeof b && (b = "utf8"), b) {case "base64":
        return h.fromBase64(a, c);case "hex":
        return h.fromHex(a, c);case "binary":
        return h.fromBinary(a, c);case "utf8":
        return h.fromUTF8(a, c);case "debug":
        return h.fromDebug(a, c);default:
        throw Error("Unsupported encoding: " + b);}if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) throw TypeError("Illegal buffer");if (h.isByteBuffer(a)) return b = e.clone.call(a), b.markedOffset = -1, b;if (a instanceof Uint8Array) b = new h(0, c, d), 0 < a.length && (b.buffer = a.buffer, b.offset = a.byteOffset, b.limit = a.byteOffset + a.byteLength, b.view = new Uint8Array(a.buffer));else if (a instanceof ArrayBuffer) b = new h(0, c, d), 0 < a.byteLength && (b.buffer = a, b.offset = 0, b.limit = a.byteLength, b.view = 0 < a.byteLength ? new Uint8Array(a) : null);else if ("[object Array]" === Object.prototype.toString.call(a)) for (b = new h(a.length, c, d), b.limit = a.length, c = 0; c < a.length; ++c) {
      b.view[c] = a[c];
    } else throw TypeError("Illegal buffer");return b;
  };e.writeBitSet = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if (!(a instanceof Array)) throw TypeError("Illegal BitSet: Not an array");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f = a.length,
        e = f >> 3,
        g = 0,
        h;for (b += this.writeVarint32(f, b); e--;) {
      h = !!a[g++] & 1 | (!!a[g++] & 1) << 1 | (!!a[g++] & 1) << 2 | (!!a[g++] & 1) << 3 | (!!a[g++] & 1) << 4 | (!!a[g++] & 1) << 5 | (!!a[g++] & 1) << 6 | (!!a[g++] & 1) << 7, this.writeByte(h, b++);
    }if (g < f) {
      for (h = e = 0; g < f;) {
        h |= (!!a[g++] & 1) << e++;
      }this.writeByte(h, b++);
    }return c ? (this.offset = b, this) : b - d;
  };e.readBitSet = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);var c = this.readVarint32(a),
        d = c.value,
        f = d >> 3,
        e = 0,
        g = [];for (a += c.length; f--;) {
      c = this.readByte(a++), g[e++] = !!(c & 1), g[e++] = !!(c & 2), g[e++] = !!(c & 4), g[e++] = !!(c & 8), g[e++] = !!(c & 16), g[e++] = !!(c & 32), g[e++] = !!(c & 64), g[e++] = !!(c & 128);
    }if (e < d) for (f = 0, c = this.readByte(a++); e < d;) {
      g[e++] = !!(c >> f++ & 1);
    }b && (this.offset = a);return g;
  };e.readBytes = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + a > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+" + a + ") <= " + this.buffer.byteLength);
    }var d = this.slice(b, b + a);c && (this.offset += a);return d;
  };e.writeBytes = e.append;e.writeInt8 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 1;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);this.view[b - 1] = a;c && (this.offset += 1);return this;
  };e.writeByte = e.writeInt8;e.readInt8 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }a = this.view[a];128 === (a & 128) && (a = -(255 - a + 1));b && (this.offset += 1);return a;
  };e.readByte = e.readInt8;e.writeUint8 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 1;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);
    this.view[b - 1] = a;c && (this.offset += 1);return this;
  };e.writeUInt8 = e.writeUint8;e.readUint8 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }a = this.view[a];b && (this.offset += 1);return a;
  };e.readUInt8 = e.readUint8;e.writeInt16 = function (a, b) {
    var c = "undefined" === typeof b;
    c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 2;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 2;this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);c && (this.offset += 2);return this;
  };e.writeShort = e.writeInt16;e.readInt16 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);32768 === (c & 32768) && (c = -(65535 - c + 1));b && (this.offset += 2);return c;
  };e.readShort = e.readInt16;e.writeUint16 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 2;var d = this.buffer.byteLength;
    b > d && this.resize((d *= 2) > b ? d : b);b -= 2;this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);c && (this.offset += 2);return this;
  };e.writeUInt16 = e.writeUint16;e.readUint16 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);b && (this.offset += 2);return c;
  };e.readUInt16 = e.readUint16;e.writeInt32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 4;this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);c && (this.offset += 4);return this;
  };e.writeInt = e.writeInt32;e.readInt32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);b && (this.offset += 4);return c | 0;
  };e.readInt = e.readInt32;e.writeUint32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 4;this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);c && (this.offset += 4);return this;
  };e.writeUInt32 = e.writeUint32;e.readUint32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);b && (this.offset += 4);return c;
  };e.readUInt32 = e.readUint32;k && (e.writeInt64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 8;var d = a.low,
        f = a.high;this.littleEndian ? (this.view[b + 3] = d >>> 24 & 255, this.view[b + 2] = d >>> 16 & 255, this.view[b + 1] = d >>> 8 & 255, this.view[b] = d & 255, b += 4, this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255, b += 4, this.view[b] = d >>> 24 & 255, this.view[b + 1] = d >>> 16 & 255, this.view[b + 2] = d >>> 8 & 255, this.view[b + 3] = d & 255);c && (this.offset += 8);return this;
  }, e.writeLong = e.writeInt64, e.readInt64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
      a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0, a += 4, d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0, a += 4, c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);
    a = new k(c, d, !1);b && (this.offset += 8);return a;
  }, e.readLong = e.readInt64, e.writeUint64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 8;var d = a.low,
        f = a.high;this.littleEndian ? (this.view[b + 3] = d >>> 24 & 255, this.view[b + 2] = d >>> 16 & 255, this.view[b + 1] = d >>> 8 & 255, this.view[b] = d & 255, b += 4, this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255, b += 4, this.view[b] = d >>> 24 & 255, this.view[b + 1] = d >>> 16 & 255, this.view[b + 2] = d >>> 8 & 255, this.view[b + 3] = d & 255);c && (this.offset += 8);return this;
  }, e.writeUInt64 = e.writeUint64, e.readUint64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0, a += 4, d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0, a += 4, c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);a = new k(c, d, !0);b && (this.offset += 8);return a;
  }, e.readUInt64 = e.readUint64);e.writeFloat32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);u(this.view, a, b - 4, this.littleEndian, 23, 4);c && (this.offset += 4);return this;
  };e.writeFloat = e.writeFloat32;e.readFloat32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }a = s(this.view, a, this.littleEndian, 23, 4);b && (this.offset += 4);return a;
  };e.readFloat = e.readFloat32;e.writeFloat64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);u(this.view, a, b - 8, this.littleEndian, 52, 8);c && (this.offset += 8);return this;
  };e.writeDouble = e.writeFloat64;e.readFloat64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }a = s(this.view, a, this.littleEndian, 52, 8);b && (this.offset += 8);return a;
  };e.readDouble = e.readFloat64;h.MAX_VARINT32_BYTES = 5;h.calculateVarint32 = function (a) {
    a >>>= 0;return 128 > a ? 1 : 16384 > a ? 2 : 2097152 > a ? 3 : 268435456 > a ? 4 : 5;
  };h.zigZagEncode32 = function (a) {
    return ((a |= 0) << 1 ^ a >> 31) >>> 0;
  };h.zigZagDecode32 = function (a) {
    return a >>> 1 ^ -(a & 1) | 0;
  };e.writeVarint32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = h.calculateVarint32(a),
        f;b += d;f = this.buffer.byteLength;b > f && this.resize((f *= 2) > b ? f : b);
    b -= d;for (a >>>= 0; 128 <= a;) {
      f = a & 127 | 128, this.view[b++] = f, a >>>= 7;
    }this.view[b++] = a;return c ? (this.offset = b, this) : d;
  };e.writeVarint32ZigZag = function (a, b) {
    return this.writeVarint32(h.zigZagEncode32(a), b);
  };e.readVarint32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0,
        f;do {
      if (!this.noAssert && a > this.limit) throw a = Error("Truncated"), a.truncated = !0, a;f = this.view[a++];5 > c && (d |= (f & 127) << 7 * c);++c;
    } while (0 !== (f & 128));d |= 0;return b ? (this.offset = a, d) : { value: d, length: c };
  };e.readVarint32ZigZag = function (a) {
    a = this.readVarint32(a);"object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) ? a.value = h.zigZagDecode32(a.value) : a = h.zigZagDecode32(a);return a;
  };k && (h.MAX_VARINT64_BYTES = 10, h.calculateVarint64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));var b = a.toInt() >>> 0,
        c = a.shiftRightUnsigned(28).toInt() >>> 0;a = a.shiftRightUnsigned(56).toInt() >>> 0;return 0 == a ? 0 == c ? 16384 > b ? 128 > b ? 1 : 2 : 2097152 > b ? 3 : 4 : 16384 > c ? 128 > c ? 5 : 6 : 2097152 > c ? 7 : 8 : 128 > a ? 9 : 10;
  }, h.zigZagEncode64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());return a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned();
  }, h.zigZagDecode64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());return a.shiftRightUnsigned(1).xor(a.and(k.ONE).toSigned().negate()).toSigned();
  }, e.writeVarint64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());var d = h.calculateVarint64(a),
        f = a.toInt() >>> 0,
        e = a.shiftRightUnsigned(28).toInt() >>> 0,
        g = a.shiftRightUnsigned(56).toInt() >>> 0;b += d;var t = this.buffer.byteLength;b > t && this.resize((t *= 2) > b ? t : b);b -= d;switch (d) {case 10:
        this.view[b + 9] = g >>> 7 & 1;case 9:
        this.view[b + 8] = 9 !== d ? g | 128 : g & 127;case 8:
        this.view[b + 7] = 8 !== d ? e >>> 21 | 128 : e >>> 21 & 127;case 7:
        this.view[b + 6] = 7 !== d ? e >>> 14 | 128 : e >>> 14 & 127;case 6:
        this.view[b + 5] = 6 !== d ? e >>> 7 | 128 : e >>> 7 & 127;case 5:
        this.view[b + 4] = 5 !== d ? e | 128 : e & 127;case 4:
        this.view[b + 3] = 4 !== d ? f >>> 21 | 128 : f >>> 21 & 127;case 3:
        this.view[b + 2] = 3 !== d ? f >>> 14 | 128 : f >>> 14 & 127;case 2:
        this.view[b + 1] = 2 !== d ? f >>> 7 | 128 : f >>> 7 & 127;case 1:
        this.view[b] = 1 !== d ? f | 128 : f & 127;}return c ? (this.offset += d, this) : d;
  }, e.writeVarint64ZigZag = function (a, b) {
    return this.writeVarint64(h.zigZagEncode64(a), b);
  }, e.readVarint64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d = 0,
        f = 0,
        e = 0,
        g = 0,
        g = this.view[a++],
        d = g & 127;if (g & 128 && (g = this.view[a++], d |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], d |= (g & 127) << 14, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], d |= (g & 127) << 21, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f = g & 127, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 14, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 21, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], e = g & 127, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], e |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g)) throw Error("Buffer overrun");d = k.fromBits(d | f << 28, f >>> 4 | e << 24, !1);return b ? (this.offset = a, d) : { value: d, length: a - c };
  }, e.readVarint64ZigZag = function (a) {
    (a = this.readVarint64(a)) && a.value instanceof k ? a.value = h.zigZagDecode64(a.value) : a = h.zigZagDecode64(a);return a;
  });e.writeCString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);var d,
        f = a.length;if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");for (d = 0; d < f; ++d) {
        if (0 === a.charCodeAt(d)) throw RangeError("Illegal str: Contains NULL-characters");
      }if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }f = n.calculateUTF16asUTF8(m(a))[1];b += f + 1;d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= f + 1;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));this.view[b++] = 0;return c ? (this.offset = b, this) : f;
  };e.readCString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d,
        f = -1;n.decodeUTF8toUTF16(function () {
      if (0 === f) return null;if (a >= this.limit) throw RangeError("Illegal range: Truncated data, " + a + " < " + this.limit);f = this.view[a++];return 0 === f ? null : f;
    }.bind(this), d = r(), !0);return b ? (this.offset = a, d()) : { string: d(), length: a - c };
  };e.writeIString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f;f = n.calculateUTF16asUTF8(m(a), this.noAssert)[1];b += 4 + f;var e = this.buffer.byteLength;b > e && this.resize((e *= 2) > b ? e : b);b -= 4 + f;this.littleEndian ? (this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255);b += 4;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));if (b !== d + 4 + f) throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + 4 + f));return c ? (this.offset = b, this) : b - d;
  };e.readIString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = a,
        d = this.readUint32(a),
        d = this.readUTF8String(d, h.METRICS_BYTES, a += 4);a += d.length;return b ? (this.offset = a, d.string) : { string: d.string, length: a - c };
  };h.METRICS_CHARS = "c";h.METRICS_BYTES = "b";e.writeUTF8String = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d,
        f = b;d = n.calculateUTF16asUTF8(m(a))[1];b += d;var e = this.buffer.byteLength;b > e && this.resize((e *= 2) > b ? e : b);b -= d;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));return c ? (this.offset = b, this) : b - f;
  };e.writeString = e.writeUTF8String;h.calculateUTF8Chars = function (a) {
    return n.calculateUTF16asUTF8(m(a))[0];
  };h.calculateUTF8Bytes = function (a) {
    return n.calculateUTF16asUTF8(m(a))[1];
  };
  h.calculateString = h.calculateUTF8Bytes;e.readUTF8String = function (a, b, c) {
    "number" === typeof b && (c = b, b = void 0);var d = "undefined" === typeof c;d && (c = this.offset);"undefined" === typeof b && (b = h.METRICS_CHARS);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");a |= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }var f = 0,
        e = c,
        g;if (b === h.METRICS_CHARS) {
      g = r();n.decodeUTF8(function () {
        return f < a && c < this.limit ? this.view[c++] : null;
      }.bind(this), function (a) {
        ++f;n.UTF8toUTF16(a, g);
      });if (f !== a) throw RangeError("Illegal range: Truncated data, " + f + " == " + a);return d ? (this.offset = c, g()) : { string: g(), length: c - e };
    }if (b === h.METRICS_BYTES) {
      if (!this.noAssert) {
        if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + a > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+" + a + ") <= " + this.buffer.byteLength);
      }var k = c + a;n.decodeUTF8toUTF16(function () {
        return c < k ? this.view[c++] : null;
      }.bind(this), g = r(), this.noAssert);if (c !== k) throw RangeError("Illegal range: Truncated data, " + c + " == " + k);return d ? (this.offset = c, g()) : { string: g(), length: c - e };
    }throw TypeError("Unsupported metrics: " + b);
  };e.readString = e.readUTF8String;e.writeVString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f,
        e;f = n.calculateUTF16asUTF8(m(a), this.noAssert)[1];e = h.calculateVarint32(f);b += e + f;var g = this.buffer.byteLength;b > g && this.resize((g *= 2) > b ? g : b);b -= e + f;b += this.writeVarint32(f, b);n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));if (b !== d + f + e) throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + f + e));return c ? (this.offset = b, this) : b - d;
  };e.readVString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d = this.readVarint32(a),
        d = this.readUTF8String(d.value, h.METRICS_BYTES, a += d.length);a += d.length;return b ? (this.offset = a, d.string) : { string: d.string,
      length: a - c };
  };e.append = function (a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) c = b, b = void 0;var d = "undefined" === typeof c;d && (c = this.offset);if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }a instanceof h || (a = h.wrap(a, b));b = a.limit - a.offset;if (0 >= b) return this;c += b;var f = this.buffer.byteLength;c > f && this.resize((f *= 2) > c ? f : c);c -= b;this.view.set(a.view.subarray(a.offset, a.limit), c);a.offset += b;d && (this.offset += b);return this;
  };e.appendTo = function (a, b) {
    a.append(this, b);return this;
  };e.assert = function (a) {
    this.noAssert = !a;return this;
  };e.capacity = function () {
    return this.buffer.byteLength;
  };e.clear = function () {
    this.offset = 0;this.limit = this.buffer.byteLength;this.markedOffset = -1;return this;
  };e.clone = function (a) {
    var b = new h(0, this.littleEndian, this.noAssert);a ? (b.buffer = new ArrayBuffer(this.buffer.byteLength), b.view = new Uint8Array(b.buffer)) : (b.buffer = this.buffer, b.view = this.view);b.offset = this.offset;b.markedOffset = this.markedOffset;b.limit = this.limit;return b;
  };e.compact = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (0 === a && b === this.buffer.byteLength) return this;var c = b - a;if (0 === c) return this.buffer = v, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= a), this.limit = this.offset = 0, this;var d = new ArrayBuffer(c),
        f = new Uint8Array(d);f.set(this.view.subarray(a, b));this.buffer = d;this.view = f;0 <= this.markedOffset && (this.markedOffset -= a);this.offset = 0;this.limit = c;return this;
  };e.copy = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (a === b) return new h(0, this.littleEndian, this.noAssert);var c = b - a,
        d = new h(c, this.littleEndian, this.noAssert);d.offset = 0;d.limit = c;0 <= d.markedOffset && (d.markedOffset -= a);this.copyTo(d, 0, a, b);return d;
  };e.copyTo = function (a, b, c, d) {
    var f, e;if (!this.noAssert && !h.isByteBuffer(a)) throw TypeError("Illegal target: Not a ByteBuffer");b = (e = "undefined" === typeof b) ? a.offset : b | 0;c = (f = "undefined" === typeof c) ? this.offset : c | 0;d = "undefined" === typeof d ? this.limit : d | 0;if (0 > b || b > a.buffer.byteLength) throw RangeError("Illegal target range: 0 <= " + b + " <= " + a.buffer.byteLength);if (0 > c || d > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= " + c + " <= " + this.buffer.byteLength);var g = d - c;if (0 === g) return a;a.ensureCapacity(b + g);
    a.view.set(this.view.subarray(c, d), b);f && (this.offset += g);e && (a.offset += g);return this;
  };e.ensureCapacity = function (a) {
    var b = this.buffer.byteLength;return b < a ? this.resize((b *= 2) > a ? b : a) : this;
  };e.fill = function (a, b, c) {
    var d = "undefined" === typeof b;d && (b = this.offset);"string" === typeof a && 0 < a.length && (a = a.charCodeAt(0));"undefined" === typeof b && (b = this.offset);"undefined" === typeof c && (c = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal begin: Not an integer");b >>>= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal end: Not an integer");c >>>= 0;if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
    }if (b >= c) return this;for (; b < c;) {
      this.view[b++] = a;
    }d && (this.offset = b);return this;
  };e.flip = function () {
    this.limit = this.offset;this.offset = 0;return this;
  };e.mark = function (a) {
    a = "undefined" === typeof a ? this.offset : a;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+0) <= " + this.buffer.byteLength);
    }this.markedOffset = a;return this;
  };e.order = function (a) {
    if (!this.noAssert && "boolean" !== typeof a) throw TypeError("Illegal littleEndian: Not a boolean");this.littleEndian = !!a;return this;
  };e.LE = function (a) {
    this.littleEndian = "undefined" !== typeof a ? !!a : !0;return this;
  };e.BE = function (a) {
    this.littleEndian = "undefined" !== typeof a ? !a : !1;return this;
  };e.prepend = function (a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) c = b, b = void 0;var d = "undefined" === typeof c;d && (c = this.offset);if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }a instanceof h || (a = h.wrap(a, b));b = a.limit - a.offset;if (0 >= b) return this;var f = b - c;if (0 < f) {
      var e = new ArrayBuffer(this.buffer.byteLength + f),
          g = new Uint8Array(e);g.set(this.view.subarray(c, this.buffer.byteLength), b);this.buffer = e;this.view = g;this.offset += f;0 <= this.markedOffset && (this.markedOffset += f);this.limit += f;c += f;
    } else new Uint8Array(this.buffer);this.view.set(a.view.subarray(a.offset, a.limit), c - b);a.offset = a.limit;d && (this.offset -= b);return this;
  };e.prependTo = function (a, b) {
    a.prepend(this, b);return this;
  };e.printDebug = function (a) {
    "function" !== typeof a && (a = console.log.bind(console));a(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0));
  };e.remaining = function () {
    return this.limit - this.offset;
  };e.reset = function () {
    0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0;return this;
  };e.resize = function (a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal capacity: " + a + " (not an integer)");a |= 0;if (0 > a) throw RangeError("Illegal capacity: 0 <= " + a);
    }if (this.buffer.byteLength < a) {
      a = new ArrayBuffer(a);var b = new Uint8Array(a);b.set(this.view);this.buffer = a;this.view = b;
    }return this;
  };
  e.reverse = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (a === b) return this;Array.prototype.reverse.call(this.view.subarray(a, b));return this;
  };
  e.skip = function (a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");a |= 0;
    }var b = this.offset + a;if (!this.noAssert && (0 > b || b > this.buffer.byteLength)) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + a + " <= " + this.buffer.byteLength);this.offset = b;return this;
  };e.slice = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
      a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }var c = this.clone();c.offset = a;c.limit = b;return c;
  };e.toBuffer = function (a) {
    var b = this.offset,
        c = this.limit;if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: Not an integer");b >>>= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal limit: Not an integer");
      c >>>= 0;if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
    }if (!a && 0 === b && c === this.buffer.byteLength) return this.buffer;if (b === c) return v;a = new ArrayBuffer(c - b);new Uint8Array(a).set(new Uint8Array(this.buffer).subarray(b, c), 0);return a;
  };e.toArrayBuffer = e.toBuffer;e.toString = function (a, b, c) {
    if ("undefined" === typeof a) return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";"number" === typeof a && (c = b = a = "utf8");switch (a) {case "utf8":
        return this.toUTF8(b, c);case "base64":
        return this.toBase64(b, c);case "hex":
        return this.toHex(b, c);case "binary":
        return this.toBinary(b, c);case "debug":
        return this.toDebug();case "columns":
        return this.toColumns();default:
        throw Error("Unsupported encoding: " + a);}
  };var x = function () {
    for (var a = {}, b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], c = [], d = 0, f = b.length; d < f; ++d) {
      c[b[d]] = d;
    }a.encode = function (a, c) {
      for (var d, f; null !== (d = a());) {
        c(b[d >> 2 & 63]), f = (d & 3) << 4, null !== (d = a()) ? (f |= d >> 4 & 15, c(b[(f | d >> 4 & 15) & 63]), f = (d & 15) << 2, null !== (d = a()) ? (c(b[(f | d >> 6 & 3) & 63]), c(b[d & 63])) : (c(b[f & 63]), c(61))) : (c(b[f & 63]), c(61), c(61));
      }
    };a.decode = function (a, b) {
      function d(a) {
        throw Error("Illegal character code: " + a);
      }for (var f, e, h; null !== (f = a());) {
        if (e = c[f], "undefined" === typeof e && d(f), null !== (f = a()) && (h = c[f], "undefined" === typeof h && d(f), b(e << 2 >>> 0 | (h & 48) >> 4), null !== (f = a()))) {
          e = c[f];if ("undefined" === typeof e) if (61 === f) break;else d(f);b((h & 15) << 4 >>> 0 | (e & 60) >> 2);if (null !== (f = a())) {
            h = c[f];if ("undefined" === typeof h) if (61 === f) break;else d(f);b((e & 3) << 6 >>> 0 | h);
          }
        }
      }
    };a.test = function (a) {
      return (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)
      );
    };return a;
  }();e.toBase64 = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);a |= 0;b |= 0;if (0 > a || b > this.capacity || a > b) throw RangeError("begin, end");var c;x.encode(function () {
      return a < b ? this.view[a++] : null;
    }.bind(this), c = r());return c();
  };h.fromBase64 = function (a, b) {
    if ("string" !== typeof a) throw TypeError("str");var c = new h(a.length / 4 * 3, b),
        d = 0;x.decode(m(a), function (a) {
      c.view[d++] = a;
    });c.limit = d;return c;
  };h.btoa = function (a) {
    return h.fromBinary(a).toBase64();
  };h.atob = function (a) {
    return h.fromBase64(a).toBinary();
  };e.toBinary = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);
    a |= 0;b |= 0;if (0 > a || b > this.capacity() || a > b) throw RangeError("begin, end");if (a === b) return "";for (var c = [], d = []; a < b;) {
      c.push(this.view[a++]), 1024 <= c.length && (d.push(String.fromCharCode.apply(String, c)), c = []);
    }return d.join("") + String.fromCharCode.apply(String, c);
  };h.fromBinary = function (a, b) {
    if ("string" !== typeof a) throw TypeError("str");for (var c = 0, d = a.length, f, e = new h(d, b); c < d;) {
      f = a.charCodeAt(c);if (255 < f) throw RangeError("illegal char code: " + f);e.view[c++] = f;
    }e.limit = d;return e;
  };e.toDebug = function (a) {
    for (var b = -1, c = this.buffer.byteLength, d, f = "", e = "", g = ""; b < c;) {
      -1 !== b && (d = this.view[b], f = 16 > d ? f + ("0" + d.toString(16).toUpperCase()) : f + d.toString(16).toUpperCase(), a && (e += 32 < d && 127 > d ? String.fromCharCode(d) : "."));++b;if (a && 0 < b && 0 === b % 16 && b !== c) {
        for (; 51 > f.length;) {
          f += " ";
        }g += f + e + "\n";f = e = "";
      }f = b === this.offset && b === this.limit ? f + (b === this.markedOffset ? "!" : "|") : b === this.offset ? f + (b === this.markedOffset ? "[" : "<") : b === this.limit ? f + (b === this.markedOffset ? "]" : ">") : f + (b === this.markedOffset ? "'" : a || 0 !== b && b !== c ? " " : "");
    }if (a && " " !== f) {
      for (; 51 > f.length;) {
        f += " ";
      }g += f + e + "\n";
    }return a ? g : f;
  };h.fromDebug = function (a, b, c) {
    var d = a.length;b = new h((d + 1) / 3 | 0, b, c);for (var f = 0, e = 0, g, k = !1, m = !1, n = !1, p = !1, q = !1; f < d;) {
      switch (g = a.charAt(f++)) {case "!":
          if (!c) {
            if (m || n || p) {
              q = !0;break;
            }m = n = p = !0;
          }b.offset = b.markedOffset = b.limit = e;k = !1;break;case "|":
          if (!c) {
            if (m || p) {
              q = !0;break;
            }m = p = !0;
          }b.offset = b.limit = e;k = !1;break;case "[":
          if (!c) {
            if (m || n) {
              q = !0;break;
            }m = n = !0;
          }b.offset = b.markedOffset = e;k = !1;break;case "<":
          if (!c) {
            if (m) {
              q = !0;break;
            }m = !0;
          }b.offset = e;k = !1;break;case "]":
          if (!c) {
            if (p || n) {
              q = !0;break;
            }p = n = !0;
          }b.limit = b.markedOffset = e;k = !1;break;case ">":
          if (!c) {
            if (p) {
              q = !0;break;
            }p = !0;
          }b.limit = e;k = !1;break;case "'":
          if (!c) {
            if (n) {
              q = !0;break;
            }n = !0;
          }b.markedOffset = e;k = !1;break;case " ":
          k = !1;break;default:
          if (!c && k) {
            q = !0;break;
          }g = parseInt(g + a.charAt(f++), 16);if (!c && (isNaN(g) || 0 > g || 255 < g)) throw TypeError("Illegal str: Not a debug encoded string");b.view[e++] = g;k = !0;}if (q) throw TypeError("Illegal str: Invalid symbol at " + f);
    }if (!c) {
      if (!m || !p) throw TypeError("Illegal str: Missing offset or limit");
      if (e < b.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + e + " < " + d);
    }return b;
  };e.toHex = function (a, b) {
    a = "undefined" === typeof a ? this.offset : a;b = "undefined" === typeof b ? this.limit : b;if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }for (var c = Array(b - a), d; a < b;) {
      d = this.view[a++], 16 > d ? c.push("0", d.toString(16)) : c.push(d.toString(16));
    }return c.join("");
  };h.fromHex = function (a, b, c) {
    if (!c) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");if (0 !== a.length % 2) throw TypeError("Illegal str: Length not a multiple of 2");
    }var d = a.length;b = new h(d / 2 | 0, b);for (var f, e = 0, g = 0; e < d; e += 2) {
      f = parseInt(a.substring(e, e + 2), 16);if (!c && (!isFinite(f) || 0 > f || 255 < f)) throw TypeError("Illegal str: Contains non-hex characters");
      b.view[g++] = f;
    }b.limit = g;return b;
  };var n = function () {
    var a = { MAX_CODEPOINT: 1114111, encodeUTF8: function encodeUTF8(a, c) {
        var d = null;"number" === typeof a && (d = a, a = function a() {
          return null;
        });for (; null !== d || null !== (d = a());) {
          128 > d ? c(d & 127) : (2048 > d ? c(d >> 6 & 31 | 192) : (65536 > d ? c(d >> 12 & 15 | 224) : (c(d >> 18 & 7 | 240), c(d >> 12 & 63 | 128)), c(d >> 6 & 63 | 128)), c(d & 63 | 128)), d = null;
        }
      }, decodeUTF8: function decodeUTF8(a, c) {
        for (var d, f, e, g, h = function h(a) {
          a = a.slice(0, a.indexOf(null));var b = Error(a.toString());b.name = "TruncatedError";b.bytes = a;throw b;
        }; null !== (d = a());) {
          if (0 === (d & 128)) c(d);else if (192 === (d & 224)) null === (f = a()) && h([d, f]), c((d & 31) << 6 | f & 63);else if (224 === (d & 240)) null !== (f = a()) && null !== (e = a()) || h([d, f, e]), c((d & 15) << 12 | (f & 63) << 6 | e & 63);else if (240 === (d & 248)) null !== (f = a()) && null !== (e = a()) && null !== (g = a()) || h([d, f, e, g]), c((d & 7) << 18 | (f & 63) << 12 | (e & 63) << 6 | g & 63);else throw RangeError("Illegal starting byte: " + d);
        }
      }, UTF16toUTF8: function UTF16toUTF8(a, c) {
        for (var d, e = null; null !== (d = null !== e ? e : a());) {
          55296 <= d && 57343 >= d && null !== (e = a()) && 56320 <= e && 57343 >= e ? (c(1024 * (d - 55296) + e - 56320 + 65536), e = null) : c(d);
        }null !== e && c(e);
      }, UTF8toUTF16: function UTF8toUTF16(a, c) {
        var d = null;"number" === typeof a && (d = a, a = function a() {
          return null;
        });for (; null !== d || null !== (d = a());) {
          65535 >= d ? c(d) : (d -= 65536, c((d >> 10) + 55296), c(d % 1024 + 56320)), d = null;
        }
      }, encodeUTF16toUTF8: function encodeUTF16toUTF8(b, c) {
        a.UTF16toUTF8(b, function (b) {
          a.encodeUTF8(b, c);
        });
      }, decodeUTF8toUTF16: function decodeUTF8toUTF16(b, c) {
        a.decodeUTF8(b, function (b) {
          a.UTF8toUTF16(b, c);
        });
      }, calculateCodePoint: function calculateCodePoint(a) {
        return 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
      }, calculateUTF8: function calculateUTF8(a) {
        for (var c, d = 0; null !== (c = a());) {
          d += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
        }return d;
      }, calculateUTF16asUTF8: function calculateUTF16asUTF8(b) {
        var c = 0,
            d = 0;a.UTF16toUTF8(b, function (a) {
          ++c;d += 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
        });return [c, d];
      } };return a;
  }();e.toUTF8 = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }var c;try {
      n.decodeUTF8toUTF16(function () {
        return a < b ? this.view[a++] : null;
      }.bind(this), c = r());
    } catch (d) {
      if (a !== b) throw RangeError("Illegal range: Truncated data, " + a + " != " + b);
    }return c();
  };h.fromUTF8 = function (a, b, c) {
    if (!c && "string" !== typeof a) throw TypeError("Illegal str: Not a string");var d = new h(n.calculateUTF16asUTF8(m(a), !0)[1], b, c),
        e = 0;n.encodeUTF16toUTF8(m(a), function (a) {
      d.view[e++] = a;
    });d.limit = e;return d;
  };return h;
});

cc._RF.pop();
},{"long":"long"}],"clicksound":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'e8863CYlohPK4xL3ltZzDVX', 'clicksound');
// Scripts\Gui\Widget\clicksound.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        this.node.on("click", function () {
            cc.audiomanager.playSFX("click");
        });
    }

});

cc._RF.pop();
},{}],"init":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b5713OFGZhA+Jt7gBxhwNe/', 'init');
// Scripts\init.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        cc.log("onload begin");

        Date.prototype.Format = function (fmt) {
            //author: meizz   
            var o = {
                "M+": this.getMonth() + 1, //月份   
                "d+": this.getDate(), //日   
                "h+": this.getHours(), //小时   
                "m+": this.getMinutes(), //分   
                "s+": this.getSeconds(), //秒   
                "q+": Math.floor((this.getMonth() + 3) / 3), //季度   
                "S": this.getMilliseconds() //毫秒   
            };
            if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
            for (var k in o) {
                if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
            }return fmt;
        };
        cc.netmanager.init();
        cc.netmanager.registerHandler(cc.datamanager);
        cc.netmanager.registerHandler(cc.gamemanager);
        cc.netmanager.registerHandler(cc.guimanager);
        cc.netmanager.registerHandler(cc.robot);

        cc.audiomanager.init();

        cc.netmanager.reconnect();

        cc.log('onload');
    }

});

cc._RF.pop();
},{}],"long":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2c847wd+iJEZZInKRIzLwWs', 'long');
// Scripts\Lib\long.js

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define([], factory);
    /* CommonJS */else if (typeof require === 'function' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory();
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
})(undefined, function () {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */

    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned, unsigned = false;
        } else {
            unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long) return val;
        if (typeof val === 'number') return fromNumber(val);
        if (typeof val === 'string') return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');
        if (this.isZero()) return '0';
        if (this.isNegative()) {
            // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) {
            if ((val & 1 << bit) != 0) break;
        }return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq( /* validates */other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp( /* validates */other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp( /* validates */other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp( /* validates */other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp( /* validates */other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        // At this point the sign bits are the same
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return ZERO;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (multiplier.isZero()) return ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error('division by zero');
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE)) return ONE;else {
                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                        var halfThis = this.shr(1);
                        approx = halfThis.div(divisor).shl(1);
                        if (approx.eq(ZERO)) {
                            return divisor.isNegative() ? ONE : NEG_ONE;
                        } else {
                            rem = this.sub(divisor.mul(approx));
                            res = approx.add(rem.div(divisor));
                            return res;
                        }
                    }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),


            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0) return this;else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
    };

    return Long;
});

cc._RF.pop();
},{}],"protobuf":[function(require,module,exports){
(function (process){
"use strict";
cc._RF.push(module, 'e6691hW/mRNZZdi3yfy4y8r', 'protobuf');
// Scripts\Lib\protobuf.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/protobuf.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define(["bytebuffer"], factory);
    /* CommonJS */else if (typeof require === "function" && (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory(require("bytebuffer"), true);
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
})(undefined, function (ByteBuffer, isCommonJS) {
    "use strict";

    /**
     * The ProtoBuf namespace.
     * @exports ProtoBuf
     * @namespace
     * @expose
     */

    var ProtoBuf = {};

    /**
     * @type {!function(new: ByteBuffer, ...[*])}
     * @expose
     */
    ProtoBuf.ByteBuffer = ByteBuffer;

    /**
     * @type {?function(new: Long, ...[*])}
     * @expose
     */
    ProtoBuf.Long = ByteBuffer.Long || null;

    /**
     * ProtoBuf.js version.
     * @type {string}
     * @const
     * @expose
     */
    ProtoBuf.VERSION = "5.0.1";

    /**
     * Wire types.
     * @type {Object.<string,number>}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES = {};

    /**
     * Varint wire type.
     * @type {number}
     * @expose
     */
    ProtoBuf.WIRE_TYPES.VARINT = 0;

    /**
     * Fixed 64 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS64 = 1;

    /**
     * Length delimited wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.LDELIM = 2;

    /**
     * Start group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

    /**
     * End group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

    /**
     * Fixed 32 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS32 = 5;

    /**
     * Packable wire types.
     * @type {!Array.<number>}
     * @const
     * @expose
     */
    ProtoBuf.PACKABLE_WIRE_TYPES = [ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32];

    /**
     * Types.
     * @dict
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
     * @const
     * @expose
     */
    ProtoBuf.TYPES = {
        // According to the protobuf spec.
        "int32": {
            name: "int32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "uint32": {
            name: "uint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "sint32": {
            name: "sint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "int64": {
            name: "int64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "uint64": {
            name: "uint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sint64": {
            name: "sint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "bool": {
            name: "bool",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: false
        },
        "double": {
            name: "double",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: 0
        },
        "string": {
            name: "string",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: ""
        },
        "bytes": {
            name: "bytes",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null // overridden in the code, must be a unique instance
        },
        "fixed32": {
            name: "fixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "sfixed32": {
            name: "sfixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "fixed64": {
            name: "fixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sfixed64": {
            name: "sfixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "float": {
            name: "float",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "enum": {
            name: "enum",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "message": {
            name: "message",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null
        },
        "group": {
            name: "group",
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
            defaultValue: null
        }
    };

    /**
     * Valid map key types.
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
     * @const
     * @expose
     */
    ProtoBuf.MAP_KEY_TYPES = [ProtoBuf.TYPES["int32"], ProtoBuf.TYPES["sint32"], ProtoBuf.TYPES["sfixed32"], ProtoBuf.TYPES["uint32"], ProtoBuf.TYPES["fixed32"], ProtoBuf.TYPES["int64"], ProtoBuf.TYPES["sint64"], ProtoBuf.TYPES["sfixed64"], ProtoBuf.TYPES["uint64"], ProtoBuf.TYPES["fixed64"], ProtoBuf.TYPES["bool"], ProtoBuf.TYPES["string"], ProtoBuf.TYPES["bytes"]];

    /**
     * Minimum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MIN = 1;

    /**
     * Maximum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MAX = 0x1FFFFFFF;

    /**
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
     *  Must be set prior to parsing.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.convertFieldsToCamelCase = false;

    /**
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
     *  setting this to `false` prior to building messages.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateAccessors = true;

    /**
     * By default, messages are populated with default values if a field is not present on the wire. To disable
     *  this behavior, set this setting to `false`.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateDefaults = true;

    /**
     * @alias ProtoBuf.Util
     * @expose
     */
    ProtoBuf.Util = function () {
        "use strict";

        /**
         * ProtoBuf utilities.
         * @exports ProtoBuf.Util
         * @namespace
         */

        var Util = {};

        /**
         * Flag if running in node or not.
         * @type {boolean}
         * @const
         * @expose
         */
        Util.IS_NODE = !!((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process + '' === '[object process]' && !process['browser']);

        /**
         * Constructs a XMLHttpRequest object.
         * @return {XMLHttpRequest}
         * @throws {Error} If XMLHttpRequest is not supported
         * @expose
         */
        Util.XHR = function () {
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
            var XMLHttpFactories = [function () {
                return new XMLHttpRequest();
            }, function () {
                return new ActiveXObject("Msxml2.XMLHTTP");
            }, function () {
                return new ActiveXObject("Msxml3.XMLHTTP");
            }, function () {
                return new ActiveXObject("Microsoft.XMLHTTP");
            }];
            /** @type {?XMLHttpRequest} */
            var xhr = null;
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xhr = XMLHttpFactories[i]();
                } catch (e) {
                    continue;
                }
                break;
            }
            if (!xhr) throw Error("XMLHttpRequest is not supported");
            return xhr;
        };

        /**
         * Fetches a resource.
         * @param {string} path Resource path
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose
         */
        Util.fetch = function (path, callback) {
            if (callback && typeof callback != 'function') callback = null;
            if (Util.IS_NODE) {
                var fs = require("fs");
                if (callback) {
                    fs.readFile(path, function (err, data) {
                        if (err) callback(null);else callback("" + data);
                    });
                } else try {
                    return fs.readFileSync(path);
                } catch (e) {
                    return null;
                }
            } else {
                var xhr = Util.XHR();
                xhr.open('GET', path, callback ? true : false);
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                xhr.setRequestHeader('Accept', 'text/plain');
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                if (callback) {
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState != 4) return;
                        if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') callback(xhr.responseText);else callback(null);
                    };
                    if (xhr.readyState == 4) return;
                    xhr.send(null);
                } else {
                    xhr.send(null);
                    if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') return xhr.responseText;
                    return null;
                }
            }
        };

        /**
         * Converts a string to camel case.
         * @param {string} str
         * @returns {string}
         * @expose
         */
        Util.toCamelCase = function (str) {
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                return $1.toUpperCase();
            });
        };

        return Util;
    }();

    /**
     * Language expressions.
     * @type {!Object.<string,!RegExp>}
     * @expose
     */
    ProtoBuf.Lang = {

        // Characters always ending a statement
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,

        // Field rules
        RULE: /^(?:required|optional|repeated|map)$/,

        // Field types
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,

        // Names
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,

        // Type definitions
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,

        // Type references
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,

        // Fully qualified type references
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,

        // All numbers
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,

        // Decimal numbers
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,

        // Hexadecimal numbers
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,

        // Octal numbers
        NUMBER_OCT: /^0[0-7]+$/,

        // Floating point numbers
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,

        // Booleans
        BOOL: /^(?:true|false)$/i,

        // Id numbers
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Negative id numbers (enum values)
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Whitespaces
        WHITESPACE: /\s/,

        // All strings
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,

        // Double quoted strings
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,

        // Single quoted strings
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
    };

    /**
     * @alias ProtoBuf.DotProto
     * @expose
     */
    ProtoBuf.DotProto = function (ProtoBuf, Lang) {
        "use strict";

        /**
         * Utilities to parse .proto files.
         * @exports ProtoBuf.DotProto
         * @namespace
         */

        var DotProto = {};

        /**
         * Constructs a new Tokenizer.
         * @exports ProtoBuf.DotProto.Tokenizer
         * @class prototype tokenizer
         * @param {string} proto Proto to tokenize
         * @constructor
         */
        var Tokenizer = function Tokenizer(proto) {

            /**
             * Source to parse.
             * @type {string}
             * @expose
             */
            this.source = proto + "";

            /**
             * Current index.
             * @type {number}
             * @expose
             */
            this.index = 0;

            /**
             * Current line.
             * @type {number}
             * @expose
             */
            this.line = 1;

            /**
             * Token stack.
             * @type {!Array.<string>}
             * @expose
             */
            this.stack = [];

            /**
             * Opening character of the current string read, if any.
             * @type {?string}
             * @private
             */
            this._stringOpen = null;
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer.prototype
         * @inner
         */
        var TokenizerPrototype = Tokenizer.prototype;

        /**
         * Reads a string beginning at the current index.
         * @return {string}
         * @private
         */
        TokenizerPrototype._readString = function () {
            var re = this._stringOpen === '"' ? Lang.STRING_DQ : Lang.STRING_SQ;
            re.lastIndex = this.index - 1; // Include the open quote
            var match = re.exec(this.source);
            if (!match) throw Error("unterminated string");
            this.index = re.lastIndex;
            this.stack.push(this._stringOpen);
            this._stringOpen = null;
            return match[1];
        };

        /**
         * Gets the next token and advances by one.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.next = function () {
            if (this.stack.length > 0) return this.stack.shift();
            if (this.index >= this.source.length) return null;
            if (this._stringOpen !== null) return this._readString();

            var repeat, prev, next;
            do {
                repeat = false;

                // Strip white spaces
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
                    if (next === '\n') ++this.line;
                    if (++this.index === this.source.length) return null;
                }

                // Strip comments
                if (this.source.charAt(this.index) === '/') {
                    ++this.index;
                    if (this.source.charAt(this.index) === '/') {
                        // Line
                        while (this.source.charAt(++this.index) !== '\n') {
                            if (this.index == this.source.length) return null;
                        }++this.index;
                        ++this.line;
                        repeat = true;
                    } else if ((next = this.source.charAt(this.index)) === '*') {
                        /* Block */
                        do {
                            if (next === '\n') ++this.line;
                            if (++this.index === this.source.length) return null;
                            prev = next;
                            next = this.source.charAt(this.index);
                        } while (prev !== '*' || next !== '/');
                        ++this.index;
                        repeat = true;
                    } else return '/';
                }
            } while (repeat);

            if (this.index === this.source.length) return null;

            // Read the next token
            var end = this.index;
            Lang.DELIM.lastIndex = 0;
            var delim = Lang.DELIM.test(this.source.charAt(end++));
            if (!delim) while (end < this.source.length && !Lang.DELIM.test(this.source.charAt(end))) {
                ++end;
            }var token = this.source.substring(this.index, this.index = end);
            if (token === '"' || token === "'") this._stringOpen = token;
            return token;
        };

        /**
         * Peeks for the next token.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.peek = function () {
            if (this.stack.length === 0) {
                var token = this.next();
                if (token === null) return null;
                this.stack.push(token);
            }
            return this.stack[0];
        };

        /**
         * Skips a specific token and throws if it differs.
         * @param {string} expected Expected token
         * @throws {Error} If the actual token differs
         */
        TokenizerPrototype.skip = function (expected) {
            var actual = this.next();
            if (actual !== expected) throw Error("illegal '" + actual + "', '" + expected + "' expected");
        };

        /**
         * Omits an optional token.
         * @param {string} expected Expected optional token
         * @returns {boolean} `true` if the token exists
         */
        TokenizerPrototype.omit = function (expected) {
            if (this.peek() === expected) {
                this.next();
                return true;
            }
            return false;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Tokenizer(index/length)"
         * @expose
         */
        TokenizerPrototype.toString = function () {
            return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")";
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer
         * @expose
         */
        DotProto.Tokenizer = Tokenizer;

        /**
         * Constructs a new Parser.
         * @exports ProtoBuf.DotProto.Parser
         * @class prototype parser
         * @param {string} source Source
         * @constructor
         */
        var Parser = function Parser(source) {

            /**
             * Tokenizer.
             * @type {!ProtoBuf.DotProto.Tokenizer}
             * @expose
             */
            this.tn = new Tokenizer(source);

            /**
             * Whether parsing proto3 or not.
             * @type {boolean}
             */
            this.proto3 = false;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser.prototype
         * @inner
         */
        var ParserPrototype = Parser.prototype;

        /**
         * Parses the source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        ParserPrototype.parse = function () {
            var topLevel = {
                "name": "[ROOT]", // temporary
                "package": null,
                "messages": [],
                "enums": [],
                "imports": [],
                "options": {},
                "services": []
                // "syntax": undefined
            };
            var token,
                head = true,
                weak;
            try {
                while (token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!head || topLevel["package"] !== null) throw Error("unexpected 'package'");
                            token = this.tn.next();
                            if (!Lang.TYPEREF.test(token)) throw Error("illegal package name: " + token);
                            this.tn.skip(";");
                            topLevel["package"] = token;
                            break;
                        case 'import':
                            if (!head) throw Error("unexpected 'import'");
                            token = this.tn.peek();
                            if (token === "public" || (weak = token === "weak")) // token ignored
                                this.tn.next();
                            token = this._readString();
                            this.tn.skip(";");
                            if (!weak) // import ignored
                                topLevel["imports"].push(token);
                            break;
                        case 'syntax':
                            if (!head) throw Error("unexpected 'syntax'");
                            this.tn.skip("=");
                            if ((topLevel["syntax"] = this._readString()) === "proto3") this.proto3 = true;
                            this.tn.skip(";");
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null);
                            head = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel);
                            head = false;
                            break;
                        case 'option':
                            this._parseOption(topLevel);
                            break;
                        case 'service':
                            this._parseService(topLevel);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel);
                            break;
                        default:
                            throw Error("unexpected '" + token + "'");
                    }
                }
            } catch (e) {
                e.message = "Parse error at line " + this.tn.line + ": " + e.message;
                throw e;
            }
            delete topLevel["name"];
            return topLevel;
        };

        /**
         * Parses the specified source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        Parser.parse = function (source) {
            return new Parser(source).parse();
        };

        // ----- Conversion ------

        /**
         * Converts a numerical string to an id.
         * @param {string} value
         * @param {boolean=} mayBeNegative
         * @returns {number}
         * @inner
         */
        function mkId(value, mayBeNegative) {
            var id = -1,
                sign = 1;
            if (value.charAt(0) == '-') {
                sign = -1;
                value = value.substring(1);
            }
            if (Lang.NUMBER_DEC.test(value)) id = parseInt(value);else if (Lang.NUMBER_HEX.test(value)) id = parseInt(value.substring(2), 16);else if (Lang.NUMBER_OCT.test(value)) id = parseInt(value.substring(1), 8);else throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            id = sign * id | 0; // Force to 32bit
            if (!mayBeNegative && id < 0) throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            return id;
        }

        /**
         * Converts a numerical string to a number.
         * @param {string} val
         * @returns {number}
         * @inner
         */
        function mkNumber(val) {
            var sign = 1;
            if (val.charAt(0) == '-') {
                sign = -1;
                val = val.substring(1);
            }
            if (Lang.NUMBER_DEC.test(val)) return sign * parseInt(val, 10);else if (Lang.NUMBER_HEX.test(val)) return sign * parseInt(val.substring(2), 16);else if (Lang.NUMBER_OCT.test(val)) return sign * parseInt(val.substring(1), 8);else if (val === 'inf') return sign * Infinity;else if (val === 'nan') return NaN;else if (Lang.NUMBER_FLT.test(val)) return sign * parseFloat(val);
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
        }

        // ----- Reading ------

        /**
         * Reads a string.
         * @returns {string}
         * @private
         */
        ParserPrototype._readString = function () {
            var value = "",
                token,
                delim;
            do {
                delim = this.tn.next();
                if (delim !== "'" && delim !== '"') throw Error("illegal string delimiter: " + delim);
                value += this.tn.next();
                this.tn.skip(delim);
                token = this.tn.peek();
            } while (token === '"' || token === '"'); // multi line?
            return value;
        };

        /**
         * Reads a value.
         * @param {boolean=} mayBeTypeRef
         * @returns {number|boolean|string}
         * @private
         */
        ParserPrototype._readValue = function (mayBeTypeRef) {
            var token = this.tn.peek(),
                value;
            if (token === '"' || token === "'") return this._readString();
            this.tn.next();
            if (Lang.NUMBER.test(token)) return mkNumber(token);
            if (Lang.BOOL.test(token)) return token.toLowerCase() === 'true';
            if (mayBeTypeRef && Lang.TYPEREF.test(token)) return token;
            throw Error("illegal value: " + token);
        };

        // ----- Parsing constructs -----

        /**
         * Parses a namespace option.
         * @param {!Object} parent Parent definition
         * @param {boolean=} isList
         * @private
         */
        ParserPrototype._parseOption = function (parent, isList) {
            var token = this.tn.next(),
                custom = false;
            if (token === '(') {
                custom = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
                throw Error("illegal option name: " + token);
            var name = token;
            if (custom) {
                // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                this.tn.skip(')');
                name = '(' + name + ')';
                token = this.tn.peek();
                if (Lang.FQTYPEREF.test(token)) {
                    name += token;
                    this.tn.next();
                }
            }
            this.tn.skip('=');
            this._parseOptionValue(parent, name);
            if (!isList) this.tn.skip(";");
        };

        /**
         * Sets an option on the specified options object.
         * @param {!Object.<string,*>} options
         * @param {string} name
         * @param {string|number|boolean} value
         * @inner
         */
        function setOption(options, name, value) {
            if (typeof options[name] === 'undefined') options[name] = value;else {
                if (!Array.isArray(options[name])) options[name] = [options[name]];
                options[name].push(value);
            }
        }

        /**
         * Parses an option value.
         * @param {!Object} parent
         * @param {string} name
         * @private
         */
        ParserPrototype._parseOptionValue = function (parent, name) {
            var token = this.tn.peek();
            if (token !== '{') {
                // Plain value
                setOption(parent["options"], name, this._readValue(true));
            } else {
                // Aggregate options
                this.tn.skip("{");
                while ((token = this.tn.next()) !== '}') {
                    if (!Lang.NAME.test(token)) throw Error("illegal option name: " + name + "." + token);
                    if (this.tn.omit(":")) setOption(parent["options"], name + "." + token, this._readValue(true));else this._parseOptionValue(parent, name + "." + token);
                }
            }
        };

        /**
         * Parses a service definition.
         * @param {!Object} parent Parent definition
         * @private
         */
        ParserPrototype._parseService = function (parent) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal service name at line " + this.tn.line + ": " + token);
            var name = token;
            var svc = {
                "name": name,
                "rpc": {},
                "options": {}
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(svc);else if (token === 'rpc') this._parseServiceRPC(svc);else throw Error("illegal service token: " + token);
            }
            this.tn.omit(";");
            parent["services"].push(svc);
        };

        /**
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
         * @param {!Object} svc Service definition
         * @private
         */
        ParserPrototype._parseServiceRPC = function (svc) {
            var type = "rpc",
                token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal rpc service method name: " + token);
            var name = token;
            var method = {
                "request": null,
                "response": null,
                "request_stream": false,
                "response_stream": false,
                "options": {}
            };
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["request_stream"] = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token)) throw Error("illegal rpc service request type: " + token);
            method["request"] = token;
            this.tn.skip(")");
            token = this.tn.next();
            if (token.toLowerCase() !== "returns") throw Error("illegal rpc service request type delimiter: " + token);
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["response_stream"] = true;
                token = this.tn.next();
            }
            method["response"] = token;
            this.tn.skip(")");
            token = this.tn.peek();
            if (token === '{') {
                this.tn.next();
                while ((token = this.tn.next()) !== '}') {
                    if (token === 'option') this._parseOption(method);else throw Error("illegal rpc service token: " + token);
                }
                this.tn.omit(";");
            } else this.tn.skip(";");
            if (typeof svc[type] === 'undefined') svc[type] = {};
            svc[type][name] = method;
        };

        /**
         * Parses a message definition.
         * @param {!Object} parent Parent definition
         * @param {!Object=} fld Field definition if this is a group
         * @returns {!Object}
         * @private
         */
        ParserPrototype._parseMessage = function (parent, fld) {
            var isGroup = !!fld,
                token = this.tn.next();
            var msg = {
                "name": "",
                "fields": [],
                "enums": [],
                "messages": [],
                "options": {},
                "services": [],
                "oneofs": {}
                // "extensions": undefined
            };
            if (!Lang.NAME.test(token)) throw Error("illegal " + (isGroup ? "group" : "message") + " name: " + token);
            msg["name"] = token;
            if (isGroup) {
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                msg["isGroup"] = true;
            }
            token = this.tn.peek();
            if (token === '[' && fld) this._parseFieldOptions(fld);
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(msg, token);else if (token === "oneof") this._parseMessageOneOf(msg);else if (token === "enum") this._parseEnum(msg);else if (token === "message") this._parseMessage(msg);else if (token === "option") this._parseOption(msg);else if (token === "service") this._parseService(msg);else if (token === "extensions") {
                    if (msg.hasOwnProperty("extensions")) {
                        msg["extensions"] = msg["extensions"].concat(this._parseExtensionRanges());
                    } else {
                        msg["extensions"] = this._parseExtensionRanges();
                    }
                } else if (token === "reserved") this._parseIgnored(); // TODO
                else if (token === "extend") this._parseExtend(msg);else if (Lang.TYPEREF.test(token)) {
                        if (!this.proto3) throw Error("illegal field rule: " + token);
                        this._parseMessageField(msg, "optional", token);
                    } else throw Error("illegal message token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(msg);
            return msg;
        };

        /**
         * Parses an ignored statement.
         * @private
         */
        ParserPrototype._parseIgnored = function () {
            while (this.tn.peek() !== ';') {
                this.tn.next();
            }this.tn.skip(";");
        };

        /**
         * Parses a message field.
         * @param {!Object} msg Message definition
         * @param {string} rule Field rule
         * @param {string=} type Field type if already known (never known for maps)
         * @returns {!Object} Field descriptor
         * @private
         */
        ParserPrototype._parseMessageField = function (msg, rule, type) {
            if (!Lang.RULE.test(rule)) throw Error("illegal message field rule: " + rule);
            var fld = {
                "rule": rule,
                "type": "",
                "name": "",
                "options": {},
                "id": 0
            };
            var token;
            if (rule === "map") {

                if (type) throw Error("illegal type: " + type);
                this.tn.skip('<');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field type: " + token);
                fld["keytype"] = token;
                this.tn.skip(',');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field: " + token);
                fld["type"] = token;
                this.tn.skip('>');
                token = this.tn.next();
                if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                fld["name"] = token;
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                token = this.tn.peek();
                if (token === '[') this._parseFieldOptions(fld);
                this.tn.skip(";");
            } else {

                type = typeof type !== 'undefined' ? type : this.tn.next();

                if (type === "group") {

                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    var grp = this._parseMessage(msg, fld);
                    if (!/^[A-Z]/.test(grp["name"])) throw Error('illegal group name: ' + grp["name"]);
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    this.tn.omit(";");
                } else {

                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type)) throw Error("illegal message field type: " + type);
                    fld["type"] = type;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                    fld["name"] = token;
                    this.tn.skip("=");
                    fld["id"] = mkId(this.tn.next());
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions(fld);
                    this.tn.skip(";");
                }
            }
            msg["fields"].push(fld);
            return fld;
        };

        /**
         * Parses a message oneof.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseMessageOneOf = function (msg) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal oneof name: " + token);
            var name = token,
                fld;
            var fields = [];
            this.tn.skip("{");
            while ((token = this.tn.next()) !== "}") {
                fld = this._parseMessageField(msg, "optional", token);
                fld["oneof"] = name;
                fields.push(fld["id"]);
            }
            this.tn.omit(";");
            msg["oneofs"][name] = fields;
        };

        /**
         * Parses a set of field option definitions.
         * @param {!Object} fld Field definition
         * @private
         */
        ParserPrototype._parseFieldOptions = function (fld) {
            this.tn.skip("[");
            var token,
                first = true;
            while ((token = this.tn.peek()) !== ']') {
                if (!first) this.tn.skip(",");
                this._parseOption(fld, true);
                first = false;
            }
            this.tn.next();
        };

        /**
         * Parses an enum.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseEnum = function (msg) {
            var enm = {
                "name": "",
                "values": [],
                "options": {}
            };
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
            enm["name"] = token;
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(enm);else {
                    if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
                    this.tn.skip("=");
                    var val = {
                        "name": token,
                        "id": mkId(this.tn.next(), true)
                    };
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions({ "options": {} });
                    this.tn.skip(";");
                    enm["values"].push(val);
                }
            }
            this.tn.omit(";");
            msg["enums"].push(enm);
        };

        /**
         * Parses extension / reserved ranges.
         * @returns {!Array.<!Array.<number>>}
         * @private
         */
        ParserPrototype._parseExtensionRanges = function () {
            var ranges = [];
            var token, range, value;
            do {
                range = [];
                while (true) {
                    token = this.tn.next();
                    switch (token) {
                        case "min":
                            value = ProtoBuf.ID_MIN;
                            break;
                        case "max":
                            value = ProtoBuf.ID_MAX;
                            break;
                        default:
                            value = mkNumber(token);
                            break;
                    }
                    range.push(value);
                    if (range.length === 2) break;
                    if (this.tn.peek() !== "to") {
                        range.push(value);
                        break;
                    }
                    this.tn.next();
                }
                ranges.push(range);
            } while (this.tn.omit(","));
            this.tn.skip(";");
            return ranges;
        };

        /**
         * Parses an extend block.
         * @param {!Object} parent Parent object
         * @private
         */
        ParserPrototype._parseExtend = function (parent) {
            var token = this.tn.next();
            if (!Lang.TYPEREF.test(token)) throw Error("illegal extend reference: " + token);
            var ext = {
                "ref": token,
                "fields": []
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(ext, token);else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3) throw Error("illegal field rule: " + token);
                    this._parseMessageField(ext, "optional", token);
                } else throw Error("illegal extend token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(ext);
            return ext;
        };

        // ----- General -----

        /**
         * Returns a string representation of this parser.
         * @returns {string}
         */
        ParserPrototype.toString = function () {
            return "Parser at line " + this.tn.line;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser
         * @expose
         */
        DotProto.Parser = Parser;

        return DotProto;
    }(ProtoBuf, ProtoBuf.Lang);

    /**
     * @alias ProtoBuf.Reflect
     * @expose
     */
    ProtoBuf.Reflect = function (ProtoBuf) {
        "use strict";

        /**
         * Reflection types.
         * @exports ProtoBuf.Reflect
         * @namespace
         */

        var Reflect = {};

        /**
         * Constructs a Reflect base class.
         * @exports ProtoBuf.Reflect.T
         * @constructor
         * @abstract
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         */
        var T = function T(builder, parent, name) {

            /**
             * Builder reference.
             * @type {!ProtoBuf.Builder}
             * @expose
             */
            this.builder = builder;

            /**
             * Parent object.
             * @type {?ProtoBuf.Reflect.T}
             * @expose
             */
            this.parent = parent;

            /**
             * Object name in namespace.
             * @type {string}
             * @expose
             */
            this.name = name;

            /**
             * Fully qualified class name
             * @type {string}
             * @expose
             */
            this.className;
        };

        /**
         * @alias ProtoBuf.Reflect.T.prototype
         * @inner
         */
        var TPrototype = T.prototype;

        /**
         * Returns the fully qualified name of this object.
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
         * @expose
         */
        TPrototype.fqn = function () {
            var name = this.name,
                ptr = this;
            do {
                ptr = ptr.parent;
                if (ptr == null) break;
                name = ptr.name + "." + name;
            } while (true);
            return name;
        };

        /**
         * Returns a string representation of this Reflect object (its fully qualified name).
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
         * @return String representation
         * @expose
         */
        TPrototype.toString = function (includeClass) {
            return (includeClass ? this.className + " " : "") + this.fqn();
        };

        /**
         * Builds this type.
         * @throws {Error} If this type cannot be built directly
         * @expose
         */
        TPrototype.build = function () {
            throw Error(this.toString(true) + " cannot be built directly");
        };

        /**
         * @alias ProtoBuf.Reflect.T
         * @expose
         */
        Reflect.T = T;

        /**
         * Constructs a new Namespace.
         * @exports ProtoBuf.Reflect.Namespace
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
         * @param {string} name Namespace name
         * @param {Object.<string,*>=} options Namespace options
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Namespace = function Namespace(builder, parent, name, options, syntax) {
            T.call(this, builder, parent, name);

            /**
             * @override
             */
            this.className = "Namespace";

            /**
             * Children inside the namespace.
             * @type {!Array.<ProtoBuf.Reflect.T>}
             */
            this.children = [];

            /**
             * Options.
             * @type {!Object.<string, *>}
             */
            this.options = options || {};

            /**
             * Syntax level (e.g., proto2 or proto3).
             * @type {!string}
             */
            this.syntax = syntax || "proto2";
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace.prototype
         * @inner
         */
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

        /**
         * Returns an array of the namespace's children.
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}
         * @expose
         */
        NamespacePrototype.getChildren = function (type) {
            type = type || null;
            if (type == null) return this.children.slice();
            var children = [];
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i] instanceof type) children.push(this.children[i]);
            }return children;
        };

        /**
         * Adds a child to the namespace.
         * @param {ProtoBuf.Reflect.T} child Child
         * @throws {Error} If the child cannot be added (duplicate)
         * @expose
         */
        NamespacePrototype.addChild = function (child) {
            var other;
            if (other = this.getChild(child.name)) {
                // Try to revert camelcase transformation on collision
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null) other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null) child.name = child.originalName;else throw Error("Duplicate name in namespace " + this.toString(true) + ": " + child.name);
            }
            this.children.push(child);
        };

        /**
         * Gets a child by its name or id.
         * @param {string|number} nameOrId Child name or id
         * @return {?ProtoBuf.Reflect.T} The child or null if not found
         * @expose
         */
        NamespacePrototype.getChild = function (nameOrId) {
            var key = typeof nameOrId === 'number' ? 'id' : 'name';
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i][key] === nameOrId) return this.children[i];
            }return null;
        };

        /**
         * Resolves a reflect object inside of this namespace.
         * @param {string|!Array.<string>} qn Qualified name to resolve
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
         * @expose
         */
        NamespacePrototype.resolve = function (qn, excludeNonNamespace) {
            var part = typeof qn === 'string' ? qn.split(".") : qn,
                ptr = this,
                i = 0;
            if (part[i] === "") {
                // Fully qualified name, e.g. ".My.Message'
                while (ptr.parent !== null) {
                    ptr = ptr.parent;
                }i++;
            }
            var child;
            do {
                do {
                    if (!(ptr instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    child = ptr.getChild(part[i]);
                    if (!child || !(child instanceof Reflect.T) || excludeNonNamespace && !(child instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    ptr = child;i++;
                } while (i < part.length);
                if (ptr != null) break; // Found
                // Else search the parent
                if (this.parent !== null) return this.parent.resolve(qn, excludeNonNamespace);
            } while (ptr != null);
            return ptr;
        };

        /**
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
         * @param {!ProtoBuf.Reflect.T} t Reflection type
         * @returns {string} The shortest qualified name or, if there is none, the fqn
         * @expose
         */
        NamespacePrototype.qn = function (t) {
            var part = [],
                ptr = t;
            do {
                part.unshift(ptr.name);
                ptr = ptr.parent;
            } while (ptr !== null);
            for (var len = 1; len <= part.length; len++) {
                var qn = part.slice(part.length - len);
                if (t === this.resolve(qn, t instanceof Reflect.Namespace)) return qn.join(".");
            }
            return t.fqn();
        };

        /**
         * Builds the namespace and returns the runtime counterpart.
         * @return {Object.<string,Function|Object>} Runtime namespace
         * @expose
         */
        NamespacePrototype.build = function () {
            /** @dict */
            var ns = {};
            var children = this.children;
            for (var i = 0, k = children.length, child; i < k; ++i) {
                child = children[i];
                if (child instanceof Namespace) ns[child.name] = child.build();
            }
            if (Object.defineProperty) Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
            return ns;
        };

        /**
         * Builds the namespace's '$options' property.
         * @return {Object.<string,*>}
         */
        NamespacePrototype.buildOpt = function () {
            var opt = {},
                keys = Object.keys(this.options);
            for (var i = 0, k = keys.length; i < k; ++i) {
                var key = keys[i],
                    val = this.options[keys[i]];
                // TODO: Options are not resolved, yet.
                // if (val instanceof Namespace) {
                //     opt[key] = val.build();
                // } else {
                opt[key] = val;
                // }
            }
            return opt;
        };

        /**
         * Gets the value assigned to the option with the specified name.
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
         */
        NamespacePrototype.getOption = function (name) {
            if (typeof name === 'undefined') return this.options;
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace
         * @expose
         */
        Reflect.Namespace = Namespace;

        /**
         * Constructs a new Element implementation that checks and converts values for a
         * particular field type, as appropriate.
         *
         * An Element represents a single value: either the value of a singular field,
         * or a value contained in one entry of a repeated field or map field. This
         * class does not implement these higher-level concepts; it only encapsulates
         * the low-level typechecking and conversion.
         *
         * @exports ProtoBuf.Reflect.Element
         * @param {{name: string, wireType: number}} type Resolved data type
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
         * (e.g. submessage field).
         * @param {boolean} isMapKey Is this element a Map key? The value will be
         * converted to string form if so.
         * @param {string} syntax Syntax level of defining message type, e.g.,
         * proto2 or proto3.
         * @param {string} name Name of the field containing this element (for error
         * messages)
         * @constructor
         */
        var Element = function Element(type, resolvedType, isMapKey, syntax, name) {

            /**
             * Element type, as a string (e.g., int32).
             * @type {{name: string, wireType: number}}
             */
            this.type = type;

            /**
             * Element type reference to submessage or enum definition, if needed.
             * @type {ProtoBuf.Reflect.T|null}
             */
            this.resolvedType = resolvedType;

            /**
             * Element is a map key.
             * @type {boolean}
             */
            this.isMapKey = isMapKey;

            /**
             * Syntax level of defining message type, e.g., proto2 or proto3.
             * @type {string}
             */
            this.syntax = syntax;

            /**
             * Name of the field containing this element (for error messages)
             * @type {string}
             */
            this.name = name;

            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0) throw Error("Invalid map key type: " + type.name);
        };

        var ElementPrototype = Element.prototype;

        /**
         * Obtains a (new) default value for the specified type.
         * @param type {string|{name: string, wireType: number}} Field type
         * @returns {*} Default value
         * @inner
         */
        function mkDefault(type) {
            if (typeof type === 'string') type = ProtoBuf.TYPES[type];
            if (typeof type.defaultValue === 'undefined') throw Error("default value for type " + type.name + " is not supported");
            if (type == ProtoBuf.TYPES["bytes"]) return new ByteBuffer(0);
            return type.defaultValue;
        }

        /**
         * Returns the default value for this field in proto3.
         * @function
         * @param type {string|{name: string, wireType: number}} the field type
         * @returns {*} Default value
         */
        Element.defaultFieldValue = mkDefault;

        /**
         * Makes a Long from a value.
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers
         * @returns {!Long}
         * @throws {Error} If the value cannot be converted to a Long
         * @inner
         */
        function mkLong(value, unsigned) {
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean' && value.low === value.low && value.high === value.high) return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string') return ProtoBuf.Long.fromString(value, unsigned || false, 10);
            if (typeof value === 'number') return ProtoBuf.Long.fromNumber(value, unsigned || false);
            throw Error("not convertible to Long");
        }

        ElementPrototype.toString = function () {
            return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';
        };

        /**
         * Checks if the given value can be set for an element of this type (singular
         * field or one element of a repeated field or map).
         * @param {*} value Value to check
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be verified for this element slot
         * @expose
         */
        ElementPrototype.verifyValue = function (value) {
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            switch (this.type) {
                // Signed 32bit
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                    // Account for !NaN: value === value
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value > 4294967295 ? value | 0 : value;

                // Unsigned 32bit
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value < 0 ? value >>> 0 : value;

                // Signed 64bit
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, false);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Unsigned 64bit
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, true);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value !== 'boolean') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a boolean");
                    return value;

                // Float
                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    if (typeof value !== 'number') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a number");
                    return value;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    if (typeof value !== 'string' && !(value && value instanceof String)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a string");
                    return "" + value; // Convert String object to string

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (ByteBuffer.isByteBuffer(value)) return value;
                    return ByteBuffer.wrap(value, "base64");

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    {
                        var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
                        for (i = 0; i < values.length; i++) {
                            if (values[i].name == value) return values[i].id;else if (values[i].id == value) return values[i].id;
                        }if (this.syntax === 'proto3') {
                            // proto3: just make sure it's an integer.
                            if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                            if (value > 4294967295 || value < 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not in range for uint32");
                            return value;
                        } else {
                            // proto2 requires enum values to be valid.
                            fail(value, "not a valid enum value");
                        }
                    }
                // Embedded message
                case ProtoBuf.TYPES["group"]:
                case ProtoBuf.TYPES["message"]:
                    {
                        if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== 'object') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "object expected");
                        if (value instanceof this.resolvedType.clazz) return value;
                        if (value instanceof ProtoBuf.Builder.Message) {
                            // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                            var obj = {};
                            for (var i in value) {
                                if (value.hasOwnProperty(i)) obj[i] = value[i];
                            }value = obj;
                        }
                        // Else let's try to construct one from a key-value object
                        return new this.resolvedType.clazz(value); // May throw for a hundred of reasons
                    }
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal value for " + this.toString(true) + ": " + value + " (undefined type " + this.type + ")");
        };

        /**
         * Calculates the byte length of an element on the wire.
         * @param {number} id Field number
         * @param {*} value Field value
         * @returns {number} Byte length
         * @throws {Error} If the value cannot be calculated
         * @expose
         */
        ElementPrototype.calculateLength = function (id, value) {
            if (value === null) return 0; // Nothing to encode
            // Tag has already been written
            var n;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["uint32"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["sint32"]:
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                case ProtoBuf.TYPES["fixed32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["float"]:
                    return 4;
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    return ByteBuffer.calculateVarint64(value);
                case ProtoBuf.TYPES["sint64"]:
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                case ProtoBuf.TYPES["fixed64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    return 8;
                case ProtoBuf.TYPES["bool"]:
                    return 1;
                case ProtoBuf.TYPES["enum"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["double"]:
                    return 8;
                case ProtoBuf.TYPES["string"]:
                    n = ByteBuffer.calculateUTF8Bytes(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                case ProtoBuf.TYPES["message"]:
                    n = this.resolvedType.calculate(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["group"]:
                    n = this.resolvedType.calculate(value);
                    return n + ByteBuffer.calculateVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
            }
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
        };

        /**
         * Encodes a value to the specified buffer. Does not encode the key.
         * @param {number} id Field number
         * @param {*} value Field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the value cannot be encoded
         * @expose
         */
        ElementPrototype.encodeValue = function (id, value, buffer) {
            if (value === null) return buffer; // Nothing to encode
            // Tag has already been written

            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long – it is, effectively, treated like a very large unsigned integer." (see #122)
                    if (value < 0) buffer.writeVarint64(value);else buffer.writeVarint32(value);
                    break;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    buffer.writeVarint32ZigZag(value);
                    break;

                // Fixed unsigned 32bit
                case ProtoBuf.TYPES["fixed32"]:
                    buffer.writeUint32(value);
                    break;

                // Fixed signed 32bit
                case ProtoBuf.TYPES["sfixed32"]:
                    buffer.writeInt32(value);
                    break;

                // 64bit varint as-is
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    buffer.writeVarint64(value); // throws
                    break;

                // 64bit varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    buffer.writeVarint64ZigZag(value); // throws
                    break;

                // Fixed unsigned 64bit
                case ProtoBuf.TYPES["fixed64"]:
                    buffer.writeUint64(value); // throws
                    break;

                // Fixed signed 64bit
                case ProtoBuf.TYPES["sfixed64"]:
                    buffer.writeInt64(value); // throws
                    break;

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value === 'string') buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);else buffer.writeVarint32(value ? 1 : 0);
                    break;

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    buffer.writeFloat32(value);
                    break;

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    buffer.writeFloat64(value);
                    break;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    buffer.writeVString(value);
                    break;

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    var prevOffset = value.offset;
                    buffer.writeVarint32(value.remaining());
                    buffer.append(value);
                    value.offset = prevOffset;
                    break;

                // Embedded message
                case ProtoBuf.TYPES["message"]:
                    var bb = new ByteBuffer().LE();
                    this.resolvedType.encode(value, bb);
                    buffer.writeVarint32(bb.offset);
                    buffer.append(bb.flip());
                    break;

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    this.resolvedType.encode(value, buffer);
                    buffer.writeVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
                    break;

                default:
                    // We should never end here
                    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
            }
            return buffer;
        };

        /**
         * Decode one element value from the specified buffer.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number} wireType The field wire type
         * @param {number} id The field number
         * @return {*} Decoded value
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        ElementPrototype.decode = function (buffer, wireType, id) {
            if (wireType != this.type.wireType) throw Error("Unexpected wire type for element");

            var value, nBytes;
            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    return buffer.readVarint32() | 0;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    return buffer.readVarint32() >>> 0;

                // 32bit signed varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    return buffer.readVarint32ZigZag() | 0;

                // Fixed 32bit unsigned
                case ProtoBuf.TYPES["fixed32"]:
                    return buffer.readUint32() >>> 0;

                case ProtoBuf.TYPES["sfixed32"]:
                    return buffer.readInt32() | 0;

                // 64bit signed varint
                case ProtoBuf.TYPES["int64"]:
                    return buffer.readVarint64();

                // 64bit unsigned varint
                case ProtoBuf.TYPES["uint64"]:
                    return buffer.readVarint64().toUnsigned();

                // 64bit signed varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    return buffer.readVarint64ZigZag();

                // Fixed 64bit unsigned
                case ProtoBuf.TYPES["fixed64"]:
                    return buffer.readUint64();

                // Fixed 64bit signed
                case ProtoBuf.TYPES["sfixed64"]:
                    return buffer.readInt64();

                // Bool varint
                case ProtoBuf.TYPES["bool"]:
                    return !!buffer.readVarint32();

                // Constant enum value (varint)
                case ProtoBuf.TYPES["enum"]:
                    // The following Builder.Message#set will already throw
                    return buffer.readVarint32();

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    return buffer.readFloat();

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    return buffer.readDouble();

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    return buffer.readVString();

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset + nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                // Length-delimited embedded message
                case ProtoBuf.TYPES["message"]:
                    {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    return this.resolvedType.decode(buffer, -1, id);
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal decode type");
        };

        /**
         * Converts a value from a string to the canonical element type.
         *
         * Legal only when isMapKey is true.
         *
         * @param {string} str The string value
         * @returns {*} The value
         */
        ElementPrototype.valueFromString = function (str) {
            if (!this.isMapKey) {
                throw Error("valueFromString() called on non-map-key element");
            }

            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return this.verifyValue(parseInt(str));

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    // Long-based fields support conversions from string already.
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bool"]:
                    return str === "true";

                case ProtoBuf.TYPES["string"]:
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bytes"]:
                    return ByteBuffer.fromBinary(str);
            }
        };

        /**
         * Converts a value from the canonical element type to a string.
         *
         * It should be the case that `valueFromString(valueToString(val))` returns
         * a value equivalent to `verifyValue(val)` for every legal value of `val`
         * according to this element type.
         *
         * This may be used when the element must be stored or used as a string,
         * e.g., as a map key on an Object.
         *
         * Legal only when isMapKey is true.
         *
         * @param {*} val The value
         * @returns {string} The string form of the value.
         */
        ElementPrototype.valueToString = function (value) {
            if (!this.isMapKey) {
                throw Error("valueToString() called on non-map-key element");
            }

            if (this.type === ProtoBuf.TYPES["bytes"]) {
                return value.toString("binary");
            } else {
                return value.toString();
            }
        };

        /**
         * @alias ProtoBuf.Reflect.Element
         * @expose
         */
        Reflect.Element = Element;

        /**
         * Constructs a new Message.
         * @exports ProtoBuf.Reflect.Message
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
         * @param {string} name Message name
         * @param {Object.<string,*>=} options Message options
         * @param {boolean=} isGroup `true` if this is a legacy group
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Message = function Message(builder, parent, name, options, isGroup, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Message";

            /**
             * Extensions range.
             * @type {!Array.<number>|undefined}
             * @expose
             */
            this.extensions = undefined;

            /**
             * Runtime message class.
             * @type {?function(new:ProtoBuf.Builder.Message)}
             * @expose
             */
            this.clazz = null;

            /**
             * Whether this is a legacy group or not.
             * @type {boolean}
             * @expose
             */
            this.isGroup = !!isGroup;

            // The following cached collections are used to efficiently iterate over or look up fields when decoding.

            /**
             * Cached fields.
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fields = null;

            /**
             * Cached fields by id.
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsById = null;

            /**
             * Cached fields by name.
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsByName = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Message.prototype
         * @inner
         */
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the message and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Message
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
         * @return {ProtoBuf.Reflect.Message} Message class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        MessagePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Message class in its own scope
            var clazz = function (ProtoBuf, T) {

                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

                /**
                 * Constructs a new runtime Message.
                 * @name ProtoBuf.Builder.Message
                 * @class Barebone of all runtime messages.
                 * @param {!Object.<string,*>|string} values Preset values
                 * @param {...string} var_args
                 * @constructor
                 * @throws {Error} If the message cannot be created
                 */
                var Message = function Message(values, var_args) {
                    ProtoBuf.Builder.Message.call(this);

                    // Create virtual oneof properties
                    for (var i = 0, k = oneofs.length; i < k; ++i) {
                        this[oneofs[i].name] = null;
                    } // Create fields and set default values
                    for (i = 0, k = fields.length; i < k; ++i) {
                        var field = fields[i];
                        this[field.name] = field.repeated ? [] : field.map ? new ProtoBuf.Map(field) : null;
                        if ((field.required || T.syntax === 'proto3') && field.defaultValue !== null) this[field.name] = field.defaultValue;
                    }

                    if (arguments.length > 0) {
                        var value;
                        // Set field values from a values object
                        if (arguments.length === 1 && values !== null && (typeof values === "undefined" ? "undefined" : _typeof(values)) === 'object' && (
                        /* not _another_ Message */typeof values.encode !== 'function' || values instanceof Message) &&
                        /* not a repeated field */!Array.isArray(values) &&
                        /* not a Map */!(values instanceof ProtoBuf.Map) &&
                        /* not a ByteBuffer */!ByteBuffer.isByteBuffer(values) &&
                        /* not an ArrayBuffer */!(values instanceof ArrayBuffer) &&
                        /* not a Long */!(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            this.$set(values);
                        } else // Set field values from arguments, in declaration order
                            for (i = 0, k = arguments.length; i < k; ++i) {
                                if (typeof (value = arguments[i]) !== 'undefined') this.$set(fields[i].name, value);
                            } // May throw
                    }
                };

                /**
                 * @alias ProtoBuf.Builder.Message.prototype
                 * @inner
                 */
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                /**
                 * Adds a value to a repeated field.
                 * @name ProtoBuf.Builder.Message#add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.add = function (key, value, noAssert) {
                    var field = T._fieldsByName[key];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + key + " is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated) throw Error(this + "#" + key + " is not a repeated field");
                        value = field.verifyValue(value, true);
                    }
                    if (this[key] === null) this[key] = [];
                    this[key].push(value);
                    return this;
                };

                /**
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                 * @name ProtoBuf.Builder.Message#$add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.$add = MessagePrototype.add;

                /**
                 * Sets a field's value.
                 * @name ProtoBuf.Builder.Message#set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.set = function (keyOrObj, value, noAssert) {
                    if (keyOrObj && (typeof keyOrObj === "undefined" ? "undefined" : _typeof(keyOrObj)) === 'object') {
                        noAssert = value;
                        for (var ikey in keyOrObj) {
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined') this.$set(ikey, value, noAssert);
                        }return this;
                    }
                    var field = T._fieldsByName[keyOrObj];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + keyOrObj + " is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + keyOrObj + " is not a field: " + field.toString(true));
                        this[field.name] = value = field.verifyValue(value); // May throw
                    } else this[keyOrObj] = value;
                    if (field && field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
                        if (value !== null) {
                            if (currentField !== null && currentField !== field.name) this[currentField] = null; // Clear currently set field
                            this[field.oneof.name] = field.name; // Point virtual field at this field
                        } else if ( /* value === null && */currentField === keyOrObj) this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
                    }
                    return this;
                };

                /**
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                 * @name ProtoBuf.Builder.Message#$set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.$set = MessagePrototype.set;

                /**
                 * Gets a field's value.
                 * @name ProtoBuf.Builder.Message#get
                 * @function
                 * @param {string} key Key
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.get = function (key, noAssert) {
                    if (noAssert) return this[key];
                    var field = T._fieldsByName[key];
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: undefined");
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true));
                    return this[field.name];
                };

                /**
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                 * @name ProtoBuf.Builder.Message#$get
                 * @function
                 * @param {string} key Key
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.$get = MessagePrototype.get;

                // Getters and setters

                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    // no setters for extension fields as these are named by their fqn
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField) continue;

                    if (T.builder.options['populateAccessors']) (function (field) {
                        // set/get[SomeValue]
                        var Name = field.originalName.replace(/(_[a-zA-Z])/g, function (match) {
                            return match.toUpperCase().replace('_', '');
                        });
                        Name = Name.substring(0, 1).toUpperCase() + Name.substring(1);

                        // set/get_[some_value] FIXME: Do we really need these?
                        var name = field.originalName.replace(/([A-Z])/g, function (match) {
                            return "_" + match;
                        });

                        /**
                         * The current field's unbound setter function.
                         * @function
                         * @param {*} value
                         * @param {boolean=} noAssert
                         * @returns {!ProtoBuf.Builder.Message}
                         * @inner
                         */
                        var setter = function setter(value, noAssert) {
                            this[field.name] = noAssert ? value : field.verifyValue(value);
                            return this;
                        };

                        /**
                         * The current field's unbound getter function.
                         * @function
                         * @returns {*}
                         * @inner
                         */
                        var getter = function getter() {
                            return this[field.name];
                        };

                        if (T.getChild("set" + Name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set" + Name] = setter;

                        if (T.getChild("set_" + name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set_" + name] = setter;

                        if (T.getChild("get" + Name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            MessagePrototype["get" + Name] = getter;

                        if (T.getChild("get_" + name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            MessagePrototype["get_" + name] = getter;
                    })(field);
                }

                // En-/decoding

                /**
                 * Encodes the message.
                 * @name ProtoBuf.Builder.Message#$encode
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message#encode64
                 * @see ProtoBuf.Builder.Message#encodeHex
                 * @see ProtoBuf.Builder.Message#encodeAB
                 */
                MessagePrototype.encode = function (buffer, noVerify) {
                    if (typeof buffer === 'boolean') noVerify = buffer, buffer = undefined;
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var le = buffer.littleEndian;
                    try {
                        T.encode(this, buffer.LE(), noVerify);
                        return (isNew ? buffer.flip() : buffer).LE(le);
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Encodes a message using the specified data payload.
                 * @param {!Object.<string,*>} data Data payload
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @expose
                 */
                Message.encode = function (data, buffer, noVerify) {
                    return new Message(data).encode(buffer, noVerify);
                };

                /**
                 * Calculates the byte length of the message.
                 * @name ProtoBuf.Builder.Message#calculate
                 * @function
                 * @returns {number} Byte length
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
                 * @expose
                 */
                MessagePrototype.calculate = function () {
                    return T.calculate(this);
                };

                /**
                 * Encodes the varint32 length-delimited message.
                 * @name ProtoBuf.Builder.Message#encodeDelimited
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeDelimited = function (buffer, noVerify) {
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var enc = new ByteBuffer().LE();
                    T.encode(this, enc, noVerify).flip();
                    buffer.writeVarint32(enc.remaining());
                    buffer.append(enc);
                    return isNew ? buffer.flip() : buffer;
                };

                /**
                 * Directly encodes the message to an ArrayBuffer.
                 * @name ProtoBuf.Builder.Message#encodeAB
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeAB = function () {
                    try {
                        return this.encode().toArrayBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

                /**
                 * Directly encodes the message to a node Buffer.
                 * @name ProtoBuf.Builder.Message#encodeNB
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeNB = function () {
                    try {
                        return this.encode().toBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;

                /**
                 * Directly encodes the message to a base64 encoded string.
                 * @name ProtoBuf.Builder.Message#encode64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encode64 = function () {
                    try {
                        return this.encode().toBase64();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBase64 = MessagePrototype.encode64;

                /**
                 * Directly encodes the message to a hex encoded string.
                 * @name ProtoBuf.Builder.Message#encodeHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeHex = function () {
                    try {
                        return this.encode().toHex();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toHex = MessagePrototype.encodeHex;

                /**
                 * Clones a message object or field value to a raw object.
                 * @param {*} obj Object to clone
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
                 * @returns {*} Cloned object
                 * @inner
                 */
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
                    if (obj === null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== 'object') {
                        // Convert enum values to their respective names
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
                            if (name !== null) return name;
                        }
                        // Pass-through string, number, boolean, null...
                        return obj;
                    }
                    // Convert ByteBuffers to raw buffer or strings
                    if (ByteBuffer.isByteBuffer(obj)) return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
                    // Convert Longs to proper objects or strings
                    if (ProtoBuf.Long.isLong(obj)) return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
                    var clone;
                    // Clone arrays
                    if (Array.isArray(obj)) {
                        clone = [];
                        obj.forEach(function (v, k) {
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                        });
                        return clone;
                    }
                    clone = {};
                    // Convert maps to objects
                    if (obj instanceof ProtoBuf.Map) {
                        var it = obj.entries();
                        for (var e = it.next(); !e.done; e = it.next()) {
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        }return clone;
                    }
                    // Everything else is a non-null object
                    var type = obj.$type,
                        field = undefined;
                    for (var i in obj) {
                        if (obj.hasOwnProperty(i)) {
                            if (type && (field = type.getChild(i))) clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);else clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
                        }
                    }return clone;
                }

                /**
                 * Returns the message's raw payload.
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @returns {Object.<string,*>} Raw payload
                 * @expose
                 */
                MessagePrototype.toRaw = function (binaryAsBase64, longsAsStrings) {
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                };

                /**
                 * Encodes a message to JSON.
                 * @returns {string} JSON string
                 * @expose
                 */
                MessagePrototype.encodeJSON = function () {
                    return JSON.stringify(cloneRaw(this,
                    /* binary-as-base64 */true,
                    /* longs-as-strings */true, this.$type));
                };

                /**
                 * Decodes a message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decode
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message.decode64
                 * @see ProtoBuf.Builder.Message.decodeHex
                 */
                Message.decode = function (buffer, length, enc) {
                    if (typeof length === 'string') enc = length, length = -1;
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    var le = buffer.littleEndian;
                    try {
                        var msg = T.decode(buffer.LE(), length);
                        buffer.LE(le);
                        return msg;
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Decodes a varint32 length-delimited message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decodeDelimited
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeDelimited = function (buffer, enc) {
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    if (buffer.remaining() < 1) return null;
                    var off = buffer.offset,
                        len = buffer.readVarint32();
                    if (buffer.remaining() < len) {
                        buffer.offset = off;
                        return null;
                    }
                    try {
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    } catch (err) {
                        buffer.offset += len;
                        throw err;
                    }
                };

                /**
                 * Decodes the message from the specified base64 encoded string.
                 * @name ProtoBuf.Builder.Message.decode64
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decode64 = function (str) {
                    return Message.decode(str, "base64");
                };

                /**
                 * Decodes the message from the specified hex encoded string.
                 * @name ProtoBuf.Builder.Message.decodeHex
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeHex = function (str) {
                    return Message.decode(str, "hex");
                };

                /**
                 * Decodes the message from a JSON string.
                 * @name ProtoBuf.Builder.Message.decodeJSON
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are
                 * missing.
                 * @expose
                 */
                Message.decodeJSON = function (str) {
                    return new Message(JSON.parse(str));
                };

                // Utility

                /**
                 * Returns a string representation of this Message.
                 * @name ProtoBuf.Builder.Message#toString
                 * @function
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
                 * @expose
                 */
                MessagePrototype.toString = function () {
                    return T.toString();
                };

                // Properties

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message.$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message#$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Message, '$options', { "value": T.buildOpt() }), Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }), Object.defineProperty(Message, "$type", { "value": T }), Object.defineProperty(MessagePrototype, "$type", { "value": T });

                return Message;
            }(ProtoBuf, this);

            // Static enums and prototyped sub-messages / cached collections
            this._fields = [];
            this._fieldsById = {};
            this._fieldsByName = {};
            for (var i = 0, k = this.children.length, child; i < k; i++) {
                child = this.children[i];
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                    if (clazz.hasOwnProperty(child.name)) throw Error("Illegal reflect child of " + this.toString(true) + ": " + child.toString(true) + " cannot override static property '" + child.name + "'");
                    clazz[child.name] = child.build();
                } else if (child instanceof Message.Field) child.build(), this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child;else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
                    throw Error("Illegal reflect child of " + this.toString(true) + ": " + this.children[i].toString(true));
            }

            return this.clazz = clazz;
        };

        /**
         * Encodes a runtime message's contents to the specified buffer.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @param {ByteBuffer} buffer ByteBuffer to write to
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
         * @expose
         */
        MessagePrototype.encode = function (message, buffer, noVerify) {
            var fieldMissing = null,
                field;
            for (var i = 0, k = this._fields.length, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) {
                    if (fieldMissing === null) fieldMissing = field;
                } else field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
            }
            if (fieldMissing !== null) {
                var err = Error("Missing at least one required field for " + this.toString(true) + ": " + fieldMissing);
                err["encoded"] = buffer; // Still expose what we got
                throw err;
            }
            return buffer;
        };

        /**
         * Calculates a runtime message's byte length.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @returns {number} Byte length
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
         * @expose
         */
        MessagePrototype.calculate = function (message) {
            for (var n = 0, i = 0, k = this._fields.length, field, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) throw Error("Missing at least one required field for " + this.toString(true) + ": " + field);else n += field.calculate(val, message);
            }
            return n;
        };

        /**
         * Skips all data until the end of the specified group has been reached.
         * @param {number} expectedId Expected GROUPEND id
         * @param {!ByteBuffer} buf ByteBuffer
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
         * @inner
         */
        function skipTillGroupEnd(expectedId, buf) {
            var tag = buf.readVarint32(),
                // Throws on OOB
            wireType = tag & 0x07,
                id = tag >>> 3;
            switch (wireType) {
                case ProtoBuf.WIRE_TYPES.VARINT:
                    do {
                        tag = buf.readUint8();
                    } while ((tag & 0x80) === 0x80);
                    break;
                case ProtoBuf.WIRE_TYPES.BITS64:
                    buf.offset += 8;
                    break;
                case ProtoBuf.WIRE_TYPES.LDELIM:
                    tag = buf.readVarint32(); // reads the varint
                    buf.offset += tag; // skips n bytes
                    break;
                case ProtoBuf.WIRE_TYPES.STARTGROUP:
                    skipTillGroupEnd(id, buf);
                    break;
                case ProtoBuf.WIRE_TYPES.ENDGROUP:
                    if (id === expectedId) return false;else throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");
                case ProtoBuf.WIRE_TYPES.BITS32:
                    buf.offset += 4;
                    break;
                default:
                    throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
            }
            return true;
        }

        /**
         * Decodes an encoded message and returns the decoded message.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number=} length Message length. Defaults to decode all remaining data.
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
         * @return {ProtoBuf.Builder.Message} Decoded message
         * @throws {Error} If the message cannot be decoded
         * @expose
         */
        MessagePrototype.decode = function (buffer, length, expectedGroupEndId) {
            if (typeof length !== 'number') length = -1;
            var start = buffer.offset,
                msg = new this.clazz(),
                tag,
                wireType,
                id,
                field;
            while (buffer.offset < start + length || length === -1 && buffer.remaining() > 0) {
                tag = buffer.readVarint32();
                wireType = tag & 0x07;
                id = tag >>> 3;
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                    if (id !== expectedGroupEndId) throw Error("Illegal group end indicator for " + this.toString(true) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
                    break;
                }
                if (!(field = this._fieldsById[id])) {
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {
                        case ProtoBuf.WIRE_TYPES.VARINT:
                            buffer.readVarint32();
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS32:
                            buffer.offset += 4;
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS64:
                            buffer.offset += 8;
                            break;
                        case ProtoBuf.WIRE_TYPES.LDELIM:
                            var len = buffer.readVarint32();
                            buffer.offset += len;
                            break;
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            while (skipTillGroupEnd(id, buffer)) {}
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(true) + "#decode: " + wireType);
                    }
                    continue;
                }
                if (field.repeated && !field.options["packed"]) {
                    msg[field.name].push(field.decode(wireType, buffer));
                } else if (field.map) {
                    var keyval = field.decode(wireType, buffer);
                    msg[field.name].set(keyval[0], keyval[1]);
                } else {
                    msg[field.name] = field.decode(wireType, buffer);
                    if (field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
                        if (currentField !== null && currentField !== field.name) msg[currentField] = null; // Clear currently set field
                        msg[field.oneof.name] = field.name; // Point virtual field at this field
                    }
                }
            }

            // Check if all required fields are present and set default values for optional fields that are not
            for (var i = 0, k = this._fields.length; i < k; ++i) {
                field = this._fields[i];
                if (msg[field.name] === null) {
                    if (this.syntax === "proto3") {
                        // Proto3 sets default values by specification
                        msg[field.name] = field.defaultValue;
                    } else if (field.required) {
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got
                        throw err;
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null) msg[field.name] = field.defaultValue;
                }
            }
            return msg;
        };

        /**
         * @alias ProtoBuf.Reflect.Message
         * @expose
         */
        Reflect.Message = Message;

        /**
         * Constructs a new Message Field.
         * @exports ProtoBuf.Reflect.Message.Field
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string?} keytype Key data type, if any.
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {Object.<string,*>=} options Options
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Field = function Field(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
            T.call(this, builder, message, name);

            /**
             * @override
             */
            this.className = "Message.Field";

            /**
             * Message field required flag.
             * @type {boolean}
             * @expose
             */
            this.required = rule === "required";

            /**
             * Message field repeated flag.
             * @type {boolean}
             * @expose
             */
            this.repeated = rule === "repeated";

            /**
             * Message field map flag.
             * @type {boolean}
             * @expose
             */
            this.map = rule === "map";

            /**
             * Message field key type. Type reference string if unresolved, protobuf
             * type if resolved. Valid only if this.map === true, null otherwise.
             * @type {string|{name: string, wireType: number}|null}
             * @expose
             */
            this.keyType = keytype || null;

            /**
             * Message field type. Type reference string if unresolved, protobuf type if
             * resolved. In a map field, this is the value type.
             * @type {string|{name: string, wireType: number}}
             * @expose
             */
            this.type = type;

            /**
             * Resolved type reference inside the global namespace.
             * @type {ProtoBuf.Reflect.T|null}
             * @expose
             */
            this.resolvedType = null;

            /**
             * Unique message field id.
             * @type {number}
             * @expose
             */
            this.id = id;

            /**
             * Message field options.
             * @type {!Object.<string,*>}
             * @dict
             * @expose
             */
            this.options = options || {};

            /**
             * Default value.
             * @type {*}
             * @expose
             */
            this.defaultValue = null;

            /**
             * Enclosing OneOf.
             * @type {?ProtoBuf.Reflect.Message.OneOf}
             * @expose
             */
            this.oneof = oneof || null;

            /**
             * Syntax level of this definition (e.g., proto3).
             * @type {string}
             * @expose
             */
            this.syntax = syntax || 'proto2';

            /**
             * Original field name.
             * @type {string}
             * @expose
             */
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

            /**
             * Element implementation. Created in build() after types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.element = null;

            /**
             * Key element implementation, for map fields. Created in build() after
             * types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.keyElement = null;

            // Convert field names to camel case notation if the override is set
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField)) this.name = ProtoBuf.Util.toCamelCase(this.name);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field.prototype
         * @inner
         */
        var FieldPrototype = Field.prototype = Object.create(T.prototype);

        /**
         * Builds the field.
         * @override
         * @expose
         */
        FieldPrototype.build = function () {
            this.element = new Element(this.type, this.resolvedType, false, this.syntax, this.name);
            if (this.map) this.keyElement = new Element(this.keyType, undefined, true, this.syntax, this.name);

            // In proto3, fields do not have field presence, and every field is set to
            // its type's default value ("", 0, 0.0, or false).
            if (this.syntax === 'proto3' && !this.repeated && !this.map) this.defaultValue = Element.defaultFieldValue(this.type);

            // Otherwise, default values are present when explicitly specified
            else if (typeof this.options['default'] !== 'undefined') this.defaultValue = this.verifyValue(this.options['default']);
        };

        /**
         * Checks if the given value can be set for this field.
         * @param {*} value Value to check
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be set for this field
         * @expose
         */
        FieldPrototype.verifyValue = function (value, skipRepeated) {
            skipRepeated = skipRepeated || false;
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            if (value === null) {
                // NULL values for optional fields
                if (this.required) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "required");
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"]) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "proto3 field without field presence cannot be null");
                return null;
            }
            var i;
            if (this.repeated && !skipRepeated) {
                // Repeated values as arrays
                if (!Array.isArray(value)) value = [value];
                var res = [];
                for (i = 0; i < value.length; i++) {
                    res.push(this.element.verifyValue(value[i]));
                }return res;
            }
            if (this.map && !skipRepeated) {
                // Map values as objects
                if (!(value instanceof ProtoBuf.Map)) {
                    // If not already a Map, attempt to convert.
                    if (!(value instanceof Object)) {
                        fail(typeof value === "undefined" ? "undefined" : _typeof(value), "expected ProtoBuf.Map or raw object for map field");
                    }
                    return new ProtoBuf.Map(this, value);
                } else {
                    return value;
                }
            }
            // All non-repeated fields expect no array
            if (!this.repeated && Array.isArray(value)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "no array expected");

            return this.element.verifyValue(value);
        };

        /**
         * Determines whether the field will have a presence on the wire given its
         * value.
         * @param {*} value Verified field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {boolean} Whether the field will be present on the wire
         */
        FieldPrototype.hasWirePresence = function (value, message) {
            if (this.syntax !== 'proto3') return value !== null;
            if (this.oneof && message[this.oneof.name] === this.name) return true;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return value !== 0;

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    return value.low !== 0 || value.high !== 0;

                case ProtoBuf.TYPES["bool"]:
                    return value;

                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    return value !== 0.0;

                case ProtoBuf.TYPES["string"]:
                    return value.length > 0;

                case ProtoBuf.TYPES["bytes"]:
                    return value.remaining() > 0;

                case ProtoBuf.TYPES["enum"]:
                    return value !== 0;

                case ProtoBuf.TYPES["message"]:
                    return value !== null;
                default:
                    return true;
            }
        };

        /**
         * Encodes the specified field value to the specified buffer.
         * @param {*} value Verified field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the field cannot be encoded
         * @expose
         */
        FieldPrototype.encode = function (value, buffer, message) {
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return buffer; // Optional omitted
            try {
                if (this.repeated) {
                    var i;
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin
                        for (i = 0; i < value.length; i++) {
                            this.element.encodeValue(this.id, value[i], buffer);
                        }var len = buffer.offset - start,
                            varintLen = ByteBuffer.calculateVarint32(len);
                        if (varintLen > 1) {
                            // We need to move the contents
                            var contents = buffer.slice(start, buffer.offset);
                            start += varintLen - 1;
                            buffer.offset = start;
                            buffer.append(contents);
                        }
                        buffer.writeVarint32(len, start - varintLen);
                    } else {
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"
                        for (i = 0; i < value.length; i++) {
                            buffer.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, value[i], buffer);
                        }
                    }
                } else if (this.map) {
                    // Write out each map entry as a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        // Submessage with wire type of length-delimited.
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.writeVarint32(length);

                        // Write out the key and val.
                        buffer.writeVarint32(1 << 3 | this.keyType.wireType);
                        this.keyElement.encodeValue(1, key, buffer);
                        buffer.writeVarint32(2 << 3 | this.type.wireType);
                        this.element.encodeValue(2, val, buffer);
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        buffer.writeVarint32(this.id << 3 | this.type.wireType);
                        this.element.encodeValue(this.id, value, buffer);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return buffer;
        };

        /**
         * Calculates the length of this field's value on the network level.
         * @param {*} value Field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @returns {number} Byte length
         * @expose
         */
        FieldPrototype.calculate = function (value, message) {
            value = this.verifyValue(value); // May throw
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return 0; // Optional omitted
            var n = 0;
            try {
                if (this.repeated) {
                    var i, ni;
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        ni = 0;
                        for (i = 0; i < value.length; i++) {
                            ni += this.element.calculateLength(this.id, value[i]);
                        }n += ByteBuffer.calculateVarint32(ni);
                        n += ni;
                    } else {
                        for (i = 0; i < value.length; i++) {
                            n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), n += this.element.calculateLength(this.id, value[i]);
                        }
                    }
                } else if (this.map) {
                    // Each map entry becomes a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        n += ByteBuffer.calculateVarint32(length);
                        n += length;
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType);
                        n += this.element.calculateLength(this.id, value);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return n;
        };

        /**
         * Decode the field value from the specified buffer.
         * @param {number} wireType Leading wire type
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
         *             map fields, or an individual value otherwise.
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        FieldPrototype.decode = function (wireType, buffer, skipRepeated) {
            var value, nBytes;

            // We expect wireType to match the underlying type's wireType unless we see
            // a packed repeated field, or unless this is a map field.
            var wireTypeOK = !this.map && wireType == this.type.wireType || !skipRepeated && this.repeated && this.options["packed"] && wireType == ProtoBuf.WIRE_TYPES.LDELIM || this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM;
            if (!wireTypeOK) throw Error("Illegal wire type for field " + this.toString(true) + ": " + wireType + " (" + this.type.wireType + " expected)");

            // Handle packed repeated fields.
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {
                    nBytes = buffer.readVarint32();
                    nBytes = buffer.offset + nBytes; // Limit
                    var values = [];
                    while (buffer.offset < nBytes) {
                        values.push(this.decode(this.type.wireType, buffer, true));
                    }return values;
                }
                // Read the next value otherwise...
            }

            // Handle maps.
            if (this.map) {
                // Read one (key, value) submessage, and return [key, value]
                var key = Element.defaultFieldValue(this.keyType);
                value = Element.defaultFieldValue(this.type);

                // Read the length
                nBytes = buffer.readVarint32();
                if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());

                // Get a sub-buffer of this key/value submessage
                var msgbuf = buffer.clone();
                msgbuf.limit = msgbuf.offset + nBytes;
                buffer.offset += nBytes;

                while (msgbuf.remaining() > 0) {
                    var tag = msgbuf.readVarint32();
                    wireType = tag & 0x07;
                    var id = tag >>> 3;
                    if (id === 1) {
                        key = this.keyElement.decode(msgbuf, wireType, id);
                    } else if (id === 2) {
                        value = this.element.decode(msgbuf, wireType, id);
                    } else {
                        throw Error("Unexpected tag in map field key/value submessage");
                    }
                }

                return [key, value];
            }

            // Handle singular and non-packed repeated field values.
            return this.element.decode(buffer, wireType, this.id);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field
         * @expose
         */
        Reflect.Message.Field = Field;

        /**
         * Constructs a new Message ExtensionField.
         * @exports ProtoBuf.Reflect.Message.ExtensionField
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {!Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Message.Field
         */
        var ExtensionField = function ExtensionField(builder, message, rule, type, name, id, options) {
            Field.call(this, builder, message, rule, /* keytype = */null, type, name, id, options);

            /**
             * Extension reference.
             * @type {!ProtoBuf.Reflect.Extension}
             * @expose
             */
            this.extension;
        };

        // Extends Field
        ExtensionField.prototype = Object.create(Field.prototype);

        /**
         * @alias ProtoBuf.Reflect.Message.ExtensionField
         * @expose
         */
        Reflect.Message.ExtensionField = ExtensionField;

        /**
         * Constructs a new Message OneOf.
         * @exports ProtoBuf.Reflect.Message.OneOf
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} name OneOf name
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var OneOf = function OneOf(builder, message, name) {
            T.call(this, builder, message, name);

            /**
             * Enclosed fields.
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
             * @expose
             */
            this.fields = [];
        };

        /**
         * @alias ProtoBuf.Reflect.Message.OneOf
         * @expose
         */
        Reflect.Message.OneOf = OneOf;

        /**
         * Constructs a new Enum.
         * @exports ProtoBuf.Reflect.Enum
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
         * @param {string} name Enum name
         * @param {Object.<string,*>=} options Enum options
         * @param {string?} syntax The syntax level (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Enum = function Enum(builder, parent, name, options, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Enum";

            /**
             * Runtime enum object.
             * @type {Object.<string,number>|null}
             * @expose
             */
            this.object = null;
        };

        /**
         * Gets the string name of an enum value.
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
         * @param {number} value Enum value
         * @returns {?string} Name or `null` if not present
         * @expose
         */
        Enum.getName = function (enm, value) {
            var keys = Object.keys(enm);
            for (var i = 0, key; i < keys.length; ++i) {
                if (enm[key = keys[i]] === value) return key;
            }return null;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum.prototype
         * @inner
         */
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);

        /**
         * Builds this enum and returns the runtime counterpart.
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
         * @returns {!Object.<string,number>}
         * @expose
         */
        EnumPrototype.build = function (rebuild) {
            if (this.object && !rebuild) return this.object;
            var enm = new ProtoBuf.Builder.Enum(),
                values = this.getChildren(Enum.Value);
            for (var i = 0, k = values.length; i < k; ++i) {
                enm[values[i]['name']] = values[i]['id'];
            }if (Object.defineProperty) Object.defineProperty(enm, '$options', {
                "value": this.buildOpt(),
                "enumerable": false
            });
            return this.object = enm;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum
         * @expose
         */
        Reflect.Enum = Enum;

        /**
         * Constructs a new Enum Value.
         * @exports ProtoBuf.Reflect.Enum.Value
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Value = function Value(builder, enm, name, id) {
            T.call(this, builder, enm, name);

            /**
             * @override
             */
            this.className = "Enum.Value";

            /**
             * Unique enum value id.
             * @type {number}
             * @expose
             */
            this.id = id;
        };

        // Extends T
        Value.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Enum.Value
         * @expose
         */
        Reflect.Enum.Value = Value;

        /**
         * An extension (field).
         * @exports ProtoBuf.Reflect.Extension
         * @constructor
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
         */
        var Extension = function Extension(builder, parent, name, field) {
            T.call(this, builder, parent, name);

            /**
             * Extended message field.
             * @type {!ProtoBuf.Reflect.Message.Field}
             * @expose
             */
            this.field = field;
        };

        // Extends T
        Extension.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Extension
         * @expose
         */
        Reflect.Extension = Extension;

        /**
         * Constructs a new Service.
         * @exports ProtoBuf.Reflect.Service
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} root Root
         * @param {string} name Service name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Service = function Service(builder, root, name, options) {
            Namespace.call(this, builder, root, name, options);

            /**
             * @override
             */
            this.className = "Service";

            /**
             * Built runtime service class.
             * @type {?function(new:ProtoBuf.Builder.Service)}
             */
            this.clazz = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Service.prototype
         * @inner
         */
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the service and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Service
         * @param {boolean=} rebuild Whether to rebuild or not
         * @return {Function} Service class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        ServicePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Service class in its own scope
            return this.clazz = function (ProtoBuf, T) {

                /**
                 * Constructs a new runtime Service.
                 * @name ProtoBuf.Builder.Service
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.
                 * @constructor
                 * @throws {Error} If the service cannot be created
                 */
                var Service = function Service(rpcImpl) {
                    ProtoBuf.Builder.Service.call(this);

                    /**
                     * Service implementation.
                     * @name ProtoBuf.Builder.Service#rpcImpl
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose
                     */
                    this.rpcImpl = rpcImpl || function (name, msg, callback) {
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first
                        // argument or null and the actual response message.
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };
                };

                /**
                 * @alias ProtoBuf.Builder.Service.prototype
                 * @inner
                 */
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                /**
                 * Asynchronously performs an RPC call using the given RPC implementation.
                 * @name ProtoBuf.Builder.Service.[Method]
                 * @function
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                /**
                 * Asynchronously performs an RPC call using the instance's RPC implementation.
                 * @name ProtoBuf.Builder.Service#[Method]
                 * @function
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                for (var i = 0; i < rpc.length; i++) {
                    (function (method) {

                        // service#Method(message, callback)
                        ServicePrototype[method.name] = function (req, callback) {
                            try {
                                try {
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                                } catch (err) {
                                    if (!(err instanceof TypeError)) throw err;
                                }
                                if (req === null || (typeof req === "undefined" ? "undefined" : _typeof(req)) !== 'object') throw Error("Illegal arguments");
                                if (!(req instanceof method.resolvedRequestType.clazz)) req = new method.resolvedRequestType.clazz(req);
                                this.rpcImpl(method.fqn(), req, function (err, res) {
                                    // Assumes that this is properly async
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    // Coalesce to empty string when service response has empty content
                                    if (res === null) res = '';
                                    try {
                                        res = method.resolvedResponseType.clazz.decode(res);
                                    } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                        callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                                        return;
                                    }
                                    callback(null, res);
                                });
                            } catch (err) {
                                setTimeout(callback.bind(this, err), 0);
                            }
                        };

                        // Service.Method(rpcImpl, message, callback)
                        Service[method.name] = function (rpcImpl, req, callback) {
                            new Service(rpcImpl)[method.name](req, callback);
                        };

                        if (Object.defineProperty) Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }), Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);
                }

                // Properties

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service.$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service#$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Service, "$options", { "value": T.buildOpt() }), Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }), Object.defineProperty(Service, "$type", { "value": T }), Object.defineProperty(ServicePrototype, "$type", { "value": T });

                return Service;
            }(ProtoBuf, this);
        };

        /**
         * @alias ProtoBuf.Reflect.Service
         * @expose
         */
        Reflect.Service = Service;

        /**
         * Abstract service method.
         * @exports ProtoBuf.Reflect.Service.Method
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Method = function Method(builder, svc, name, options) {
            T.call(this, builder, svc, name);

            /**
             * @override
             */
            this.className = "Service.Method";

            /**
             * Options.
             * @type {Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Reflect.Service.Method.prototype
         * @inner
         */
        var MethodPrototype = Method.prototype = Object.create(T.prototype);

        /**
         * Builds the method's '$options' property.
         * @name ProtoBuf.Reflect.Service.Method#buildOpt
         * @function
         * @return {Object.<string,*>}
         */
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;

        /**
         * @alias ProtoBuf.Reflect.Service.Method
         * @expose
         */
        Reflect.Service.Method = Method;

        /**
         * RPC service method.
         * @exports ProtoBuf.Reflect.Service.RPCMethod
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {string} request Request message name
         * @param {string} response Response message name
         * @param {boolean} request_stream Whether requests are streamed
         * @param {boolean} response_stream Whether responses are streamed
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Service.Method
         */
        var RPCMethod = function RPCMethod(builder, svc, name, request, response, request_stream, response_stream, options) {
            Method.call(this, builder, svc, name, options);

            /**
             * @override
             */
            this.className = "Service.RPCMethod";

            /**
             * Request message name.
             * @type {string}
             * @expose
             */
            this.requestName = request;

            /**
             * Response message name.
             * @type {string}
             * @expose
             */
            this.responseName = response;

            /**
             * Whether requests are streamed
             * @type {bool}
             * @expose
             */
            this.requestStream = request_stream;

            /**
             * Whether responses are streamed
             * @type {bool}
             * @expose
             */
            this.responseStream = response_stream;

            /**
             * Resolved request message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedRequestType = null;

            /**
             * Resolved response message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedResponseType = null;
        };

        // Extends Method
        RPCMethod.prototype = Object.create(Method.prototype);

        /**
         * @alias ProtoBuf.Reflect.Service.RPCMethod
         * @expose
         */
        Reflect.Service.RPCMethod = RPCMethod;

        return Reflect;
    }(ProtoBuf);

    /**
     * @alias ProtoBuf.Builder
     * @expose
     */
    ProtoBuf.Builder = function (ProtoBuf, Lang, Reflect) {
        "use strict";

        /**
         * Constructs a new Builder.
         * @exports ProtoBuf.Builder
         * @class Provides the functionality to build protocol messages.
         * @param {Object.<string,*>=} options Options
         * @constructor
         */

        var Builder = function Builder(options) {

            /**
             * Namespace.
             * @type {ProtoBuf.Reflect.Namespace}
             * @expose
             */
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

            /**
             * Namespace pointer.
             * @type {ProtoBuf.Reflect.T}
             * @expose
             */
            this.ptr = this.ns;

            /**
             * Resolved flag.
             * @type {boolean}
             * @expose
             */
            this.resolved = false;

            /**
             * The current building result.
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
             * @expose
             */
            this.result = null;

            /**
             * Imported files.
             * @type {Array.<string>}
             * @expose
             */
            this.files = {};

            /**
             * Import root override.
             * @type {?string}
             * @expose
             */
            this.importRoot = null;

            /**
             * Options.
             * @type {!Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Builder.prototype
         * @inner
         */
        var BuilderPrototype = Builder.prototype;

        // ----- Definition tests -----

        /**
         * Tests if a definition most likely describes a message.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessage = function (def) {
            // Messages require a string name
            if (typeof def["name"] !== 'string') return false;
            // Messages do not contain values (enum) or rpc methods (service)
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a message field.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessageField = function (def) {
            // Message fields require a string rule, name and type and an id
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an enum.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isEnum = function (def) {
            // Enums require a string name
            if (typeof def["name"] !== 'string') return false;
            // Enums require at least one value
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a service.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isService = function (def) {
            // Services require a string name and an rpc object
            if (typeof def["name"] !== 'string' || _typeof(def["rpc"]) !== 'object' || !def["rpc"]) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an extended message
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isExtend = function (def) {
            // Extends rquire a string ref
            if (typeof def["ref"] !== 'string') return false;
            return true;
        };

        // ----- Building -----

        /**
         * Resets the pointer to the root namespace.
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.reset = function () {
            this.ptr = this.ns;
            return this;
        };

        /**
         * Defines a namespace on top of the current pointer position and places the pointer on it.
         * @param {string} namespace
         * @return {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.define = function (namespace) {
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace)) throw Error("illegal namespace: " + namespace);
            namespace.split(".").forEach(function (part) {
                var ns = this.ptr.getChild(part);
                if (ns === null) // Keep existing
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
                this.ptr = ns;
            }, this);
            return this;
        };

        /**
         * Creates the specified definitions at the current pointer position.
         * @param {!Array.<!Object>} defs Messages, enums or services to create
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If a message definition is invalid
         * @expose
         */
        BuilderPrototype.create = function (defs) {
            if (!defs) return this; // Nothing to create
            if (!Array.isArray(defs)) defs = [defs];else {
                if (defs.length === 0) return this;
                defs = defs.slice();
            }

            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
            var stack = [defs];
            while (stack.length > 0) {
                defs = stack.pop();

                if (!Array.isArray(defs)) // Stack always contains entire namespaces
                    throw Error("not a valid namespace: " + JSON.stringify(defs));

                while (defs.length > 0) {
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

                    if (Builder.isMessage(def)) {
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);

                        // Create OneOfs
                        var oneofs = {};
                        if (def["oneofs"]) Object.keys(def["oneofs"]).forEach(function (name) {
                            obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                        }, this);

                        // Create fields
                        if (def["fields"]) def["fields"].forEach(function (fld) {
                            if (obj.getChild(fld["id"] | 0) !== null) throw Error("duplicate or invalid field id in " + obj.name + ": " + fld['id']);
                            if (fld["options"] && _typeof(fld["options"]) !== 'object') throw Error("illegal field options in " + obj.name + "#" + fld["name"]);
                            var oneof = null;
                            if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]])) throw Error("illegal oneof in " + obj.name + "#" + fld["name"] + ": " + fld["oneof"]);
                            fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                            if (oneof) oneof.fields.push(fld);
                            obj.addChild(fld);
                        }, this);

                        // Push children to stack
                        var subObj = [];
                        if (def["enums"]) def["enums"].forEach(function (enm) {
                            subObj.push(enm);
                        });
                        if (def["messages"]) def["messages"].forEach(function (msg) {
                            subObj.push(msg);
                        });
                        if (def["services"]) def["services"].forEach(function (svc) {
                            subObj.push(svc);
                        });

                        // Set extension ranges
                        if (def["extensions"]) {
                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
                                obj.extensions = [def["extensions"]];else obj.extensions = def["extensions"];
                        }

                        // Create on top of current namespace
                        this.ptr.addChild(obj);
                        if (subObj.length > 0) {
                            stack.push(defs); // Push the current level back
                            defs = subObj; // Continue processing sub level
                            subObj = null;
                            this.ptr = obj; // And move the pointer to this namespace
                            obj = null;
                            continue;
                        }
                        subObj = null;
                    } else if (Builder.isEnum(def)) {

                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
                        def["values"].forEach(function (val) {
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isService(def)) {

                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
                        Object.keys(def["rpc"]).forEach(function (name) {
                            var mtd = def["rpc"][name];
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isExtend(def)) {

                        obj = this.ptr.resolve(def["ref"], true);
                        if (obj) {
                            def["fields"].forEach(function (fld) {
                                if (obj.getChild(fld['id'] | 0) !== null) throw Error("duplicate extended field id in " + obj.name + ": " + fld['id']);
                                // Check if field id is allowed to be extended
                                if (obj.extensions) {
                                    var valid = false;
                                    obj.extensions.forEach(function (range) {
                                        if (fld["id"] >= range[0] && fld["id"] <= range[1]) valid = true;
                                    });
                                    if (!valid) throw Error("illegal extended field id in " + obj.name + ": " + fld['id'] + " (not within valid ranges)");
                                }
                                // Convert extension field names to camel case notation if the override is set
                                var name = fld["name"];
                                if (this.options['convertFieldsToCamelCase']) name = ProtoBuf.Util.toCamelCase(name);
                                // see #161: Extensions use their fully qualified name as their runtime key and...
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn() + '.' + name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for
                                // resolving their type later on (the extension always keeps the original name to
                                // prevent naming collisions)
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
                                field.extension = ext;
                                this.ptr.addChild(ext);
                                obj.addChild(field);
                            }, this);
                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                            throw Error("extended message " + def["ref"] + " is not defined");
                    } else throw Error("not a valid definition: " + JSON.stringify(def));

                    def = null;
                    obj = null;
                }
                // Break goes here
                defs = null;
                this.ptr = this.ptr.parent; // Namespace done, continue at parent
            }
            this.resolved = false; // Require re-resolve
            this.result = null; // Require re-build
            return this;
        };

        /**
         * Propagates syntax to all children.
         * @param {!Object} parent
         * @inner
         */
        function propagateSyntax(parent) {
            if (parent['messages']) {
                parent['messages'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                    propagateSyntax(child);
                });
            }
            if (parent['enums']) {
                parent['enums'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                });
            }
        }

        /**
         * Imports another definition into this builder.
         * @param {Object.<string,*>} json Parsed import
         * @param {(string|{root: string, file: string})=} filename Imported file name
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If the definition or file cannot be imported
         * @expose
         */
        BuilderPrototype["import"] = function (json, filename) {
            var delim = '/';

            // Make sure to skip duplicate imports

            if (typeof filename === 'string') {

                if (ProtoBuf.Util.IS_NODE) filename = require("path")['resolve'](filename);
                if (this.files[filename] === true) return this.reset();
                this.files[filename] = true;
            } else if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                // Object with root, file.

                var root = filename.root;
                if (ProtoBuf.Util.IS_NODE) root = require("path")['resolve'](root);
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0) delim = '\\';
                var fname = root + delim + filename.file;
                if (this.files[fname] === true) return this.reset();
                this.files[fname] = true;
            }

            // Import imports

            if (json['imports'] && json['imports'].length > 0) {
                var importRoot,
                    resetRoot = false;

                if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                    // If an import root is specified, override

                    this.importRoot = filename["root"];resetRoot = true; // ... and reset afterwards
                    importRoot = this.importRoot;
                    filename = filename["file"];
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                } else if (typeof filename === 'string') {

                    if (this.importRoot) // If import root is overridden, use it
                        importRoot = this.importRoot;else {
                        // Otherwise compute from filename
                        if (filename.indexOf("/") >= 0) {
                            // Unix
                            importRoot = filename.replace(/\/[^\/]*$/, "");
                            if ( /* /file.proto */importRoot === "") importRoot = "/";
                        } else if (filename.indexOf("\\") >= 0) {
                            // Windows
                            importRoot = filename.replace(/\\[^\\]*$/, "");
                            delim = '\\';
                        } else importRoot = ".";
                    }
                } else importRoot = null;

                for (var i = 0; i < json['imports'].length; i++) {
                    if (typeof json['imports'][i] === 'string') {
                        // Import file
                        if (!importRoot) throw Error("cannot determine import root");
                        var importFilename = json['imports'][i];
                        if (importFilename === "google/protobuf/descriptor.proto") continue; // Not needed and therefore not used
                        importFilename = importRoot + delim + importFilename;
                        if (this.files[importFilename] === true) continue; // Already imported
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto) // If this is a light build
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);
                        if (contents === null) throw Error("failed to import '" + importFilename + "' in '" + filename + "': file not found");
                        if (/\.json$/i.test(importFilename)) // Always possible
                            this["import"](JSON.parse(contents + ""), importFilename); // May throw
                        else this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                    } else // Import structure
                        if (!filename) this["import"](json['imports'][i]);else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function ($0, $1, $2) {
                                return $1 + "_import" + i + "." + $2;
                            }));else // Without extension: Append _importN to make it unique
                            this["import"](json['imports'][i], filename + "_import" + i);
                }
                if (resetRoot) // Reset import root override when all imports are done
                    this.importRoot = null;
            }

            // Import structures

            if (json['package']) this.define(json['package']);
            if (json['syntax']) propagateSyntax(json);
            var base = this.ptr;
            if (json['options']) Object.keys(json['options']).forEach(function (key) {
                base.options[key] = json['options'][key];
            });
            if (json['messages']) this.create(json['messages']), this.ptr = base;
            if (json['enums']) this.create(json['enums']), this.ptr = base;
            if (json['services']) this.create(json['services']), this.ptr = base;
            if (json['extends']) this.create(json['extends']);

            return this.reset();
        };

        /**
         * Resolves all namespace objects.
         * @throws {Error} If a type cannot be resolved
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.resolveAll = function () {
            // Resolve all reflected objects
            var res;
            if (this.ptr == null || _typeof(this.ptr.type) === 'object') return this; // Done (already resolved)

            if (this.ptr instanceof Reflect.Namespace) {
                // Resolve children

                this.ptr.children.forEach(function (child) {
                    this.ptr = child;
                    this.resolveAll();
                }, this);
            } else if (this.ptr instanceof Reflect.Message.Field) {
                // Resolve type

                if (!Lang.TYPE.test(this.ptr.type)) {
                    if (!Lang.TYPEREF.test(this.ptr.type)) throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res) throw Error("unresolvable type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    this.ptr.resolvedType = res;
                    if (res instanceof Reflect.Enum) {
                        this.ptr.type = ProtoBuf.TYPES["enum"];
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3') throw Error("proto3 message cannot reference proto2 enum");
                    } else if (res instanceof Reflect.Message) this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];else throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                } else this.ptr.type = ProtoBuf.TYPES[this.ptr.type];

                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                if (this.ptr.map) {
                    if (!Lang.TYPE.test(this.ptr.keyType)) throw Error("illegal key type for map field in " + this.ptr.toString(true) + ": " + this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                }
            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {

                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.requestName);
                    this.ptr.resolvedRequestType = res;
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.responseName);
                    this.ptr.resolvedResponseType = res;
                } else // Should not happen as nothing else is implemented
                    throw Error("illegal service type in " + this.ptr.toString(true));
            } else if (!(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
            ) throw Error("illegal object in namespace: " + _typeof(this.ptr) + ": " + this.ptr);

            return this.reset();
        };

        /**
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
         * return the built package.
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
         * @throws {Error} If a type could not be resolved
         * @expose
         */
        BuilderPrototype.build = function (path) {
            this.reset();
            if (!this.resolved) this.resolveAll(), this.resolved = true, this.result = null; // Require re-build
            if (this.result === null) // (Re-)Build
                this.result = this.ns.build();
            if (!path) return this.result;
            var part = typeof path === 'string' ? path.split(".") : path,
                ptr = this.result; // Build namespace pointer (no hasChild etc.)
            for (var i = 0; i < part.length; i++) {
                if (ptr[part[i]]) ptr = ptr[part[i]];else {
                    ptr = null;
                    break;
                }
            }return ptr;
        };

        /**
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
         */
        BuilderPrototype.lookup = function (path, excludeNonNamespace) {
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Builder"
         * @expose
         */
        BuilderPrototype.toString = function () {
            return "Builder";
        };

        // ----- Base classes -----
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Message = function () {};

        /**
         * @alias ProtoBuf.Builder.Enum
         */
        Builder.Enum = function () {};

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Service = function () {};

        return Builder;
    }(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);

    /**
     * @alias ProtoBuf.Map
     * @expose
     */
    ProtoBuf.Map = function (ProtoBuf, Reflect) {
        "use strict";

        /**
         * Constructs a new Map. A Map is a container that is used to implement map
         * fields on message objects. It closely follows the ES6 Map API; however,
         * it is distinct because we do not want to depend on external polyfills or
         * on ES6 itself.
         *
         * @exports ProtoBuf.Map
         * @param {!ProtoBuf.Reflect.Field} field Map field
         * @param {Object.<string,*>=} contents Initial contents
         * @constructor
         */

        var Map = function Map(field, contents) {
            if (!field.map) throw Error("field is not a map");

            /**
             * The field corresponding to this map.
             * @type {!ProtoBuf.Reflect.Field}
             */
            this.field = field;

            /**
             * Element instance corresponding to key type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

            /**
             * Element instance corresponding to value type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

            /**
             * Internal map: stores mapping of (string form of key) -> (key, value)
             * pair.
             *
             * We provide map semantics for arbitrary key types, but we build on top
             * of an Object, which has only string keys. In order to avoid the need
             * to convert a string key back to its native type in many situations,
             * we store the native key value alongside the value. Thus, we only need
             * a one-way mapping from a key type to its string form that guarantees
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
             * === K2).
             *
             * @type {!Object<string, {key: *, value: *}>}
             */
            this.map = {};

            /**
             * Returns the number of elements in the map.
             */
            Object.defineProperty(this, "size", {
                get: function get() {
                    return Object.keys(this.map).length;
                }
            });

            // Fill initial contents from a raw object.
            if (contents) {
                var keys = Object.keys(contents);
                for (var i = 0; i < keys.length; i++) {
                    var key = this.keyElem.valueFromString(keys[i]);
                    var val = this.valueElem.verifyValue(contents[keys[i]]);
                    this.map[this.keyElem.valueToString(key)] = { key: key, value: val };
                }
            }
        };

        var MapPrototype = Map.prototype;

        /**
         * Helper: return an iterator over an array.
         * @param {!Array<*>} arr the array
         * @returns {!Object} an iterator
         * @inner
         */
        function arrayIterator(arr) {
            var idx = 0;
            return {
                next: function next() {
                    if (idx < arr.length) return { done: false, value: arr[idx++] };
                    return { done: true };
                }
            };
        }

        /**
         * Clears the map.
         */
        MapPrototype.clear = function () {
            this.map = {};
        };

        /**
         * Deletes a particular key from the map.
         * @returns {boolean} Whether any entry with this key was deleted.
         */
        MapPrototype["delete"] = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            var hadKey = keyValue in this.map;
            delete this.map[keyValue];
            return hadKey;
        };

        /**
         * Returns an iterator over [key, value] pairs in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.entries = function () {
            var entries = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                entries.push([(entry = this.map[strKeys[i]]).key, entry.value]);
            }return arrayIterator(entries);
        };

        /**
         * Returns an iterator over keys in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.keys = function () {
            var keys = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                keys.push(this.map[strKeys[i]].key);
            }return arrayIterator(keys);
        };

        /**
         * Returns an iterator over values in the map.
         * @returns {!Object} The iterator
         */
        MapPrototype.values = function () {
            var values = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                values.push(this.map[strKeys[i]].value);
            }return arrayIterator(values);
        };

        /**
         * Iterates over entries in the map, calling a function on each.
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
         * @param {Object=} thisArg The `this` value for the callback
         */
        MapPrototype.forEach = function (cb, thisArg) {
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                cb.call(thisArg, (entry = this.map[strKeys[i]]).value, entry.key, this);
            }
        };

        /**
         * Sets a key in the map to the given value.
         * @param {*} key The key
         * @param {*} value The value
         * @returns {!ProtoBuf.Map} The map instance
         */
        MapPrototype.set = function (key, value) {
            var keyValue = this.keyElem.verifyValue(key);
            var valValue = this.valueElem.verifyValue(value);
            this.map[this.keyElem.valueToString(keyValue)] = { key: keyValue, value: valValue };
            return this;
        };

        /**
         * Gets the value corresponding to a key in the map.
         * @param {*} key The key
         * @returns {*|undefined} The value, or `undefined` if key not present
         */
        MapPrototype.get = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            if (!(keyValue in this.map)) return undefined;
            return this.map[keyValue].value;
        };

        /**
         * Determines whether the given key is present in the map.
         * @param {*} key The key
         * @returns {boolean} `true` if the key is present
         */
        MapPrototype.has = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            return keyValue in this.map;
        };

        return Map;
    }(ProtoBuf, ProtoBuf.Reflect);

    /**
     * Loads a .proto string and returns the Builder.
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadProto = function (proto, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = undefined;
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
    };

    /**
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
     * @function
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

    /**
     * Loads a .proto file and returns the Builder.
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadProtoFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadProto(contents, builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
    };

    /**
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
     * @function
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


    /**
     * Constructs a new empty Builder.
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
     * @return {!ProtoBuf.Builder} Builder
     * @expose
     */
    ProtoBuf.newBuilder = function (options) {
        options = options || {};
        if (typeof options['convertFieldsToCamelCase'] === 'undefined') options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
        if (typeof options['populateAccessors'] === 'undefined') options['populateAccessors'] = ProtoBuf.populateAccessors;
        return new ProtoBuf.Builder(options);
    };

    /**
     * Loads a .json definition and returns the Builder.
     * @param {!*|string} json JSON definition
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadJson = function (json, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = null;
        if (!builder || (typeof builder === "undefined" ? "undefined" : _typeof(builder)) !== 'object') builder = ProtoBuf.newBuilder();
        if (typeof json === 'string') json = JSON.parse(json);
        builder["import"](json, filename);
        builder.resolveAll();
        return builder;
    };

    /**
     * Loads a .json file and returns the Builder.
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadJsonFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
    };

    return ProtoBuf;
});

cc._RF.pop();
}).call(this,require('_process'))

},{"_process":2,"bytebuffer":"bytebuffer","fs":undefined,"path":1}],"robot":[function(require,module,exports){
"use strict";
cc._RF.push(module, '70fa3v9AY9L4LKhZit7nNJY', 'robot');
// Scripts\Manager\robot.js

"use strict";

//练习房
var Long = require("long");

var M = cc.Class({

    ctor: function ctor() {},

    //重置数据
    reset: function reset() {
        this.mainPlayer = null;
        this.S_G13_AllRounds = { "players": [] };

        //单局积分
        this.matchScores = [];

        this.player1 = null;
        this.player2 = null;
        this.player3 = null;
    },

    dispachMsg: function dispachMsg(name, data) {
        if (typeof this[name] == 'function') {
            this[name](data);
        }
    },

    _initRobotPlayers: function _initRobotPlayers() {
        this.player1 = { "cuid": new Long(Math.floor(Math.random() * 1000000), 0), "status": 0, "name": cc.datamanager.createRandomName(), "rank": 0, "imgurl": cc.datamanager.getRobotHeadIcon(), "ipstr": "127.0.0.1" };
        this.player2 = { "cuid": new Long(Math.floor(Math.random() * 1000000), 0), "status": 0, "name": cc.datamanager.createRandomName(), "rank": 0, "imgurl": cc.datamanager.getRobotHeadIcon(), "ipstr": "127.0.0.1" };
        this.player3 = { "cuid": new Long(Math.floor(Math.random() * 1000000), 0), "status": 0, "name": cc.datamanager.createRandomName(), "rank": 0, "imgurl": cc.datamanager.getRobotHeadIcon(), "ipstr": "127.0.0.1" };
    },

    //模拟创建房间
    createPracticeRoom: function createPracticeRoom() {
        var S_G13_RoomAttr = { "room_id": 888888, "attr": {
                "player_size": 4, "play_type": 52, "rounds": 10, "payor": 10, "da_qiang": 2, "quan_lei_da": true, "yi_tiao_long": 1
            } };
        S_G13_RoomAttr.banker_cuid = cc.datamanager.mainPlayerData.cuid;
        S_G13_RoomAttr.robot = true; //标记在练习房间
        cc.netmanager.dispach("dispachMsg", "PublicProto_S_G13_RoomAttr", S_G13_RoomAttr);
    },

    //刷新playerInRoom
    /* status取值
            NONE    = 0; //空状态
            PREP    = 1; //准备
            READY   = 2; //就绪
            SORT    = 3; //摆牌
            COMPARE = 4; //比牌
            DONE    = 5; //结束
    */
    sendPlayerInRoom: function sendPlayerInRoom(round, selfStatus, robotStatus) {
        if (!this.mainPlayer) {
            this.mainPlayer = {};
            this.mainPlayer.cuid = cc.datamanager.mainPlayerData.cuid;
            this.mainPlayer.status = 0;
            this.mainPlayer.rank = 0;
            this.mainPlayer.name = cc.datamanager.mainPlayerData.nick_name;
            this.mainPlayer.imgurl = cc.datamanager.mainPlayerData.url;
            this.mainPlayer.ipstr = cc.datamanager.mainPlayerData.ipstr;
        }

        if (!this.player1) {
            this._initRobotPlayers();
        }

        this.mainPlayer.status = selfStatus;
        this.player1.status = robotStatus;
        this.player2.status = robotStatus;
        this.player3.status = robotStatus;

        var S_G13_PlayersInRoom = {};
        this.allplayers = [this.mainPlayer, this.player1, this.player2, this.player3];

        for (var i = 0; i < this.allplayers.length; ++i) {
            this.allplayers[i].rank = this._getMachRoundScore(this.allplayers[i].cuid, round);
        }

        S_G13_PlayersInRoom.players = this.allplayers;
        S_G13_PlayersInRoom.rounds = round;
        cc.netmanager.dispach("dispachMsg", "PublicProto_S_G13_PlayersInRoom", S_G13_PlayersInRoom);

        //初始化总计算消息
        if (this.S_G13_AllRounds.players.length == 0) {
            for (var i = 0; i < this.allplayers.length; ++i) {
                var player = { "win": 0, "daqiang": 0, "quanleida": 0, "rank": 0 };
                player.cuid = this.allplayers[i].cuid;
                this.S_G13_AllRounds.players.push(player);
            }
        }
    },

    //发牌
    sendHandleOfMine: function sendHandleOfMine(round) {

        var cardpool = [];
        for (var i = 0; i < 52; ++i) {
            cardpool.push(i + 1);
        }

        //四个玩家的牌
        this.cardArr = [[], [], [], []];
        for (var i = 0; i < this.cardArr.length; ++i) {
            while (this.cardArr[i].length != 13) {
                var randomIdx = Math.floor(Math.random() * cardpool.length);
                if (randomIdx < 0 || randomIdx >= cardpool.length) {
                    randomIdx = 0;
                }
                this.cardArr[i].push(cardpool[randomIdx]);
                cardpool.splice(randomIdx, 1);
            }
        }

        cc.log("robot 发牌 ", this.cardArr[0].length);
        var S_G13_HandOfMine = {};
        S_G13_HandOfMine.rounds = round;
        S_G13_HandOfMine.cards = this.cardArr[0].slice();
        cc.netmanager.dispach("dispachMsg", "PublicProto_S_G13_HandOfMine", S_G13_HandOfMine);
    },

    //所有人比牌数据
    //selfcard: 自己选择的牌
    sendAllHands: function sendAllHands(special, selfcard) {
        if (!this.cardArr) {
            cc.log("还未发牌!");
            return;
        }

        //请求计算模拟牌局的结果
        var msg = cc.netmanager.msg("PublicProto.C_G13_SimulationRound");
        msg.players.push({ "cuid": this.allplayers[0].cuid, "cards": selfcard, "special": special });

        for (var i = 1; i < this.allplayers.length; ++i) {
            cc.log("proint cards:   ", i);
            var player = {};
            player.cuid = this.allplayers[i].cuid;
            player.cards = cc.robot._calculateRobotCard(this.cardArr[i].slice());
            player.special = false;
            msg.players.push(player);
        }
        //cc.log("请求计算模拟牌局的结果, ", msg.players.length)
        //cc.PokerUtil.printPokerEncode(msg.players[0].cards)
        //cc.PokerUtil.printPokerEncode(msg.players[1].cards)
        //cc.PokerUtil.printPokerEncode(msg.players[2].cards)
        //cc.PokerUtil.printPokerEncode(msg.players[3].cards)
        cc.netmanager.send(msg);
    },

    //计算机器人牌型数据
    _calculateRobotCard: function _calculateRobotCard(cards) {
        var ret = cc.PokerUtil.getRecommendPokerSet(cards);
        if (ret.length > 0) {
            var c = [];
            c = c.concat(ret[0].top.card, ret[0].middle.card, ret[0].bottom.card);
            return c;
        }
        return cards;
    },

    _getAllRoundsPlayer: function _getAllRoundsPlayer(cuid) {
        for (var i = 0; i < this.S_G13_AllRounds.players.length; ++i) {
            if (this.S_G13_AllRounds.players[i].cuid.eq(cuid)) {
                return this.S_G13_AllRounds.players[i];
            }
        }
        return null;
    },

    _getMachRoundScore: function _getMachRoundScore(cuid, round) {
        if (!this.matchScores[round]) {
            return 0;
        }

        for (var i = 0; i < this.matchScores[round].length; ++i) {
            if (this.matchScores[round][i].cuid.eq(cuid)) {
                return this.matchScores[round][i].rank;
            }
        }
    },

    PublicProto_S_G13_CalcRoundSimulationRet: function PublicProto_S_G13_CalcRoundSimulationRet(msg) {
        cc.log("收到服务器返回的模拟数据");

        var round = cc.gamemanager._currentRounds + 1;

        for (var i = 0; i < msg.result.players.length; ++i) {
            var cuid = msg.result.players[i].cuid;
            var p = this._getAllRoundsPlayer(cuid);
            if (p) {
                p.rank += msg.result.players[i].rank;
                if (msg.result.players[i].rank > 0) {
                    p.win++;
                }
            }

            if (!this.matchScores[round]) {
                this.matchScores[round] = [];
            }

            var score = this._getMachRoundScore(cuid, round - 1) + msg.result.players[i].rank;
            this.matchScores[round].push({ "cuid": cuid, "rank": score });
        }
        cc.netmanager.dispach("dispachMsg", "PublicProto_S_G13_AllHands", msg.result);
    },

    //练习场要保存结算数据
    saveMatchResult: function saveMatchResult(data) {
        for (var i = 0; i < data.length; ++i) {
            var p = this._getAllRoundsPlayer(data[i].cuid);
            if (p) {
                p.daqiang += data[i].daqianglist.length;
                if (data[i].quanleida) {
                    p.quanleida++;
                }
            }
        }
    },

    //发送送结算数据
    sendAllRoundsSummary: function sendAllRoundsSummary() {
        cc.netmanager.dispach("dispachMsg", "PublicProto_S_G13_AllRounds", this.S_G13_AllRounds);
    }
});

cc.robot = new M();

cc._RF.pop();
},{"long":"long"}],"smJsPanel":[function(require,module,exports){
"use strict";
cc._RF.push(module, '8428cNCtRBIg4y0u+OGG49L', 'smJsPanel');
// Scripts\Gui\Widget\smJsPanel.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        topcard: cc.Node,
        middlecard: cc.Node,
        bottomcard: cc.Node,
        zongfen: cc.Label,
        daqiang: cc.Label,
        username: cc.Label,
        touxiang: cc.Node,
        quanleida: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    _scoreStr: function _scoreStr(num) {

        if (num < 0) {
            return num.toString();
        } else if (num > 0) {
            return "+" + num.toString();
        } else {
            return "0";
        }
    },

    _setScore: function _setScore(node, name, num) {
        var lb = node.getChildByName(name).getComponent(cc.Label);
        if (lb) {
            lb.string = this._scoreStr(num);
            cc.datamanager.setScoreFont(num >= 0, lb);
        }
    },

    initCard: function initCard(carddata, score) {
        var special = false;
        if (carddata.spec.brand != 0) {
            special = true;
        }

        var tc = this.topcard.getChildByName("card");
        for (var i = 0; i < tc.childrenCount; ++i) {
            var node = tc.children[i];
            cc.PokerUtil.replacePokerSprite(carddata.cards[i], node);
        }
        var st1 = cc.configmanager.pokerFlopCfg[carddata.dun0.brand];
        if (!special) {
            this.topcard.getChildByName("name").getComponent(cc.Label).string = st1.name;
        }

        var mc = this.middlecard.getChildByName("card");
        for (var i = 0; i < mc.childrenCount; ++i) {
            var node = mc.children[i];
            cc.PokerUtil.replacePokerSprite(carddata.cards[i + 3], node);
        }
        var st2 = cc.configmanager.pokerFlopCfg[carddata.dun1.brand];
        if (!special) {
            this.middlecard.getChildByName("name").getComponent(cc.Label).string = st2.name;
        }

        var bc = this.bottomcard.getChildByName("card");
        for (var i = 0; i < bc.childrenCount; ++i) {
            var node = bc.children[i];
            cc.PokerUtil.replacePokerSprite(carddata.cards[i + 8], node);
        }
        var st3 = cc.configmanager.pokerFlopCfg[carddata.dun2.brand];
        if (!special) {
            this.bottomcard.getChildByName("name").getComponent(cc.Label).string = st3.name;
        }

        this.zongfen.string = this._scoreStr(carddata.rank);
        cc.datamanager.setScoreFont(carddata.rank >= 0, this.zongfen);

        var player = cc.gamemanager.getPlayer(carddata.cuid);
        if (player != null) {
            this.username.string = player.name;
            cc.datamanager.loadHeadImg(player.imgurl, this.touxiang.getComponent(cc.Sprite));
        }

        if (!special) {
            //this.topcard.getChildByName("score").getComponent(cc.Label).string = this._scoreStr(score.score.top)
            //this.middlecard.getChildByName("score").getComponent(cc.Label).string = this._scoreStr(score.score.middle)
            //this.bottomcard.getChildByName("score").getComponent(cc.Label).string = this._scoreStr(score.score.bottom)

            this._setScore(this.topcard, "score", score.score.top);
            this._setScore(this.middlecard, "score", score.score.middle);
            this._setScore(this.bottomcard, "score", score.score.bottom);
        } else {
            var rk = Math.floor(carddata.spec.brand / 10);
            //var str = cc.configmanager.specialFlopCfg[rk].name.toString() + "  +" + score.score.special.toString()
            var lbl = this.node.getChildByName("score").getComponent(cc.Label);
            lbl.string = this._scoreStr(score.score.special);
            cc.datamanager.setScoreFont(score.score.special >= 0, lbl);
            cc.PokerUtil.replaceSprite(cc.configmanager.specialFlopCfg[rk].texres, this.node.getChildByName("PokerType"));
        }
        this.daqiang.string = this._scoreStr(score.score.spe);
        cc.datamanager.setScoreFont(score.score.spe >= 0, this.daqiang);

        this.quanleida.string = this._scoreStr(score.score.quanleida);
        cc.datamanager.setScoreFont(score.score.quanleida >= 0, this.quanleida);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"tanchusound":[function(require,module,exports){
"use strict";
cc._RF.push(module, '3376f1nGcNLMYnUj9eboHM7', 'tanchusound');
// Scripts\Gui\Widget\tanchusound.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        this.node.on("click", function () {
            cc.audiomanager.playSFX("tanchu");
        });
    }

});

cc._RF.pop();
},{}],"waitformatch":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd91dfbe7ThOMqQ74Gu08IJY', 'waitformatch');
// Scripts\Gui\Widget\waitformatch.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        actNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._index = 0;

        var action = cc.repeatForever(cc.sequence(cc.callFunc(function (target, param) {
            var i = 0;
            for (; i < param._index; ++i) {
                param.actNode.children[i].active = true;
            }
            for (; i < param.actNode.childrenCount; ++i) {
                param.actNode.children[i].active = false;
            }

            ++param._index;
            if (param._index > param.actNode.childrenCount) {
                param._index = 0;
            }
        }, this, this), cc.delayTime(0.3)));

        this.actNode.runAction(action);
    }

});

cc._RF.pop();
},{}]},{},["CardMoveEvent","GameResult","MainGame","PokerDun","PokerFlop","PokerList","PokerSelect","PokerSelectHandler","PokerSort","RecordItem","ScoreSummary","UIChat","UICreateRoom","UIGm","UIHelp","UIJoinRoom","UILoading","UILogin","UIMain","UIMessageBox","UINotice","UIPanel","UIPokerGame","UIRecord","UISetting","UIShare","UIShop","UISpecialCard","UIUserIp","UIVote","UIWaiting","ChatBubble","HeadInfo","ShopItem","bigJsPanel","clicksound","smJsPanel","tanchusound","waitformatch","bytebuffer","long","protobuf","AudioMgr","ConfigManager","DataManager","GameManager","GuiManager","IMManager","NetManager","PokerUtils","SceneManager","robot","init"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvQXVkaW9NZ3IuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvQ2FyZE1vdmVFdmVudC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvQ2hhdEJ1YmJsZS5qcyIsImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvQ29uZmlnTWFuYWdlci5qcyIsImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvRGF0YU1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL0dhbWVNYW5hZ2VyLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL0dhbWVSZXN1bHQuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL0d1aU1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvV2lkZ2V0L0hlYWRJbmZvLmpzIiwiYXNzZXRzL1NjcmlwdHMvTWFuYWdlci9JTU1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvTWFpbkdhbWUuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL05ldE1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvUG9rZXJEdW4uanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvUG9rZXJGbG9wLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1Bva2VyTGlzdC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9Qb2tlclNlbGVjdEhhbmRsZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvUG9rZXJTZWxlY3QuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvUG9rZXJTb3J0LmpzIiwiYXNzZXRzL1NjcmlwdHMvTWFuYWdlci9Qb2tlclV0aWxzLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1JlY29yZEl0ZW0uanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL1NjZW5lTWFuYWdlci5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9TY29yZVN1bW1hcnkuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvV2lkZ2V0L1Nob3BJdGVtLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJQ2hhdC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSUNyZWF0ZVJvb20uanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlHbS5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSUhlbHAuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlKb2luUm9vbS5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSUxvYWRpbmcuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlMb2dpbi5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSU1haW4uanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlNZXNzYWdlQm94LmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJTm90aWNlLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJUGFuZWwuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlQb2tlckdhbWUuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlSZWNvcmQuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlTZXR0aW5nLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJU2hhcmUuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlTaG9wLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJU3BlY2lhbENhcmQuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlVc2VySXAuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlWb3RlLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJV2FpdGluZy5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvYmlnSnNQYW5lbC5qcyIsImFzc2V0cy9TY3JpcHRzL0xpYi9ieXRlYnVmZmVyLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1dpZGdldC9jbGlja3NvdW5kLmpzIiwiYXNzZXRzL1NjcmlwdHMvaW5pdC5qcyIsImFzc2V0cy9TY3JpcHRzL0xpYi9sb25nLmpzIiwiYXNzZXRzL1NjcmlwdHMvTGliL3Byb3RvYnVmLmpzIiwiYXNzZXRzL1NjcmlwdHMvTWFuYWdlci9yb2JvdC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvc21Kc1BhbmVsLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1dpZGdldC90YW5jaHVzb3VuZC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvd2FpdGZvcm1hdGNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVJO0FBQ0k7QUFDQTtBQUZROztBQUtaO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUdHO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7QUFHRztBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUdHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQXJHWTs7QUE2R2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFaUTs7QUFlWjtBQUNBOztBQUlBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBOUJLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUhROztBQU1aO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQXJDSTs7Ozs7Ozs7OztBQ0NUOztBQUVBOztBQUVJOztBQUVJO0FBQ0E7O0FBRUE7QUFFSTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7QUFHRztBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7QUFDRDs7QUFFQTs7QUFNQTs7QUFNQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUplOztBQU9uQjs7QUFFQTtBQUNBOztBQWFBO0FBQ0E7O0FBaUJBOztBQUVBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBSUE7O0FBS0E7O0FBT0E7QUFDQTtBQUdIO0FBOUhZOztBQWlJakI7Ozs7Ozs7Ozs7QUNwSUE7QUFDQTs7QUFFSTtBQUNJOztBQU9BOztBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFFSTtBQUNIO0FBQ0o7O0FBR0Q7QUFDSTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDUTtBQUNBO0FBQ0E7QUFDUDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUVJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFFSTtBQUVIO0FBR0c7QUFDSDtBQUdHO0FBQ0g7QUFDSjs7QUFFRDs7QUFFSTs7QUFHQTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBR0E7QUFDQTtBQUVJO0FBRUk7QUFFSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBR0c7QUFDSDtBQUNEO0FBRUk7QUFDSDtBQUdHO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRmM7QUFJckI7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0k7QUFBYztBQUFzQztBQUNwRDtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0c7QUFDSTtBQUNIO0FBQ0c7QUFDSTtBQUFjO0FBQXNDO0FBQ3BEO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQWhNWTs7QUFtTWpCOzs7Ozs7Ozs7O0FDcE1BO0FBQ0E7O0FBRUk7QUFDSTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFFSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUk7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRDs7QUFHQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFFSTtBQUVJO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBRUk7O0FBRUE7QUFFSTtBQUNBO0FBQ0c7QUFDSDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNIOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUFnRDtBQUM1QztBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJOztBQUVBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNHO0FBQ0E7QUFDRjs7QUFFRDtBQUNBO0FBQ0c7QUFDQTtBQUNBO0FBQ0Y7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUc7QUFDSjtBQUNJO0FBQ0g7O0FBeFFZOztBQTRRakI7Ozs7Ozs7Ozs7QUM3UUE7QUFDQTtBQUNJOztBQUVBO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFKUzs7QUFPWjtBQUNBOztBQUVJO0FBQ0E7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFFSjs7QUFFRDs7QUFFSTtBQUNBOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKO0FBRUo7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDs7QUFFSTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFHQTtBQUNIOztBQUdEO0FBQ0E7O0FBRUE7QUFoSUs7Ozs7Ozs7Ozs7QUNBVDs7QUFFSTtBQUNJO0FBRUg7O0FBRUY7QUFDSztBQUNJO0FBQ0E7QUFFSTtBQUNJO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0w7O0FBRUQ7QUFDQzs7QUFFQTtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBSUk7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUM7QUFDRzs7QUFFSjtBQUNIO0FBR0c7QUFDSDtBQUNKO0FBQ0Q7O0FBRUQ7QUFDSztBQUNBO0FBRUk7QUFDSDtBQUdHO0FBQ0g7QUFDTDs7QUFFRDtBQUNJO0FBQ0M7QUFDSTtBQUNBO0FBQ0g7QUFDTDs7QUFFRDtBQUNJO0FBQ0M7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNMOztBQUVEO0FBQ0M7QUFDQTtBQUNJO0FBQ0g7QUFDRDs7QUFFRDtBQUNDO0FBQ0E7O0FBRUQ7QUFDSztBQUVJO0FBQ0E7O0FBRUE7QUFDSDtBQUNKOztBQUVGO0FBQ0U7QUFFRztBQUNBO0FBRUk7QUFDSTtBQUVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFWTDtBQVdDO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBRUk7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRjtBQUNLO0FBQ0E7QUFDQTtBQUVJO0FBRUk7QUFDSDtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBRUk7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFFSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7QUE3TFk7QUErTGpCOzs7Ozs7Ozs7O0FDaE1BO0FBQ0k7O0FBRUE7O0FBSUE7QUFDQTs7QUFJQTtBQUNJOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNRO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDUjs7QUE1Q0k7Ozs7Ozs7Ozs7QUNBVDs7QUFFSTs7QUFHQTtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQztBQUNHO0FBQ0g7QUFDRDtBQUNIO0FBR0c7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUErQjtBQUMvQjtBQUNJO0FBRUk7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQXBCSjtBQXNCSDs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7O0FBRUE7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNKO0FBOUdZOztBQWlIakI7Ozs7Ozs7Ozs7QUNqSEE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTs7QUFqQks7Ozs7Ozs7Ozs7QUNDVDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVFO0FBRUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUVFO0FBQ0Q7QUFHQztBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDRTtBQURnQjtBQUduQjs7QUFFRDtBQUNFO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUdIO0FBQ0Y7O0FBRUQ7QUFDRTtBQUVFO0FBQ0Q7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNFO0FBQ0Q7QUFDRDtBQU1EOztBQUVEO0FBQ0U7QUFDRTtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBRUU7QUFDQTtBQUNBO0FBQ0Q7QUFHQztBQUNEO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUEyQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBQW9EO0FBQ2hEO0FBQ0E7QUFDSjtBQUE4QztBQUMxQztBQUNBO0FBQ0o7QUFBNEM7QUFDMUM7QUFDRTtBQUNBO0FBQ0Q7QUE3Q0w7QUErQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFWTjtBQVlEOztBQUdEO0FBQ0k7QUFDRDtBQUNHO0FBQ0E7QUFDRjtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNFO0FBQ0E7QUFDRTtBQUNEO0FBQ0Y7O0FBRUQ7QUFDRTtBQUNEOztBQUVEO0FBQ0k7QUFDQTs7QUFHQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBSUM7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNGO0FBQ0E7QUFDSTtBQUNGO0FBQ0Q7QUFDRDs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDRTtBQUVFO0FBQ0Q7QUFDRDs7QUFFQTtBQUNBO0FBQ0U7QUFDQztBQUNDO0FBRUU7QUFDRTtBQUNEO0FBQ0Y7QUFHQztBQUNBO0FBQ0E7QUFFRTtBQUNEO0FBQ0Y7QUFDSjtBQUNGOztBQUVEO0FBQ007QUFFRTtBQUNBO0FBQ0Q7QUFDTjtBQUNEO0FBQ0E7O0FBRUU7QUFDQztBQUVLO0FBRUk7QUFDSTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0Y7QUFDRjtBQUNKO0FBR0M7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNGO0FBQ0o7QUFHQztBQUNEO0FBQ0o7O0FBRUQ7QUFDQTtBQUNFO0FBRUU7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0U7QUFDQTtBQUVFO0FBQ0Q7QUFDRDtBQUNEOztBQUVEOztBQUVFO0FBRUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUdDO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUhVO0FBRkc7QUFRbEI7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFDQTtBQUVFO0FBQ0Q7QUFDRDtBQUVBO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDRTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBRUU7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNKOztBQUVEO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUVJO0FBQ0g7QUFDSDtBQUNEOztBQUVEO0FBQ0U7QUFFRTtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFFRTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFFRTtBQUNBO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUVJO0FBQ0g7QUFDRjs7QUFFRDtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNFO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUVFO0FBQ0E7QUFFRTtBQUNEO0FBR0M7QUFDRDtBQUNGO0FBQ0Q7QUFDRDs7QUFFRjtBQUNHO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJTO0FBVVg7QUFFRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNEOztBQUdEO0FBQ0U7QUFFRTtBQUNBO0FBQ0U7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNFO0FBRUU7QUFDQTtBQUNFO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBRUU7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQUzs7QUFVWDtBQUVFO0FBQ0E7QUFDRDs7QUFFRDtBQUNEOztBQUVEO0FBQ0U7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFwbUJZO0FBc21CakI7Ozs7Ozs7Ozs7QUN0bUJBOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBRlE7O0FBS1o7QUFDQTs7QUFJQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBR0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNEO0FBQ1E7QUFDQTtBQUNQO0FBRUo7O0FBRUQ7QUFDSTtBQUNIOztBQUdEO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDUDs7QUFFRDs7QUFFSTtBQUNBO0FBQ0E7QUFDSTs7QUFFQTtBQUVIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUVKOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQTlMSTs7Ozs7Ozs7OztBQ0hUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFWUTs7QUFhWjtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNLO0FBQ0c7QUFDQTtBQUNIO0FBQ0E7QUFDRztBQUNBO0FBQ0g7QUFDQTtBQUNHO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUVJO0FBQ0k7QUFFSTtBQUNBO0FBQ0g7QUFDRDs7QUFFQTtBQUFzQztBQUNsQztBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUVJO0FBQ0k7QUFFSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQUFxQztBQUNqQztBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFFSjtBQUNKOztBQUVEO0FBQ0E7QUFFSTtBQUNJO0FBRUk7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBRUg7QUFDSjs7QUFFRDtBQUNBO0FBRUk7QUFDSTtBQUVJO0FBQ0E7QUFDSDs7QUFFRDtBQUVJO0FBQ0E7QUFDSDs7QUFFRDtBQUVJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDRTtBQUNEOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBektJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTs7QUFHQTtBQUNBOztBQUlBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBckJLOzs7Ozs7Ozs7O0FDQ1Q7QUFDQTtBQUVJOztBQUVJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUExQjRCO0FBNkJwQzs7Ozs7Ozs7OztBQ2pDRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiUTs7QUFnQlo7QUFDQTtBQUNJOzs7Ozs7Ozs7OztBQVdIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQUNIOztBQUVEOztBQUVJO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQztBQUNBOztBQUVBO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBdEhLOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBR0o7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQWlFO0FBQTJCO0FBQzVGO0FBQWdFO0FBQTBCO0FBQzFGO0FBQStEO0FBQXlCOztBQUV4RjtBQUF5RDtBQUF1QjtBQUNuRjtBQUNHO0FBQWdFO0FBQTJCO0FBQzNGO0FBQWdFO0FBQTBCO0FBQzFGO0FBQThEO0FBQXlCOztBQUV2RjtBQUF3RDtBQUF1QjtBQUNsRjs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFFSTtBQUNBO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFFSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFSTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQXNDO0FBQXFCO0FBQzNEO0FBQXNDO0FBQXFCO0FBQzNEO0FBQXNDO0FBQXFCOztBQUUzRDtBQUNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7O0FBRUk7QUFDSTtBQUNEO0FBQ0E7QUFDQTtBQUNGOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBRUo7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDTDtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7O0FBRUs7QUFFSTtBQUNBO0FBRUk7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNHO0FBQ0E7QUFDQTtBQUNKOztBQUVBO0FBQ0E7QUFDSztBQUNBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7O0FBRUE7QUFFSTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUVJO0FBQ0E7QUFDSDtBQUNMO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFSTtBQUNBOztBQUVBO0FBRUk7QUFFSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFHRztBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0g7QUFFSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNBO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUk7O0FBRUE7QUFFSTtBQUdRO0FBQ0E7QUFDSDtBQUNMO0FBQ0g7QUFFRztBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSDtBQUVKOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNHO0FBQ0s7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNMO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQWx0Qkk7Ozs7Ozs7Ozs7QUNEVDtBQUNJOztBQUlKOzs7Ozs7O0FBUUk7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUo7QUFDQTtBQUNDO0FBQ007QUFDSTtBQUNIO0FBQ1A7O0FBRUU7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUo7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0M7QUFERDtBQUdBOztBQUVEO0FBQ0E7QUFDQztBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNEO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQzs7QUFFQTtBQUNBO0FBQ0E7QUFFQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQzs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBOztBQUVEO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0M7QUFDQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHRDtBQUNBO0FBQ0M7QUFDQTtBQUFBO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQWtDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFBVztBQUNWO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFHQTtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBOztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUEyQjtBQUMzQjtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFBMkM7QUFDMUM7QUFDQTtBQUNEO0FBQThCO0FBQzlCO0FBQ0M7QUFDQTtBQUNEO0FBQTRCO0FBQzVCO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQTtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQztBQUNBOztBQUVEO0FBRUM7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNEO0FBQ0Q7QUFFQztBQUFZO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBRUE7QUFDQTtBQUNDO0FBQ0M7O0FBR0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUE7QUFDRDtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUFBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0U7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBRUQ7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRjtBQUNBOztBQUVDO0FBQ0M7QUFDQTs7QUFFQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDRDs7QUFFRDtBQUE4QjtBQUF5Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFFQztBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0M7QUFBNkI7QUFBYTtBQUV6QztBQUE2QjtBQUFhO0FBQ1A7QUFBZ0M7QUFDbkU7QUFDRDtBQUNBOztBQUVEO0FBQ0M7QUFBNkI7QUFBYTtBQUV6QztBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFRztBQUNBO0FBQ0Y7QUFDTTtBQUNJO0FBQWdDO0FBQzVCO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFFRztBQUNJO0FBQ0E7QUFDWjtBQUNBOztBQUVBO0FBRUE7O0FBR0E7QUFFQTtBQUVBO0FBQ1M7QUFDSjtBQUNKOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVDO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFBQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFBc0I7QUFBYztBQUNwQztBQUFzQjtBQUFjOztBQUVwQztBQUNBO0FBQ0M7QUFDQTtBQUVEO0FBQ0M7QUFDQztBQUE4QjtBQUM3QjtBQUNBO0FBQ0Q7QUFBOEI7QUFDN0I7QUFDQTtBQUNEO0FBQ0M7QUFDQTtBQUNEO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUVEO0FBQ0M7QUFDQTs7QUFFQTs7QUFHQTtBQUVDO0FBRUM7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUVDO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0Q7QUFDRDtBQUdBO0FBQ0E7QUFFQztBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUVEO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0Q7QUFDQTtBQUVEO0FBQ0M7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ2dCO0FBQ2hCO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUFpQjtBQUNqQjtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQztBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVDO0FBQ0E7QUFDQTtBQUVDO0FBQ0E7QUFDQTtBQUNEO0FBRUM7QUFDQTtBQUFhO0FBQ1o7O0FBRUE7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUVDO0FBQ0E7QUFDQTtBQUNBO0FBRUM7QUFDQTs7QUFFQTtBQUVDO0FBQ0M7QUFDQTtBQUNEOztBQUVDO0FBQ1g7Ozs7Ozs7QUFPVztBQUNBO0FBQ0Q7O0FBRUQ7QUFFQztBQUVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFFRDtBQUNEO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBOztBQUVDO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFBOEI7QUFDN0I7QUFDQTtBQUNEO0FBQStCO0FBQzlCO0FBQ0E7QUFDRDtBQUNDO0FBQVk7QUFBYTtBQUN6QjtBQUFZO0FBQVk7QUFDeEI7QUFDRDtBQUNDO0FBQVk7QUFBVztBQUN2QjtBQUFZO0FBQVc7QUFDdkI7QUFDRDtBQUNDO0FBQVk7QUFBVztBQUN2QjtBQUFZO0FBQVc7QUFDdkI7QUFDRDtBQUdBO0FBQ0E7QUFDQTtBQUFZO0FBQ1g7QUFDQTtBQUNBO0FBQ0Q7QUFBWTtBQUNYO0FBQ0E7QUFDQTtBQUNEO0FBQVk7QUFBYTtBQUN6QjtBQUFZO0FBQWE7QUFDekI7QUFBVztBQUFhO0FBQ3hCO0FBQXdCO0FBQVc7QUFDbkM7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFFQztBQUNBO0FBQ0E7O0FBRUQ7O0FBRUE7QUFDQTtBQUVDO0FBQ0E7O0FBRUE7QUFDQTtBQUVDO0FBQ0E7O0FBRUE7QUFDQztBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQTtBQUVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBRUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBRUM7QUFDQTtBQUFpRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBRUM7QUFDQztBQUNBO0FBRUM7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0Q7O0FBRUQ7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0M7QUFDQTs7QUFFQTs7QUFHQTtBQUVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQUc7QUFBSDtBQUdDO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQWdEO0FBQy9DO0FBQ0E7QUFDRDtBQUFnRDtBQUMvQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUNBOztBQUVBO0FBQ0E7QUFDQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFoa0RlOztBQW1rRGpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN4bURBO0FBQ0k7O0FBRUE7QUFDUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEk7O0FBY1o7QUFDSTtBQUVJO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUdHO0FBQ0E7QUFDSDtBQUdHO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFSTtBQUVJO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDSjtBQTNESTs7Ozs7Ozs7OztBQ0FUOztBQUVJO0FBRUk7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUg7QUFDSjtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBRUk7QUFDSDtBQUdHO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIO0FBbEVZOztBQXFFakI7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJROztBQVdaO0FBQ0E7QUFDSTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUdBO0FBQ0g7O0FBRUQ7O0FBRUk7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDs7QUFFQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRzs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBRUo7O0FBRUQ7QUFDSTs7O0FBR0o7QUFDQTs7QUFFQTtBQTNJSzs7Ozs7Ozs7OztBQ0RUO0FBQ0k7O0FBRUE7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTFM7O0FBUVo7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBakNJOzs7Ozs7Ozs7O0FDQ1Q7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMUTs7QUFTWjtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBRUE7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTjs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUVJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSDtBQTlHSTs7Ozs7Ozs7OztBQ0hUO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMUTs7QUFRWjtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUZNO0FBSWI7QUFDRDtBQUNBO0FBQ0E7QUFFSTtBQUNBOztBQUVBO0FBRUk7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUNIO0FBQ0Q7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBRUk7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0g7QUFDRDtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7QUFHRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUk7QUFDSDtBQUdFO0FBQ0E7QUFDRjtBQUdFO0FBQ0Y7QUFHRztBQUVBO0FBQ0g7QUFFSjtBQUNEO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUVJOztBQUVIO0FBQ0o7O0FBckxJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSFE7O0FBTVo7O0FBRUk7QUFDQTs7QUFFQTtBQUVJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQXZCSTs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTs7QUFISzs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7QUFDSTs7QUFFQTtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBSlM7O0FBT1o7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUVJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBRUk7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDRztBQUNBO0FBQ0E7QUFFSztBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBRU07QUFDTDtBQUdHO0FBQ0g7QUFHRztBQUNIO0FBRUY7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQS9ISzs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQU5JOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBTFE7O0FBUVo7QUFDQTtBQUNJO0FBRUk7QUFDSDtBQUdHO0FBQ0g7QUFDRDtBQUVJO0FBQ0g7QUFHRztBQUVJO0FBQ0g7QUFHRztBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7QUFDSjtBQUNEOztBQUVBO0FBRUk7QUFDSDtBQUNEOztBQUVSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCSzs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTs7QUFFQTs7QUFHSTtBQUVIO0FBR0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBdklLOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhROztBQWNaO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUk7QUFDSDs7QUFFRDtBQUVJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDs7QUFFSTtBQUVJO0FBQ0g7QUFDSjs7QUFHRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBR0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBNUVLOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSFE7O0FBTVo7QUFDQTs7QUFJQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUVJO0FBRUk7QUFDSDtBQUNKO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQS9DSTs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBSlE7O0FBT1o7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNRO0FBQ1A7O0FBekJJOzs7Ozs7Ozs7O0FDRFQ7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRE87QUFHWDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEOztBQUlBO0FBQ0k7QUFFSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBSUE7O0FBSUE7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUFDRDtBQUVJO0FBQ0g7QUFuRmlCO0FBcUZ6Qjs7Ozs7Ozs7OztBQ3hGRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4Q1E7O0FBMkNaO0FBQ0E7QUFDSTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUE7O0FBR0E7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVJOztBQUVBOztBQUVJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUdHO0FBQ0g7QUFDRDtBQUVLO0FBQ0o7QUFHRztBQUNIOztBQUVEO0FBRUk7QUFDSDs7QUFFRDtBQUVJO0FBQ0g7QUFHRztBQUNIOztBQUdEO0FBQ0g7O0FBRUQ7QUFDSTs7QUFHQTtBQUNBOztBQUVBO0FBRUk7QUFDQTtBQUNIO0FBR0c7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0c7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBRUk7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUVJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUk7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUVJO0FBQ0E7QUFDQTtBQUNIO0FBQ1Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Qks7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFFSTtBQUVJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBRUk7QUFDQTs7QUFFQTtBQUVJO0FBQ0g7QUFHRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBRUk7QUFDQTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBR0c7QUFDQTtBQUNIO0FBQ0Q7QUFFSTtBQUNBO0FBQ0E7QUFDSTtBQUVJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7O0FBRUk7QUFFSTtBQUVJO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBR0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUk7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNHO0FBQ0k7QUFDSDtBQUNKO0FBRUo7O0FBRUQ7QUFDUTtBQUNQOztBQUVEO0FBQ0E7O0FBRUk7O0FBRUE7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDUTtBQUNBO0FBQ0E7QUFDQTtBQUNQOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVSOzs7Ozs7Ozs7O0FBVVE7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNEO0FBQ0g7QUFDSjtBQUNiOzs7Ozs7Ozs7Ozs7OztBQWNTO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0M7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNMOztBQUVEO0FBQ0E7QUFDQTtBQUFtQjtBQUF3QztBQUNuQztBQUF3QztBQUN4QztBQUF3Qzs7QUFFaEU7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBRUk7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0k7QUFBb0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQWE7QUFBK0I7QUFDMUI7QUFBaUM7QUFDakM7QUFBa0M7QUFDcEQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUFBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUFpQztBQUM3QjtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDRTtBQUF3QztBQUN0QztBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDRTtBQUFzQztBQUMzQztBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUVJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFFSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDs7QUFFSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDs7QUFFRDtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBR0c7QUFDSDs7QUFFRDtBQUVJO0FBQ0g7QUFHRztBQUNIOztBQUVEO0FBRUk7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBNW5DSzs7Ozs7Ozs7OztBQ0FUO0FBQ0E7QUFDSTs7QUFFQTtBQUNDO0FBQ0E7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSUTs7QUFXWjtBQUNJO0FBQ0E7O0FBRUE7QUFDSDtBQUNBOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7O0FBRUk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0g7QUFHRztBQUVJO0FBQ0g7QUFDRDtBQUVJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUVDO0FBQ0E7QUFFQztBQUNBO0FBRUM7QUFDQTtBQUNEO0FBQ0Q7QUFDRTtBQUNIO0FBbEZJOzs7Ozs7Ozs7O0FDRFQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUFM7O0FBVWI7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUk7QUFDSDtBQUdHO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNDO0FBQ0E7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFDSDtBQUdHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0M7QUFDRztBQUNBO0FBQ0g7O0FBRUQ7QUFDQztBQUNHO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBR0U7QUFDQTtBQUNGO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDRztBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIOztBQTVHSTs7Ozs7Ozs7OztBQ0FUO0FBQ0E7QUFDSTs7QUFFQTs7QUFLQTtBQUVDO0FBQ0E7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBRUM7QUFDRztBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7O0FBRUQ7QUFFQzs7QUFFRztBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7O0FBMUNJOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBOztBQWpCSzs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBSlE7O0FBT1o7QUFDSTtBQUNBOztBQUVBO0FBQ0E7QUFFSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7O0FBRUk7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBbkNJOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKUTs7QUFPWjtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBekJLOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0c7QUFDQTtBQUNBO0FBSFM7O0FBTVo7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0M7QUFDTDtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUVJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUVJO0FBRUk7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUdHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBcEhJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNJOztBQUVBO0FBQ0c7QUFEUzs7QUFJWjtBQUNJO0FBQ0g7QUFUSTs7Ozs7Ozs7OztBQ0ZUO0FBQ0k7O0FBRUE7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUUzs7QUFZWjtBQUNBOztBQUlBOztBQUVJO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7OztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQXRESTs7Ozs7Ozs7Ozs7O0FDQVQ7Ozs7OztBQU1BO0FBQWU7QUFBb0o7QUFBQTtBQUFtQjtBQUFrQjtBQUE2QjtBQUEyRDtBQUFtQjtBQUFjO0FBQTBCO0FBQXlDO0FBQUM7QUFBYTtBQUFBO0FBQWdDO0FBQ2pWO0FBQUM7QUFBc0I7QUFBZ0I7QUFBQTtBQUFxQztBQUF1SztBQUE4RDtBQUFpQztBQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQy9aO0FBQTBhO0FBQXNCO0FBQ3hXO0FBQTZEO0FBQTRLO0FBQ2pRO0FBQXFFO0FBQWtCO0FBQTRCO0FBQW9CO0FBQTRCO0FBQW1HO0FBQXJDO0FBQ3RVO0FBRHdlO0FBQzVWO0FBQTRCO0FBQW1DO0FBQW1CO0FBQW1CO0FBQTBCO0FBQTBIO0FBQW9DO0FBQW9DO0FBQXFDO0FBQ3plO0FBQWdDO0FBQ2dIO0FBQTlEO0FBQTZIO0FBQTZCO0FBQW1FO0FBQ3hOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0U7QUFBcEM7QUFBK0w7QUFBZTtBQUFmO0FBQTBEO0FBQWtDO0FBQTBCO0FBQWdEO0FBQUE7QUFBQTtBQUFBO0FBQzdiO0FBQXJCO0FBQWdOO0FBQWxDO0FBQWtGO0FBQTJCO0FBQW1FO0FBQzdVO0FBQXFEO0FBQWlEO0FBQW1FO0FBQ25OO0FBQWtIO0FBQWdEO0FBQW1FO0FBQW9OO0FBQzlhO0FBQWtEO0FBQW1FO0FBQW9UO0FBQ3JiO0FBQWlEO0FBQW1EO0FBQW1FO0FBQW9OO0FBQTRDO0FBQW9EO0FBQzNkO0FBQXNDO0FBQWtUO0FBQ2hTO0FBQW1EO0FBQW1FO0FBQW9OO0FBQ3BWO0FBQXFEO0FBQW1FO0FBQW9UO0FBQzFkO0FBQTBMO0FBQXNEO0FBQW1FO0FBQ2xUO0FBQW1JO0FBQXNEO0FBQW1FO0FBQ3ROO0FBQTRUO0FBQWlEO0FBQW1FO0FBQ2pTO0FBQXFPO0FBQW1EO0FBQzljO0FBQW1CO0FBQW9UO0FBQzlMO0FBQXNEO0FBQW1FO0FBQW9OO0FBQzVSO0FBQTBEO0FBQW1FO0FBQ2pIO0FBQXFKO0FBQ2xDO0FBQWtEO0FBQW1FO0FBQzlhO0FBQTBIO0FBQUE7QUFDMUg7QUFBNkM7QUFBb0Q7QUFBbUU7QUFDN0g7QUFBcUo7QUFDakM7QUFBc0Q7QUFBbUU7QUFBb047QUFBQTtBQUM3RjtBQUF5RDtBQUFtRTtBQUNuUDtBQUEySTtBQUF1RDtBQUNuYjtBQUFvTjtBQUFxRTtBQUF3RDtBQUFtRTtBQUN2YjtBQUFvTjtBQUEySTtBQUF3RDtBQUFtRTtBQUNsUztBQUFxRTtBQUFtRjtBQUE0RDtBQUE4QjtBQUE0QjtBQUE4QjtBQUMvZDtBQUErQjtBQUFtRTtBQUFrVDtBQUFBO0FBQ3paO0FBQXdCO0FBQW5CO0FBQXdHO0FBQXFDO0FBQWlEO0FBQTRCO0FBQW1FO0FBQ2pTO0FBQUE7QUFBQTtBQUFpQjtBQUF3SDtBQUFzRTtBQUFrQztBQUE0RztBQUE2RDtBQUErRTtBQUM5VDtBQUE4QjtBQUE2SztBQUE4QjtBQUNwVDtBQUErQjtBQUFtRTtBQUM1SjtBQUFvSDtBQUFBO0FBQUE7QUFBbU47QUFBOEI7QUFBd0M7QUFBa0Q7QUFDbmM7QUFBZ0Q7QUFBd0M7QUFBa0Q7QUFBa0Q7QUFBZ0Q7QUFBZ0U7QUFBcUM7QUFBaUQ7QUFBNEI7QUFBbUU7QUFDOVQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNUk7QUFBa0M7QUFBZ0g7QUFBK0I7QUFBZ0Q7QUFBb0M7QUFBb0Y7QUFBaEI7QUFDdk07QUFBNkk7QUFBaUI7QUFBOEQ7QUFBMkI7QUFBbUU7QUFDaFQ7QUFBQTtBQUFBO0FBQThDO0FBQWtKO0FBQTJFO0FBQThCO0FBQ2xiO0FBQXdSO0FBQUE7QUFDcEg7QUFBaUI7QUFBaUk7QUFBMkI7QUFBbUU7QUFDaFU7QUFBQTtBQUFBO0FBQXNKO0FBQXlFO0FBQW1FO0FBQ2xTO0FBQUE7QUFBdUo7QUFBaUI7QUFBK0M7QUFBa0U7QUFBdUM7QUFBa0M7QUFBdUM7QUFDMWhCO0FBQXdFO0FBQW1KO0FBQ2xNO0FBQUE7QUFBQTtBQUFzQztBQUE4QjtBQUE2QztBQUF3QjtBQUF1QjtBQUErSDtBQUF3QjtBQUFtQjtBQUN4VDtBQUF5QztBQUErQjtBQUE4SjtBQUE0QztBQUE0RDtBQUFtRTtBQUM1YjtBQUFvTjtBQUFBO0FBQUE7QUFBK047QUFBaUI7QUFDaFo7QUFBMkI7QUFBbUU7QUFBb047QUFBQTtBQUFBO0FBQ3RXO0FBQVk7QUFBMEI7QUFBNEg7QUFBb047QUFDM1E7QUFBMEI7QUFBNkI7QUFBc0I7QUFBNkI7QUFBdUI7QUFBOEI7QUFBb0I7QUFBaUY7QUFBcUI7QUFDMVE7QUFBeUI7QUFBa0c7QUFDbk47QUFBbUw7QUFBMEw7QUFBc0I7QUFBa0c7QUFDOU87QUFBeUQ7QUFBK0k7QUFDMWQ7QUFDUDtBQUF1RjtBQUE4QjtBQUF1RTtBQUF3QjtBQUF1TTtBQUNsSDtBQUE4QjtBQUFWO0FBQTBEO0FBQW1CO0FBQWlEO0FBQW9CO0FBQy9jO0FBQW1CO0FBQW9OO0FBQWdDO0FBQXFCO0FBQWlJO0FBQWtCO0FBQTREO0FBQWtCO0FBQ3BkO0FBQTJCO0FBQTRIO0FBQW9OO0FBQXlGO0FBQUE7QUFDdlQ7QUFBdUk7QUFBMkI7QUFBOEI7QUFBMEI7QUFDOVg7QUFBd0I7QUFBOEI7QUFBb0I7QUFBb0c7QUFBc0I7QUFBbUI7QUFBdUo7QUFBNkI7QUFBd0Y7QUFBWTtBQUNqZ0I7QUFBd0I7QUFBa0c7QUFBdVM7QUFBdUY7QUFDeGY7QUFBbUI7QUFBbUI7QUFBK0Y7QUFBNkw7QUFBdUI7QUFBa0c7QUFDM2I7QUFBc047QUFBaUQ7QUFBd0I7QUFBQTtBQUFrRDtBQUNqVjtBQUFnSTtBQUFxTDtBQUF1RDtBQUM5UztBQUFzQztBQUFxQztBQUFxQztBQUF1QztBQUFxQztBQUFnQztBQUEwQztBQUFrQjtBQUNqUDtBQURpUDtBQUNoTjtBQUE0QjtBQUE1QjtBQUE4TTtBQUF3QjtBQUFjO0FBQTJDO0FBQThCO0FBQ3ZYO0FBQXlHO0FBQTZFO0FBQUM7QUFEa0s7QUFDaks7QUFBb0I7QUFBQTtBQUFpRjtBQUFVO0FBQTRCO0FBQ2xWO0FBQStCO0FBQThCO0FBQTRCO0FBQThDO0FBQTBEO0FBQWM7QUFBcUI7QUFBb0I7QUFBa0M7QUFBb0I7QUFBa0M7QUFBMEI7QUFDdmE7QUFBaUg7QUFBdkI7QUFBdUs7QUFBNEI7QUFBMEY7QUFBbUY7QUFBbUI7QUFBdUI7QUFDamM7QUFBbUw7QUFBa0I7QUFBbEI7QUFBNEM7QUFBNE47QUFDM2U7QUFBa0I7QUFBbEI7QUFBcUM7QUFBYTtBQUE2QjtBQUF1RjtBQUFpQztBQUFPO0FBQVk7QUFBVztBQUFTO0FBQXNEO0FBQU87QUFBUztBQUFXO0FBQU87QUFBdUM7QUFBTztBQUFTO0FBQVc7QUFBTztBQUE4QztBQUFPO0FBQU07QUFBVztBQUFLO0FBQStCO0FBQU87QUFDaGdCO0FBQVc7QUFBTztBQUE2QztBQUFPO0FBQU07QUFBVztBQUFLO0FBQThCO0FBQU87QUFBTTtBQUFXO0FBQUs7QUFBcUM7QUFBbUI7QUFBVTtBQUFXO0FBQXNNO0FBQU87QUFDcGI7QUFBNkc7QUFBUztBQUF1QjtBQUFnRztBQUNwTjtBQUE0QjtBQUE1QjtBQUFzSDtBQUEyQjtBQUFPO0FBQWtKO0FBQTREO0FBQy9YO0FBQWM7QUFBbUI7QUFBa0I7QUFBc0Q7QUFBa0Q7QUFBWTtBQUFpQztBQUEvQjtBQUFtSztBQUEwQjtBQUE4QjtBQUFrRztBQUFpQjtBQUFqSjtBQUNaO0FBQTJCO0FBQTRDO0FBQTVDO0FBQ3pWO0FBQTJCO0FBQWtEO0FBQVk7QUFBaUM7QUFBL0I7QUFBZ0c7QUFBaUM7QUFBNEI7QUFBa0I7QUFBRTtBQUFpQztBQUEyQjtBQUFtQjtBQUFFO0FBQWdDO0FBQW9DO0FBQTJCO0FBQThCO0FBQTlCO0FBQ2xiO0FBQWtDO0FBQUE7QUFBd0M7QUFBb0M7QUFBYztBQUFXO0FBQTBCO0FBQWtHO0FBQzlQO0FBQVU7QUFBK0I7QUFBK0I7QUFBbUI7QUFBUztBQUF5RTtBQUFXO0FBQTRCO0FBQXdFO0FBQTZGO0FBQWM7QUFBcUI7QUFBVTs7Ozs7Ozs7OztBQzVGamQ7QUFDSTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0c7QUFDSTtBQUNIO0FBQ0g7O0FBWEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBO0FBQ0k7O0FBRUE7QUFBeUM7QUFDekM7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBJO0FBU1I7QUFDQTtBQUNJO0FBREo7QUFHQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDSDs7QUE5Q0k7Ozs7Ozs7Ozs7OztBQ0FUOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7QUFLQTs7QUFFSTtBQUVBO0FBRUE7QUFHSDtBQUNHOztBQUVBOzs7Ozs7Ozs7OztBQVVBOztBQUVJOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUhnRDs7QUFNcEQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0g7QUFDRztBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0k7QUFFQTtBQUVIO0FBQ0c7QUFFQTtBQUVIO0FBQ0Q7QUFFQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFFQTtBQUVBO0FBQ0k7QUFDQTtBQUVIO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7O0FBR0E7QUFDQTtBQUdJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBRUE7QUFFQTtBQUF5QjtBQUNyQjtBQUNJO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNIO0FBRUo7O0FBRUQ7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0k7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUdJO0FBQ0k7QUFESjtBQUdIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNJO0FBQ0o7QUFDQTtBQUNJO0FBREo7QUFJSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFFQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUVBOztBQUdBO0FBQ0k7QUFJSDs7QUFHRDtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFBQTtBQUtJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUVEO0FBQ0k7QUFFQTtBQUNIO0FBRUQ7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDSTtBQUNKO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFDSTtBQUxKO0FBT0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBTUg7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBTUg7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0E7QUFHSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBSUo7QUFDSjs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUNIOztBQUVEO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUM3c0NEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7OztBQUtBOztBQUVJO0FBRUE7QUFFQTtBQUdIO0FBQ0c7O0FBRUE7Ozs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFNQTs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhJO0FBS1I7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0k7QUFDQTtBQUNBO0FBSFE7QUFLWjtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDSTtBQUNBO0FBQ0E7QUFIUTtBQUtaO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUFLVDtBQUNJO0FBQ0E7QUFDQTtBQUhJO0FBS1I7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUF2Rkk7O0FBOEZqQjs7Ozs7O0FBTUE7O0FBZ0JBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7QUFJQTtBQUNJOztBQUVBOzs7Ozs7QUFLQTs7QUFFQTs7Ozs7O0FBTUE7O0FBSUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNpQjtBQUE0QjtBQUM1QjtBQUEyQztBQUMzQztBQUEyQztBQUMzQztBQUE4QztBQUUvRDtBQUNBO0FBQ0E7QUFDSTtBQUFNO0FBQThCO0FBQ3hCO0FBQVc7QUFDdkI7QUFDSDtBQUNEO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUlIO0FBQ0o7QUFFTztBQUNIO0FBQ0c7QUFDSDtBQUNSO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBSUg7QUFDRDtBQUVBO0FBQ0g7QUFDRztBQUNBO0FBRUE7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSDs7QUFFRDs7Ozs7QUFLQTs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBekRZOztBQTREaEI7Ozs7QUFJQTtBQUNJOztBQUVBOzs7Ozs7QUFLQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVJOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFFQTs7QUFHQTtBQUdBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBRUE7QUFFSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUE4QztBQUMxQztBQUNJO0FBREo7QUFJQTtBQUNBO0FBQ0g7QUFBNkQ7QUFDMUQ7QUFDSTtBQUVBO0FBRUE7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBRUo7QUFDSjs7QUFFRDs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRVE7QUFESjtBQUdKO0FBRUE7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUVIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUlc7QUFVZjtBQUFBO0FBQUE7QUFHQTtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFFQTtBQUNBO0FBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDSTtBQUNKO0FBQ0o7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUEvQ1I7QUFpREg7QUFDSjtBQUNHO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQVFBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQVlBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBQUE7QUFHQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVIOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ1I7QUFDQTtBQUFjO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDQTtBQUVIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUdJO0FBRUE7QUFDSDtBQUNKOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFBcUI7QUFDakI7QUFDSDtBQUFRO0FBQ0w7QUFDQTtBQUNJO0FBRUE7QUFJSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDQTtBQUNJO0FBTUg7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxTO0FBT2I7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBSUg7QUFDRDtBQUNIO0FBRUQ7QUFFQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUk07QUFVVjtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFhSTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBTEE7QUFNQTtBQUtEO0FBRUE7QUFDSDtBQUVKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0k7QUFESjtBQUdIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMTTtBQU9WO0FBQ0E7O0FBRUk7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUg7O0FBRUc7O0FBRUE7O0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVIOztBQUVHO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUg7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQUE7QUFFQTtBQUNJO0FBRUE7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFHSTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBRk07QUFJVjtBQUNBO0FBRUE7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBR0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQVRSO0FBV0E7QUFDQTtBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUE7QUFDSTtBQUNBO0FBRk07QUFJVjtBQUNBO0FBQ0k7QUFHSTtBQUVBO0FBQ0g7QUFFSjtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVBOzs7O0FBSUE7QUFDSTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7QUFFSDs7QUFFRDs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7OztBQUtBOztBQUVBOzs7Ozs7Ozs7QUFTQTs7QUFFSTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBRUE7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFDSTtBQURKO0FBSUg7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFBQTtBQU1IO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUlIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBQUE7QUFHQTtBQUFzQjtBQUNsQjtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0E7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUVBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOztBQUVJOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUVIOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBR0E7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUVBOztBQUVKO0FBQ0E7QUFDQTtBQUNJO0FBRUE7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFBaUM7QUFDN0I7QUFFUTtBQUNIO0FBQ0c7QUFDSDtBQUdSOztBQUVEO0FBQ0E7QUFDQTtBQUFnQztBQUM1QjtBQUVRO0FBQ0g7QUFDRztBQUNIO0FBR1I7O0FBRUQ7QUFDQTtBQUNJO0FBRUE7O0FBRUo7QUFDQTtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQTZCO0FBQ3pCO0FBQ0E7QUFDSTtBQURKO0FBT0k7QUFDQTtBQUVBO0FBRUE7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQWdDO0FBQzVCO0FBRUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFJSDtBQUNEO0FBQ0E7QUFDSDtBQTNHTDs7QUE4R0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDSTtBQUNKO0FBQ0E7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNBO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBRUE7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFyQ1I7QUF1Q0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBSUE7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFJQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDSTtBQUNBO0FBMUdSO0FBNEdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7O0FBR0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFBOEI7QUFDMUI7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUFnQztBQUM1QjtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBaEZSOztBQW1GQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNO0FBQ0E7O0FBRU47QUFDTTs7QUFFTjtBQUNNOztBQUVOO0FBQ007QUF2QlY7QUF5Qkg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDSTs7QUFHQTtBQUNBOztBQUVJO0FBQUE7O0FBR0E7Ozs7Ozs7OztBQVNBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBREo7QUFHQTtBQUNJO0FBQ0E7QUFHQTtBQUdIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0k7QUFESjtBQUdQO0FBQ0o7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0E7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQURKO0FBSUg7QUFDRDtBQUNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0g7QUFFRDtBQUE0QjtBQUN4QjtBQUNBO0FBQ0k7QUFFQTtBQUNIO0FBRUo7QUFDRDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7O0FBR0E7QUFFUTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFSjtBQUNJOzs7Ozs7Ozs7OztBQVdBOztBQUVKO0FBQ0k7Ozs7Ozs7O0FBUUE7O0FBRUo7QUFDSTs7Ozs7Ozs7QUFRQTtBQUVQO0FBQ1I7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNJO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0E7QUFBQTtBQUVBO0FBQ0k7QUFDSTtBQUlIO0FBTkw7QUFRSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRVM7QUFDQTtBQUlaOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0k7QUFHQTtBQUlBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7QUFJQTtBQUVBO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7O0FBTUE7QUFFSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRUE7QUFDSDtBQU1HO0FBQ1A7O0FBRUQ7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVIO0FBRUo7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFJSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUFBO0FBQ0k7QUFESjtBQUdBO0FBQ0k7QUFDSTtBQUFHO0FBQUg7QUFFQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUlKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUF4QlI7QUEwQkE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFsQlI7QUFvQkE7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFBbUI7QUFDZjtBQUNBO0FBRUE7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUFnQztBQUM1QjtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7QUFFSjtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBRUg7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBSEE7QUFNSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUFzQjtBQUNsQjtBQUVBO0FBRUE7QUFDSDtBQUNEO0FBQ0E7QUFBc0M7QUFDbEM7QUFFQTtBQUNBO0FBQ0k7QUFESjtBQUdIO0FBQ0Q7QUFBaUM7QUFDN0I7QUFDSTtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDRDtBQUNBOztBQUdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBRUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0k7O0FBRUo7QUFDSTtBQUNKO0FBQ0k7QUFsQ1I7QUFvQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUVBO0FBRUE7QUFBcUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0g7QUFDSjtBQUNHO0FBQ0E7QUFDSTtBQUNBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNHO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdBO0FBQ0g7QUFDRztBQUNJO0FBREo7QUFHSDtBQUNKO0FBQ0c7QUFDQTtBQUNJO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNHO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7QUFHQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNJOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUlIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUFBO0FBRUE7QUFDSTtBQURKO0FBSVE7QUFDQTtBQUZtQztBQUkzQztBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0k7O0FBR0E7QUFDQTs7QUFFSTs7Ozs7Ozs7QUFRQTtBQUNJOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNJOztBQUVJO0FBQ0E7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFFSDtBQUNEO0FBRUE7QUFFQTtBQUFxRDtBQUNqRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUFNO0FBQXNEO0FBQzVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBR0g7QUFDSjs7QUFFRDs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7O0FBTUE7QUFFSDtBQUNKOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFFSDs7QUFFRDs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7Ozs7O0FBT0E7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNKO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBR0k7QUFFQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJOztBQUVBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUVRO0FBQ0g7O0FBRUw7QUFDQTtBQUVRO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0g7O0FBRUw7QUFDQTtBQUNBO0FBRVE7QUFDSDtBQUNMO0FBRVE7QUFDSDtBQUNMO0FBRVE7QUFDSDs7QUFFTDtBQUNBO0FBQ0k7QUFDSTtBQUdQOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFFSDs7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBRUg7O0FBRUc7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBRUg7O0FBRUc7QUFDQTtBQUNJO0FBQ0k7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRUg7QUFDRDtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFSjtBQUNHO0FBRVA7O0FBR0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJOztBQUVBOztBQUVBOztBQUVJO0FBRUE7QUFFQTtBQUVIO0FBQTBDOztBQUV2QztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7QUFFQTtBQUNJO0FBQUE7O0FBR0E7QUFBb0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBR0g7O0FBRUc7QUFDSTtBQUNHO0FBQ0g7QUFBa0M7QUFDOUI7QUFDQTtBQUVIO0FBQXlDO0FBQ3RDO0FBQ0E7QUFDSDtBQUVKO0FBRUo7O0FBR0Q7QUFDSTtBQUE4QztBQUMxQztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSTtBQUNKO0FBQ0E7QUFFQTtBQUNJO0FBREo7QUFJSDtBQUNHO0FBR0k7QUFBNEY7QUFBK0I7QUFFM0g7QUFDWDtBQUNEO0FBQ0k7QUFDUDs7QUFFRDs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVRO0FBQ0g7QUFDTDtBQUdBO0FBR0E7QUFHQTs7QUFHQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTs7QUFHQTtBQUE2Qzs7QUFFekM7QUFDSTtBQUNBO0FBQ0g7QUFFSjtBQUF1RDs7QUFFcEQ7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBS0o7O0FBR0Q7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNIO0FBRUo7O0FBRUc7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDSDtBQUNHO0FBRVA7QUFFRztBQUNBO0FBSEc7O0FBT1A7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFJQTtBQUNJO0FBQ0o7QUFFQTtBQUFBO0FBRUE7QUFDSTtBQUdJO0FBQ0E7QUFDSDtBQU5MO0FBUUg7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUVIOztBQUVEOzs7O0FBSUE7QUFDSTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTs7QUFHQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7QUFFQTs7O0FBR0E7QUFDSTtBQUFrQjtBQUFzQztBQUR4Qjs7QUFJcEM7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFFSDtBQUNKO0FBQ0o7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFFQTtBQUNIO0FBTEU7QUFPVjs7QUFFRDs7O0FBR0E7QUFDSTtBQUNIOztBQUVEOzs7O0FBSUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7O0FBSUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDs7QUFFRDs7OztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUNJO0FBREo7QUFFSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFHRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDSTtBQUtBO0FBRVE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQTs7O0FBR0E7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUE7QUFDSTtBQUtBO0FBRVE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7Ozs7Ozs7Ozs7O0FDeG5LRDtBQUNBOztBQUVBOztBQUVJOztBQUdBO0FBQ0E7QUFDSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUVJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBRDJDO0FBRy9DO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFSTtBQUNBO0FBQTZCO0FBQW9COztBQUVqRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFRDtBQUNLO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNHO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBMU5ZOztBQTZOakI7Ozs7Ozs7Ozs7QUNqT0E7QUFDSTs7QUFFQTtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSUzs7QUFXWjtBQUNBOztBQUdBOztBQUVJO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFFSTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUE3R0s7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBOztBQUdBO0FBQ0E7QUFDRztBQUNJO0FBQ0g7QUFDSDs7QUFYSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQURROztBQUlaO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSDs7QUEzQkkiLCJzb3VyY2VzQ29udGVudCI6WyIvL+mfs+S5kOeuoeeQhuWZqFxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYmdtVm9sdW1lOjEuMCxcclxuICAgICAgICBzZnhWb2x1bWU6MS4wLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImdibVZvbHVtZVwiKTtcclxuICAgICAgICBpZih0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLnNldEJHTVZvbHVtZSh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldEJHTVZvbHVtZSgxLjApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNmeFZvbHVtZVwiKTtcclxuICAgICAgICBpZih0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLnNldFNGWFZvbHVtZSh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNGWFZvbHVtZSgxLjApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfSElERSwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbFwiKTtcclxuICAgICAgICAgICAgc2VsZi5zYXZlKClcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfU0hPVywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5hdWRpb0VuZ2luZS5yZXN1bWVBbGxcIik7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIHBsYXk6ZnVuY3Rpb24oY2xpcE5hbWUsbmFtZSxsb29wKSB7XHJcbiAgICAgICAgdmFyIGNsaXBuYW1lID0gXCJfXCIgKyBjbGlwTmFtZVxyXG4gICAgICAgIGlmICghdGhpc1tjbGlwbmFtZV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoJ1NvdW5kLycgKyBjbGlwTmFtZSxjYy5BdWRpb0NsaXAsZnVuY3Rpb24oZXJyLGNsaXApe1xyXG4gICAgICAgICAgICAgICAgc2VsZltjbGlwbmFtZV0gPSBjbGlwXHJcbiAgICAgICAgICAgICAgICBjYy5hdWRpb0VuZ2luZVtuYW1lXShzZWxmW2NsaXBuYW1lXSwgbG9vcCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lW25hbWVdKHRoaXNbY2xpcG5hbWVdLCBsb29wKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYXlCR00gOiBmdW5jdGlvbihjbGlwTmFtZSl7XHJcbiAgICAgICAgaWYgKHRoaXMuYmdtTmFtZSAhPSBjbGlwTmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmdtTmFtZSA9IGNsaXBOYW1lXHJcbiAgICAgICAgICAgIHRoaXMucGxheShjbGlwTmFtZSxcInBsYXlNdXNpY1wiLHRydWUpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwbGF5U0ZYIDogZnVuY3Rpb24oY2xpcE5hbWUpe1xyXG4gICAgICAgIGlmKHRoaXMuc2Z4Vm9sdW1lID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMucGxheShjbGlwTmFtZSxcInBsYXlFZmZlY3RcIixmYWxzZSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJHTVZvbHVtZTpmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmdtVm9sdW1lID0gdmFsdWVcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5zZXRNdXNpY1ZvbHVtZSh2YWx1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QkdNVm9sdW1lOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJnbVZvbHVtZVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTRlhWb2x1bWU6ZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNmeFZvbHVtZSA9IHZhbHVlXHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUuc2V0RWZmZWN0c1ZvbHVtZSh2YWx1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U0ZYVm9sdW1lOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNmeFZvbHVtZVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXVzZUFsbCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlID0gdHJ1ZVxyXG4gICAgICAgIGNjLmF1ZGlvRW5naW5lLnBhdXNlQWxsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZUFsbCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlID0gZmFsc2VcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5yZXN1bWVBbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2F2ZSA6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJnYm1Wb2x1bWVcIix0aGlzLmJnbVZvbHVtZSk7XHJcbiAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic2Z4Vm9sdW1lXCIsdGhpcy5zZnhWb2x1bWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuXHJcbmNjLmF1ZGlvbWFuYWdlciA9IG5ldyBNKCk7IiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG5cclxuICAgICAgICBwYXJlbnROb2RlOiBjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvbkFuaW1Db21wbGV0ZWQ6IGZ1bmN0aW9uKG51bSl7XHJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmdldENvbXBvbmVudChcIlVJUG9rZXJHYW1lXCIpLm9uQW5pbUNvbXBsZXRlZChudW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHRleHQ6Y2MuTGFiZWwsXHJcbiAgICAgICAgZmFjZTpjYy5BbmltYXRpb24sXHJcbiAgICAgICAgZmFjZVNwcml0ZTpjYy5TcHJpdGVcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dUZXh0OmZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIHRoaXMubm9kZS53aWR0aCA9IDIwMFxyXG4gICAgICAgIHRoaXMudGV4dC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLmZhY2Uubm9kZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMudGV4dC5zdHJpbmcgPSBtc2dcclxuICAgICAgICBjYy5sb2coJ3Rlc3Q6JyArIG1zZylcclxuICAgIH0sXHJcbiAgICBzaG93RmFjZSA6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLndpZHRoID0gMjAwXHJcbiAgICAgICAgdGhpcy50ZXh0Lm5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICB0aGlzLmZhY2Uubm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5mYWNlLnBsYXkoXCJmYWNlX1wiICsgaWQpXHJcbiAgICAgICAgLy8gdGhpcy5mYWNlLnNwcml0ZUZyYW1lID0gY2MuZ2FtZW1hbmFnZXIuY3JlYXRlRmFjZShpZClcclxuICAgICAgICAvLyBjYy5sb2coJ3RoaXMuZmFjZS5zcHJpdGVGcmFtZTonICsgdGhpcy5mYWNlLnNwcml0ZUZyYW1lKVxyXG4gICAgfSxcclxuICAgIHNob3dWb2ljZSA6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB0aGlzLm5vZGUud2lkdGggPSA4MFxyXG4gICAgICAgIGNjLmxvZygnY2MuZ2FtZW1hbmFnZXIuc3BlYWtTcHJpdGU6JyArIGNjLmdhbWVtYW5hZ2VyLnNwZWFrU3ByaXRlKVxyXG4gICAgICAgIHRoaXMuZmFjZVNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLmdhbWVtYW5hZ2VyLnNwZWFrU3ByaXRlXHJcbiAgICAgICAgdGhpcy5mYWNlLnN0b3AoKVxyXG4gICAgICAgIHRoaXMudGV4dC5ub2RlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5mYWNlLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIGNjLmltbWFuYWdlci5wbGF5UmVjb3JkKGRhdGEpICAgIFxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcbi8v5L+d5a2Y5LiA5Lqb5a6i5oi356uv6YWN572uXHJcblxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuXHJcbiAgICBjdG9yOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0aGlzLnRlc3RDbGllbnQgPSB0cnVlXHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIxLjZcIlxyXG5cclxuICAgICAgICBpZiAoY2Muc3lzLmlzTW9iaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVzdENsaWVudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJJUCA9IFwiMTE5LjIzLjQzLjE5XCIgLy9cIjExOS4yMy43MS4yMzdcIiBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVySVAgPSBcIjExOS4yMy43MS4yMzdcIiAvL1wiMTE5LjIzLjcxLjIzN1wiIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRlc3RDbGllbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVySVAgPSBcIjExOS4yMy40My4xOVwiIC8vXCIxMTkuMjMuNzEuMjM3XCIgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcklQID0gXCIxMTkuMjMuNzEuMjM3XCIgLy9cIjExOS4yMy43MS4yMzdcIiBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlcnZlclBvcnQgPSA3MDAwXHJcblxyXG4gICAgICAgIHRoaXMubmlja05hbWUxID0gW1xyXG4gICAgICAgICAgICBcIuiKseWRhuKWslwiLCBcIue0q+auh1wiLCBcIuWkj+auh1wiLCBcIuWHieeUn1wiLCBcIuazieecvFwiLFxyXG4gICAgICAgICAgICBcIuOBk+msveiUuVwiLCBcIuaXoOiMg1wiLCBcIuKUiembquWFlFwiLCBcIue0oOmhlFwiLCBcIuegtOabieS4tlwiLFxyXG4gICAgICAgICAgICBcIuKVrua3qeS6glwiLCBcIueXtOW/g8KwXCJcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5pY2tOYW1lMiA9IFtcclxuICAgICAgICAgICAgXCLlmKbmgqhcIiwgXCLlmJ/lmJ9cIiwgXCLpmYzmrofjgIZcIiwgXCLlpLHlv4NcIiwgXCLoi6bmkpFcIixcclxuICAgICAgICAgICAgXCLnrJHpnaVcIiwgXCLlv4Plh4njgptcIiwgXCLmrqTln47jgKRcIiwgXCLlnJ/osapcIixcIumtheees+OBpVwiXHJcbiAgICAgICAgXTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMud25kU2NhbGUgPSBjYy52aWV3LmdldEZyYW1lU2l6ZSgpLmhlaWdodCAvIDcyMDtcclxuXHJcbiAgICAgICAgY2MubG9nKFwiZ2V0RnJhbWVTaXplOiBcIiwgY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aCwgY2Mudmlldy5nZXRGcmFtZVNpemUoKS5oZWlnaHQpXHJcblxyXG4gICAgICAgIC8v5oi/6Ze05aS05YOP5L2N572uKOS7juiHquW3seW8gOWni+mAhuaXtumSiOaWueWQke+8jOmZpOiHquW3seWkluacgOWkmuS6lOWQjeeOqeWutilcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnduZFNjYWxlXHJcbiAgICAgICAgdmFyIHN4ID0gY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aC8yXHJcbiAgICAgICAgdGhpcy5oZWFkSWNvblBvcyA9IFtcclxuICAgICAgICAgICAgW2NjLnYyKDAsIDE4OCldLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMuS6ulxyXG4gICAgICAgICAgICBbY2MudjIoMzAwL3NjYWxlLCAxNjApLCBjYy52MigtMzAwL3NjYWxlLCAxNjApXSwgICAgLy8z5Lq6XHJcbiAgICAgICAgICAgIFtjYy52Migoc3gtNTApL3NjYWxlLCAtNDApLCBjYy52MigwLCAxODgpLCBjYy52MigoLXN4KzUwKS9zY2FsZSwgLTQwKV0sIC8vNOS6ulxyXG4gICAgICAgICAgICBbY2MudjIoKHN4LTUwKS9zY2FsZSwgLTQwKSwgY2MudjIoMzAwL3NjYWxlLCAxNTApLCBjYy52MigtMzAwL3NjYWxlLCAxNTApLCBjYy52MigoLXN4KzUwKS9zY2FsZSwgLTQwKV0gIC8vNeS6ulxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMueXVueWluX3Nka19pZCA9IDEwMDE2NjQ7XHJcblxyXG4gICAgICAgIC8v54mM5Z6L5Zu+54mH6YWN572uXHJcbiAgICAgICAgdGhpcy5wb2tlckZsb3BDZmcgPSBbXHJcbiAgICAgICAgICAgIHtcIm5hbWVcIjpcIuS5jOm+mVwiLCAgXCJzb3VuZF9tYWxlXCI6XCJNX3d1bG9uZ1wiLCBcInNvdW5kX2ZlbWFsZVwiOlwiRl93dWxvbmdcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvd3Vsb25nXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLlr7nlrZBcIiwgIFwic291bmRfbWFsZVwiOlwiTV9kdWl6aVwiLCBcInNvdW5kX2ZlbWFsZVwiOlwiRl9kdWl6aVwiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS9kdWl6aVwifSxcclxuICAgICAgICAgICAge1wibmFtZVwiOlwi5Lik5a+5XCIsICBcInNvdW5kX21hbGVcIjpcIk1fbGlhbmdkdWlcIiwgXCJzb3VuZF9mZW1hbGVcIjpcIkZfbGlhbmdkdWlcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvbGlhbmdkdWlcIn0sXHJcbiAgICAgICAgICAgIHtcIm5hbWVcIjpcIuS4ieadoVwiLCAgXCJzb3VuZF9tYWxlXCI6XCJNX3NhbnRpYW9cIiwgXCJzb3VuZF9mZW1hbGVcIjpcIkZfc2FudGlhb1wiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS9zYW50aWFvXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLpobrlrZBcIiwgIFwic291bmRfbWFsZVwiOlwiTV9zaHVuemlcIiwgXCJzb3VuZF9mZW1hbGVcIjpcIkZfc2h1bnppXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3NodW56aVwifSxcclxuICAgICAgICAgICAge1wibmFtZVwiOlwi5ZCM6IqxXCIsICBcInNvdW5kX21hbGVcIjpcIk1fdG9uZ2h1YVwiLCBcInNvdW5kX2ZlbWFsZVwiOlwiRl90b25naHVhXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3RvbmdodWFcIn0sXHJcbiAgICAgICAgICAgIHtcIm5hbWVcIjpcIuiRq+iKplwiLCAgXCJzb3VuZF9tYWxlXCI6XCJNX2h1bHVcIiwgXCJzb3VuZF9mZW1hbGVcIjpcIkZfaHVsdVwiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS9odWx1XCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLpk4HmlK9cIiwgIFwic291bmRfbWFsZVwiOlwiTV90aWV6aGlcIiwgXCJzb3VuZF9mZW1hbGVcIjpcIkZfdGllemhpXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3RpZXpoaVwifSxcclxuICAgICAgICAgICAge1wibmFtZVwiOlwi5ZCM6Iqx6aG6XCIsXCJzb3VuZF9tYWxlXCI6XCJNX3RvbmdodWFzaHVuXCIsIFwic291bmRfZmVtYWxlXCI6XCJGX3RvbmdodWFzaHVuXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3RvbmdodWFzaHVuXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkupTlkIxcIiwgIFwic291bmRfbWFsZVwiOlwid3V0b25nXCIsIFwic291bmRfZmVtYWxlXCI6XCJ3dXRvbmdcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvd3V0b25nXCJ9LFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8v54m55q6K54mM5Z6L5Zu+54mH6YWN572uXHJcbiAgICAgICAgdGhpcy5zcGVjaWFsRmxvcENmZyA9IFtcclxuICAgICAgICAgICAge1wibmFtZVwiOlwi5pegXCIsICBcInNvdW5kX21hbGVcIjpcIm5vbmVcIiwgXCJzb3VuZF9mZW1hbGVcIjpcIm5vbmVcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvd3Vsb25nXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkuInlkIzoirFcIiwgIFwic291bmRfbWFsZVwiOlwiTV9zYW50b25naHVhXCIsIFwic291bmRfZmVtYWxlXCI6XCJGX3NhbnRvbmdodWFcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvc2FudG9uZ2h1YVwifSxcclxuICAgICAgICAgICAge1wibmFtZVwiOlwi5LiJ6aG65a2QXCIsICBcInNvdW5kX21hbGVcIjpcIk1fc2Fuc2h1bnppXCIsIFwic291bmRfZmVtYWxlXCI6XCJGX3NhbnNodW56aVwiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS9zYW5zaHVuemlcIn0sXHJcbiAgICAgICAgICAgIHtcIm5hbWVcIjpcIuWFreWvueWNilwiLCAgXCJzb3VuZF9tYWxlXCI6XCJNX2xpdWR1aWJhblwiLCBcInNvdW5kX2ZlbWFsZVwiOlwiRl9saXVkdWliYW5cIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvbGl1ZHVpYmFuXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkupTlr7nkuInmnaFcIiwgIFwic291bmRfbWFsZVwiOlwid3VkdWlzYW50aWFvXCIsIFwic291bmRfZmVtYWxlXCI6XCJ3dWR1aXNhbnRpYW9cIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvd3VkdWlzYW50aWFvXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLlm5vlpZfkuInmnaFcIiwgIFwic291bmRfbWFsZVwiOlwic2l0YW9zYW50aWFvXCIsIFwic291bmRfZmVtYWxlXCI6XCJzaXRhb3NhbnRpYW9cIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvc2l0YW9zYW50aWFvXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLlh5HkuIDoibJcIiwgIFwic291bmRfbWFsZVwiOlwiY291eWlzZVwiLCBcInNvdW5kX2ZlbWFsZVwiOlwiY291eWlzZVwiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS9jb3V5aXNlXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLlhajlsI9cIiwgIFwic291bmRfbWFsZVwiOlwicXVhbnhpYW9cIiwgXCJzb3VuZF9mZW1hbGVcIjpcInF1YW54aWFvXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3F1YW54aWFvXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLlhajlpKdcIiwgIFwic291bmRfbWFsZVwiOlwicXVhbmRhXCIsIFwic291bmRfZmVtYWxlXCI6XCJxdWFuZGFcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvcXVhbmRhXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkuInlpZfngrjlvLlcIiwgIFwic291bmRfbWFsZVwiOlwic2FudGFvemhhZGFuXCIsIFwic291bmRfZmVtYWxlXCI6XCJzYW50YW96aGFkYW5cIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvc2FudGFvemhhZGFuXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkuInlkIzoirHpobpcIiwgIFwic291bmRfbWFsZVwiOlwic2FudG9uZ2h1YXNodW5cIiwgXCJzb3VuZF9mZW1hbGVcIjpcInNhbnRvbmdodWFzaHVuXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3NhbnRvbmdodWFzaHVuXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLljYHkuoznmofml49cIiwgIFwic291bmRfbWFsZVwiOlwic2hpZXJodWFuZ3p1XCIsIFwic291bmRfZmVtYWxlXCI6XCJzaGllcmh1YW5nenVcIiwgXCJ0ZXhyZXNcIjpcIlRleHR1cmVzL1Bva2VyU3R5bGUvc2hpZXJodWFuZ3p1XCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLkuIDmnaHpvplcIiwgIFwic291bmRfbWFsZVwiOlwieWl0aWFvbG9uZ1wiLCBcInNvdW5kX2ZlbWFsZVwiOlwieWl0aWFvbG9uZ1wiLCBcInRleHJlc1wiOlwiVGV4dHVyZXMvUG9rZXJTdHlsZS95aXRpYW9sb25nXCJ9LFxyXG4gICAgICAgICAgICB7XCJuYW1lXCI6XCLmuIXpvplcIiwgIFwic291bmRfbWFsZVwiOlwicWluZ2xvbmdcIiwgXCJzb3VuZF9mZW1hbGVcIjpcInFpbmdsb25nXCIsIFwidGV4cmVzXCI6XCJUZXh0dXJlcy9Qb2tlclN0eWxlL3Fpbmdsb25nXCJ9LFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMudXBlcmNhc2VGaWd1cmUgPSBbXCLpm7ZcIixcIuS4gFwiLFwi5LqMXCIsXCLkuIlcIixcIuWbm1wiLFwi5LqUXCIsXCLlha1cIixcIuS4g1wiLFwi5YWrXCIsXCLkuZ1cIixcIuWNgVwiXVxyXG5cclxuICAgICAgICB0aGlzLnN1bW1hcnlwb3MgPSBbXHJcbiAgICAgICAgICAgIFtjYy52MigtMTMwLCA1OCksIGNjLnYyKDEzMCwgNTgpXSwgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBbY2MudjIoLTI2MCwgNTgpLCBjYy52MigwLCA1OCksIGNjLnYyKDI2MCw1OCldLCAgXHJcbiAgICAgICAgICAgIFtjYy52MigtMzkwLCA1OCksIGNjLnYyKC0xMzAsIDU4KSwgY2MudjIoMTMwLDU4KSwgY2MudjIoMzkwLDU4KV0sIFxyXG4gICAgICAgICAgICBbY2MudjIoLTUxMCwgNTgpLCBjYy52MigtMjU1LCA1OCksIGNjLnYyKDAsIDU4KSwgY2MudjIoMjU1LDU4KSxjYy52Mig1MTAsIDU4KV0sICBcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvL+eJjOWei+WQjeWtl++8iDIsM+WiqTXlvKDniYwpXHJcbiAgICAgICAgdGhpcy50NU5hbWUgPSBbXCLkupTlkIxcIixcIuWQjOiKsemhulwiLFwi6ZOB5pSvXCIsXCLokavoiqZcIixcIuWQjOiKsVwiLFwi6aG65a2QXCIsXCLkuInmnaFcIixcIuS4pOWvuVwiLFwi5a+55a2QXCIsXCLkuYzpvplcIl1cclxuICAgICAgICB0aGlzLnQzTmFtZSA9IFtcIuS4ieadoVwiLFwi5a+55a2QXCIsXCLkuYzpvplcIl1cclxuXHJcbiAgICAgICAgLy/miZPmnqrop5LluqYsIGNjLnYyLngg5peL6L2s6KeS5bqmICBjYy52Mi55IHNjYWxlWFxyXG4gICAgICAgIHRoaXMuZHFBbmdsZSA9IFtdXHJcbiAgICAgICAgdGhpcy5kcUFuZ2xlWzNdID0gW1tjYy52MigwLCAxKSwgY2MudjIoLTQ4LCAxKSwgY2MudjIoMCwgLTEpXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYy52MigtMTI2LCAtMSksIGNjLnYyKDAsIDEpLCBjYy52MigtNzAsIC0xKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYy52Mig2MSwxKSwgY2MudjIoMCwxKSwgY2MudjIoMCwxKV1dXHJcblxyXG4gICAgICAgIHRoaXMuZHFBbmdsZVs0XSA9IFtbY2MudjIoMCwxKSwgY2MudjIoMCwxKSwgY2MudjIoLTUwLDEpLCBjYy52MigwLC0xKV0sIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbY2MudjIoLTcwLC0xKSwgY2MudjIoMCwxKSwgY2MudjIoLTEwLC0xKSwgY2MudjIoLTM2LC0xKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYy52MigtMTI1LC0xKSwgY2MudjIoNjUsMSksIGNjLnYyKDAsMSksIGNjLnYyKC02NSwtMSldLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NjLnYyKDY1LDEpLCBjYy52MigzNSwxKSwgY2MudjIoMTAsMSksIGNjLnYyKDAsMSldXVxyXG5cclxuICAgICAgICB0aGlzLmRxQW5nbGVbNV0gPSBbW2NjLnYyKDAsMSksIGNjLnYyKDAsMSksIGNjLnYyKC0xNSwxKSwgY2MudjIoMjIsLTEpLCBjYy52MigwLC0xKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYy52MigtNzAsLTEpLCBjYy52MigwLDEpLCBjYy52Mig2LC0xKSwgY2MudjIoLTE2LC0xKSwgY2MudjIoLTM4LC0xKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYy52MigtMTA0LC0xKSwgY2MudjIoOTAsMSksIGNjLnYyKDAsMSksIGNjLnYyKC0zOSwtMSksIGNjLnYyKC01OSwtMSldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbY2MudjIoOTgsMSksIGNjLnYyKDY5LDEpLCBjYy52MigzNSwxKSwgY2MudjIoMCwxKSwgY2MudjIoLTkwLCAtMSldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbY2MudjIoNzMsMSksIGNjLnYyKDMwLDEpLCBjYy52MigxNiwxKSwgY2MudjIoLTE0LDEpLCBjYy52MigwLDEpXV1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/mnLrlmajkurrlpLTlg49pY29uXHJcbiAgICAgICAgdGhpcy5yb2JvdEhlYWRJY29ucyA9IFtcIlRleHR1cmVzL3JvYm90aGVhZHMvMVwiLCBcIlRleHR1cmVzL3JvYm90aGVhZHMvMlwiLCBcIlRleHR1cmVzL3JvYm90aGVhZHMvM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGV4dHVyZXMvcm9ib3RoZWFkcy80XCIsIFwiVGV4dHVyZXMvcm9ib3RoZWFkcy81XCIsIFwiVGV4dHVyZXMvcm9ib3RoZWFkcy82XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUZXh0dXJlcy9yb2JvdGhlYWRzLzdcIixcIlRleHR1cmVzL3JvYm90aGVhZHMvOFwiLFwiVGV4dHVyZXMvcm9ib3RoZWFkcy85XCIsXCJUZXh0dXJlcy9yb2JvdGhlYWRzLzEwXCJdXHJcbiAgICB9LFxyXG59KTtcclxuXHJcbmNjLmNvbmZpZ21hbmFnZXIgPSBuZXcgTSgpOyIsIi8v5pWw5o2u566h55CG5Zmo77yM5a2Y5YKo5YWo5bGA5pWw5o2uXHJcbnZhciBNID0gY2MuQ2xhc3Moe1xyXG4gICAgXHJcbiAgICBjdG9yOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5uaWNrTmFtZTEgPSBbXHJcbiAgICAgICAgICAgIFwi5LiK5a6YXCIsIFwi5qyn6ZizXCIsIFwi5Lic5pa5XCIsIFwi56uv5pyoXCIsIFwi54us5a2kXCIsXHJcbiAgICAgICAgICAgIFwi5Y+46amsXCIsIFwi5Y2X5a6rXCIsIFwi5aSP5L6vXCIsIFwi6K+46JGbXCIsIFwi55qH55SrXCIsXHJcbiAgICAgICAgICAgIFwi6ZW/5a2ZXCIsIFwi5a6H5paHXCIsIFwi6L2p6L6VXCIsIFwi5Lic6YOtXCIsIFwi5a2Q6L2mXCIsXHJcbiAgICAgICAgICAgIFwi5Lic6ZizXCIsIFwi5a2Q6KiAXCJcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5pY2tOYW1lMiA9IFtcclxuICAgICAgICAgICAgXCLpm4DlnKNcIiwgXCLotYzkvqBcIiwgXCLotYzlnKNcIiwgXCLnqLPotaJcIiwgXCLkuI3ovpNcIixcclxuICAgICAgICAgICAgXCLlpb3ov5BcIiwgXCLoh6rmkbhcIiwgXCLmnInpkrFcIiwgXCLlnJ/osapcIixcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvL+S4u+S6uueJqeWfuuacrOaVsOaNrlxyXG4gICAgICAgIHRoaXMubWFpblBsYXllckRhdGEgPSB7fVxyXG4gICAgICAgIHRoaXMubWFpblBsYXllckRhdGEuY3VpZCA9IDAsXHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YS5uaWNrX25hbWUgPSBcIlwiLFxyXG4gICAgICAgIHRoaXMubWFpblBsYXllckRhdGEucGVuaWQgPSBcIlwiXHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YS5zZXggPSAwXHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YS51cmwgPSBudWxsXHJcbiAgICAgICAgdGhpcy5nbU5vdGljZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhZFVSTCA9IFtdXHJcblxyXG4gICAgICAgIC8v5a2X5L2TXHJcbiAgICAgICAgdGhpcy53aW5GbnQgPSBudWxsXHJcbiAgICAgICAgdGhpcy5sb3NlRm50ID0gbnVsbFxyXG4gICAgICAgIHRoaXMuaGFzT3Blbk5vdGljZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG5hbWUsZGF0YSl7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdKGRhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19Ob3RpY2UgOiBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICBpZiAoZGF0YS50eXBlID09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm1zZ0JveChkYXRhLnRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbU5vdGljZSA9IGRhdGEudGV4dFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT0gMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWNlID0gZGF0YS50ZXh0XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzYXZlUm9vbVNldHRpbmc6ZnVuY3Rpb24oc2V0dGluZyl7XHJcbiAgICAgICAgdGhpcy5yb29tU2V0dGluZyA9IHNldHRpbmdcclxuICAgIH0sXHJcbiAgICBnZXRSb29tU2V0dGluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb21TZXR0aW5nXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVzZXJPcGVuSWQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGlkID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlck9wZW5JZFwiKTtcclxuICAgICAgICBpZihpZCA9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwMDAwKTtcclxuICAgICAgICAgICAgaWQgPSBudW0udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlck9wZW5JZFwiLCBpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlUmFuZG9tTmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5pY2tOYW1lMSA9IGNjLmNvbmZpZ21hbmFnZXIubmlja05hbWUxXHJcbiAgICAgICAgICAgIHZhciBuaWNrTmFtZTIgPSBjYy5jb25maWdtYW5hZ2VyLm5pY2tOYW1lMlxyXG4gICAgICAgICAgICByZXR1cm4gbmlja05hbWUxW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobmlja05hbWUxLmxlbmd0aC0xKSldICsgbmlja05hbWUyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobmlja05hbWUyLmxlbmd0aC0xKSldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXROaWNrTmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbmlja25hbWUgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyTmlja05hbWVcIik7XHJcbiAgICAgICAgaWYobmlja25hbWUgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIG5pY2tuYW1lID0gdGhpcy5jcmVhdGVSYW5kb21OYW1lKClcclxuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlck5pY2tOYW1lXCIsIG5pY2tuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5pY2tuYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSb2JvdEhlYWRJY29uOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBhbGxoZWFkcyA9IGNjLmNvbmZpZ21hbmFnZXIucm9ib3RIZWFkSWNvbnNcclxuICAgICAgICBpZighYWxsaGVhZHMgfHwgYWxsaGVhZHMubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFsbGhlYWRzLmxlbmd0aClcclxuICAgICAgICBpZihpZHggPj0gMCAmJiBpZHggPCBhbGxoZWFkcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYWxsaGVhZHNbaWR4XVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsaGVhZHNbMF1cclxuICAgIH0sXHJcblxyXG4gICAgY29weVRvQ2xpcGJvYXJkIDogZnVuY3Rpb24oc3RyVGV4dCkge1xyXG4gICAgICAgIGlmIChjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwib3JnL2NvY29zMmR4L2phdmFzY3JpcHQvQXBwQWN0aXZpdHlcIiwgXHJcbiAgICAgICAgICAgICAgICBcImNvcHlUb0NsaXBib2FyZFwiLCBcIihMamF2YS9sYW5nL1N0cmluZzspSVwiLCBzdHJUZXh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJBcHBDb250cm9sbGVyXCIsXCJjb3B5VG9DbGlwYm9hcmQ6XCIsc3RyVGV4dClcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MubG9nKCfor6XlubPlj7DkuI3mlK/mjIHlpI3liLY6JyArIHN0clRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkSGVhZEltZyA6IGZ1bmN0aW9uKHVybCxzcCkge1xyXG5cclxuICAgICAgICBpZiAoIXNwIHx8ICF1cmwgfHwgdXJsID09IFwiXCIpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Yqg6L295pys5Zyw5Zu+54mHXHJcbiAgICAgICAgaWYodXJsLmluZGV4T2YoXCJUZXh0dXJlcy9yb2JvdGhlYWRzL1wiKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHVybCwgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICAgICAgc3Auc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNNb2JpbGUpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG5cclxuICAgICAgICB2YXIgdGV4dCA9IG51bGxcclxuICAgICAgICBpZiAodGhpcy5oZWFkVVJMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhlYWRVUkwubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRVUkxbaV0udXJsID09IHVybClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5oZWFkVVJMW2ldLnNwcml0ZUZyYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRVUkwgPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNwLnNwcml0ZUZyYW1lID0gdGV4dFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICAgICAgY2MubG9hZGVyLmxvYWQoe3VybDogdXJsLCB0eXBlOiAncG5nJ30sIGZ1bmN0aW9uKGVyciwgdGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBuZXcgY2MuU3ByaXRlRnJhbWUodGV4KVxyXG4gICAgICAgICAgICAgICAgc3Auc3ByaXRlRnJhbWUgPSBmcmFtZVxyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkVVJMLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHVybDp1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlRnJhbWU6ZnJhbWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjb3JlRm9udDogZnVuY3Rpb24od2luLCBsYWJlbCl7XHJcbiAgICAgICAgbGFiZWwuaXNTeXN0ZW1Gb250VXNlZCA9IGZhbHNlXHJcbiAgICAgICAgbGFiZWwuZm9udFNpemUgPSAzMlxyXG5cclxuICAgICAgICBpZih3aW4pe1xyXG4gICAgICAgICAgICBpZihjYy5kYXRhbWFuYWdlci53aW5GbnQpe1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuZm9udCA9IGNjLmRhdGFtYW5hZ2VyLndpbkZudCAgICAgICBcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyggJ0ZvbnRzL3dpbmZvbnQnLCBmdW5jdGlvbihlcnJvciwgcmVzKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiggZXJyb3IgKSB7IGNjLmxvZyggJ0Vycm9yOiAnICsgZXJyb3IgKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIud2luRm50ID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmZvbnQgPSBjYy5kYXRhbWFuYWdlci53aW5GbnRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKGNjLmRhdGFtYW5hZ2VyLmxvc2VGbnQpe1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuZm9udCA9IGNjLmRhdGFtYW5hZ2VyLmxvc2VGbnQgICAgICAgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoICdGb250cy9sb3NlZm9udCcsIGZ1bmN0aW9uKGVycm9yLCByZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCBlcnJvciApIHsgY2MubG9nKCAnRXJyb3I6ICcgKyBlcnJvciApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgICAgICBjYy5kYXRhbWFuYWdlci5sb3NlRm50ID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmZvbnQgPSBjYy5kYXRhbWFuYWdlci5sb3NlRm50XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG5cclxuY2MuZGF0YW1hbmFnZXIgPSBuZXcgTSgpXHJcbiIsIi8v5ri45oiP566h55CG5Zmo77yM6L+b5YWl5oi/6Ze05ZCO55qE5pWw5o2u5ZKM6YC76L6R566h55CGXHJcbnZhciBNID0gY2MuQ2xhc3Moe1xyXG5cclxuICAgIGN0b3I6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5fcGxheWVycyA9IFtdOyAgICAgLy/miL/pl7Tnjqnlrrbkv6Hmga/vvIzljIXmi6zoh6rlt7FcclxuXHJcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdFBva2VycygpXHJcblxyXG4gICAgICAgIC8vdGhpcy5fY3VycmVudE1hdGNoSWR4ID0gMDsgICAgICAvL+acjeWKoeWZqOWPkeadpeeahOW9k+WJjeesrOWHoOWxgOOAkOWSjOWuouaIt+err+eahOWxgOaVsOS4jeS4gOagt+OAkVxyXG5cclxuICAgICAgICB0aGlzLl9jdXJyZW50Um91bmRzID0gMDsgICAgICAgIC8v5b2T5YmN5piv56ys5Yeg5bGALOWuouaIt+err+S/neWtmOeahOW9k+WJjeWxgFxyXG5cclxuICAgICAgICB0aGlzLm5vcm1hbFByb2Nlc3MgPSBmYWxzZTsgICAgLy/moIforrDmmK/lkKbmraPluLjmtYHnqIvov5jmmK/mjonnur/lkI7lho3kuIrnur/mtYHnqIvvvIjmraPluLjmtYHnqIvlnKjmiL/pl7TopoHngrnlh4blpIfvvIlcclxuXHJcbiAgICAgICAgLy/oh6rlt7HnmoTnirbmgIFcclxuICAgICAgICB0aGlzLl9zZWxmU3RhdHVzID0gMFxyXG5cclxuICAgICAgICAvL+WFtuS7luS6uueahOacgOS9jueKtuaAgVxyXG4gICAgICAgIHRoaXMuX290aGVyU3RhdHVzID0gMFxyXG5cclxuICAgICAgICB0aGlzLmNvaW4gPSAwICAvL+mHkeW4geaVsOmHj1xyXG4gICAgICAgIHRoaXMuZGlhbW9uZCA9IDAgLy/msLTmmbbmlbDph49cclxuXHJcbiAgICAgICAgdGhpcy5tYXRjaFJhbmtzID0gW10gIC8v5L+d5a2Y5q+P5bGA57uT5p2f546p5a6255qE56ev5YiG5pWw5o2uXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXREZWZhdWx0UG9rZXJzOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX215UG9rZXJWYWx1ZXMgPSBbXVxyXG4gICAgICAgIC8vdGhpcy5fbXlQb2tlclZhbHVlcy5wdXNoKFsxOCw0Miw4LDcsNiw1LDM4LDI2LDE3LDI1LDM3LDIxLDE5XSk7ICAgLy/miJHmiYvkuIrnmoTljYHkuInlvKDniYwsIOesrDDlsYDmtYvor5XmlbDmja5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGFjaE1zZzpmdW5jdGlvbihuYW1lLGRhdGEpe1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXSA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpc1tuYW1lXShkYXRhKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8v5Yib5bu65oiW5Yqg5YWl5oi/6Ze06L+U5Zue5oiQ5YqfXHJcbiAgICBQdWJsaWNQcm90b19TX0cxM19Sb29tQXR0cjpmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGlmIChtc2cucm9vbV9jb2RlICE9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJvb21faW5mbyA9IG1zZ1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVTdGFydCgpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIt+aWsOaIv+mXtOeOqeWutuaVsOaNrlxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfUGxheWVyc0luUm9vbTogZnVuY3Rpb24obXNnKXtcclxuICAgICAgICBjYy5sb2coXCLmlLbliLDliqDlhaXmiL/pl7Tmtojmga8gc2l6ZSA9XCIgKyBtc2cucGxheWVycy5sZW5ndGgsIFwicm91bmRzID0gXCIsIG1zZy5yb3VuZHMpO1xyXG4gICAgICAgIHRoaXMuX3BsYXllcnMgPSBtc2cucGxheWVyc1xyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIuZGlzcGFjaE1zZyhcIm9uUGxheWVySW5Sb29tXCIsIHRoaXMuX3BsYXllcnMpO1xyXG5cclxuICAgICAgICB0aGlzLl9vdGhlclN0YXR1cyA9IDVcclxuICAgICAgICB2YXIgc2VsZkN1aWQgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5jdWlkXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5wbGF5ZXJzLmxlbmd0aDsgKytpKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwZGF0YSA9IG1zZy5wbGF5ZXJzW2ldXHJcbiAgICAgICAgICAgIHZhciByYW5rID0ge1wiY3VpZFwiOnBkYXRhLmN1aWQsIFwicmFua1wiOnBkYXRhLnJhbmt9XHJcblxyXG4gICAgICAgICAgICBpZighdGhpcy5tYXRjaFJhbmtzW21zZy5yb3VuZHNdKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hSYW5rc1ttc2cucm91bmRzXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXRjaFJhbmtzW21zZy5yb3VuZHNdLnB1c2gocmFuaylcclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBpZihwZGF0YS5jdWlkLmVxKHNlbGZDdWlkKSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxmU3RhdHVzID0gcGRhdGEuc3RhdHVzXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihwZGF0YS5zdGF0dXMgPCB0aGlzLl9vdGhlclN0YXR1cyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdGhlclN0YXR1cyA9IHBkYXRhLnN0YXR1c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iOt+WPluW9k+WJjeWxgOeOqeWutueahOenr+WIhuaVsOaNrlxyXG4gICAgZ2V0Q3VyTWF0Y2hSYW5rOiBmdW5jdGlvbihjdWlkKXtcclxuICAgICAgICBpZighdGhpcy5tYXRjaFJhbmtzIHx8ICF0aGlzLm1hdGNoUmFua3NbdGhpcy5fY3VycmVudFJvdW5kc10pe1xyXG4gICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm1hdGNoUmFua3NbdGhpcy5fY3VycmVudFJvdW5kc11cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKGRhdGFbaV0uY3VpZC5lcShjdWlkKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpXS5yYW5rXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDBcclxuICAgIH0sXHJcblxyXG4gICAgLy/liLfmlrDnjqnlrrbotKfluIHmlbDmja5cclxuICAgIFB1YmxpY1Byb3RvX1NfUGxheWVyQmFzaWNEYXRhOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIHRoaXMuY29pbiA9IG1zZy5tb25leTFcclxuICAgICAgICB0aGlzLmRpYW1vbmQgPSBtc2cubW9uZXlcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLmRpc3BhY2hNc2coXCJyZWZyZXNoTWFpblBsYXllck1vbmV5XCIpXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBsYXllciA6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgY2MubG9nKFwidGhpcy5fcGxheWVycy5sZW5ndGg6XCIgKyB0aGlzLl9wbGF5ZXJzLmxlbmd0aClcclxuICAgICAgICBpZiAodGhpcy5fcGxheWVycylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGxheWVycy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXllcnNbaV0uY3VpZC5lcShpZCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXllcnNbaV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICBtYWluUGxheWVyIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGxheWVyKGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWQpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5ri45oiP5byA5aeL6LCD55SoXHJcbiAgICBnYW1lU3RhcnQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZih0aGlzLnJvb21faW5mbyAmJiBjYy5kaXJlY3Rvci5nZXRTY2VuZSgpLm5hbWUgPT0gXCJNYWluXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5zY2VuZW1hbmFnZXIubG9hZFBva2VyR2FtZVNjZW5lKClcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zcGVha1Nwcml0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgICAgICAgICBjYy5sb2FkZXIubG9hZFJlcygnVGV4dHVyZXMvc3BlYWsnLCBjYy5TcHJpdGVGcmFtZSwgZnVuY3Rpb24oZXJyLCBzcHJpdGVGcmFtZSl7IFxyXG4gICAgICAgICAgICAgICAgICAgc2VsZi5zcGVha1Nwcml0ZSA9IHNwcml0ZUZyYW1lXHJcbiAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhpcy5fZmFjZXMgPSBbXVxyXG4gICAgICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDE7IGkgPD0gMTU7ICsraSlcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgaW5kZXggPSBpXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcyA9IHNlbGZcclxuICAgICAgICAgICAgLy8gICAgIHZhciBmdW5jID0gZnVuY3Rpb24oZXJyLHNmKXtcclxuICAgICAgICAgICAgLy8gICAgICAgICBzLl9mYWNlc1tpbmRleCAtIDFdID0gc2ZcclxuICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgLy8gICAgIGNjLmxvYWRlci5sb2FkUmVzKCdUZXh0dXJlcy9leHByZXNzaW9uJyArIGluZGV4LGNjLlNwcml0ZUZyYW1lLGZ1bmMpXHJcbiAgICAgICAgICAgIC8vICAgICB9KSgpXHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5ri45oiP57uT5p2f6LCD55SoXHJcbiAgICBnYW1lT3ZlciA6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBjYy5sb2coXCJnYW1lT3Zlcuiwg+eUqO+8ge+8gWdhbWVPdmVy6LCD55So77yB77yBZ2FtZU92ZXLosIPnlKjvvIHvvIFnYW1lT3Zlcuiwg+eUqO+8ge+8gVwiKVxyXG5cclxuICAgICAgICB0aGlzLnJvb21faW5mbyA9IG51bGxcclxuICAgICAgICB0aGlzLl9wbGF5ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFJvdW5kcyA9IDA7XHJcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdFBva2VycygpXHJcbiAgICAgICAgdGhpcy5hbGxSb3VuZHNEYXRhID0gW11cclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWxQcm9jZXNzID0gZmFsc2VcclxuICAgICAgICB0aGlzLl9zZWxmU3RhdHVzID0gMFxyXG4gICAgICAgIHRoaXMuX290aGVyU3RhdHVzID0gMFxyXG4gICAgICAgIHRoaXMubWF0Y2hSYW5rcyA9IFtdXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9mYWNlcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLl9mYWNlc1tpXSlcclxuICAgICAgICAvLyAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgY2MubG9hZGVyLnJlbGVhc2VBc3NldCh0aGlzLl9mYWNlc1tpXSlcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB0aGlzLl9mYWNlcyA9IG51bGxcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vIGNyZWF0ZUZhY2U6ZnVuY3Rpb24oZmFjZWlkKXtcclxuICAgIC8vICAgICBpZiAodGhpcy5fZmFjZXMgJiYgZmFjZWlkIDw9IHRoaXMuX2ZhY2VzLmxlbmd0aClcclxuICAgIC8vICAgICB7XHJcbiAgICAvLyAgICAgICAgIHZhciBwcmVmYWIgPSB0aGlzLl9mYWNlc1tmYWNlaWQgLSAxXVxyXG4gICAgLy8gICAgICAgICBjYy5sb2coJ3ByZWZhYjonICsgcHJlZmFiKVxyXG4gICAgLy8gICAgICAgICByZXR1cm4gY2MuaW5zdGFudGlhdGUocHJlZmFiKVxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICByZXR1cm4gbnVsbFxyXG4gICAgLy8gfSxcclxuXHJcbiAgICAvL+iOt+WPluW9k+WJjeWxgOeahDEz5byg54mMXHJcbiAgICBnZXRDdXJNYXRoUG9rZXJzOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwb2tlcnMgPSB0aGlzLl9teVBva2VyVmFsdWVzW3RoaXMuX2N1cnJlbnRSb3VuZHNdXHJcbiAgICAgICAgaWYoIXBva2Vycyl7XHJcbiAgICAgICAgICAgIHJldHVybiBbXVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gcG9rZXJzXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHJpbnRBcnJheTogZnVuY3Rpb24oYSl7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCJcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHN0ciArPSAoYVtpXS50b1N0cmluZygpICsgXCIgIFwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5sb2coc3RyKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aUtuWIsOWPkeeJjOa2iOaBr1xyXG4gICAgUHVibGljUHJvdG9fU19HMTNfSGFuZE9mTWluZTogZnVuY3Rpb24obXNnKXtcclxuICAgICAgICBjYy5sb2coXCLmlLbliLDlj5HniYzmtojmga8sIOeJjOaVsOmHjyA9IFwiICsgbXNnLmNhcmRzLmxlbmd0aClcclxuICAgICAgICB0aGlzLl9wcmludEFycmF5KG1zZy5jYXJkcylcclxuXHJcbiAgICAgICAgaWYobXNnLmNhcmRzLmxlbmd0aCAhPSAxMyl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIueJjOaVsOaNruS4jeWvue+8gVwiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNjLmxvZyhcIuesrFwiK21zZy5yb3VuZHMrXCLlsYBcIilcclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX215UG9rZXJWYWx1ZXMubGVuZ3RoXHJcblxyXG4gICAgICAgIHRoaXMuX215UG9rZXJWYWx1ZXNbbXNnLnJvdW5kc10gPSBtc2cuY2FyZHNcclxuXHJcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFJvdW5kcyA9PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJvdW5kcyA9IG1zZy5yb3VuZHNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMubm9ybWFsUHJvY2VzcyA9PSB0cnVlICYmIGxlbiA9PSAwKXsgICAgIC8v5byA5aeL56ys5LiA5oqKXHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIuZGlzcGFjaE1zZyhcIm5ld01hdGNoU3RhcnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aUtuWIsOaAu+e7k+eul+a2iOaBr1xyXG4gICAgUHVibGljUHJvdG9fU19HMTNfQWxsUm91bmRzOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGNjLmxvZyhcIuaUtuWIsOaAu+e7k+eul+a2iOaBr1wiKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWxsUm91bmRzRGF0YSA9IG1zZy5wbGF5ZXJzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+aWsOeahOS4gOWxgFxyXG4gICAgbmV4dE1hdGNoOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRSb3VuZHMgPiB0aGlzLnJvb21faW5mby5hdHRyLnJvdW5kcyl7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KFwi54mM5bGA57uT5p2fXCIpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50Um91bmRzKytcclxuICAgICAgICB2YXIgcm9vdCA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZVwiKVxyXG4gICAgICAgIHJvb3QuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIikubmV3TWF0Y2hTdGFydCgpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5oqV56Wo5Y2P6K6uXHJcbiAgICBQdWJsaWNQcm90b19TX0cxM19BYm9ydEdhbWVPck5vdDogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICB0aGlzLnZvdGVJbmZvID0gbXNnIFxyXG4gICAgICAgY2MuZ3VpbWFuYWdlci5zaG93T3JPcGVuVUkoJ1VJVm90ZScpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5oqV56Wo5aSx6LSlXHJcbiAgICBQdWJsaWNQcm90b19TX0cxM19Wb3RlRmFpbGVkOiBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgIGNjLmd1aW1hbmFnZXIuY2xvc2VCeU5hbWUoJ1VJVm90ZScpXHJcbiAgICAgICB2YXIgbmFtZSA9IGNjLmdhbWVtYW5hZ2VyLmdldFBsYXllcihtc2cub3Bwb25lbnQpLm5hbWVcclxuICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCfnjqnlrrY6Jy5jb25jYXQobmFtZSwnLOS4jeWQjOaEjyzmipXnpajmnKrpgJrov4cs5ri45oiP57un57ut44CCJykpXHJcbiAgICB9LFxyXG5cclxuICAgIGdpdmV1cCA6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19HMTNfR2l2ZVVwXCIpXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgIH0sXHJcblxyXG4gICAgICAgIC8v5piv5ZCm5Zyo57uD5Lmg5oi/6Ze0XHJcbiAgICBpc1ByYWN0aWNlUm9vbTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb29tX2luZm8gJiYgdGhpcy5yb29tX2luZm8ucm9ib3RcclxuICAgIH0sXHJcbiAgICBcclxufSk7XHJcblxyXG5jYy5nYW1lbWFuYWdlciA9IG5ldyBNKClcclxuIiwicmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgdGltZTogY2MuTGFiZWwsXHJcbiAgICAgICBjb3VudDogY2MuTGFiZWwsXHJcbiAgICAgICBiaWdKc1BhbmVsOiBjYy5QcmVmYWIsXHJcbiAgICAgICB0aW1lY2Q6IGNjLlJpY2hUZXh0LFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLmNkID0gMTIwXHJcbiAgICAgICAgdGhpcy5ub2RlLnJ1bkFjdGlvbihjYy5yZXBlYXRGb3JldmVyKGNjLnNlcXVlbmNlKGNjLmRlbGF5VGltZSgxLjApLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQsIHBhcmFtKXtcclxuICAgICAgICAgICAgcGFyYW0uY2QgPSBwYXJhbS5jZCAtIDFcclxuXHJcbiAgICAgICAgICAgIHZhciByb29tQXR0cj0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHJcclxuICAgICAgICAgICAgcGFyYW0udGltZWNkLnN0cmluZyA9IFwiPGNvbG9yPSNGRjAwMDA+XCIgKyBwYXJhbS5jZC50b1N0cmluZygpICsgXCI8L2M+56eS5ZCO6Ieq5Yqo56a75byAXCJcclxuICAgICAgICAgICAgaWYocGFyYW0uY2QgPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5jbG9zZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLCB0aGlzKSkpKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZUdhbWVSZXN1bHQ6IGZ1bmN0aW9uKGRhdGEpe1xyXG5cclxuICAgICAgICB2YXIgcGxheWVyTnVtID0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemVcclxuICAgICAgICB0aGlzLmNvdW50LnN0cmluZyA9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnJvdW5kcy50b1N0cmluZygpICsgXCLlsYBcIlxyXG5cclxuICAgICAgICBpZighZGF0YSl7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJpZ2dlc3RTY29yZSA9IC0xMDAwMFxyXG4gICAgICAgIHZhciBzbWFsbFNvY3JlID0gMTAwMDBcclxuICAgICAgICB2YXIgcGFuZWxMaXN0ID0gW11cclxuXHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImNvbnRhaW5lclwiKVxyXG4gICAgICAgIHZhciBwb3NlcyA9IGNjLmNvbmZpZ21hbmFnZXIuc3VtbWFyeXBvc1twbGF5ZXJOdW0tMl1cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGxheWVyTnVtOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMuYmlnSnNQYW5lbClcclxuICAgICAgICAgICAgdmFyIGNvbSA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiYmlnSnNQYW5lbFwiKVxyXG4gICAgICAgICAgICBjb20uaW5pdChkYXRhW2ldKVxyXG5cclxuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IGNjLnYyKDAsMClcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjb250YWluZXJcclxuICAgICAgICAgICAgLy9ub2RlLnBvc2l0aW9uID0gcG9zZXNbaV1cclxuICAgICAgICAgICAgcGFuZWxMaXN0LnB1c2goY29tKVxyXG5cclxuICAgICAgICAgICAgdmFyIHJhbmsgPSBkYXRhW2ldLnJhbmtcclxuICAgICAgICAgICAgaWYoIHJhbmsgPiBiaWdnZXN0U2NvcmUpe1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdFNjb3JlID0gcmFua1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHJhbmsgPCBzbWFsbFNvY3JlKXtcclxuICAgICAgICAgICAgICAgIHNtYWxsU29jcmUgPSByYW5rXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWQuZXEoZGF0YVtpXS5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICBpZihyYW5rID4gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJ3aW5cIilcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHJhbmsgPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheVNGWChcImxvc2VcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY3Vyd2lkdGggPSBmcmFtZWhlaWdodC83MjAqMTI4MFxyXG4gICAgICAgIC8vc2FjbGUgPSBmcmFtZXdpZHRoL2N1cndpZHRoID0gZnJhbWV3aWR0aC8oMTI4MCpmcmFtZWhlaWd0aC83MjApXHJcbiAgICAgICAgdmFyIHNjYWxlID0gY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aCAvICgxLjgqY2Mudmlldy5nZXRGcmFtZVNpemUoKS5oZWlnaHQpXHJcbiAgICAgICAgY29udGFpbmVyLnNjYWxlID0gc2NhbGVcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBsYXllck51bTsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcGFuZWxMaXN0W2ldLnNldFN0YXRlKGZhbHNlLCBmYWxzZSkgICBcclxuICAgICAgICAgICAgaWYoZGF0YVtpXS5yYW5rID09IGJpZ2dlc3RTY29yZSAmJiBiaWdnZXN0U2NvcmUgPiAwKXtcclxuICAgICAgICAgICAgICAgIHBhbmVsTGlzdFtpXS5zZXRTdGF0ZSh0cnVlLCBmYWxzZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmKGRhdGFbaV0ucmFuayA9PSBzbWFsbFNvY3JlICYmIHNtYWxsU29jcmUgPCAwKXtcclxuICAgICAgICAgICAgLy8gICAgcGFuZWxMaXN0W2ldLnNldFN0YXRlKGZhbHNlLCB0cnVlKVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGltZS5zdHJpbmcgPSB0aGlzLmdldE5vd0Zvcm1hdERhdGUoKS50b1N0cmluZygpXHJcbiAgICB9LFxyXG5cclxuICAgIHNoYXJlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbignVUlTaGFyZScsZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRUeXBlKDEpICAgXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIWNjLmdhbWVtYW5hZ2VyLmlzUHJhY3RpY2VSb29tKCkpe1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coXCJQdWJsaWNQcm90by5DX0cxM19HaXZlVXBcIilcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5kZXN0cm95KClcclxuICAgICAgICBjYy5zY2VuZW1hbmFnZXIubG9hZE1haW5TY2VuZSgpXHJcbiAgICB9LFxyXG5cclxuICAgIGdldE5vd0Zvcm1hdERhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIMKgwqDCoMKgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgwqDCoMKgwqB2YXIgc2VwZXJhdG9yMSA9IFwiLVwiO1xyXG4gICAgwqDCoMKgwqB2YXIgc2VwZXJhdG9yMiA9IFwiOlwiO1xyXG4gICAgwqDCoMKgwqB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xyXG4gICAgwqDCoMKgwqB2YXIgc3RyRGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xyXG4gICAgwqDCoMKgwqBpZiAobW9udGggPj0gMSAmJiBtb250aCA8PSA5KSB7XHJcbiAgICDCoMKgwqDCoMKgwqDCoMKgbW9udGggPSBcIjBcIiArIG1vbnRoO1xyXG4gICAgwqDCoMKgwqB9XHJcbiAgICDCoMKgwqDCoGlmIChzdHJEYXRlID49IDAgJiYgc3RyRGF0ZSA8PSA5KSB7XHJcbiAgICDCoMKgwqDCoMKgwqDCoMKgc3RyRGF0ZSA9IFwiMFwiICsgc3RyRGF0ZTtcclxuICAgIMKgwqDCoMKgfVxyXG4gICAgwqDCoMKgwqB2YXIgY3VycmVudGRhdGUgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyBzZXBlcmF0b3IxICsgbW9udGggKyBzZXBlcmF0b3IxICsgc3RyRGF0ZVxyXG4gICAgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgKyBcIiBcIiArIGRhdGUuZ2V0SG91cnMoKSArIHNlcGVyYXRvcjIgKyBkYXRlLmdldE1pbnV0ZXMoKVxyXG4gICAgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgKyBzZXBlcmF0b3IyICsgZGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICDCoMKgwqDCoHJldHVybiBjdXJyZW50ZGF0ZTtcclxuICAgIH0gXHJcblxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJcclxudmFyIE0gPSBjYy5DbGFzcyh7XHJcblxyXG4gICAgY3RvciA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB7fVxyXG4gICAgICAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG5hbWUsbXNnZGF0YSl7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucGFuZWxzKXtcclxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhbmVsc1trZXldXHJcbiAgICAgICAgICAgIGlmIChsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8bGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbGlzdFtpXVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcFtuYW1lXSA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcFtuYW1lXShtc2dkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgfSxcclxuXHJcbiAgIG9wZW46ZnVuY3Rpb24obmFtZSxjYWxsLGJ2aXNpYmxlKXtcclxuICAgIHZhciBzZWxmID0gdGhpc1xyXG5cclxuICAgIGNjLmxvYWRlci5sb2FkUmVzKCdHdWkvJyArIG5hbWUsZnVuY3Rpb24oZXJyLHByZWZhYikge1xyXG4gICAgICAgIGlmIChwcmVmYWIgIT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcInByZWZhYiBsb2FkIHN1Y2Nlc3MgXCIsIHByZWZhYilcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHByZWZhYilcclxuICAgICAgICAgICAgb2JqLnBhcmVudCA9IGNjLmRpcmVjdG9yLmdldFNjZW5lKClcclxuICAgICAgICAgICAgdmFyIHBhbmVsID0gb2JqLmdldENvbXBvbmVudChjYy51aXBhbmVsKTtcclxuICAgICAgICAgICAgdmFyIGxpc3QgPSBzZWxmLnBhbmVsc1tuYW1lXVxyXG4gICAgICAgICAgICBjYy5sb2coJ29wZW4gbGlzdDonICsgbGlzdClcclxuICAgICAgICAgICAgaWYgKCFsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coJ2FkZCBsaXN0OicgKyBuYW1lKVxyXG4gICAgICAgICAgICAgICAgbGlzdCA9IFtdXHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsc1tuYW1lXSA9IGxpc3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBwYW5lbC5vbkNyZWF0ZSgpXHJcbiAgICAgICAgICAgIGlmIChidmlzaWJsZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBwYW5lbC5zZXRWaXNpYmxlKHRydWUpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc2V0VmlzaWJsZShidmlzaWJsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy/nibnmrorlpITnkIblsYLnuqdcclxuICAgICAgICAgICAgaWYobmFtZSA9PSBcIlVJVm90ZVwiIHx8IG5hbWUgPT0gXCJVSU1lc3NhZ2VCb3hcIiB8fCBuYW1lID09IFwiVUlXYWl0aW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgaWYocGFuZWwgJiYgcGFuZWwubm9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwubm9kZS56SW5kZXggPSAxMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaXN0LnB1c2gocGFuZWwpXHJcblxyXG4gICAgICAgICAgICAgaWYgKGNhbGwgIT0gbnVsbCkgICAvL+aUvuWcqHNlbGYucGFuZWxzIGFkZOS5i+WQju+8jOebrueahOS4uuS6hmNhbGxiYWNr5YaF5Y+v5LulZGlzcGF0Y2ggbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgY2FsbChwYW5lbClcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcGFuZWxcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MubG9nKCdvcGVuIHBhbmVsIGZhaWw6JyArIG5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgfSxcclxuXHJcbiAgIHNob3dPck9wZW5VSTpmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgdmFyIHBhbmVsID0gdGhpcy5nZXRCeU5hbWUobmFtZSlcclxuICAgICAgICBpZiAocGFuZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRWaXNpYmxlKHRydWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbihuYW1lLG51bGwsdHJ1ZSlcclxuICAgICAgICB9XHJcbiAgIH0sXHJcblxyXG4gICBtc2dCb3ggOiBmdW5jdGlvbihtc2csZnVuYykge1xyXG4gICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJtc2dib3hcIilcclxuICAgICAgICB0aGlzLm9wZW4oJ1VJTWVzc2FnZUJveCcsZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRNZXNzYWdlKG1zZylcclxuICAgICAgICAgICAgcGFuZWwuc2V0Q2FsbChmdW5jKVxyXG4gICAgICAgIH0pXHJcbiAgIH0sXHJcblxyXG4gICBtc2dCb3hXaXRoQ2FuY2VsOiBmdW5jdGlvbihtc2csIGZ1bmMsIGNhbmNlbGZ1bmMpe1xyXG4gICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJtc2dib3hcIilcclxuICAgICAgICB0aGlzLm9wZW4oXCJVSU1lc3NhZ2VCb3hcIiwgZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRNZXNzYWdlKG1zZylcclxuICAgICAgICAgICAgcGFuZWwuc2V0Q2FsbChmdW5jKVxyXG4gICAgICAgICAgICBwYW5lbC5zZXRDYW5jZWxDYWxsKGNhbmNlbGZ1bmMpXHJcbiAgICAgICAgfSlcclxuICAgfSxcclxuXHJcbiAgIHdhaXQgOiBmdW5jdGlvbihtc2cpIHtcclxuICAgIGNjLmxvZyhtc2cpXHJcbiAgICB0aGlzLm9wZW4oJ1VJV2FpdGluZycsZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgIHBhbmVsLnNldE1lc3NhZ2UobXNnKVxyXG4gICAgfSk7XHJcbiAgIH0sXHJcblxyXG4gICBjbG9zZVdhaXQgOiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5jbG9zZUJ5TmFtZSgnVUlXYWl0aW5nJylcclxuICAgfSxcclxuXHJcbiAgIGRlc3Ryb3lQYW5lbDpmdW5jdGlvbihwYW5lbCl7XHJcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLm5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYW5lbC5vbkNsb3NlKClcclxuICAgICAgICAgICAgcGFuZWwubm9kZS5kZXN0cm95KClcclxuXHJcbiAgICAgICAgICAgIGNjLmxvZyhcImRlc3Ryb3lQYW5lbCBkZXN0cm95UGFuZWwgZGVzdHJveVBhbmVsXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgIGNsb3NlOmZ1bmN0aW9uKHBhbmVsKXtcclxuICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wYW5lbHMpXHJcbiAgICAge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5wYW5lbHNba2V5XVxyXG4gICAgICAgIGlmIChsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTtpID49IDA7IC0taSlcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldID09IHBhbmVsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVBhbmVsKHBhbmVsKVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZyhcImFmdGVyIGRlc3Ryb3kgcGFuZWxcIiwgbGlzdCwgbGlzdC5sZW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZygnbGlzdC5jb3VudDonICsgbGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwxKVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZygnc3BsaWNlIGxpc3QuY291bnQ6JyArIGxpc3QubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW2tleV0gPSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ5TmFtZTpmdW5jdGlvbihwYW5lbE5hbWUpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucGFuZWxzW3BhbmVsTmFtZV1cclxuICAgICAgICBjYy5sb2coJ2dldEJ5TmFtZScpXHJcbiAgICAgICAgaWYgKGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFswXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgY2xvc2VCeU5hbWU6ZnVuY3Rpb24ocGFuZWxOYW1lKXtcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucGFuZWxzW3BhbmVsTmFtZV1cclxuICAgICAgICBjYy5sb2coJ2JlZ2luIGNsb3NlQnluYW1lOicgKyBwYW5lbE5hbWUpXHJcbiAgICAgICAgaWYgKGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGlzdC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95UGFuZWwobGlzdFtpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbE5hbWVdID0gW11cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb3NlQWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucGFuZWxzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coJ2tleTonICsga2V5KVxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhbmVsc1trZXldXHJcbiAgICAgICAgICAgICAgICBjYy5sb2coJ2xpc3Q6JyArIGxpc3QpXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coJ2xpc3QubGVuZ3RoOicgKyBsaXN0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGlzdC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLmxvZygnZGVzdHJveVBhbmVsOicgKyBsaXN0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95UGFuZWwobGlzdFtpXSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYW5lbHMgPSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5sb2coJ291dCEnKVxyXG4gICAgfVxyXG59KTtcclxuY2MuZ3VpbWFuYWdlciA9IG5ldyBNKCk7XHJcblxyXG5cclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsaWNrSGVhZDogZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5sb2coXCJvbkNsaWNrSGVhZCAgXCIsIHRoaXMubm9kZS5jdWlkKVxyXG5cclxuICAgICAgICB2YXIgcG9rZXJzb3J0ID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyU29ydFwiKVxyXG4gICAgICAgIGlmKHBva2Vyc29ydCl7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5ub2RlLmN1aWQgJiYgdGhpcy5ub2RlLmN1aWQgIT0gMCl7XHJcbiAgICAgICAgICAgIHZhciBwbGF5ZXIgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIodGhpcy5ub2RlLmN1aWQpXHJcbiAgICAgICAgICAgIGlmKHBsYXllciAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbihcIlVJVXNlcklwXCIsIGZ1bmN0aW9uKHBhbmVsKXtcclxuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXRVc2VySW5mbyhwbGF5ZXIpXHJcbiAgICAgICAgICAgICAgICB9KSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25DbGlja1VJTWFpbkhlYWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHBva2Vyc29ydCA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS9Qb2tlclNvcnRcIilcclxuICAgICAgICAgICAgaWYocG9rZXJzb3J0KXtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGxheWVyRGF0YSA9IHt9XHJcbiAgICAgICAgICAgIHBsYXllckRhdGEuY3VpZCA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWRcclxuICAgICAgICAgICAgcGxheWVyRGF0YS5uYW1lID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEubmlja19uYW1lXHJcbiAgICAgICAgICAgIHBsYXllckRhdGEuaW1ndXJsID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEudXJsXHJcbiAgICAgICAgICAgIHBsYXllckRhdGEuaXBzdHIgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5pcHN0clxyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm9wZW4oXCJVSVVzZXJJcFwiLCBmdW5jdGlvbihwYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBwYW5lbC5zZXRVc2VySW5mbyhwbGF5ZXJEYXRhKVxyXG4gICAgICAgICAgICB9KSBcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInZhciBNID0gY2MuQ2xhc3Moe1xyXG4gICBcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdCA6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzSW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmxvZygnaW1tYW5hZ2VyIGluaXQgYmVnaW4nKVxyXG4gICAgICAgICAgICB2YXIgbWUgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YVxyXG4gICAgICAgICAgICB0aGlzLmltID0geXVudmFzZGsuSU1EaXNwYXRjaE1zZ05vZGUuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW0uaW5pdFNESyhjYy5jb25maWdtYW5hZ2VyLnl1bnlpbl9zZGtfaWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltLmNwTG9naW4obWUubmlja19uYW1lLFN0cmluZyhtZS5jdWlkKSkgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltLnNldExpc3RlbmVyKHRoaXMub25NZXNzYWdlLHRoaXMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0luaXQgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhbGwoZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvL+S4iuS8oOaIkOWKn1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19TZW5kQ2hhdFwiKVxyXG4gICAgICAgICAgICAgICAgbXNnLnR5cGUgPSAyXHJcbiAgICAgICAgICAgICAgICBtc2cuZGF0YV90ZXh0ID0gZGF0YS51cmxcclxuICAgICAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIuc2VuZChtc2cpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2MuaW1tYW5hZ2VyLmltLnBsYXlSZWNvcmQoKVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5UmVjb3JkKClcclxuICAgICAgICAgICAgICAgIH0sZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAvL+WBnOatouW9leWItlxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIGNjLmxvZygnaW1tYW5hZ2VyIGluaXQhJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLmxvZygnaW1tYW5hZ2VyIGNyZWF0ZSBmYWlsIScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5oYXNJbml0ID0gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgb25NZXNzYWdlIDogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIGNjLmluZm8oJ+aUtuWIsOivremfs+a2iOaBrzonICsgZGF0YSlcclxuICAgICAgICB2YXIgcnNwID0gSlNPTi5wYXJzZShkYXRhKVxyXG4gICAgICAgIHN3aXRjaChyc3AubmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJZVlNES19VUExPQURfQ09NUExFVEVEXCI6IC8v5LiK5Lyg5oiQ5YqfXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9vblVwbG9hZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vblVwbG9hZChyc3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiWVZTREtfU1RPUF9SRUNPUkRcIjpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5fb25TdG9wUmVjb3JkKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU3RvcFJlY29yZChyc3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiWVZTREtfUExBWV9DT01QTEVURURcIjpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vblBsYXlDb21wbGV0ZWQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25QbGF5Q29tcGxldGVkIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhbmVsID0gY2MuZ3VpbWFuYWdlci5nZXRCeU5hbWUoJ1VJUG9rZXJHYW1lJylcclxuICAgICAgICBpZiAocGFuZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYW5lbC5vblBsYXlDb21wbGV0ZWQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucmVzdW1lQWxsKClcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q2FsbCA6IGZ1bmN0aW9uKG9uVXBsb2FkLG9uU3RvcFJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuX29uVXBsb2FkID0gb25VcGxvYWRcclxuICAgICAgICB0aGlzLl9vblN0b3BSZWNvcmQgPSBvblN0b3BSZWNvcmRcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRSZWNvcmQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmltLnN0YXJ0UmVjb3JkKClcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcFJlY29yZCA6IGZ1bmN0aW9uKGNhbmNlbCkge1xyXG4gICAgICAgIHRoaXMuaXNDYW5jZWwgPSBjYW5jZWxcclxuICAgICAgICB0aGlzLmltLnN0b3BSZWNvcmQoKVxyXG4gICAgICAgIGlmIChjYW5jZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5hdWRpb21hbmFnZXIucmVzdW1lQWxsKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcGxheVJlY29yZCA6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIGlmICghY2Muc2NlbmVtYW5hZ2VyLmlzUG9rZXJHYW1lU2NlbmUoKSkgcmV0dXJuXHJcbiAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBhdXNlQWxsKClcclxuXHJcbiAgICAgICAgaWYgKHVybClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuaW0ucGxheUZyb21VcmwodXJsKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmltLnBsYXlSZWNvcmQoKVxyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcbn0pO1xyXG5cclxuY2MuaW1tYW5hZ2VyID0gbmV3IE0oKSIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJcclxudmFyIE0gPSBjYy5DbGFzcyh7XHJcbiAgICBjdG9yOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmVxdWlyZSgnbG9uZycpXHJcbiAgICAgICAgcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpXHJcbiAgICAgICAgdGhpcy5Qcm90b0J1ZiA9IHJlcXVpcmUoJ3Byb3RvYnVmJylcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBbXVxyXG4gICAgICAgIHRoaXMuZmlyc3RMb2dpbiA9IHRydWVcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXQ6ZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgIGlmIChjYy5zeXMuaXNNb2JpbGUpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgYWdlbnQgPSBhbnlzZGsuYWdlbnRNYW5hZ2VyXHJcbiAgICAgICAgdGhpcy51c2VyX3BsdWdpbiA9IGFnZW50LmdldFVzZXJQbHVnaW4oKVxyXG4gICAgICAgIC8vIHRoaXMudXNlcl9wbHVnaW4ucmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICB0aGlzLnVzZXJfcGx1Z2luLnNldExpc3RlbmVyKHRoaXMub25Vc2VyUmVzdWx0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFyZV9wbHVnaW4gPSBhZ2VudC5nZXRTaGFyZVBsdWdpbigpO1xyXG4gICAgICAgIC8vIHRoaXMuc2hhcmVfcGx1Z2luLnJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgdGhpcy5zaGFyZV9wbHVnaW4uc2V0TGlzdGVuZXIodGhpcy5vblNoYXJlUmVzdWx0LCB0aGlzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tZXNzYWdlcyA9IHt9O1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHRoaXMubG9hZFByb3RvKCdQcm90by9jbGllbnQnLGZ1bmN0aW9uKGJ1aWxkZXIpe1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfTG9naW4nKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0xvZ2luUmV0Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19QbGF5ZXJCYXNpY0RhdGEnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX05vdGljZScpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfU2VuZENoYXQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0NoYXQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DU19IZWFydGJlYXQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19KaW9uR2FtZScpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfRzEzX0NyZWF0ZUdhbWUnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19QbGF5ZXJzSW5Sb29tJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfUm9vbUF0dHInKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19HaXZlVXAnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19Wb3RlRmFpbGVkJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfQWJvcnRHYW1lT3JOb3QnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19Wb3RlRm9BYm9ydEdhbWUnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19QbGF5ZXJRdWl0ZWQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19SZWFkeUZsYWcnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19IYW5kT2ZNaW5lJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfQnJpbmdPdXQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19BbGxIYW5kcycpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX0FsbFJvdW5kcycpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfRzEzX1JlcUdhbWVIaXN0b3J5Q291bnQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19HYW1lSGlzdG9yeUNvdW50Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfUmVxR2FtZUhpc3RvcnlEZXRpYWwnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0cxM19HYW1lSGlzdG9yeURldGlhbCcpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfRzEzX1NpbXVsYXRpb25Sb3VuZCcpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX0NhbGNSb3VuZFNpbXVsYXRpb25SZXQnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX1NlcnZlclZlcnNpb24nKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMubG9hZFByb3RvSUQoKTtcclxuXHJcbiAgICAgIGNjLmdhbWUub24oY2MuZ2FtZS5FVkVOVF9TSE9XLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgdmFyIF9zZWxmID0gc2VsZlxyXG4gICAgICAgICAgc2VsZi5jbGVhcl9uZXRfY2hlY2soKVxyXG4gICAgICAgICAgdmFyIHNjaGVkdWxlciA9IGNjLmRpcmVjdG9yLmdldFNjaGVkdWxlcigpXHJcbiAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmICghX3NlbGYucmVjdlRpbWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBfc2VsZi5jbG9zZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcl9uZXRfY2hlY2soKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LF9zZWxmLDAsMCwxLGZhbHNlKVxyXG4gICAgICAgICAgX3NlbGYuc2VuZFRpbWUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICBfc2VsZi5zZW5kSGVhcnRiZWF0KClcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHRoaXMuc2VydmVySW5mbyA9IHtcclxuICAgICAgICBhcHBsZV9yZXZpZXcgOiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJfbmV0X2NoZWNrIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuc2VuZFRpbWUgPSBudWxsXHJcbiAgICAgIHRoaXMucmVjdlRpbWUgPSBudWxsXHJcbiAgICAgIGNjLmRpcmVjdG9yLmdldFNjaGVkdWxlcigpLnVuc2NoZWR1bGVBbGxGb3JUYXJnZXQodGhpcylcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRIZWFydGJlYXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jbGVhcl9uZXRfY2hlY2soKVxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCkuc2NoZWR1bGUoZnVuY3Rpb24oKXtcclxuICAgICAgICAgIGNjLmxvZyhcIjMw56eS5Y+R6YCB5LiA5Liq5peg5pWI5pWw5o2ua2VlcGFsaXZlXCIpXHJcbiAgICAgICAgICBzZWxmLnNlbmRIZWFydGJlYXQoKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBcclxuICAgICAgfSwgdGhpcywgMzApXHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX0NTX0hlYXJ0YmVhdCA6IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICBpZiAodGhpcy5zZW5kVGltZSlcclxuICAgICAge1xyXG4gICAgICAgIHRoaXMucmVjdlRpbWUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2VuZEhlYXJ0YmVhdCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coXCJQdWJsaWNQcm90by5DU19IZWFydGJlYXRcIilcclxuICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcEhlYXJ0YmVhdCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBjYy5kaXJlY3Rvci5nZXRTY2hlZHVsZXIoKS51bnNjaGVkdWxlQWxsRm9yVGFyZ2V0KHRoaXMpIFxyXG4gICAgfSxcclxuXHJcbiAgICBpc1dYSW5zdGFsbCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKCF0aGlzLnVzZXJfcGx1Z2luKXtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1MpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlcl9wbHVnaW4uaXNXWEluc3RhbGwoKVxyXG4gICAgICBlbHNlIGlmIChjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBvblVzZXJSZXN1bHQ6ZnVuY3Rpb24oY29kZSxtc2cpIHtcclxuICAgICAgc3dpdGNoKGNvZGUpIHtcclxuICAgICAgICBjYXNlIGFueXNkay5Vc2VyQWN0aW9uUmVzdWx0Q29kZS5rSW5pdFN1Y2Nlc3M6XHJcbiAgICAgICAgICAgIC8v5Yid5aeL5YyW5oiQ5YqfXHJcbiAgICAgICAgICAgIHRoaXMudXNlcl9wbHVnaW5faW5pdF9zdWNjZXNzID0gdHJ1ZVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgYW55c2RrLlVzZXJBY3Rpb25SZXN1bHRDb2RlLmtMb2dpblN1Y2Nlc3M6XHJcbiAgICAgICAgICAgIC8v55m75b2V5oiQ5YqfXHJcbiAgICAgICAgICAgIHRoaXMubG9naW5TdWNjZXNzID0gdHJ1ZVxyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKG1zZylcclxuICAgICAgICAgICAgaWYgKGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZ2luR2FtZSgxLGRhdGEpXHJcbiAgICAgICAgICAgICAgdGhpcy53ZWl4aW5EYXRhID0gZGF0YVxyXG4gICAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIndlaXhpbkRhdGFcIixtc2cpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goJ0xvZ2luIEZhaWwhJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIC8vIGNhc2UgYW55c2RrLlVzZXJBY3Rpb25SZXN1bHRDb2RlLmtMb2dvdXRTdWNjZXNzOlxyXG4gICAgICAgIC8vICAgICAgICAgICB0aGlzLmZpcnN0TG9naW4gPSB0cnVlXHJcbiAgICAgICAgLy8gICAgICAgICAgIHRoaXMucmVjb25uZWN0KClcclxuICAgICAgICAvLyAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gY2FzZSBhbnlzZGsuVXNlckFjdGlvblJlc3VsdENvZGUua0xvZ291dEZhaWw6XHJcbiAgICAgICAgLy8gICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KFwiTG9naW5vdXQgRmFpbCFcIilcclxuICAgICAgICAvLyAgICAgdGhpcy5maXJzdExvZ2luID0gdHJ1ZVxyXG4gICAgICAgIC8vICAgICB0aGlzLnJlY29ubmVjdCgpXHJcbiAgICAgICAgLy8gICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgYW55c2RrLlVzZXJBY3Rpb25SZXN1bHRDb2RlLmtJbml0RmFpbDovL+WIneWni+WMliBTREsg5aSx6LSl5Zue6LCDXHJcbiAgICAgICAgICAgIC8vU0RLIOWIneWni+WMluWksei0pe+8jOa4uOaIj+ebuOWFs+WkhOeQhlxyXG4gICAgICAgICAgICB0aGlzLnVzZXJfcGx1Z2luX2luaXRfc3VjY2VzcyA9IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIGNjLmd1aW1hbmFnZXIubXNnQm94KFwia0luaXRGYWlsXCIpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSBhbnlzZGsuVXNlckFjdGlvblJlc3VsdENvZGUua0xvZ2luTmV0d29ya0Vycm9yOi8v55m76ZmG572R57uc5Ye66ZSZ5Zue6LCDXHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KFwiVXNlckFjdGlvblJlc3VsdENvZGUua0xvZ2luTmV0d29ya0Vycm9yXCIpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSBhbnlzZGsuVXNlckFjdGlvblJlc3VsdENvZGUua0xvZ2luQ2FuY2VsOi8v55m76ZmG5Y+W5raI5Zue6LCDXHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KFwi55m76ZmG5Y+W5raIIVwiKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgYW55c2RrLlVzZXJBY3Rpb25SZXN1bHRDb2RlLmtMb2dpbkZhaWw6Ly/nmbvpmYblpLHotKXlm57osINcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goJ+W+ruS/oeacquWuieijhSEnKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25TaGFyZVJlc3VsdDpmdW5jdGlvbihjb2RlLCBtc2cpe1xyXG4gICAgICBjYy5sb2coXCJzaGFyZSByZXN1bHQsIHJlc3VsdGNvZGU6XCIrY29kZStcIiwgbXNnOiBcIittc2cpO1xyXG4gICAgICBzd2l0Y2ggKCBjb2RlICkge1xyXG4gICAgICAgIGNhc2UgYW55c2RrLlNoYXJlUmVzdWx0Q29kZS5rU2hhcmVTdWNjZXNzOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBhbnlzZGsuU2hhcmVSZXN1bHRDb2RlLmtTaGFyZUZhaWw6XHJcbiAgICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goJ+WIhuS6q+Wksei0pe+8gemUmeivr+S7o+eggTonICsgY29kZSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgYW55c2RrLlNoYXJlUmVzdWx0Q29kZS5rU2hhcmVDYW5jZWw6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGFueXNkay5TaGFyZVJlc3VsdENvZGUua1NoYXJlTmV0d29ya0Vycm9yOlxyXG4gICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCfnvZHnu5zplJnor6/vvIEnKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgIH0sXHJcblxyXG5cclxuICAgIGxvYWRQcm90bzpmdW5jdGlvbihwYXRoLGNhbGwpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgY2MubG9hZGVyLmxvYWRSZXMocGF0aCxmdW5jdGlvbihlcnIscHJvdG8pe1xyXG4gICAgICAgICAgdmFyIGJ1aWxkZXIgPSBzZWxmLlByb3RvQnVmLnByb3RvRnJvbVN0cmluZyhwcm90byk7XHJcbiAgICAgICAgICBjYWxsKGJ1aWxkZXIpXHJcbiAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRNZXNzYWdlOmZ1bmN0aW9uKGJ1aWxkZXIsbmFtZSl7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlc1tuYW1lXSA9IGJ1aWxkZXIuYnVpbGQobmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRQcm90b0lEOmZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICBjYy5sb2FkZXIubG9hZFJlcygnUHJvdG8vcHJvdG9pZCcsZnVuY3Rpb24oZXJyLHByb3RvaWQpe1xyXG4gICAgICAgIHNlbGYuaWRfbmFtZV9tYXAgPSBKU09OLnBhcnNlKHByb3RvaWQpXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBpZF9uYW1lX2NvbnZlcnQ6ZnVuY3Rpb24oaWRfb3JfbmFtZSl7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb3RvX2lkX25hbWVfbWFwW2lkX29yX25hbWVdXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbm5lY3Q6ZnVuY3Rpb24oaXAscG9ydCxmdW5jKXtcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLndhaXQoJ+ato+WcqOi/nuaOpSzor7fnqI3lkI4uLi4nKVxyXG4gICAgICAgIGlmICghdGhpcy5qYnNvY2tldClcclxuICAgICAgICAgIHRoaXMuamJzb2NrZXQgPSBuZXcgSkJTb2NrZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmpic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICBmdW5jKHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuamJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3JpZCA9PSBKQlNvY2tldC5Db25uZWN0RXJyb3IpXHJcbiAgICAgICAgICAgIGZ1bmMoZmFsc2UpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgIC8vIHNlbGYuZGlzcGFjaCgnZGlzcGFjaE1zZycsJ29uTmV0RXJyb3InLGRhdGEuZXJyb3JpZCk7XHJcbiAgICAgICAgICAgY2MubG9nKCdlcnJvcjonKVxyXG4gICAgICAgICAgIHNlbGYuc3RvcEhlYXJ0YmVhdCgpXHJcbiAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICAgdGhpcy5qYnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY2MubG9nKCdkYXRhLm1zZ2lkOicgKyBkYXRhLm1zZ2lkKVxyXG4gICAgICAgICAgc2VsZi5kaXNwYWNoTXNnKGRhdGEubXNnaWQsZGF0YS5tc2cpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuamJzb2NrZXQuY29ubmVjdChpcCxwb3J0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJJUCA9IGlwXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJQb3J0ID0gcG9ydFxyXG4gICAgfSxcclxuXHJcbiAgICByZWNvbm5lY3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgaWYgKHRoaXMuamJzb2NrZXQpXHJcbiAgICAgIHtcclxuICAgICAgICAvLyB0aGlzLmpic29ja2V0LmNsb3NlKClcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmpic29ja2V0ID0gbnVsbFxyXG5cclxuICAgICAgdmFyIF90aGlzID0gdGhpc1xyXG4gICAgICB0aGlzLmNvbm5lY3QoY2MuY29uZmlnbWFuYWdlci5zZXJ2ZXJJUCxjYy5jb25maWdtYW5hZ2VyLnNlcnZlclBvcnQsZnVuY3Rpb24oaXNDb25uZWN0KXtcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLmNsb3NlV2FpdCgpXHJcbiAgICAgICAgIHZhciBzZWxmID0gX3RoaXNcclxuICAgICAgICAgIGlmICghaXNDb25uZWN0KVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm1zZ0JveCgn6L+e5o6l5aSx6LSlLOeCueWHu+ehruWumumHjeivlSEnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBzZWxmLnN0YXJ0SGVhcnRiZWF0KClcclxuICAgICAgICAgICAgLy/ov57mjqXmiJDlip8gLOWHhuWkh+eZu+mZhlxyXG4gICAgICAgICAgICBpZiAoIXNlbGYuZmlyc3RMb2dpbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHNlbGYubG9naW4oc2VsZi5sb2dpblR5cGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgZ290b0xvZ2luU2NlbmUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmZpcnN0TG9naW4pXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2dpbiA9IGZhbHNlXHJcbiAgICAgICAgICAgIGNjLnNjZW5lbWFuYWdlci5sb2FkTG9naW5TY2VuZSgpXHJcbiAgICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy9cclxuICAgIFB1YmxpY1Byb3RvX1NfU2VydmVyVmVyc2lvbiA6IGZ1bmN0aW9uKG1zZykge1xyXG5cclxuICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0gbXNnXHJcbiAgICAgICBpZiAobXNnLnZlcnNpb24gIT0gY2MuY29uZmlnbWFuYWdlci52ZXJzaW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNjLm5ldG1hbmFnZXIuc2VydmVySW5mby5zdHJpY3RfdmVyc2lvbikgICAgXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCfmgqjlvZPliY3niYjmnKzkuI7mnI3liqHlmajkuI3ljLnphY3vvIzor7fkuIvovb3mnIDmlrDlrqLmiLfnq6/vvIEnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5vcGVuVVJMKGNjLm5ldG1hbmFnZXIuc2VydmVySW5mby5pb3NfYXBwX3VybClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5vcGVuVVJMKGNjLm5ldG1hbmFnZXIuc2VydmVySW5mby5hbmRyb2lkX2FwcF91cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWUgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCfmgqjlvZPliY3niYjmnKzkuI7mnI3liqHlmajkuI3ljLnphY3vvIzor7fkuIvovb3mnIDmlrDlrqLmiLfnq6/vvIEnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmdvdG9Mb2dpblNjZW5lKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRoaXMuZ290b0xvZ2luU2NlbmUoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/nmbvpmYbov5Tlm55cclxuICAgIFB1YmxpY1Byb3RvX1NfTG9naW5SZXQ6ZnVuY3Rpb24obXNnKXtcclxuICAgICAgaWYgKG1zZy5yZXRfY29kZSA9PSAxIClcclxuICAgICAge1xyXG4gICAgICAgIGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWQgPSBtc2cuY3VpZDtcclxuICAgICAgICBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5pcHN0ciA9IG1zZy5pcHN0clxyXG4gICAgICAgIGNjLmxvZygn6YeN6L+e5oiQ5YqfIScpXHJcbiAgICAgIH1cclxuICAgICAgY2MuZGF0YW1hbmFnZXIubWFpbkRhdGEgPSBtc2dcclxuICAgIH0sXHJcblxyXG4gICAgY2hlY2tXZWl4aW4gOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGRhdGE9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIndlaXhpbkRhdGFcIilcclxuICAgICAgaWYgKGRhdGEgJiYgZGF0YSAhPSBcIlwiKVxyXG4gICAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgbG9naW46ZnVuY3Rpb24odHlwZSkge1xyXG5cclxuICAgICAgaWYgKGNjLnN5cy5pc01vYmlsZSAmJiB0eXBlICE9IDApXHJcbiAgICAgIHtcclxuICAgICAgICB0aGlzLnVzZXJfcGx1Z2luLmxvZ2luKClcclxuICAgICAgICAvLyB0aGlzLndlaXhpbkRhdGEgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ3ZWl4aW5EYXRhXCIpXHJcbiAgICAgICAgLy8gaWYgKCF0aGlzLndlaXhpbkRhdGEgfHwgdGhpcy53ZWl4aW5EYXRhID09IFwiXCIpXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgaWYgKHRoaXMudXNlcl9wbHVnaW5faW5pdF9zdWNjZXNzKVxyXG4gICAgICAgIC8vICAge1xyXG4gICAgICAgIC8vICAgICB0aGlzLnVzZXJfcGx1Z2luLmxvZ2luKClcclxuICAgICAgICAvLyAgIH1cclxuICAgICAgICAvLyAgIGVsc2VcclxuICAgICAgICAvLyAgIHtcclxuICAgICAgICAvLyAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goXCJBbnlTREsg5pyq5Yid5aeL5YyWIVwiKVxyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBlbHNlXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgdGhpcy51c2VyX3BsdWdpbi5sb2dpbigpXHJcbiAgICAgICAgLy8gICAvLyB0aGlzLndlaXhpbkRhdGEgPSBKU09OLnBhcnNlKHRoaXMud2VpeGluRGF0YSlcclxuICAgICAgICAvLyAgIC8vIGlmICh0aGlzLndlaXhpbkRhdGEpXHJcbiAgICAgICAgLy8gICAvLyB7XHJcbiAgICAgICAgLy8gICAvLyAgIHRoaXMubG9naW5HYW1lKDEsdGhpcy53ZWl4aW5EYXRhKVxyXG4gICAgICAgIC8vICAgLy8gfVxyXG4gICAgICAgIC8vICAgLy8gZWxzZVxyXG4gICAgICAgIC8vICAgLy8ge1xyXG4gICAgICAgIC8vICAgLy8gICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dlaXhpbkRhdGEnLFwiXCIpXHJcbiAgICAgICAgLy8gICAvLyAgIHRoaXMud2VpeGluRGF0YSA9IG51bGxcclxuICAgICAgICAvLyAgIC8vICAgdGhpcy5sb2dpbk91dCgpXHJcbiAgICAgICAgLy8gICAvLyB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAge1xyXG4gICAgICAgIHRoaXMubG9naW5HYW1lKDAse1xyXG4gICAgICAgICAgYWNjZXNzX3Rva2VuIDogJ3h4eHh4JyxcclxuICAgICAgICAgIHVzZXJfaW5mbyA6IHtcclxuICAgICAgICAgICAgb3BlbmlkIDogY2MuZGF0YW1hbmFnZXIuZ2V0VXNlck9wZW5JZCgpLFxyXG4gICAgICAgICAgICBuaWNrbmFtZSA6IGNjLmRhdGFtYW5hZ2VyLmdldE5pY2tOYW1lKCksXHJcbiAgICAgICAgICAgIGhlYWRpbWd1cmw6XCJcIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbG9naW5HYW1lIDogZnVuY3Rpb24odHlwZSx3ZWl4aW4pIHtcclxuICAgICAgdGhpcy5sb2dpblR5cGUgPSB0eXBlXHJcbiAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZygnUHVibGljUHJvdG8uQ19Mb2dpbicpO1xyXG4gICAgICAgbXNnLmxvZ2luX3R5cGUgPSB0eXBlXHJcbiAgICAgICBtc2cub3BlbmlkID0gd2VpeGluLnVzZXJfaW5mby5vcGVuaWRcclxuICAgICAgIG1zZy50b2tlbiA9IHdlaXhpbi5hY2Nlc3NfdG9rZW5cclxuICAgICAgIG1zZy5uaWNrX25hbWUgPSB3ZWl4aW4udXNlcl9pbmZvLm5pY2tuYW1lXHJcbiAgICAgICBtc2cuaW1ndXJsID0gd2VpeGluLnVzZXJfaW5mby5oZWFkaW1ndXJsXHJcbiAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG5cclxuICAgICAgIGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLm5pY2tfbmFtZSA9IG1zZy5uaWNrX25hbWU7XHJcbiAgICAgICBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5vcGVuaWQgPSBtc2cub3BlbmlkO1xyXG4gICAgICAgY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEuc2V4ID0gd2VpeGluLnVzZXJfaW5mby5zZXhcclxuICAgICAgIGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLnVybCA9IHdlaXhpbi51c2VyX2luZm8uaGVhZGltZ3VybFxyXG4gICAgfSxcclxuXHJcbiAgICBsb2dpbk91dCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLndlaXhpbkRhdGEgPSBudWxsXHJcbiAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2VpeGluRGF0YScsXCJcIilcclxuICAgICAgaWYgKHRoaXMudXNlcl9wbHVnaW4gJiYgdGhpcy51c2VyX3BsdWdpbi5sb2dvdXQpXHJcbiAgICAgIHtcclxuICAgICAgICB0aGlzLnVzZXJfcGx1Z2luLmxvZ291dCgpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuamJzb2NrZXQpXHJcbiAgICAgICAgdGhpcy5qYnNvY2tldC5jbG9zZSgpXHJcbiAgICAgIHRoaXMuamJzb2NrZXQgPSBudWxsXHJcbiAgICAgIHRoaXMuZmlyc3RMb2dpbiA9IHRydWVcclxuICAgICAgdGhpcy5yZWNvbm5lY3QoKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkRpc2Nvbm5lY3Q6ZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8v6YeN6L+eXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goJ+e9kee7nOaWreW8gCzngrnlh7vnoa7lrprlsJ3or5Xph43ov54hJyxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgLy/lhbPpl63nvZHnu5xcclxuICAgIGNsb3NlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0KClcclxuICAgICAgICBpZiAodGhpcy5qYnNvY2tldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aGlzLmpic29ja2V0LmNsb3NlKCk7XHJcbiAgICAgICAgICB0aGlzLmpic29ja2V0ID0gbnVsbDtcclxuICAgICAgICAgIGNjLmxvZygnb25EaXNjb25uZWN0JylcclxuICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5YiG5Y+R5raI5oGvXHJcbiAgICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG1zZ2lkLG1zZykge1xyXG4gICAgICB2YXIgbXNnbmFtZSA9IHRoaXMuaWRfbmFtZV9tYXBbU3RyaW5nKG1zZ2lkKV1cclxuICAgICAgdmFyIG1zZ2RhdGEgPSB0aGlzLm1lc3NhZ2VzW21zZ25hbWVdLmRlY29kZShtc2cpXHJcbiAgICAgIHZhciBtc2doYW5kbGVybmFtZSA9IG1zZ25hbWUucmVwbGFjZSgnLicsJ18nKVxyXG5cclxuICAgICAgY2MubG9nKCdyZWN2OicgKyBtc2duYW1lKVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2doYW5kbGVybmFtZV0gPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXNbbXNnaGFuZGxlcm5hbWVdKG1zZ2RhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICB0aGlzLmRpc3BhY2goXCJkaXNwYWNoTXNnXCIsbXNnaGFuZGxlcm5hbWUsbXNnZGF0YSlcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGFjaDpmdW5jdGlvbihmdW5jbmFtZSxuYW1lLGRhdGEpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXIubGVuZ3RoOysraSlcclxuICAgICAge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcltpXVtmdW5jbmFtZV0obmFtZSxkYXRhKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v55Sz6K+35LiA5LiqIG1zZ1xyXG4gICAgbXNnOmZ1bmN0aW9uKG1zZ25hbWUpe1xyXG4gICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbbXNnbmFtZV07XHJcbiAgICAgIGlmIChtZXNzYWdlKVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIHJldCA9IG5ldyBtZXNzYWdlKCk7XHJcbiAgICAgICAgcmV0Ll9fbXNnaWQgPSB0aGlzLmlkX25hbWVfbWFwW21zZ25hbWVdXHJcbiAgICAgICAgcmV0dXJuIHJldFxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Y+R6YCBbXNnXHJcbiAgICBzZW5kOmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgIGNjLmxvZyhcInNlbmQgc3RhdGU6IFwiICsgdGhpcy5qYnNvY2tldClcclxuICAgICAgaWYgKHRoaXMuamJzb2NrZXQpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgaWQgPSBtc2cuX19tc2dpZFxyXG4gICAgICAgIGNjLmxvZygnc2VuZCBtZXNzYWdlIGlkOicgKyBpZClcclxuICAgICAgICB0aGlzLmpic29ja2V0LnNlbmQoaWQsbmV3IFVpbnQ4QXJyYXkobXNnLnRvQnVmZmVyKCkpKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZ2lzdGVySGFuZGxlcjpmdW5jdGlvbihoYW5kbGVyKXtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgIGlmIChoYW5kbGVyICE9IG51bGwgJiYgdHlwZW9mIGhhbmRsZXIuZGlzcGFjaE1zZyA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICB7XHJcbiAgICAgICAgICBzZWxmLmhhbmRsZXIucHVzaChoYW5kbGVyKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzY3JlZW5TaG9vdCA6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgaWYgKCFjYy5zeXMuaXNOYXRpdmUpIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBkaXJwYXRoID0ganNiLmZpbGVVdGlscy5nZXRXcml0YWJsZVBhdGgoKSArICdTY3JlZW5TaG9vdC8nO1xyXG4gICAgICBpZiAoIWpzYi5maWxlVXRpbHMuaXNEaXJlY3RvcnlFeGlzdChkaXJwYXRoKSkge1xyXG4gICAgICAgIGpzYi5maWxlVXRpbHMuY3JlYXRlRGlyZWN0b3J5KGRpcnBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzY2FsZSA9IDAuNVxyXG4gICAgICBsZXQgbmFtZSA9ICdTY3JlZW5TaG9vdC5qcGcnO1xyXG4gICAgICBsZXQgZmlsZXBhdGggPSBkaXJwYXRoICsgbmFtZTtcclxuICAgICAgaWYgKGpzYi5maWxlVXRpbHMuaXNGaWxlRXhpc3QoZmlsZXBhdGgpKVxyXG4gICAgICAgICAganNiLmZpbGVVdGlscy5yZW1vdmVGaWxlKGZpbGVwYXRoKVxyXG4gICAgICBsZXQgc2l6ZSA9IGNjLndpblNpemU7XHJcbiAgICAgIGxldCBydCA9IGNjLlJlbmRlclRleHR1cmUuY3JlYXRlKHNpemUud2lkdGggKiBzY2FsZSwgc2l6ZS5oZWlnaHQgKiBzY2FsZSwyLCAweDg4RjApIFxyXG4gICAgICB2YXIgc2NlbmUgPSBjYy5kaXJlY3Rvci5nZXRTY2VuZSgpXHJcbiAgICAgIHNjZW5lLl9zZ05vZGUuYWRkQ2hpbGQocnQpO1xyXG4gICAgICBydC5zZXRWaXNpYmxlKGZhbHNlKTtcclxuXHJcbiAgICAgIGNjLmRpcmVjdG9yLnNldENvbnRlbnRTY2FsZUZhY3RvcihzY2FsZSlcclxuICAgICAgcnQuYmVnaW4oKTtcclxuICAgICAgc2NlbmUuX3NnTm9kZS52aXNpdCgpO1xyXG4gICAgICBydC5lbmQoKTtcclxuICAgICAgY2MubG9nKCdkaXJwYXRoOicgKyBkaXJwYXRoKVxyXG4gICAgICBydC5zYXZlVG9GaWxlKCdTY3JlZW5TaG9vdC8nICsgbmFtZSwgMCwgdHJ1ZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNjLmRpcmVjdG9yLnNldENvbnRlbnRTY2FsZUZhY3RvcigxKVxyXG4gICAgICAgLy8gIGlmIChjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpIFxyXG4gICAgICAgLy8gIHtcclxuICAgICAgIC8vICAgdmFyIGRzdEZpbGU9XCIvc2RjYXJkL1NjcmVlblNob290LnBuZ1wiO1xyXG4gICAgICAgLy8gICBqc2IuZmlsZVV0aWxzLmNvcHlGaWxlKGZpbGVwYXRoLGRzdEZpbGUpO1xyXG4gICAgICAgLy8gICBmaWxlcGF0aCA9IGRzdEZpbGVcclxuICAgICAgIC8vIH1cclxuXHJcbiAgICAgICBjYy5sb2coJ3NhdmUgc3VjYycpO1xyXG4gICAgICAgIHJ0LnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgZnVuYyhmaWxlcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2hhcmVJY29uIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBwYXRoID0ganNiLmZpbGVVdGlscy5nZXRXcml0YWJsZVBhdGgoKSArICdzaGFyZUljb24uanBnJ1xyXG4gICAgICBpZiAoIWpzYi5maWxlVXRpbHMuaXNGaWxlRXhpc3QocGF0aCkpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGpzYi5maWxlVXRpbHMuZ2V0RGF0YUZyb21GaWxlKGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvVGV4dHVyZXMvc2hhcmVJY29uLmpwZ1wiKSlcclxuICAgICAgICBpZiAoZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICBqc2IuZmlsZVV0aWxzLndyaXRlRGF0YVRvRmlsZShkYXRhLHBhdGgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyBjYy5ndWltYW5hZ2VyLm1zZ0JveCgnc2hhcmUgZmFpbGVkIScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9LFxyXG5cclxuICAgc2hhcmVpbWdUb1dlaVhpbiA6IGZ1bmN0aW9uKGltZ1BhdGgsc2hhclRvKSB7XHJcbiAgICAgIHZhciBpbmZvID0ge1xyXG4gICAgICAgIHRpdGxlOiBcIuaWl+mYtea4uOWNgeS4ieawtFwiLCAgXHJcbiAgICAgICAgdGV4dDogXCLmrKLov47mnaXliLDmlpfpmLXljYHkuInmsLTvvIzorqnmiJHku6zkuIDotbfmlpfpmLXmuLjlkKfvvIFcIiwgIFxyXG4gICAgICAgIHVybDogY2MuZGF0YW1hbmFnZXIubWFpbkRhdGEuc2hhcmVfbGluayxcclxuICAgICAgICBtZWRpYVR5cGU6JzEnLFxyXG4gICAgICAgIHNoYXJlVG86c2hhclRvLFxyXG4gICAgICAgIGltYWdlUGF0aDppbWdQYXRoLFxyXG4gICAgICAgIHRodW1iU2l6ZTonMTI3JyxcclxuICAgICAgICB0aHVtYkltYWdlOmltZ1BhdGhcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKVxyXG4gICAgICB7XHJcbiAgICAgICAgaW5mby5pbWdQYXRoID0gdGhpcy5nZXRTaGFyZUljb24oKVxyXG4gICAgICAgIGluZm8udGh1bWJJbWFnZSA9IGluZm8uaW1nUGF0aFxyXG4gICAgICAgIGNjLmxvZygnaW5mby50aHVtYkltYWdlOicgKyBpbmZvLnRodW1iSW1hZ2UpXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgdGhpcy5zaGFyZV9wbHVnaW4uc2hhcmUoaW5mbylcclxuICAgIH0sXHJcblxyXG5cclxuICAgIHNoYXJlU2NyZWVuVG9XZWlYaW5SaW5nIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChjYy5zeXMuaXNNb2JpbGUpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICB0aGlzLnNjcmVlblNob290KGZ1bmN0aW9uKGZpbGVwYXRoKXtcclxuICAgICAgICAgIHNlbGYuc2hhcmVpbWdUb1dlaVhpbihmaWxlcGF0aCwnMScpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNoYXJlU2NyZWVuVG9XZWlYaW5GcmllbmQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNjLnN5cy5pc01vYmlsZSlcclxuICAgICAge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIHRoaXMuc2NyZWVuU2hvb3QoZnVuY3Rpb24oZmlsZXBhdGgpe1xyXG4gICAgICAgICAgc2VsZi5zaGFyZWltZ1RvV2VpWGluKGZpbGVwYXRoLCcwJylcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNoYXJlVVJMVG9XZWlYaW4gOiBmdW5jdGlvbih0aXRsZSx0ZXh0LHNoYXJlVG8pXHJcbiAgICB7XHJcbiAgICAgIGlmICghdGl0bGUpIHRpdGxlID0gXCLmlpfpmLXljYHkuInmsLRcIlxyXG4gICAgICBpZiAoIXRleHQpIHRleHQgPSBcIuasoui/juadpeWIsOaWl+mYteWNgeS4ieawtO+8jOiuqeaIkeS7rOS4gOi1t+aWl+mYtea4uOWQp++8gVwiXHJcbiAgICAgIHZhciBpbmZvID0ge1xyXG4gICAgICAgIHRpdGxlOiB0aXRsZSwgIFxyXG4gICAgICAgIHRleHQ6IHRleHQsICBcclxuICAgICAgICB1cmw6IGNjLmRhdGFtYW5hZ2VyLm1haW5EYXRhLnNoYXJlX2xpbmssXHJcbiAgICAgICAgbWVkaWFUeXBlOicyJyxcclxuICAgICAgICBzaGFyZVRvOnNoYXJlVG8sXHJcbiAgICAgICAgdGh1bWJTaXplOic1NycsXHJcbiAgICAgICAgdGh1bWJJbWFnZTonQXBwSWNvbjU3eDU3LnBuZydcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRClcclxuICAgICAge1xyXG4gICAgICAgIGluZm8udGh1bWJJbWFnZSA9IHRoaXMuZ2V0U2hhcmVJY29uKClcclxuICAgICAgICBjYy5sb2coJ2luZm8udGh1bWJJbWFnZTonICsgaW5mby50aHVtYkltYWdlKVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHRoaXMuc2hhcmVfcGx1Z2luLnNoYXJlKGluZm8pXHJcbiAgICB9LFxyXG5cclxuICAgIHNoYXJlVG9XZWlYaW5SaW5nIDogZnVuY3Rpb24odGl0bGUsdGV4dCkge1xyXG4gICAgICB0aGlzLnNoYXJlVVJMVG9XZWlYaW4odGl0bGUsdGV4dCwnMScpXHJcbiAgICB9LFxyXG5cclxuICAgIHNoYXJlVG9XZWl4aW5GcmllbmQgOiBmdW5jdGlvbih0aXRsZSx0ZXh0KSB7XHJcbiAgICAgIHRoaXMuc2hhcmVVUkxUb1dlaVhpbih0aXRsZSx0ZXh0LCcwJylcclxuICAgIH0sXHJcbn0pO1xyXG5jYy5uZXRtYW5hZ2VyID0gbmV3IE0oKTtcclxuXHJcblxyXG4iLCJcclxuLy9Qb2tlclNvcnTnlYzpnaLkuInloqnniYxcclxuXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYnRuTGFiZWw6IGNjLkxhYmVsLFxyXG4gICAgICAgIGR1bnR5cGU6IDAsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbihwcyl7XHJcbiAgICAgICAgdGhpcy5wb2tlclNvcnQgPSBwc1xyXG5cclxuICAgICAgICB0aGlzLmNhcmRWYWx1ZXMgPSBbXVxyXG4gICAgICAgIHRoaXMuY2FyZE5vZGVzID0gW11cclxuICAgICAgICB2YXIgY24gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJjYXJkc1wiKVxyXG5cclxuICAgICAgICBjYy5sb2coXCLliJ3lp4twb2tlcmR1biBjaGlsZGNvdW50PSBcIiwgY24uY2hpbGRyZW5Db3VudClcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY24uY2hpbGRyZW5Db3VudDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5jYXJkTm9kZXMucHVzaChjbi5jaGlsZHJlbltpXSlcclxuICAgICAgICAgICAgdGhpcy5jYXJkVmFsdWVzLnB1c2goMClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRFbXB0eUhvbGVOdW1iZXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG51bSA9IDBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jYXJkVmFsdWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5jYXJkVmFsdWVzW2ldID09IDApe1xyXG4gICAgICAgICAgICAgICAgKytudW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVtXHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRGaXJzdEVtcHR5SG9sZUlkeDogZnVuY3Rpb24oKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jYXJkVmFsdWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5jYXJkVmFsdWVzW2ldID09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTFcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8v5Yi35paw5oyJ6ZKu5paH5a2X54q25oCBXHJcbiAgICBfcmVmcmVzaEJ1dHRvblRleHQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG51bSA9IHRoaXMuX2dldEVtcHR5SG9sZU51bWJlcigpXHJcbiAgICAgICAgaWYobnVtICE9IHRoaXMuY2FyZFZhbHVlcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLmJ0bkxhYmVsLnN0cmluZyA9IFwi5riF6ZmkXCJcclxuICAgICAgICAgICAgdGhpcy5idG5MYWJlbC5ub2RlLmNvbG9yID0gbmV3IGNjLkNvbG9yKDEwNSwgMCwgMylcclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy9yZWQ4OEJUTlwiLCB0aGlzLmJ0bkxhYmVsLm5vZGUucGFyZW50KVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmJ0bkxhYmVsLnN0cmluZyA9IFwi5pS+5YWlXCJcclxuICAgICAgICAgICAgdGhpcy5idG5MYWJlbC5ub2RlLmNvbG9yID0gbmV3IGNjLkNvbG9yKDk2LCA3MywgMClcclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy95ZWxsb3c4OEJUTlwiLCB0aGlzLmJ0bkxhYmVsLm5vZGUucGFyZW50KVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/muIXpmaTmiZHlhYvlm77niYdcclxuICAgIF9jbGVhclBva2VyU3ByaXRlOiBmdW5jdGlvbihub2RlKXtcclxuXHJcbiAgICAgICAgdmFyIHNwcml0ZSA9IG5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XHJcbiAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIHVybCA9IFwiVGV4dHVyZXMvRmlnaHQvdG9wZHVuYmFja1wiO1xyXG4gICAgICAgIGlmKHRoaXMuZHVudHlwZSA9PSAyKXtcclxuICAgICAgICAgICAgdXJsID0gXCJUZXh0dXJlcy9GaWdodC9taWRkbGVkdW5iYWNrXCJcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLmR1bnR5cGUgPT0gMyl7XHJcbiAgICAgICAgICAgIHVybCA9IFwiVGV4dHVyZXMvRmlnaHQvYm90ZHVuYmFja1wiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHVybCwgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaXNGdWxsOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiAwID09IHRoaXMuX2dldEVtcHR5SG9sZU51bWJlcigpXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBjbGVhckR1bjogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgY3JDYXJkcyA9IFtdXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNhcmRWYWx1ZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jYXJkVmFsdWVzW2ldICE9IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNyQ2FyZHMucHVzaCh0aGlzLmNhcmRWYWx1ZXNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJkVmFsdWVzW2ldID0gMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwieHVhbnBhaVwiKVxyXG4gICAgICAgICAgICB0aGlzLnBva2VyU29ydC5vbkZhbGxiYWNrQ2FyZChjckNhcmRzKVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jYXJkTm9kZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJQb2tlclNwcml0ZSh0aGlzLmNhcmROb2Rlc1tpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBva2VyU29ydC5fcmVmcmVzaFNlbmRCdG5TdGF0ZSgpXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uY2xpY2tfUHVzaEJ0bjogZnVuY3Rpb24oZXZlbnQsIHR5cGUpe1xyXG5cclxuICAgICAgICB2YXIgZW1wdHlOdW0gPSB0aGlzLl9nZXRFbXB0eUhvbGVOdW1iZXIoKVxyXG4gICAgICAgIGNjLmxvZyhcIuepuuS9jee9rj0gXCIsIGVtcHR5TnVtKVxyXG4gICAgICAgIGlmKGVtcHR5TnVtICE9IHRoaXMuY2FyZFZhbHVlcy5sZW5ndGggJiYgdHlwZSAhPSAtMSl7XHJcbiAgICAgICAgICAgIC8v5riF6Zmk5b2T5YmN5aKp5omA5pyJ54mMLOWPquimgeacieS4gOW8oOeJjOmDvea4hemZpFxyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGVhckR1bigpXHJcblxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL+aUvuWFpeW3sumAieS4reeahOeJjFxyXG4gICAgICAgICAgICB2YXIgc2VsTGVuID0gdGhpcy5wb2tlclNvcnQuX3NlbGVjdGVkUG9rZXIubGVuZ3RoXHJcbiAgICAgICAgICAgIGNjLmxvZyhcImVtcHR5TnVtOiBcIiwgZW1wdHlOdW0sIFwic2VsZWN0TGVuZ3RoOiBcIiwgc2VsTGVuKVxyXG4gICAgICAgICAgICBpZihlbXB0eU51bSA8IHNlbExlbiB8fCBzZWxMZW4gPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coXCLpgInmi6nnmoTniYzmlbDph4/lpKrlpJpcIilcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwieHVhbnBhaVwiKVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsTGVuOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucG9rZXJTb3J0Ll9zZWxlY3RlZFBva2VyW2ldXHJcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZ2V0Rmlyc3RFbXB0eUhvbGVJZHgoKVxyXG4gICAgICAgICAgICAgICAgaWYoaWR4ICE9IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmRWYWx1ZXNbaWR4XSA9IHZhbFxyXG4gICAgICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUodmFsLCB0aGlzLmNhcmROb2Rlc1tpZHhdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucG9rZXJTb3J0Lm9uUHV0ZG93bkNhcmQoKVxyXG4gICAgICAgICAgICBpZih0eXBlICE9IC0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9rZXJTb3J0LmF1dG9QdXRMZWZ0Q2FyZCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xpY2tfUG9rZXJIb2xlOiBmdW5jdGlvbihldmVudCwgaWR4KXtcclxuICAgICAgICBpZihpZHggPCAwIHx8IGlkeCA+PSB0aGlzLmNhcmROb2Rlcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNhcmRWYWx1ZXNbaWR4XVxyXG4gICAgICAgIGlmKHZhbCAhPSAwKXtcclxuICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJ4dWFucGFpXCIpXHJcbiAgICAgICAgICAgIHRoaXMucG9rZXJTb3J0Lm9uRmFsbGJhY2tDYXJkKFt2YWxdKVxyXG4gICAgICAgICAgICB0aGlzLmNhcmRWYWx1ZXNbaWR4XSA9IDBcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQb2tlclNwcml0ZSh0aGlzLmNhcmROb2Rlc1tpZHhdKVxyXG4gICAgICAgICAgICAgdGhpcy5wb2tlclNvcnQuX3JlZnJlc2hTZW5kQnRuU3RhdGUoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVtcHR5TnVtID0gdGhpcy5fZ2V0RW1wdHlIb2xlTnVtYmVyKClcclxuICAgICAgICB2YXIgc2VsTGVuID0gdGhpcy5wb2tlclNvcnQuX3NlbGVjdGVkUG9rZXIubGVuZ3RoXHJcbiAgICAgICAgaWYodmFsID09IDAgJiYgc2VsTGVuICE9IDAgJiYgc2VsTGVuIDw9IGVtcHR5TnVtKXtcclxuICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJ4dWFucGFpXCIpXHJcbiAgICAgICAgICAgIGlmKHNlbExlbiA9PSAxKXtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxWYWwgPSB0aGlzLnBva2VyU29ydC5fc2VsZWN0ZWRQb2tlclswXVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXJkVmFsdWVzW2lkeF0gPSBzZWxWYWxcclxuICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUoc2VsVmFsLCB0aGlzLmNhcmROb2Rlc1tpZHhdKVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxMZW47ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl4ID0gdGhpcy5fZ2V0Rmlyc3RFbXB0eUhvbGVJZHgoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGl4ICE9IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbFZhbCA9IHRoaXMucG9rZXJTb3J0Ll9zZWxlY3RlZFBva2VyW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZFZhbHVlc1tpeF0gPSBzZWxWYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShzZWxWYWwsIHRoaXMuY2FyZE5vZGVzW2l4XSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9rZXJTb3J0Lm9uUHV0ZG93bkNhcmQoKVxyXG4gICAgICAgICAgICB0aGlzLnBva2VyU29ydC5hdXRvUHV0TGVmdENhcmQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaEJ1dHRvblRleHQoKVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclBva2VyczogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW11cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jYXJkTm9kZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmNhcmRWYWx1ZXNbaV0gIT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclBva2VyU3ByaXRlKHRoaXMuY2FyZE5vZGVzW2ldKVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5jYXJkVmFsdWVzW2ldKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXJkVmFsdWVzW2ldID0gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9rZXJTb3J0Lm9uRmFsbGJhY2tDYXJkKHZhbHVlcylcclxuICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgdG9wTm9kZTogY2MuTm9kZSxcclxuICAgICAgICBtaWRkbGVOb2RlOiBjYy5Ob2RlLFxyXG4gICAgICAgIGJvdHRvbU5vZGU6IGNjLk5vZGUsXHJcbiAgICAgICAgc3R5bGVOb2RlOiBjYy5Ob2RlLFxyXG5cclxuICAgICAgICBkYW5rb25nTm9kZTogY2MuTm9kZSxcclxuICAgICAgICBzaG91cWlhbmdOb2RlOiBjYy5Ob2RlLFxyXG4gICAgICAgIGpncU5vZGU6IGNjLk5vZGUsXHJcblxyXG4gICAgICAgIF9wb2tlckRhdGE6bnVsbCAgICAgICAgLy8xM+W8oOeJjCgxLDIsM+WiqemhuuW6jylcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3RoaXMuX2FsbFBva2VyVmFsdWVzID0gWzUyLDUxLDUwLDQ5LDQ4LDQ3LDQ2LDQ1LDQ0LDQzLDQyLDQxLDQwXVxyXG4gICAgfSxcclxuXHJcbiAgICAvL2RhdGHmnaXoh6pTX0cxM19BbGxIYW5kc+a2iOaBr1xyXG4gICAgaW5pdFBva2VyVmFsdWVzOiBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLl9wb2tlckRhdGEgPSBkYXRhXHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0U3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnRvcE5vZGUuY2hpbGRyZW5Db3VudDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5kID0gdGhpcy50b3BOb2RlLmNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUoXCJiYWNrXCIsIG5kKVxyXG4gICAgICAgIH1cclxuICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubWlkZGxlTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmQgPSB0aGlzLm1pZGRsZU5vZGUuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShcImJhY2tcIiwgbmQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3R0b21Ob2RlLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuZCA9IHRoaXMuYm90dG9tTm9kZS5jaGlsZHJlbltpXVxyXG4gICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKFwiYmFja1wiLCBuZClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdHlsZU5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgLy/nv7vnrKzkuIDloqnniYxcclxuICAgIHRvcEZsb3BBY3Rpb246IGZ1bmN0aW9uKHBhcmFtKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjYy5zZXF1ZW5jZShjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQscGFyYW0pe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW0udG9wTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2tlclZhbCA9IHBhcmFtLl9wb2tlckRhdGEuY2FyZHNbaV1cclxuICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUocG9rZXJWYWwsIHBhcmFtLnRvcE5vZGUuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtLnN0eWxlTm9kZS5hY3RpdmUgPSB0cnVlXHJcblxyXG4gICAgICAgICAgICBpZihwYXJhbS5fcG9rZXJEYXRhLmR1bjAuYnJhbmQgPT0gMyl7IC8v5Yay5LiJXHJcbiAgICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVNwcml0ZShcIlRleHR1cmVzL1Bva2VyU3R5bGUvY2hvbmdzYW5cIiwgcGFyYW0uc3R5bGVOb2RlKVxyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJNX2Nob25nc2FuXCIpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGNmZyA9IGNjLmNvbmZpZ21hbmFnZXIucG9rZXJGbG9wQ2ZnW3BhcmFtLl9wb2tlckRhdGEuZHVuMC5icmFuZF1cclxuICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKGNmZy50ZXhyZXMsIHBhcmFtLnN0eWxlTm9kZSlcclxuICAgICAgICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKGNmZy5zb3VuZF9tYWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcywgcGFyYW0pLCBjYy5kZWxheVRpbWUoMC42KSlcclxuICAgIH0sXHJcblxyXG4gICAgLy/nv7vnrKzkuozloqnniYxcclxuICAgIG1pZGRsZUZsb3BBY3Rpb246IGZ1bmN0aW9uKHBhcmFtKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjYy5zZXF1ZW5jZShjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQsIHBhcmFtKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcmFtLm1pZGRsZU5vZGUuY2hpbGRyZW5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9rZXJWYWwgPSBwYXJhbS5fcG9rZXJEYXRhLmNhcmRzW2krM11cclxuICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUocG9rZXJWYWwsIHBhcmFtLm1pZGRsZU5vZGUuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY2ZnID0gY2MuY29uZmlnbWFuYWdlci5wb2tlckZsb3BDZmdbcGFyYW0uX3Bva2VyRGF0YS5kdW4xLmJyYW5kXVxyXG4gICAgICAgICAgICBwYXJhbS5zdHlsZU5vZGUuYWN0aXZlID0gdHJ1ZVxyXG5cclxuICAgICAgICAgICAgaWYocGFyYW0uX3Bva2VyRGF0YS5kdW4xLmJyYW5kID09IDYpey8v5Lit5aKp6JGr6IqmXHJcbiAgICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVNwcml0ZShcIlRleHR1cmVzL1Bva2VyU3R5bGUvemhvbmdkdW5odWx1XCIsIHBhcmFtLnN0eWxlTm9kZSlcclxuICAgICAgICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwiTV96aG9uZ2R1bmh1bmx1XCIpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoY2ZnLnRleHJlcywgcGFyYW0uc3R5bGVOb2RlKVxyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoY2ZnLnNvdW5kX21hbGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSwgdGhpcyxwYXJhbSksIGNjLmRlbGF5VGltZSgwLjYpKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+e/u+esrOS4ieWiqeeJjFxyXG4gICAgYm90dG9tRmxvcEFjdGlvbjogZnVuY3Rpb24ocGFyYW0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW0uYm90dG9tTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2tlclZhbCA9IHBhcmFtLl9wb2tlckRhdGEuY2FyZHNbaSs4XVxyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShwb2tlclZhbCwgcGFyYW0uYm90dG9tTm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjZmcgPSBjYy5jb25maWdtYW5hZ2VyLnBva2VyRmxvcENmZ1twYXJhbS5fcG9rZXJEYXRhLmR1bjIuYnJhbmRdXHJcbiAgICAgICAgICAgIHBhcmFtLnN0eWxlTm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKGNmZy50ZXhyZXMsIHBhcmFtLnN0eWxlTm9kZSlcclxuICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoY2ZnLnNvdW5kX21hbGUpXHJcblxyXG4gICAgICAgIH0sIHRoaXMsIHBhcmFtKSwgY2MuZGVsYXlUaW1lKDAuNikpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v57+754m55q6K54mM5Z6LXHJcbiAgICBzcGVjaWFsRmxvcEFjdGlvbjogZnVuY3Rpb24ocGFyYW0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW0udG9wTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2tlclZhbCA9IHBhcmFtLl9wb2tlckRhdGEuY2FyZHNbaV1cclxuICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUocG9rZXJWYWwsIHBhcmFtLnRvcE5vZGUuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW0ubWlkZGxlTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2tlclZhbCA9IHBhcmFtLl9wb2tlckRhdGEuY2FyZHNbaSszXVxyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShwb2tlclZhbCwgcGFyYW0ubWlkZGxlTm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJhbS5ib3R0b21Ob2RlLmNoaWxkcmVuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gcGFyYW0uX3Bva2VyRGF0YS5jYXJkc1tpKzhdXHJcbiAgICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKHBva2VyVmFsLCBwYXJhbS5ib3R0b21Ob2RlLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0uc3R5bGVOb2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgdmFyIGNmZyA9IGNjLmNvbmZpZ21hbmFnZXIuc3BlY2lhbEZsb3BDZmdbTWF0aC5mbG9vcihwYXJhbS5fcG9rZXJEYXRhLnNwZWMuYnJhbmQvMTApXVxyXG4gICAgICAgICAgICBpZihudWxsICE9IGNmZyl7XHJcbiAgICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVNwcml0ZShjZmcudGV4cmVzLCBwYXJhbS5zdHlsZU5vZGUpXHJcbiAgICAgICAgICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheVNGWChjZmcuc291bmRfbWFsZSkgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLCBwYXJhbSlcclxuICAgIH0sXHJcblxyXG4gICAgLy/mkq3mlL7lvLnlrZTliqjnlLtcclxuICAgIHN0YXJ0RGFuS29uZ0FuaW06IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5kYW5rb25nTm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5kYW5rb25nTm9kZS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKS5wbGF5KClcclxuICAgIH0sXHJcblxyXG4gICAgZW5kRGFuS29uZ0FuaW06IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5kYW5rb25nTm9kZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aSreaUvuaJk+aequWKqOeUu1xyXG4gICAgc3RhcnREYVFpYW5nQW5pbTogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnNob3VxaWFuZ05vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuc2hvdXFpYW5nTm9kZS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKS5wbGF5KClcclxuICAgIH0sXHJcblxyXG4gICAgZW5kRGFRaWFuZ0FuaW06IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuc2hvdXFpYW5nTm9kZS5hY3RpdmUgPSBmYWxzZSAgXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzaG93KXtcclxuICAgICAgICB2YXIgbm9kZU5hbWUgPSBbXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZU5hbWUubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUobm9kZU5hbWVbaV0pXHJcbiAgICAgICAgICAgIGlmKG5kKXtcclxuICAgICAgICAgICAgICAgIG5kLmFjdGl2ZSA9IHNob3dcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFpID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicGFpXCIpXHJcbiAgICAgICAgaWYocGFpKXtcclxuICAgICAgICAgICAgcGFpLmFjdGl2ZSA9ICFzaG93XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0U3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmQgPSB0aGlzLm5vZGUuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgbmQuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsIlxyXG4vL+WkhOeQhua7keWKqOmAieaLqVxyXG5pZiAoY2MuUG9rZXJTZWxlY3RIYW5kbGVyID09IHVuZGVmaW5lZClcclxue1xyXG4gICAgY2MuUG9rZXJTZWxlY3RIYW5kbGVyID0gY2MuQ2xhc3Moe1xyXG5cclxuICAgICAgICBjdG9yOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhcigpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jbGVhcjogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBudWxsXHJcbiAgICAgICAgICAgIHRoaXMuZW5kTm9kZSA9IG51bGxcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlcyA9IFtdXHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RGb2N1c05vZGUgPSBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG91Y2hTdGFydDogZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEZvY3VzTm9kZSA9IG5vZGVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b3VjaE1vdmU6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgICBpZihub2RlID09IHRoaXMubGFzdEZvY3VzTm9kZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvdWNoRW5kOiBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgdGhpcy5lbmROb2RlID0gbm9kZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxufVxyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX2lzU2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIF9wb2tlclZhbDogMCxcclxuICAgICAgICBfcG9rZXJJbmRleDogLTEsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQgfHwgY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsIHRoaXMuX29uU2VsZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX01PVkUsIHRoaXMuX29uTW92ZSk7XHJcbiAgICAgICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfRU5ELCB0aGlzLl9vbk1vdmVFbmQpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuTU9VU0VfRE9XTiwgdGhpcy5fb25TZWxlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuTU9VU0VfTU9WRSwgdGhpcy5fb25Nb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLk1PVVNFX1VQLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgfSxcclxuXHJcbiAgICBfb25TZWxlY3Q6IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRDb21wb25lbnQoXCJQb2tlclNlbGVjdFwiKTtcclxuICAgICAgICB2YXIgcG9rZXJTb3J0ID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyU29ydFwiKS5nZXRDb21wb25lbnQoXCJQb2tlclNvcnRcIilcclxuICAgICAgICBpZighY29tcG9uZW50Ll9pc1NlbGVjdGVkKXtcclxuICAgICAgICAgICAgY29tcG9uZW50Lm1vdmVPdXQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHBva2VyU29ydC5zZWxlY3RDYXJkKGNvbXBvbmVudC5fcG9rZXJWYWwpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBjb21wb25lbnQubW92ZUJhY2soZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHBva2VyU29ydC51bnNlbGVjdENhcmQoY29tcG9uZW50Ll9wb2tlclZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBva2VyU29ydC5fbGFzdEZvY3VzUG9rZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0XHJcbiAgICAgICAgcG9rZXJTb3J0Ll9mb2N1c0JlZ2luID0gdHJ1ZVxyXG5cclxuICAgICAgICBwb2tlclNvcnQubG9nLnN0cmluZyA9IChcIl9vblNlbGVjdCBcIiArIHBva2VyU29ydC5fZm9jdXNCZWdpbi50b1N0cmluZygpICsgXCIgXCIgKyBjb21wb25lbnQuX3Bva2VySW5kZXgudG9TdHJpbmcoKSlcclxuICAgIH0sXHJcblxyXG4gICAgX29uTW92ZTogZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwb2tlclNvcnQgPSBjYy5maW5kKFwiVUlQb2tlckdhbWUvUG9rZXJTb3J0XCIpLmdldENvbXBvbmVudChcIlBva2VyU29ydFwiKVxyXG4gICAgICAgIGlmKHBva2VyU29ydC5fZm9jdXNCZWdpbiA9PSBmYWxzZSl7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHBva2VyU29ydC5fc2VsZWN0UG9rZXIoZXZlbnQuZ2V0TG9jYXRpb24oKSlcclxuXHJcbiAgICAgICAgaWYodGFyZ2V0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpXHJcbiAgICAgICAgICAgIHBva2VyU29ydC5sb2cuc3RyaW5nID0gKFwiX29uTW92ZSBcIiArIHBva2VyU29ydC5fZm9jdXNCZWdpbi50b1N0cmluZygpICsgXCIgXCIgKyBjb21wb25lbnQuX3Bva2VySW5kZXgudG9TdHJpbmcoKSlcclxuXHJcbiAgICAgICAgICAgIGlmKHRhcmdldCA9PSBwb2tlclNvcnQuX2xhc3RGb2N1c1Bva2VyKXtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb2tlclNvcnQuX2xhc3RGb2N1c1Bva2VyID0gdGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZighY29tcG9uZW50Ll9pc1NlbGVjdGVkKXtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tb3ZlT3V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBwb2tlclNvcnQuc2VsZWN0Q2FyZChjb21wb25lbnQuX3Bva2VyVmFsKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubW92ZUJhY2sodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHBva2VyU29ydC51bnNlbGVjdENhcmQoY29tcG9uZW50Ll9wb2tlclZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbk1vdmVFbmQ6IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRDb21wb25lbnQoXCJQb2tlclNlbGVjdFwiKTtcclxuICAgICAgICAgdmFyIHBva2VyU29ydCA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS9Qb2tlclNvcnRcIikuZ2V0Q29tcG9uZW50KFwiUG9rZXJTb3J0XCIpXHJcbiAgICAgICAgIHBva2VyU29ydC5fZm9jdXNCZWdpbiA9IGZhbHNlXHJcblxyXG4gICAgICAgICBwb2tlclNvcnQubG9nLnN0cmluZyA9IChcIl9vbk1vdmVFbmQgXCIgKyBwb2tlclNvcnQuX2ZvY3VzQmVnaW4udG9TdHJpbmcoKSArIFwiIFwiICsgY29tcG9uZW50Ll9wb2tlckluZGV4LnRvU3RyaW5nKCkpXHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVPdXQ6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIG5vZGUucnVuQWN0aW9uKGNjLm1vdmVCeSgwLjA2LCBjYy5wKDAsIDI0KSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtb3ZlQmFjazogZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIG5vZGUucnVuQWN0aW9uKGNjLm1vdmVCeSgwLjA2LCBjYy5wKDAsIC0yNCkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9rZXJWYWx1ZTogZnVuY3Rpb24odmFsKXtcclxuICAgICAgICB0aGlzLl9wb2tlclZhbCA9IHZhbDtcclxuICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKHZhbCwgdGhpcy5ub2RlKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XHJcbiAgICAgICAgdmFyIHVybCA9IGNjLlBva2VyVXRpbC5nZXRQb2tlclNwcml0ZVBhdGgodmFsKTtcclxuICAgICAgICBjYy5sb2codXJsKTtcclxuICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyh1cmwsIGNjLlNwcml0ZUZyYW1lLCBmdW5jdGlvbihlcnIsIHNwcml0ZUZyYW1lKXtcclxuICAgICAgICAgICAgY2MubG9nKHVybCwgc3ByaXRlRnJhbWUsIHNwcml0ZSlcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAqL1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb2tlckluZGV4OiBmdW5jdGlvbihpZHgpe1xyXG4gICAgICAgIHRoaXMuX3Bva2VySW5kZXggPSBpZHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5yZXF1aXJlKFwiUG9rZXJTZWxlY3RIYW5kbGVyXCIpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgcG9rZXJTZWxlY3RQcmVmYWI6IGNjLlByZWZhYixcclxuICAgICAgICBzb3J0VHlwZUxhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICB0b3BCdG5MYWJlbDogY2MuTGFiZWwsXHJcbiAgICAgICAgbWlkZGxlQnRuTGFiZWw6IGNjLkxhYmVsLFxyXG4gICAgICAgIGJvdHRvbUJ0bkxhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICBjYXJkTGlzdDpjYy5Ob2RlLFxyXG4gICAgICAgIGNvbmZpcm1CdG46IGNjLk5vZGUsXHJcbiAgICAgICAgLy9hdXRvVHlwZUNvbnRhaW5lcjogY2MuTm9kZSxcclxuICAgICAgICBzY3JvbGx2aWV3X3JlY29tbWVuZDogY2MuTm9kZSxcclxuICAgICAgICBzY3JvbGx2aWV3X2ZyZWU6IGNjLk5vZGUsXHJcbiAgICAgICAgZnJlZUJ0bjogY2MuTm9kZSxcclxuICAgICAgICByZWNvbW1hbmRCdG46IGNjLk5vZGUsXHJcbiAgICAgICAgc3BlY2lhbEJ0bjogY2MuTm9kZSxcclxuICAgICAgICBsb2c6IGNjLkxhYmVsLFxyXG4gICAgICAgIHJlc2V0QWxsQnRuOiBjYy5Ob2RlLFxyXG4gICAgICAgIHNwZWNhaWxQYW5lbDogY2MuUHJlZmFiLFxyXG5cclxuICAgICAgICB0b3BEdW5Ob2RlOiBjYy5Ob2RlLFxyXG4gICAgICAgIG1pZER1bk5vZGU6IGNjLk5vZGUsXHJcbiAgICAgICAgYm90RHVuTm9kZTogY2MuTm9kZSxcclxuXHJcbiAgICAgICAgX3RvcDpbXSxcclxuICAgICAgICBfbWlkZGxlOltdLFxyXG4gICAgICAgIF9ib3R0b206W10sXHJcbiAgICAgICAgX3Bva2VyTGlzdDogbnVsbCxcclxuICAgICAgICBfY3VycmVudFNvcnRUeXBlOiAxLCAgLy/pu5jorqTmjInlpKflsI/mjpLluo9cclxuXHJcbiAgICAgICAgX2ZyZWVQb2tlcjogbnVsbCxcclxuXHJcbiAgICAgICAgLy9fcG9rZXJTZWxlY3RIYW5kbGVyOiBudWxsLFxyXG5cclxuICAgICAgICBfbGFzdEZvY3VzUG9rZXI6IG51bGwsICAgLy/lvZPliY3mir3lh7rnmoTniYxcclxuICAgICAgICBfZm9jdXNCZWdpbjrjgIBmYWxzZSwgICAgIC8v5piv5ZCm5ruR5Yqo5byA5aeLXHJcblxyXG4gICAgICAgIF9jdXJPcFR5cGU6IDEsICAgICAgIC8v5b2T5YmN5pON5L2c5pa55byPKDE6IGZyZWUgIDI6IGF1dG8pXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0UG9rZXJzKCk7XHJcbiAgICAgICAgdGhpcy5pbml0RnJlZVNvcnQoKTtcclxuICAgICAgICAvL3RoaXMuX3Bva2VyU2VsZWN0SGFuZGxlciA9IG5ldyBjYy5Qb2tlclNlbGVjdEhhbmRsZXIoKTtcclxuXHJcbiAgICAgICAgdmFyIGxhb3V0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiTmV3IExheW91dFwiKVxyXG5cclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQgfHwgY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xyXG4gICAgICAgICAgICB0aGlzLmNhcmRMaXN0Lm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJULCBmdW5jdGlvbihldmVudCl7IHRoaXMuX29uVG91Y2hCZWdpbihldmVudCkgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICB0aGlzLmNhcmRMaXN0Lm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX01PVkUsIGZ1bmN0aW9uKGV2ZW50KXsgdGhpcy5fb25Ub3VjaE1vdmUoZXZlbnQpIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgdGhpcy5jYXJkTGlzdC5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9FTkQsIGZ1bmN0aW9uKGV2ZW50KXsgdGhpcy5fb25Ub3VjaEVuZChldmVudCkgfS5iaW5kKHRoaXMpKVxyXG5cclxuICAgICAgICAgICAgbGFvdXQub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsIGZ1bmN0aW9uKGV2ZW50KXsgdGhpcy5jbGlja2JhY2soZXZlbnQpIH0uYmluZCh0aGlzKSlcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5jYXJkTGlzdC5vbihjYy5Ob2RlLkV2ZW50VHlwZS5NT1VTRV9ET1dOLCBmdW5jdGlvbihldmVudCl7IHRoaXMuX29uVG91Y2hCZWdpbihldmVudCkgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICB0aGlzLmNhcmRMaXN0Lm9uKGNjLk5vZGUuRXZlbnRUeXBlLk1PVVNFX01PVkUsIGZ1bmN0aW9uKGV2ZW50KXsgdGhpcy5fb25Ub3VjaE1vdmUoZXZlbnQpIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgdGhpcy5jYXJkTGlzdC5vbihjYy5Ob2RlLkV2ZW50VHlwZS5NT1VTRV9VUCwgZnVuY3Rpb24oZXZlbnQpeyB0aGlzLl9vblRvdWNoRW5kKGV2ZW50KSB9LmJpbmQodGhpcykpXHJcblxyXG4gICAgICAgICAgICBsYW91dC5vbihjYy5Ob2RlLkV2ZW50VHlwZS5NT1VTRV9ET1dOLCBmdW5jdGlvbihldmVudCl7IHRoaXMuY2xpY2tiYWNrKGV2ZW50KSB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRvcER1biA9IHRoaXMudG9wRHVuTm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckR1blwiKVxyXG4gICAgICAgIHRoaXMudG9wRHVuLmluaXQodGhpcylcclxuXHJcbiAgICAgICAgdGhpcy5taWRkbGVEdW4gPSB0aGlzLm1pZER1bk5vZGUuZ2V0Q29tcG9uZW50KFwiUG9rZXJEdW5cIilcclxuICAgICAgICB0aGlzLm1pZGRsZUR1bi5pbml0KHRoaXMpXHJcblxyXG4gICAgICAgIHRoaXMuYm90dG9tRHVuID0gdGhpcy5ib3REdW5Ob2RlLmdldENvbXBvbmVudChcIlBva2VyRHVuXCIpXHJcbiAgICAgICAgdGhpcy5ib3R0b21EdW4uaW5pdCh0aGlzKVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0UG9rZXJzOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX3Bva2VyTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Vuc2VsZWN0UG9rZXIgPSBjYy5nYW1lbWFuYWdlci5nZXRDdXJNYXRoUG9rZXJzKCkgICAgICAgICAvL+acquaUvuWFpeeahDEz5byg54mMXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlciA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6YCJ5oup5YeG5aSH5pS+5YWl55qE54mMXHJcblxyXG4gICAgICAgIC8vdmFyIHdpZHRoID0gY2MuY29uZmlnbWFuYWdlci53bmRTY2FsZSAqIDYwXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFNvcnRUeXBlID0gMVxyXG4gICAgICAgIGNjLlBva2VyVXRpbC5zb3J0UG9rZXIodGhpcy5fY3VycmVudFNvcnRUeXBlLCB0aGlzLl91bnNlbGVjdFBva2VyKTtcclxuICAgICAgICAvL3ZhciB0b3RhbFNpemUgPSAodGhpcy5fdW5zZWxlY3RQb2tlci5sZW5ndGggLSAxKSAqIDYwIC8gMjtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fdW5zZWxlY3RQb2tlci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIC8vdmFyIHNlbGVjdFBva2VyID0gY2MuaW5zdGFudGlhdGUodGhpcy5wb2tlclNlbGVjdFByZWZhYik7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RQb2tlciA9IHRoaXMuY2FyZExpc3QuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgc2VsZWN0UG9rZXIuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2VsZWN0UG9rZXIuZ2V0Q29tcG9uZW50KFwiUG9rZXJTZWxlY3RcIik7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9rZXJWYWwgPSB0aGlzLl91bnNlbGVjdFBva2VyW2ldO1xyXG4gICAgICAgICAgICBzY3JpcHQuc2V0UG9rZXJWYWx1ZShwb2tlclZhbCk7XHJcbiAgICAgICAgICAgIHNjcmlwdC5zZXRQb2tlckluZGV4KGkpO1xyXG5cclxuICAgICAgICAgICAgLy9zZWxlY3RQb2tlci5wYXJlbnQgPSB0aGlzLmNhcmRMaXN0O1xyXG4gICAgICAgICAgICAvL3NlbGVjdFBva2VyLnBvc2l0aW9uID0gY2MudjIoLXRvdGFsU2l6ZStpKjYwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9rZXJMaXN0LnB1c2goc2VsZWN0UG9rZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3ZhciBzY2FsZSA9IGNjLmNvbmZpZ21hbmFnZXIud25kU2NhbGVcclxuICAgICAgICAvL3RoaXMuY2FyZExpc3Quc2V0U2NhbGUoc2NhbGUsIHNjYWxlKVxyXG5cclxuICAgICAgICAvL+ajgOa1i+aYr+WQpuacieeJueauiueJjOWei1xyXG4gIFxyXG4gICAgICAgIHZhciBjdXJQb2tlcnMgPSBjYy5nYW1lbWFuYWdlci5nZXRDdXJNYXRoUG9rZXJzKClcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cC5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBjYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwW2ldKGN1clBva2VycylcclxuICAgICAgICAgICAgaWYocmV0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIuajgOa1i+WIsOacieeJueauiueJjOWeiyEhISB0eXBlPSBcIiwgaSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWNpYWxDYXJkID0gcmV0XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVjaWFsQ2FyZFR5cGUgPSBpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxCdG4uYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93U3BlY2lhbFduZCgpXHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAgIFxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aYvuekuueJueauiueJjOWei+aPkOekulxyXG4gICAgc2hvd1NwZWNpYWxXbmQ6IGZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgICAgICBpZighdGhpcy5fc3BlY2lhbENhcmQgfHwgIXRoaXMuX3NwZWNpYWxDYXJkVHlwZSl7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNwZWNpYWxXbmQgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnNwZWNhaWxQYW5lbClcclxuICAgICAgICBzcGVjaWFsV25kLnBhcmVudCA9IHRoaXMubm9kZVxyXG4gICAgICAgIHNwZWNpYWxXbmQucG9zaXRpb24gPSBjYy52MigwLCAwKVxyXG4gICAgICAgIHNwZWNpYWxXbmQuZ2V0Q29tcG9uZW50KFwiVUlTcGVjaWFsQ2FyZFwiKS5zZXRTcGVpY2FsKHRoaXMsIHRoaXMuX3NwZWNpYWxDYXJkVHlwZSwgdGhpcy5fc3BlY2lhbENhcmQpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5bCG55WZ5LiL55qE54mM6YeN5paw5o6S5bqPXHJcbiAgICBfcmVzZXRQb2tlcnM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRQb2tlcnNTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgY2MuUG9rZXJVdGlsLnNvcnRQb2tlcih0aGlzLl9jdXJyZW50U29ydFR5cGUsIHRoaXMuX3Vuc2VsZWN0UG9rZXIpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl91bnNlbGVjdFBva2VyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gdGhpcy5fdW5zZWxlY3RQb2tlcltpXTtcclxuICAgICAgICAgICAgaWYocG9rZXJWYWwgIT0gMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Bva2VyTGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIG5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBub2RlLmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0LnNldFBva2VyVmFsdWUocG9rZXJWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaSA9IGluZGV4OyBpIDwgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5fcG9rZXJMaXN0W2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/miorniYzorr7lm57liJ3lp4vkvY3nva5cclxuICAgIF9yZXNldFBva2Vyc1N0YXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2tlckxpc3QubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Bva2VyTGlzdFtpXTtcclxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiUG9rZXJTZWxlY3RcIik7XHJcbiAgICAgICAgICAgIGlmKHNjcmlwdC5faXNTZWxlY3RlZCA9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgIHNjcmlwdC5tb3ZlQmFjayhub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3JlZnJlc2hTZW5kQnRuU3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSAodGhpcy50b3BEdW4uaXNGdWxsKCkgJiYgdGhpcy5taWRkbGVEdW4uaXNGdWxsKCkgJiYgdGhpcy5ib3R0b21EdW4uaXNGdWxsKCkpXHJcbiAgICAgICAgdGhpcy5jb25maXJtQnRuLmFjdGl2ZSA9IHZpc2libGU7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEJ0bi5hY3RpdmUgPSB2aXNpYmxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVDYWxjdWxhdGVGcmVlU29ydDogZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5fY3VyT3BUeXBlID09IDEpe1xyXG4gICAgICAgICAgICB0aGlzLmluaXRGcmVlU29ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25DbGlja19Tb3J0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRTb3J0VHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNvcnRUeXBlID0gMjtcclxuICAgICAgICAgICAgdGhpcy5zb3J0VHlwZUxhYmVsLnN0cmluZyA9IFwi5aSn5bCP5o6S5bqPXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTb3J0VHlwZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydFR5cGVMYWJlbC5zdHJpbmcgPSBcIuiKseiJsuaOkuW6j1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0UG9rZXIoKTtcclxuICAgICAgICB0aGlzLl9yZXNldFBva2VycygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkemAgemAieaLqeWlveeahOeJjFxyXG4gICAgb25DbGlja19Db25maXJtOiBmdW5jdGlvbihldmVudCl7XHJcblxyXG4gICAgICAgIGlmKCF0aGlzLnRvcER1bi5pc0Z1bGwoKSB8fCAhdGhpcy5taWRkbGVEdW4uaXNGdWxsKCkgfHwgIXRoaXMuYm90dG9tRHVuLmlzRnVsbCl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIueJjOWiqeacqua7oeWwseimgeWHuueJjOS6hu+8n1wiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfdG9wID0gdGhpcy50b3BEdW4uY2FyZFZhbHVlc1xyXG4gICAgICAgIHZhciBfbWlkID0gdGhpcy5taWRkbGVEdW4uY2FyZFZhbHVlc1xyXG4gICAgICAgIHZhciBfYm90ID0gdGhpcy5ib3R0b21EdW4uY2FyZFZhbHVlc1xyXG5cclxuICAgICAgICAvL+WIpOaWreebuOWFrFxyXG4gICAgICAgIGlmKGNjLlBva2VyVXRpbC5pc01lc3NpcmUoX3RvcCwgX21pZCwgX2JvdCkpe1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm1zZ0JveChcIuebuOWFrOWVpu+8geivt+mHjeaWsOmAieeJjFwiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYXJkcyA9IFtdXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IF90b3AubGVuZ3RoOyArK2kpeyBjYXJkcy5wdXNoKF90b3BbaV0pO31cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgX21pZC5sZW5ndGg7ICsraSl7IGNhcmRzLnB1c2goX21pZFtpXSk7fVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfYm90Lmxlbmd0aDsgKytpKXsgY2FyZHMucHVzaChfYm90W2ldKTt9XHJcblxyXG4gICAgICAgIGlmKCFjYy5nYW1lbWFuYWdlci5pc1ByYWN0aWNlUm9vbSgpKXtcclxuICAgICAgICAgICAgLy/pnZ7nu4PkuaDmiL9cclxuICAgICAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19HMTNfQnJpbmdPdXRcIilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG1zZy5jYXJkcyA9IGNhcmRzXHJcbiAgICAgICAgICAgIG1zZy5zcGVjaWFsID0gZmFsc2VcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuXHJcbiAgICAgICAgICAgIHZhciBwZyA9IHRoaXMubm9kZS5wYXJlbnQuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIikuc2hvd1dhaXRTdGF0ZSgpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8v57uD5Lmg5oi/6Ze0XHJcbiAgICAgICAgICAgIHZhciByb3VuZCA9IGNjLmdhbWVtYW5hZ2VyLl9jdXJyZW50Um91bmRzXHJcbiAgICAgICAgICAgIGNjLnJvYm90LnNlbmRQbGF5ZXJJblJvb20ocm91bmQsIDQsIDQpXHJcbiAgICAgICAgICAgIGNjLnJvYm90LnNlbmRBbGxIYW5kcyhmYWxzZSwgY2FyZHMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpXHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnRUaXRsZVNob3codHJ1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UGFyZW50VGl0bGVTaG93OiBmdW5jdGlvbihzaG93KXtcclxuICAgICAgICBpZih0aGlzLm5vZGUucGFyZW50KXtcclxuICAgICAgICAgICAgdmFyIGNvbSA9IHRoaXMubm9kZS5wYXJlbnQuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIilcclxuICAgICAgICAgICAgaWYoY29tKXtcclxuICAgICAgICAgICAgICAgIGNvbS5zZXRUaXRsZVNob3coc2hvdylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/liJ3lp4vljJboh6rnlLHmkYbniYxcclxuICAgIGluaXRGcmVlU29ydDogZnVuY3Rpb24oZXZlbnQpe1xyXG5cclxuICAgICAgICBpZih0aGlzLl9jdXJPcFR5cGUgPT0gMil7XHJcbiAgICAgICAgICAgIC8v5YWI5riF6Zmk5LiK6Z2i5LiJ5aKp54mMXHJcbiAgICAgICAgICAgdGhpcy50b3BEdW4uY2xlYXJQb2tlcnMoKVxyXG4gICAgICAgICAgIHRoaXMubWlkZGxlRHVuLmNsZWFyUG9rZXJzKClcclxuICAgICAgICAgICB0aGlzLmJvdHRvbUR1bi5jbGVhclBva2VycygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jdXJPcFR5cGUgPSAxXHJcblxyXG4gICAgICAgIHRoaXMuc2Nyb2xsdmlld19mcmVlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLnNjcm9sbHZpZXdfcmVjb21tZW5kLmFjdGl2ZSA9IGZhbHNlXHJcblxyXG4gICAgICAgIHRoaXMuY2FyZExpc3QuYWN0aXZlID0gdHJ1ZVxyXG5cclxuICAgICAgICB0aGlzLnJlY29tbWFuZEJ0bi5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5mcmVlQnRuLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5fcmVjb21tYW5kUG9rZXIgPSBudWxsXHJcblxyXG4gICAgICAgIC8v5LiK5qyh6YCJ5Lit55qE54mM5Z6LXHJcbiAgICAgICAgdGhpcy5fbGFzdFNlbENhcmRUeXBlID0gLTFcclxuICAgICAgICB0aGlzLl9sYXN0U2VsQ2FyZElkeCA9IC0xXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvbiA9IHRoaXMuc2Nyb2xsdmlld19mcmVlLmdldENoaWxkQnlOYW1lKFwidmlld1wiKS5nZXRDaGlsZEJ5TmFtZShcImNvbnRlbnRcIilcclxuICAgICAgICB0aGlzLl9mcmVlUG9rZXIgPSBjYy5Qb2tlclV0aWwuZ2V0RnJlZVN0eWxlUG9rZXJTZXQodGhpcy5nZXRMZWZ0Q2FyZCgpKVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9mcmVlUG9rZXIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZyZWVQb2tlcltpXVxyXG4gICAgICAgICAgICB2YXIgYnRuID0gY29uLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcImNjLkJ1dHRvblwiKVxyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBjb24uY2hpbGRyZW5baV0uY2hpbGRyZW5bMF0uZ2V0Q29tcG9uZW50KGNjLkxhYmVsKVxyXG5cclxuICAgICAgICAgICAgY29uLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzFdLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIC8vY29uLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudHMoY2MuU3ByaXRlKVswXS5zcHJpdGVGcmFtZS5nZXRUZXh0dXJlKCkuc2V0QWxpYXNUZXhQYXJhbWV0ZXJzKClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxhYmVsLnN0cmluZyA9IGRhdGEubmFtZVxyXG4gICAgICAgICAgICBidG4uZGlzYWJsZWRDb2xvciA9IG5ldyBjYy5Db2xvcigyNTUsMjU1LDI1NSwyNTUpXHJcblxyXG4gICAgICAgICAgICBpZihkYXRhLnZhbHVlLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy9wYWl4aW5nQlROXCIsIGJ0bilcclxuICAgICAgICAgICAgICAgIGJ0bi5pbnRlcmFjdGFibGUgPSB0cnVlXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy9qaWFucGFuXCIsIGJ0bilcclxuICAgICAgICAgICAgICAgIGJ0bi5pbnRlcmFjdGFibGUgPSBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/kuIDplK7mkYbniYxcclxuICAgIG9uQ2xpY2tfUmVjb21tZW5kUG9rZXJCdG46IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBmdW5jdGlvbiBwcmludEFycihhLCBuYW1lKXtcclxuXHRcdFx0dmFyIHN0ciA9IG5hbWVcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHRcdHN0ciArPSAoYVtpXSArIFwiLCBcIilcclxuXHRcdFx0fVxyXG5cdFx0XHRjYy5sb2coc3RyKVxyXG5cdFx0fVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcmludEFycjIoYSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gKFwidDpcIiArIGFbaV0udHlwZSArIFwiIHY6XCIgKyBhW2ldLnZhbHVlICsgXCIgICwgXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2MubG9nKHN0cilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2Nyb2xsdmlld19mcmVlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5zY3JvbGx2aWV3X3JlY29tbWVuZC5hY3RpdmUgPSB0cnVlXHJcblxyXG4gICAgICAgIHRoaXMucmVjb21tYW5kQnRuLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5mcmVlQnRuLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLl9mcmVlUG9rZXIgPSBudWxsXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fY3VyT3BUeXBlID0gMlxyXG5cclxuICAgICAgICAvL+WFiOa4hemZpOS4iumdouS4ieWiqeeJjFxyXG4gICAgICAgIC8vaWYodGhpcy5fY3VyT3BUeXBlID09IDEpe1xyXG4gICAgICAgICAgIHRoaXMudG9wRHVuLmNsZWFyUG9rZXJzKClcclxuICAgICAgICAgICB0aGlzLm1pZGRsZUR1bi5jbGVhclBva2VycygpXHJcbiAgICAgICAgICAgdGhpcy5ib3R0b21EdW4uY2xlYXJQb2tlcnMoKVxyXG4gICAgICAgLy99XHJcblxyXG4gICAgICAgLy/kvJjljJbkuIDkuIvvvJrlj6rnrpfkuIDmrKFcclxuICAgICAgIGlmKHRoaXMuX3JlY29tbWFuZFBva2VyID09IG51bGwpe1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gY2MuUG9rZXJVdGlsLmdldFJlY29tbWVuZFBva2VyU2V0KHRoaXMuZ2V0TGVmdENhcmQoKSlcclxuICAgICAgICAgICAgY2MubG9nKFwi5LiA6ZSu5pGG55uY5LiA6ZSu5pGG55uYIFwiLCByZXQubGVuZ3RoKVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gY2MuY29uZmlnbWFuYWdlci5wb2tlckZsb3BDZmdcclxuICAgICAgICAgICAgICAgIGNjLmxvZyhyZXRbaV0udG9wLnR5cGUsIHJldFtpXS5taWRkbGUudHlwZSwgcmV0W2ldLmJvdHRvbS50eXBlKVxyXG4gICAgICAgICAgICAgICAgLy9wcmludEFycjIocmV0W2ldLnRvcC5jYXJkKVxyXG4gICAgICAgICAgICAgICAgLy9wcmludEFycjIocmV0W2ldLm1pZGRsZS5jYXJkKVxyXG4gICAgICAgICAgICAgICAgLy9wcmludEFycjIocmV0W2ldLmJvdHRvbS5jYXJkKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZWNvbW1hbmRQb2tlciA9IFtdXHJcbiAgICAgICAgICAgIHRoaXMuX3JlY1NlbElkeCA9IC0xXHJcbiAgICAgICAgICAgIHZhciB0NU5hbWUgPSBjYy5jb25maWdtYW5hZ2VyLnQ1TmFtZVxyXG4gICAgICAgICAgICB2YXIgdDNOYW1lID0gY2MuY29uZmlnbWFuYWdlci50M05hbWVcclxuXHJcbiAgICAgICAgICAgIHZhciBjb24gPSB0aGlzLnNjcm9sbHZpZXdfcmVjb21tZW5kLmdldENoaWxkQnlOYW1lKFwidmlld1wiKS5nZXRDaGlsZEJ5TmFtZShcImNvbnRlbnRcIilcclxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXRbaV1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoZGF0YS50b3AudHlwZSAhPSAtMSAmJiBkYXRhLm1pZGRsZS50eXBlICE9IC0xICYmIGRhdGEuYm90dG9tLnR5cGUgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb21tYW5kUG9rZXIucHVzaChkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJuYW1lID0gdDNOYW1lW2RhdGEudG9wLnR5cGVdICsgXCIgXCIgKyB0NU5hbWVbZGF0YS5taWRkbGUudHlwZV0gKyBcIiBcIiArIHQ1TmFtZVtkYXRhLmJvdHRvbS50eXBlXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coc3RybmFtZSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uLmNoaWxkcmVuW2lkeF0uYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbi5jaGlsZHJlbltpZHhdLmNoaWxkcmVuWzBdLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gc3RybmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbi5jaGlsZHJlbltpZHhdLmNoaWxkcmVuWzFdLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWR4KytcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gaWR4OyBpIDwgY29uLmNoaWxkcmVuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCJcIlxyXG4gICAgICAgICAgICAgICAgY29uLmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/oh6rnlLHpgInniYzmjInpkq7ngrnlh7tcclxuICAgIG9uQ2xpY2tfRnJlZVNlbGVjdEJ0bjogZnVuY3Rpb24oZXZlbnQsIGluZGV4KXtcclxuXHJcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdFBva2VyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRQb2tlcnNTdGF0ZSgpO1xyXG5cclxuICAgICAgICBpZih0aGlzLl9jdXJPcFR5cGUgPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9mcmVlUG9rZXIubGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coXCJjbGljayBfZnJlZVBva2VyIGRhdGEgZXJyb3IhXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbiA9IHRoaXMuc2Nyb2xsdmlld19mcmVlLmdldENoaWxkQnlOYW1lKFwidmlld1wiKS5nZXRDaGlsZEJ5TmFtZShcImNvbnRlbnRcIilcclxuICAgICAgICAgICAgaWYodGhpcy5fbGFzdFNlbENhcmRUeXBlID4gLTEgJiYgdGhpcy5fbGFzdFNlbENhcmRUeXBlIDwgY29uLmNoaWxkcmVuQ291bnQpe1xyXG4gICAgICAgICAgICAgICAgY29uLmNoaWxkcmVuW3RoaXMuX2xhc3RTZWxDYXJkVHlwZV0uY2hpbGRyZW5bMV0uYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5fbGFzdFNlbENhcmRUeXBlID09IGluZGV4KXtcclxuICAgICAgICAgICAgICAgICsrdGhpcy5fbGFzdFNlbENhcmRJZHhcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2xhc3RTZWxDYXJkSWR4ID49IHRoaXMuX2ZyZWVQb2tlcltpbmRleF0udmFsdWUubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2VsQ2FyZElkeCA9IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2VsQ2FyZFR5cGUgPSBpbmRleFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNlbENhcmRJZHggPSAwXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuX2xhc3RTZWxDYXJkVHlwZSA+IC0xICYmIHRoaXMuX2xhc3RTZWxDYXJkVHlwZSA8IGNvbi5jaGlsZHJlbkNvdW50KXtcclxuICAgICAgICAgICAgICAgIGNvbi5jaGlsZHJlblt0aGlzLl9sYXN0U2VsQ2FyZFR5cGVdLmNoaWxkcmVuWzFdLmFjdGl2ZSA9IGZhbHNlICAvL3RydWUgIOWPquaYr+aaguaXtuS4jemcgOimgVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLl9mcmVlUG9rZXIubGVuZ3RoID4gaW5kZXgpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyZWVQayA9IHRoaXMuX2ZyZWVQb2tlcltpbmRleF0udmFsdWVbdGhpcy5fbGFzdFNlbENhcmRJZHhdXHJcbiAgICAgICAgICAgICAgICBjYy5sb2coZnJlZVBrLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmcmVlUGsubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwdiA9IGZyZWVQa1tpXVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZyhcInB2LnR5cGVcIiwgcHYudHlwZSwgXCJwdi52YWx1ZVwiLCBwdi52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wb2tlckxpc3Rbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBub2RlLmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzY3JpcHQuX3Bva2VyVmFsID09IChwdi50eXBlKjEzK3B2LnZhbHVlKSAmJiAhc2NyaXB0Ll9pc1NlbGVjdGVkICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQubW92ZU91dChub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDYXJkKHNjcmlwdC5fcG9rZXJWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuX3JlY29tbWFuZFBva2VyICE9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fcmVjb21tYW5kUG9rZXIubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIGNjLmxvZyhcImNsaWNrIF9yZWNvbW1hbmRQb2tlciBkYXRhIGVycm9yIVwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNjLmxvZyhcIumAieS4rXJlY29tbWVuZCBcIiwgaW5kZXgsIHRoaXMuX3JlY29tbWFuZFBva2VyLmxlbmd0aClcclxuXHJcbiAgICAgICAgICAgIHZhciBjb24gPSB0aGlzLnNjcm9sbHZpZXdfcmVjb21tZW5kLmdldENoaWxkQnlOYW1lKFwidmlld1wiKS5nZXRDaGlsZEJ5TmFtZShcImNvbnRlbnRcIilcclxuICAgICAgICAgICAgaWYodGhpcy5fcmVjU2VsSWR4ID4gLTEgJiYgdGhpcy5fcmVjU2VsSWR4IDwgY29uLmNoaWxkcmVuQ291bnQpe1xyXG4gICAgICAgICAgICAgICAgY29uLmNoaWxkcmVuW3RoaXMuX3JlY1NlbElkeF0uY2hpbGRyZW5bMV0uYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pZih0aGlzLl9yZWNTZWxJZHggPT0gaW5kZXgpe1xyXG4gICAgICAgICAgICAvLyAgICByZXR1cm5cclxuICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZWNTZWxJZHggPSBpbmRleFxyXG4gICAgICAgICAgICB2YXIgZGF0ID0gdGhpcy5fcmVjb21tYW5kUG9rZXJbaW5kZXhdXHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLl9yZWNTZWxJZHggPiAtMSAmJiB0aGlzLl9yZWNTZWxJZHggPCBjb24uY2hpbGRyZW5Db3VudCl7XHJcbiAgICAgICAgICAgICAgICBjb24uY2hpbGRyZW5bdGhpcy5fcmVjU2VsSWR4XS5jaGlsZHJlblsxXS5hY3RpdmUgPSBmYWxzZSAvL3RydWUg5Y+q5piv5pqC5pe25LiN6ZyA6KaBXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudG9wRHVuLmNsZWFyUG9rZXJzKClcclxuICAgICAgICAgICAgdGhpcy5taWRkbGVEdW4uY2xlYXJQb2tlcnMoKVxyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbUR1bi5jbGVhclBva2VycygpXHJcblxyXG4gICAgICAgICAgICAvL3ZhciB0b3AgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoZGF0LnRvcC5jYXJkKVxyXG4gICAgICAgICAgICAvL2NjLmxvZyhcInNlbGVjdCB0b3Agc2l6ZSA9IFwiLCB0b3AubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gZGF0LnRvcC5jYXJkLnNsaWNlKClcclxuICAgICAgICAgICAgdGhpcy50b3BEdW4ub25jbGlja19QdXNoQnRuKG51bGwsIC0xKVxyXG5cclxuICAgICAgICAgICAgLy92YXIgbWlkID0gY2MuUG9rZXJVdGlsLmNhcmRzRW5jb2RlKGRhdC5taWRkbGUuY2FyZClcclxuICAgICAgICAgICAgLy9jYy5sb2coXCJzZWxlY3QgbWlkIHNpemUgPSBcIiwgbWlkLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlciA9IGRhdC5taWRkbGUuY2FyZC5zbGljZSgpXHJcbiAgICAgICAgICAgIHRoaXMubWlkZGxlRHVuLm9uY2xpY2tfUHVzaEJ0bihudWxsLCAtMSlcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGJvdCA9IGNjLlBva2VyVXRpbC5jYXJkc0VuY29kZShkYXQuYm90dG9tLmNhcmQpXHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwic2VsZWN0IGJvdHRvbSBzaXplID0gXCIsIGJvdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkUG9rZXIgPSBkYXQuYm90dG9tLmNhcmQuc2xpY2UoKVxyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbUR1bi5vbmNsaWNrX1B1c2hCdG4obnVsbCwgLTEpXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW11cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iHquWKqOaUvuWFpeWJqeS4i+eahOeJjFxyXG4gICAgYXV0b1B1dExlZnRDYXJkOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLmxvZyhcIuiHquWKqOaUvuWFpVwiKVxyXG4gICAgICAgIHZhciBsZWZ0Y2FyZCA9IHRoaXMuZ2V0TGVmdENhcmQoKVxyXG4gICAgICAgIGlmKGxlZnRjYXJkLmxlbmd0aCA9PSAwIHx8IGxlZnRjYXJkLmxlbmd0aCA+IDUpe1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmdWxsbnVtID0gMFxyXG4gICAgICAgIHZhciBub3RmdWxsZHVuID0gW11cclxuICAgICAgICB2YXIgZHVucyA9IFt0aGlzLnRvcER1biwgdGhpcy5taWRkbGVEdW4sIHRoaXMuYm90dG9tRHVuXVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkdW5zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoZHVuc1tpXS5pc0Z1bGwoKSl7XHJcbiAgICAgICAgICAgICAgICBmdWxsbnVtKytcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBub3RmdWxsZHVuLnB1c2goZHVuc1tpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAgY2MubG9nKFwi6Ieq5Yqo5pS+5YWlICBcIiwgZnVsbG51bSwgbm90ZnVsbGR1bi5sZW5ndGgpXHJcbiAgICAgICAgaWYoZnVsbG51bSA9PSAyICYmIG5vdGZ1bGxkdW4ubGVuZ3RoID09IDEpe1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gbGVmdGNhcmQuc2xpY2UoKVxyXG4gICAgICAgICAgICBub3RmdWxsZHVuWzBdLm9uY2xpY2tfUHVzaEJ0bihudWxsLCAtMSlcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlciA9IFtdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkemAgeeJueauiueJjOWei1xyXG4gICAgc2VuZFNwZWNpYWxDYXJkOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjYXJkcyA9IFtdXHJcblxyXG4gICAgICAgIGlmKHRoaXMuX3NwZWNpYWxDYXJkLnRvcCAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYodGhpcy5fc3BlY2lhbENhcmQudG9wLmxlbmd0aCAhPSAzIHx8ICB0aGlzLl9zcGVjaWFsQ2FyZC5taWRkbGUubGVuZ3RoICE9IDVcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX3NwZWNpYWxDYXJkLmJvdHRvbS5sZW5ndGggIT0gNSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coXCLnibnmrorniYzlnovliKTmlq3plJnor6/vvIHvvIHvvIFcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FyZHMgPSBjYXJkcy5jb25jYXQodGhpcy5fc3BlY2lhbENhcmQudG9wLCB0aGlzLl9zcGVjaWFsQ2FyZC5taWRkbGUsIHRoaXMuX3NwZWNpYWxDYXJkLmJvdHRvbSlcclxuICAgICAgICB9ZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FyZHMgPSBjYy5nYW1lbWFuYWdlci5nZXRDdXJNYXRoUG9rZXJzKCkuc2xpY2UoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MubG9nKFwi5Y+R6YCB54m55q6K54mM5Z6LISEhISFcIilcclxuICAgICAgICBjYy5Qb2tlclV0aWwucHJpbnRQb2tlckVuY29kZShjYXJkcylcclxuXHJcbiAgICAgICAgaWYoIWNjLmdhbWVtYW5hZ2VyLmlzUHJhY3RpY2VSb29tKCkpe1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coXCJQdWJsaWNQcm90by5DX0cxM19CcmluZ091dFwiKVxyXG4gICAgICAgICAgICBtc2cuY2FyZHMgPSBjYXJkc1xyXG4gICAgICAgICAgICBtc2cuc3BlY2lhbCA9IHRydWVcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIHJvdW5kID0gY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHNcclxuICAgICAgICAgICAgY2Mucm9ib3Quc2VuZFBsYXllckluUm9vbShyb3VuZCwgNCwgNClcclxuICAgICAgICAgICAgY2Mucm9ib3Quc2VuZEFsbEhhbmRzKHRydWUsIGNhcmRzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBnID0gdGhpcy5ub2RlLnBhcmVudC5nZXRDb21wb25lbnQoXCJVSVBva2VyR2FtZVwiKS5zaG93V2FpdFN0YXRlKClcclxuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpXHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnRUaXRsZVNob3codHJ1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgInmi6nnibnmrorniYzlnotcclxuICAgIHNlbFNwZWNpYWxDYXJkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZih0aGlzLl9zcGVjaWFsQ2FyZCA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2hvd1NwZWNpYWxXbmQoKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+mHjee9ruS4ieWiqeeJjFxyXG4gICAgcmVzZXRUaHJlZUR1bjogZnVuY3Rpb24oKXtcclxuICAgICAgICBpZih0aGlzLl9jdXJPcFR5cGUgPT0gMil7XHJcbiAgICAgICAgICAgIHRoaXMub25DbGlja19SZWNvbW1lbmRQb2tlckJ0bigpXHJcbiAgICAgICAgICAgIHRoaXMudG9wRHVuLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICAgICAgICAgIHRoaXMubWlkZGxlRHVuLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tRHVuLl9yZWZyZXNoQnV0dG9uVGV4dCgpXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMudG9wRHVuLmNsZWFyRHVuKClcclxuICAgICAgICAgICAgdGhpcy5taWRkbGVEdW4uY2xlYXJEdW4oKVxyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbUR1bi5jbGVhckR1bigpXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2VsZWN0Q2FyZDogZnVuY3Rpb24odmFsKXtcclxuICAgICAgICBjYy5sb2coXCJzZWxlY3Q6IFwiICsgdmFsKTtcclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyLnB1c2godmFsKTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5zZWxlY3RDYXJkOiBmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWxlY3RlZFBva2VyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5fc2VsZWN0ZWRQb2tlcltpXSA9PSB2YWwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlci5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2MubG9nKFwidW5zZWxlY3Q6IFwiICsgdmFsICsgXCIsIGFscmVhZHkgdW5zZWxlY3QgbnVtOiBcIiArIHRoaXMuX3NlbGVjdGVkUG9rZXIubGVuZ3RoKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+W9k+acieeJjOaUvuWFpeeJjOWiqeinpuWPkeS6i+S7tlxyXG4gICAgb25QdXRkb3duQ2FyZDogZnVuY3Rpb24oKXtcclxuICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl91bnNlbGVjdFBva2VyKXtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VsZWN0ZWRQb2tlci5pbmRleE9mKHRoaXMuX3Vuc2VsZWN0UG9rZXJbaV0pXHJcbiAgICAgICAgICAgIGlmKCBpbmRleCAhPSAtMSl7XHJcbiAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0UG9rZXJbaV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW107XHJcblxyXG4gICAgICAgLy/lsIbnlZnkuIvnmoTniYzph43mlrDmmL7npLpcclxuICAgICAgIHRoaXMuX3Jlc2V0UG9rZXJzKClcclxuXHJcbiAgICAgICAvL+mHjeaWsOiuoeeul+eJjOWei1xyXG4gICAgICAgdGhpcy5fcmVDYWxjdWxhdGVGcmVlU29ydCgpO1xyXG5cclxuICAgICAgIHRoaXMuX3JlZnJlc2hTZW5kQnRuU3RhdGUoKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+W9k+aKiueJjOS7jueJjOWiqeaSpOWbnuadpeinpuWPkeS6i+S7tlxyXG4gICAgb25GYWxsYmFja0NhcmQ6IGZ1bmN0aW9uKGNhcmRzKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FyZHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5fdW5zZWxlY3RQb2tlci5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl91bnNlbGVjdFBva2VyW2pdID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0UG9rZXJbal0gPSBjYXJkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW107XHJcblxyXG4gICAgICAgLy/lsIbnlZnkuIvnmoTniYzph43mlrDmmL7npLpcclxuICAgICAgIHRoaXMuX3Jlc2V0UG9rZXJzKCkgXHJcblxyXG4gICAgICAgLy/ph43mlrDorqHnrpfniYzlnotcclxuICAgICAgIHRoaXMuX3JlQ2FsY3VsYXRlRnJlZVNvcnQoKTtcclxuXHJcbiAgICAgICB0aGlzLl9yZWZyZXNoU2VuZEJ0blN0YXRlKClcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGVmdENhcmQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHJldCA9IFtdXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Vuc2VsZWN0UG9rZXIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZih0aGlzLl91bnNlbGVjdFBva2VyW2ldICE9IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2godGhpcy5fdW5zZWxlY3RQb2tlcltpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5sb2coXCJnZXRMZWZ0Q2FyZCBzaXplID0gXCIsIHJldC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIHJldFxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclNlbGVjdFBva2VyOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkUG9rZXIgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/mmK/lkKblnKh0YXJnZXQgc2l6ZeWMuuWfn+WGhVxyXG4gICAgX2lzSW5UYXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcG9pbnQpe1xyXG4gICAgICAgIGlmKHRhcmdldCA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbG9jYXRpb25Jbk5vZGUgPSB0YXJnZXQuY29udmVydFRvTm9kZVNwYWNlKHBvaW50KVxyXG4gICAgICAgIHZhciBzaXplID0gdGFyZ2V0LmdldENvbnRlbnRTaXplKClcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyAgY2MucmVjdCgwLDAsc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9yZWN0LnggID0gICAtc2l6ZS53aWR0aC8yXHJcbiAgICAgICAgLy9yZWN0LnkgID0gICAtc2l6ZS5oZWlnaHQvMlxyXG5cclxuICAgICAgICBpZihjYy5yZWN0Q29udGFpbnNQb2ludChyZWN0LCBsb2NhdGlvbkluTm9kZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgInmi6nniYxcclxuICAgIF9zZWxlY3RQb2tlcjogZnVuY3Rpb24ocG9pbnQpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IHRoaXMuX3Bva2VyTGlzdC5sZW5ndGgtMTsgaSA+PSAwIDsgLS1pKXtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3Bva2VyTGlzdFtpXVxyXG4gICAgICAgICAgICBpZih0YXJnZXQuYWN0aXZlICYmIHRoaXMuX2lzSW5UYXJnZXQodGFyZ2V0LCBwb2ludCkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIF9vblRvdWNoQmVnaW46IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZih0aGlzLl9mb2N1c0JlZ2luID09IHRydWUpe1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWxlY3RQb2tlcihldmVudC5nZXRMb2NhdGlvbigpKVxyXG4gICAgICAgIGlmKHRhcmdldCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRhcmdldC5nZXRDb21wb25lbnQoXCJQb2tlclNlbGVjdFwiKVxyXG4gICAgICAgICAgICBpZighY29tcG9uZW50Ll9pc1NlbGVjdGVkKXtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tb3ZlT3V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENhcmQoY29tcG9uZW50Ll9wb2tlclZhbCk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm1vdmVCYWNrKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0Q2FyZChjb21wb25lbnQuX3Bva2VyVmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0Rm9jdXNQb2tlciA9IHRhcmdldFxyXG4gICAgICAgICAgICB0aGlzLl9mb2N1c0JlZ2luID0gdHJ1ZVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrYmFjaygpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZih0aGlzLl9mb2N1c0JlZ2luID09IGZhbHNlKXtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VsZWN0UG9rZXIoZXZlbnQuZ2V0TG9jYXRpb24oKSlcclxuXHJcbiAgICAgICAgaWYodGFyZ2V0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpXHJcblxyXG4gICAgICAgICAgICBpZih0YXJnZXQgPT0gdGhpcy5fbGFzdEZvY3VzUG9rZXIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGb2N1c1Bva2VyID0gdGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZighY29tcG9uZW50Ll9pc1NlbGVjdGVkKXtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tb3ZlT3V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENhcmQoY29tcG9uZW50Ll9wb2tlclZhbCk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm1vdmVCYWNrKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0Q2FyZChjb21wb25lbnQuX3Bva2VyVmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB0aGlzLl9mb2N1c0JlZ2luID0gZmFsc2VcclxuICAgICAgICB0aGlzLl9sYXN0Rm9jdXNQb2tlciA9IG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgY2xpY2tiYWNrOiBmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdFBva2VyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRQb2tlcnNTdGF0ZSgpO1xyXG4gICAgfSxcclxufSk7XHJcbiIsIlxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuICAgIGN0b3I6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgfSxcclxuXHJcbi8qXHJcbuaJkeWFi+eJjOaPj+i/sFxyXG4gICAg6Iqx6Imy77yaICDpu5HmoYMgMyAg44CB57qi5qGDIDIg44CBIOaiheiKsSAxIOOAgeaWueWdlyAwXHJcbiAgICDniYzngrnmlbDvvJogMiB+IEEgPT0gMSB+IDEzXHJcbiAgICDniYzmlbDlgLwgPSAo6Iqx6ImyICogMTMgKyDngrnmlbAgLSAxIClcclxuKi9cclxuXHJcblxyXG4gICAgX2dldFBva2VyU3ByaXRlUGF0aDpmdW5jdGlvbihwb2tlclZhbCl7XHJcbiAgICAgICAgcmV0dXJuIFwiVGV4dHVyZXMvUG9rZXIvXCIgKyBwb2tlclZhbC50b1N0cmluZygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+iuvue9ruaJkeWFi+eJjOWbvueJh1xyXG4gICAgcmVwbGFjZVBva2VyU3ByaXRlOmZ1bmN0aW9uKHBva2VyVmFsLCBub2RlKXtcclxuICAgICAgICB2YXIgc3ByaXRlID0gbm9kZS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcclxuICAgICAgICB2YXIgdXJsID0gY2MuUG9rZXJVdGlsLl9nZXRQb2tlclNwcml0ZVBhdGgocG9rZXJWYWwpO1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHVybCwgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZTtcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcblx0Ly/orr7nva7miZHlhYvniYzlm77niYdcclxuXHRyZXBsYWNlU3ByaXRlOiBmdW5jdGlvbihwYXRoLCBub2RlKXtcclxuXHRcdHZhciBzcHJpdGUgPSBub2RlLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHBhdGgsIGNjLlNwcml0ZUZyYW1lLCBmdW5jdGlvbihlcnIsIHNwcml0ZUZyYW1lKXtcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgfSlcclxuXHR9LFxyXG5cclxuICAgIC8v6L+U5Zue54mM6Iqx6Imy5ZKM54K55pWwXHJcbiAgICBfZ2V0Q2FyZFR5cGU6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHZhciByZXQgPSB7fTtcclxuICAgICAgICByZXQueCA9ICh4LTEpLzEzO1xyXG4gICAgICAgIHJldC55ID0gKHgtMSklMTM7XHJcbiAgICAgICAgcmV0dXJuIHJldFxyXG4gICAgfSxcclxuXHJcblx0Ly/ljZXlvKDmiZHlhYvop6PnoIFcclxuXHRzaW5nbGVDYXJkc0RlY29kZTogZnVuY3Rpb24oYyl7XHJcblx0XHR2YXIgcmV0ID0ge31cclxuXHRcdHJldC50eXBlID0gTWF0aC5mbG9vcigoYyAtIDEpIC8gMTMpO1xyXG5cdFx0cmV0LnZhbHVlID0gYyAtIHJldC50eXBlICogMTM7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH0sXHJcblxyXG5cdC8v5Y2V5byg5omR5YWL57yW56CBXHJcblx0c2luZ2xlQ2FyZHNFbmNvZGU6IGZ1bmN0aW9uKG8pe1xyXG5cdFx0cmV0dXJuIG8udHlwZSAqIDEzICsgby52YWx1ZTtcclxuXHR9LFxyXG5cclxuXHQvL+aJkeWFi+ino+eggVxyXG5cdGNhcmRzRGVjb2RlOiBmdW5jdGlvbihjQXJyKXtcclxuXHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjQXJyLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIGMgPSB7fVxyXG5cdFx0XHRjLnR5cGUgPSBNYXRoLmZsb29yKChjQXJyW2ldLTEpLzEzKTtcclxuXHRcdFx0Yy52YWx1ZSA9IGNBcnJbaV0gLSBjLnR5cGUqMTM7XHJcblx0XHRcdGFyci5wdXNoKGMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9LFxyXG5cclxuXHQvL+aJkeWFi+e8lueggVxyXG5cdGNhcmRzRW5jb2RlOiBmdW5jdGlvbihjQXJyKXtcclxuXHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjQXJyLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIGMgPSBjQXJyW2ldO1xyXG5cdFx0XHRhcnIucHVzaChjLnR5cGUqMTMrYy52YWx1ZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXJyO1xyXG5cdH0sXHJcblxyXG5cdF9jb3B5QXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcblx0XHR2YXIgcmV0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRyZXQucHVzaChhcnJbaV0pO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9LFxyXG5cclxuXHQvL+WIoOmZpOaJkeWFizogYSwgYuS4reWIoOmZpOWQjOagt+eahOWFg+e0oFxyXG5cdF9kZWxDYXJkczogZnVuY3Rpb24oc3JjLCBkZWwpe1xyXG5cdFx0dmFyIGEgPSBjYy5Qb2tlclV0aWwuX2NvcHlBcnJheShzcmMpXHJcblx0XHR2YXIgYiA9IGNjLlBva2VyVXRpbC5fY29weUFycmF5KGRlbClcclxuXHJcblx0XHRpZihiLmxlbmd0aCA9PSAwKXtcclxuXHRcdFx0cmV0dXJuIGFcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IGEubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2ope1xyXG5cdFx0XHRcdGlmKGFbaV0gPT0gYltqXSl7XHJcblx0XHRcdFx0XHRhLnNwbGljZShpLCAxKVxyXG5cdFx0XHRcdFx0Yi5zcGxpY2UoaiwgMSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhXHJcblx0fSxcclxuXHJcblx0Ly/ojrflj5bmma7pgJrnu4TlkIjniYzlnosgY0Fycjog5Lyg5YWl5pyq6Kej56CB55qE54mM5pWw5YC85pWw57uEXHJcblx0Z2V0R3JvdXBDYXJkczogZnVuY3Rpb24oY0Fycil7XHJcblx0XHR2YXIgdG1wQXJyID0gY2MuUG9rZXJVdGlsLl9jb3B5QXJyYXkoY0Fycik7XHJcblx0XHRjYy5Qb2tlclV0aWwuc29ydFBva2VyKDEsIHRtcEFycik7XHJcblx0XHR2YXIgZGVjb2RlQXJyID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKHRtcEFycik7XHJcblxyXG5cdFx0dmFyIHdsQXJyPVtdLCBkekFycj1bXSwgc3RBcnI9W10sIHR6QXJyPVtdLCB3dEFycj1bXSwgc0Fycj1bXSwgc3pBcnI9W107XHJcblx0XHR2YXIgc3pfbiA9IDA7XHJcblx0XHR2YXIgbnVtID0gZGVjb2RlQXJyLmxlbmd0aDtcclxuXHRcdFxyXG5cdFx0dmFyIHNhbWUgPSBbXVxyXG5cdFx0dmFyIG5vdHNhbWUgPSBbXVxyXG5cdFx0XHJcblx0XHR2YXIgYWxsZHogPSBbXVxyXG5cdFx0XHJcblx0XHRmb3IodmFyIGkgPSBudW0tMTsgaSA+PSAwOyl7XHJcblx0XHRcdHZhciBsYXN0ID0gZGVjb2RlQXJyW2ldXHJcblx0XHRcdFxyXG5cdFx0XHQtLWlcclxuXHRcdFx0dmFyIGZpbmQgPSBmYWxzZVxyXG5cdFx0XHR3aGlsZShpID49IDAgJiZsYXN0LnZhbHVlID09IGRlY29kZUFycltpXS52YWx1ZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZpbmQgPSB0cnVlXHJcblx0XHRcdFx0c2FtZS5wdXNoKGxhc3QpXHJcblx0XHRcdFx0bGFzdCA9IGRlY29kZUFycltpXVxyXG5cdFx0XHRcdC0taVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGZpbmQpe1xyXG5cdFx0XHRcdHNhbWUucHVzaChsYXN0KVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKHNhbWUubGVuZ3RoID4gMSl7XHJcblx0XHRcdFx0XHRpZihzYW1lLmxlbmd0aCA9PSAyKVx0ZHpBcnIucHVzaChbc2FtZVsxXSwgc2FtZVswXV0pXHJcblx0XHRcdFx0XHRpZihzYW1lLmxlbmd0aCA9PSAzKSBcdHN0QXJyLnB1c2goW3NhbWVbMl0sc2FtZVsxXSxzYW1lWzBdXSlcclxuXHRcdFx0XHRcdGlmKHNhbWUubGVuZ3RoID09IDQpIFx0dHpBcnIucHVzaChbc2FtZVszXSxzYW1lWzJdLHNhbWVbMV0sc2FtZVswXV0pXHJcblx0XHRcdFx0XHRpZihzYW1lLmxlbmd0aCA9PSA1KSBcdHd0QXJyLnB1c2goW3NhbWVbNF0sIHNhbWVbM10sc2FtZVsyXSxzYW1lWzFdLHNhbWVbMF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFx0Zm9yKHZhciBpZHggPSAwOyBpZHggPCBzYW1lLmxlbmd0aDsgKytpZHgpe1xyXG5cdFx0XHRcdFx0YWxsZHoucHVzaChzYW1lW2lkeF0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHRzYW1lID0gW11cclxuXHRcdFx0fVxyXG5cdFx0XHRub3RzYW1lLnB1c2gobGFzdClcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYobm90c2FtZS5sZW5ndGggPiAwKXtcclxuXHRcdFx0Zm9yKHZhciBpID0gbm90c2FtZS5sZW5ndGgtMTsgaSA+PSAwOyl7XHJcblx0XHRcdFx0dmFyIGxhc3QgPSBub3RzYW1lW2ldXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0LS1pXHJcblx0XHRcdFx0dmFyIHRtcCA9IFtdXHJcblx0XHRcdFx0d2hpbGUoaSA+PSAwICYmIGxhc3QudmFsdWUgPT0gbm90c2FtZVtpXS52YWx1ZSsxKXtcclxuXHRcdFx0XHRcdHRtcC5wdXNoKGxhc3QpXHJcblx0XHRcdFx0XHRsYXN0ID0gbm90c2FtZVtpXVxyXG5cdFx0XHRcdFx0LS1pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRtcC5wdXNoKGxhc3QpXHJcblx0XHRcdFx0aWYodG1wLmxlbmd0aCA+PSA1KXtcclxuXHRcdFx0XHRcdHN6QXJyLnB1c2godG1wKVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHRtcC5sZW5ndGg7ICsrail7XHJcblx0XHRcdFx0XHRcdHZhciBlbGUgPSB0bXBbal1cclxuXHRcdFx0XHRcdFx0dmFyIGZuZCA9IGZhbHNlXHJcblx0XHRcdFx0XHRcdGZvcih2YXIgbSA9IDA7IG0gPCBhbGxkei5sZW5ndGg7ICsrbSl7XHJcblx0XHRcdFx0XHRcdFx0aWYoYWxsZHpbbV0udHlwZSA9PSBlbGUudHlwZSAmJiBhbGxkelttXS52YWx1ZSA9PSBlbGUudmFsdWUpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm5kID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoZm5kID09IGZhbHNlKXtcclxuXHRcdFx0XHRcdFx0XHR3bEFyci5wdXNoKHRtcFtqXSlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL2R6QXJyLnJldmVyc2UoKVxyXG5cdFx0Ly9zdEFyci5yZXZlcnNlKClcclxuXHRcdC8vdHpBcnIucmV2ZXJzZSgpXHJcblx0XHQvL3d0QXJyLnJldmVyc2UoKVxyXG5cdFx0d2xBcnIucmV2ZXJzZSgpXHJcblx0XHRcclxuXHRcdHZhciByZXQgPSBbXTtcclxuXHRcdHJldC5wdXNoKHdsQXJyLGR6QXJyLHN0QXJyLHR6QXJyLHN6QXJyLGRlY29kZUFycix3dEFycik7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL+S5jOm+me+8iOS4ieW8oO+8iVxyXG5cdHd1bG9uZ1RocmVlOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKVxyXG5cdFx0dmFyIHdsQXJyID0gY0FyclswXSwgY2FyZHNBcnI9W107XHJcblx0XHRmb3IodmFyIGkgPSB3bEFyci5sZW5ndGgtMTsgaSA+PSAyOyAtLWkpe1xyXG5cdFx0XHRjYXJkc0Fyci5wdXNoKFt3bEFycltpXSx3bEFycltpLTFdLHdsQXJyW2ktMl1dKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiA5a+577yI5LiJ5byg77yJXHJcblx0eWlkdWlUaHJlZTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCAzKVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHRcclxuXHRcdHZhciBjQXJyID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHdsQXJyPWNBcnJbMF0sIGR6QXJyPWNBcnJbMV07XHJcblx0XHRpZihkekFyci5sZW5ndGggPiAwICYmIHdsQXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRmb3IodmFyIGkgPSBkekFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdGNhcmRzQXJyLnB1c2goW2R6QXJyW2ldWzBdLCBkekFycltpXVsxXSwgd2xBcnJbMF1dKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/kuInmnaEo5LiJ5bygKVxyXG5cdHNhbnRpYW86IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjYXJkc0FyciA9IFtdO1xyXG5cdFx0aWYoY2FyZHMubGVuZ3RoIDwgMylcclxuXHRcdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdFx0XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciBzdEFyciA9IGNBcnJbMl07XHJcblx0XHRmb3IodmFyIGkgPSBzdEFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRjYXJkc0Fyci5wdXNoKHN0QXJyW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cclxuXHQvL+S5jOm+mSjkupTlvKApXHJcblx0d3Vsb25nRml2ZTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHRcclxuXHRcdHZhciBjQXJyID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHdsQXJyID0gY0FyclswXTtcclxuXHRcdGlmKHdsQXJyLmxlbmd0aCA+IDQgKXtcclxuXHRcdFx0Zm9yKCB2YXIgaSA9IHdsQXJyLmxlbmd0aC0xOyBpID49IDQ7IC0taSl7XHJcblx0XHRcdFx0dmFyIGFyciA9IFt3bEFycltpXSx3bEFyclszXSx3bEFyclsyXSx3bEFyclsxXSx3bEFyclswXV07XHJcblx0XHRcdFx0dmFyIGNmbGFnID0gZmFsc2U7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMTsgaiA8IGFyci5sZW5ndGg7ICsrail7XHJcblx0XHRcdFx0XHRpZihhcnJbal0udHlwZSAhPSBhcnJbai0xXS50eXBlKXtcdC8v55yL5LmM6b6Z6Iqx6Imy5piv5ZCm5LiA5qC3LOaOkumZpOa4heS4gOiJslxyXG5cdFx0XHRcdFx0XHRjZmxhZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihjZmxhZyl7XHQvL+S4jeaYr+WQjOiKseiJslxyXG5cdFx0XHRcdFx0Y2ZsYWcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDE7IGogPCBhcnIubGVuZ3RoOyArK2ope1xyXG5cdFx0XHRcdFx0XHRpZihhcnJbal0udmFsdWUgIT0gYXJyW2otMV0udmFsdWUrMSl7XHJcblx0XHRcdFx0XHRcdFx0Y2ZsYWcgPSB0cnVlO1x0Ly/nnIvmmK/lkKbmmK/pobrlrZBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly9BMjM0NVxyXG5cdFx0XHRcdFx0aWYoY2ZsYWcgJiYgYXJyWzBdLnZhbHVlID09IDEzICYmIGFyclsxXS52YWx1ZSA9PSA0ICYmIGFyclsyXS52YWx1ZSA9PSAzICYmIGFyclszXS52YWx1ZSA9PSAyICYmIGFycls0XS52YWx1ZSA9PSAxKVxyXG5cdFx0XHRcdFx0XHRjZmxhZyA9IGZhbHNlXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmKGNmbGFnKXtcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChhcnIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiA5a+577yI5LqU5byg77yJXHJcblx0eWlkdWlGaXZlOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdO1xyXG5cdFx0aWYoZHpBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdGlmKHdsQXJyLmxlbmd0aCA+IDIpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IGR6QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtkekFycltpXVswXSwgZHpBcnJbaV1bMV0sd2xBcnJbMl0sd2xBcnJbMV0sd2xBcnJbMF1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKGR6QXJyLmxlbmd0aCA+IDMpeyAvL+S5jOm+meS4jeWkn++8jOaLhuWvueWtkFxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IGR6QXJyLmxlbmd0aC0xOyBpID49IDM7IC0taSl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtkekFycltpXVsxXSwgZHpBcnJbaV1bMF0sZHpBcnJbMl1bMV0sZHpBcnJbMV1bMV0sZHpBcnJbMF1bMV1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cclxuXHQvL+S4pOWvue+8iOS6lOW8oClcclxuXHRsaWFuZ2R1aTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdO1xyXG5cdFx0aWYoKGR6QXJyLmxlbmd0aD4xICYmIHdsQXJyLmxlbmd0aD4wKSB8fCBkekFyci5sZW5ndGggPiAyKXtcclxuXHRcdFx0dmFyIGkgPSBkekFyci5sZW5ndGg7XHJcblx0XHRcdHZhciBjb25kaXRpb24gPSAxO1xyXG5cdFx0XHRpZih3bEFyci5sZW5ndGggPT0gMCl7XHJcblx0XHRcdFx0Y29uZGl0aW9uID0gMjsgICAvL+ayoeacieS5jOm+meimgeaLhuS4gOWvuVxyXG5cdFx0XHR9XHJcblx0XHRcdGZvcih2YXIgaiA9IGR6QXJyLmxlbmd0aC0xOyBqID49IGNvbmRpdGlvbjsgLS1qKXtcclxuXHRcdFx0XHRpZih3bEFyci5sZW5ndGggPT0gMCl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtkekFycltqXVswXSxkekFycltqXVsxXSxkekFyclswXVswXSxkekFyclswXVsxXSxkekFyclsxXVswXV0pO1xyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbZHpBcnJbal1bMF0sZHpBcnJbal1bMV0sZHpBcnJbMF1bMF0sZHpBcnJbMF1bMV0sd2xBcnJbMF1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cclxuXHQvL+S4ieadoe+8iOS6lOW8oO+8ie+8muS4ieadoSvkuKTljZXlvKBcclxuXHRzYW50aWFvRml2ZTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdLCBzdEFycj1jQXJyWzJdO1xyXG5cdFx0aWYoc3RBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdGlmKHdsQXJyLmxlbmd0aCA+IDEpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IHN0QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7ICAvL+S4ieadoSvkuYzpvplcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLHdsQXJyWzFdLHdsQXJyWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihkekFyci5sZW5ndGggPiAxKXsgICAgLy/kuInmnaEr5ouG5a+55a2QKOS4ieadoSvlr7nlrZA96JGr6IqmICDkuI3lsZ7kuo7kuInmnaEpXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLGR6QXJyWzFdWzBdLGR6QXJyWzBdWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihzdEFyci5sZW5ndGggPiAyKXsgIC8v5Y+q5pyJ5LiJ5p2h77yM6KaB5ouG5Lik5Liq5LiJ5p2h5b2T5L+p5Y2V5bygXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMjsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLHN0QXJyWzFdWzBdLHN0QXJyWzBdWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/pobrlrZDvvIjkupTlvKDvvIk6IOiKseiJsuS4jeWQjOeahOmhuuWtkFxyXG5cclxuXHQvKlxyXG5cdHNodW56aTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdLCBzekFycj1jQXJyWzRdLCBkZWNvZGVBcnI9Y0Fycls1XTtcclxuXHRcdHZhciBzekNhcmRzPVtdLCB2Q2FyZHM9W107XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gZGVjb2RlQXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7XHJcblx0XHRcdHZhciBvID0gZGVjb2RlQXJyW2ldO1xyXG5cdFx0XHRpZigoaSA+IDAgJiYgby52YWx1ZSA9PSBkZWNvZGVBcnJbaS0xXS52YWx1ZSkgXHJcblx0XHRcdCAgIHx8IChzekNhcmRzLmxlbmd0aCA+IDAgJiYgc3pDYXJkc1tzekNhcmRzLmxlbmd0aC0xXS52YWx1ZSA9PSBkZWNvZGVBcnJbaV0udmFsdWUpKXtcclxuXHJcblx0XHRcdCAgIH1lbHNle1xyXG5cdFx0XHRcdCAgIHN6Q2FyZHMucHVzaChvKTtcclxuXHRcdFx0XHQgICB2Q2FyZHNbby52YWx1ZV0gPSBpO1xyXG5cdFx0XHQgICB9XHJcblx0XHR9XHJcblx0XHQvL0EyMzQ1XHJcblx0XHRpZihzekFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0dmFyIGkgPSBzekFyci5sZW5ndGgtMVxyXG5cdFx0XHR3aGlsZShpID49IDApe1xyXG5cdFx0XHRcdHZhciBsID0gc3pBcnJbaV0ubGVuZ3RoLTE7XHJcblx0XHRcdFx0d2hpbGUobCA+IDMpe1xyXG5cdFx0XHRcdFx0dmFyIHNBcnIgPSBbc3pBcnJbaV1bbF0sc3pBcnJbaV1bbC0xXSxzekFycltpXVtsLTJdLHN6QXJyW2ldW2wtM10sc3pBcnJbaV1bbC00XV07XHJcblx0XHRcdFx0XHR2YXIgY2ZsYWcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGZvcih2YXIgbiA9IDE7IG4gPCBzQXJyLmxlbmd0aDsgKytuKXtcclxuXHRcdFx0XHRcdFx0aWYoc0FycltuXS50eXBlICE9IHNBcnJbbi0xXS50eXBlKXtcclxuXHRcdFx0XHRcdFx0XHRjZmxhZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGNmbGFnKXtcclxuXHRcdFx0XHRcdFx0c0Fyci5yZXZlcnNlKClcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChzQXJyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGwtLTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aS0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRjYXJkc0Fyci5yZXZlcnNlKClcclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cdCovXHJcblxyXG5cdC8v6aG65a2Q77yI5LqU5byg77yJOiDoirHoibLkuI3lkIznmoTpobrlrZBcclxuXHRzaHVuemk6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjYXJkc0FyciA9IFtdO1xyXG5cdFx0aWYoY2FyZHMubGVuZ3RoIDwgNSlcclxuXHRcdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdFx0XHJcblx0XHRmdW5jdGlvbiBoYXMoYSl7XHJcblx0XHRcdHJldHVybiBhLmxlbmd0aCA+PSAxXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHZhciB0bXBBcnIgPSBjYy5Qb2tlclV0aWwuX2NvcHlBcnJheShjYXJkcyk7XHJcblx0XHRjYy5Qb2tlclV0aWwuc29ydFBva2VyKDEsIHRtcEFycik7XHJcblx0XHR2YXIgZGVjb2RlQXJyID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKHRtcEFycik7XHJcblx0XHRcclxuXHRcdHZhciBwbCA9IFtdXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMTM7ICsraSl7XHJcblx0XHRcdHBsW2ldID0gW11cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlY29kZUFyci5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhbCA9IDEzIC0gZGVjb2RlQXJyW2ldLnZhbHVlXHJcblx0XHRcdGlmKHZhbCA+PSAwICYmIHZhbCA8IDEzKXtcclxuXHRcdFx0XHRwbFt2YWxdLnB1c2goZGVjb2RlQXJyW2ldKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZihwbC5sZW5ndGggPj0gNSl7XHJcblx0XHRcdHZhciBBS1FKWCA9IGZhbHNlXHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBwbC5sZW5ndGggLSA0OyArK2ope1xyXG5cdFx0XHRcdHZhciB5ZXMgPSB0cnVlXHJcblx0XHRcdFx0dmFyIHllc0FyciA9IFtdXHJcblx0XHRcdFx0Zm9yKHZhciBtID0gMDsgbSA8IDU7ICsrbSl7XHJcblx0XHRcdFx0XHRpZihwbFttK2pdLmxlbmd0aCA9PSAwKXtcclxuXHRcdFx0XHRcdFx0eWVzID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2V7XHJcblx0XHRcdFx0XHRcdHllc0Fyci5wdXNoKHBsW20ral1bMF0pXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHllcylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZihqID09IDApe1x0Ly9BS1FKWFxyXG5cdFx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKHllc0FycilcclxuXHRcdFx0XHRcdFx0QUtRSlggPSB0cnVlXHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaCh5ZXNBcnIpXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly/lho3mo4Dmn6VBMjM0NVxyXG5cdFx0XHRpZihoYXMocGxbMF0pICYmIGhhcyhwbFsxMl0pICYmIGhhcyhwbFsxMV0pICYmIGhhcyhwbFsxMF0pICYmIGhhcyhwbFs5XSkpe1xyXG5cdFx0XHRcdGlmKEFLUUpYKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnNwbGljZSgxLCAwLCBbcGxbMF1bMF0scGxbMTJdWzBdLHBsWzExXVswXSxwbFsxMF1bMF0scGxbOV1bMF1dKVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIuc3BsaWNlKDAsIDAsIFtwbFswXVswXSxwbFsxMl1bMF0scGxbMTFdWzBdLHBsWzEwXVswXSxwbFs5XVswXV0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBjYXJkc0FyclxyXG5cdH0sXHJcblxyXG5cdC8v6JGr6Iqm77ya5LiJ5byg55u45ZCMK+S4gOWvuVxyXG5cdGh1bHU6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjYXJkc0FyciA9IFtdO1xyXG5cdFx0aWYoY2FyZHMubGVuZ3RoIDwgNSlcclxuXHRcdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdFx0dmFyIGNBcnIgPSBjYy5Qb2tlclV0aWwuZ2V0R3JvdXBDYXJkcyhjYXJkcyk7XHJcblx0XHR2YXIgZHpBcnI9Y0FyclsxXSwgc3RBcnI9Y0FyclsyXTtcclxuXHRcdGlmKHN0QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRpZihkekFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSBzdEFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGR6QXJyLmxlbmd0aDsgKytqKXtcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbc3RBcnJbaV1bMF0sc3RBcnJbaV1bMV0sc3RBcnJbaV1bMl0sZHpBcnJbal1bMF0sZHpBcnJbal1bMV1dKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHQvL+ayoeacieWvueWtkCAg5ouG5a+55a2QXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGZvcih2YXIgbCA9IDA7IGwgPCBzdEFyci5sZW5ndGg7ICsrbCl7XHJcblx0XHRcdFx0XHRcdGlmKGwgPj0gaSlcclxuXHRcdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbc3RBcnJbaV1bMF0sc3RBcnJbaV1bMV0sc3RBcnJbaV1bMl0sc3RBcnJbbF1bMF0sc3RBcnJbbF1bMV1dKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cclxuXHQvL+mTgeaUr++8muWbm+W4puS4gFxyXG5cdHRpZXpoaTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblxyXG5cdFx0dmFyIGNBcnIgPSBjYy5Qb2tlclV0aWwuZ2V0R3JvdXBDYXJkcyhjYXJkcyk7XHJcblx0XHR2YXIgd2xBcnI9Y0FyclswXSwgZHpBcnI9Y0FyclsxXSwgc3RBcnI9Y0FyclsyXSwgdHpBcnI9Y0FyclszXVxyXG5cdFx0aWYodHpBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdGlmKHdsQXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IHR6QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFt0ekFycltpXVswXSx0ekFycltpXVsxXSx0ekFycltpXVsyXSx0ekFycltpXVszXSx3bEFyclswXV0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihkekFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSB0ekFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbdHpBcnJbaV1bMF0sdHpBcnJbaV1bMV0sdHpBcnJbaV1bMl0sdHpBcnJbaV1bM10sZHpBcnJbMF1bMF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2UgaWYoc3RBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gdHpBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3R6QXJyW2ldWzBdLHR6QXJyW2ldWzFdLHR6QXJyW2ldWzJdLHR6QXJyW2ldWzNdLHN0QXJyWzBdWzBdXSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHR6QXJyLmxlbmd0aCA+IDEpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IHR6QXJyLmxlbmd0aC0xOyBpID49IDE7IC0taSl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFt0ekFycltpXVswXSx0ekFycltpXVsxXSx0ekFycltpXVsyXSx0ekFycltpXVszXSx0ekFyclswXVswXV0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/kupTlkIxcclxuXHR3dXRvbmc6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjYXJkc0FyciA9IFtdO1xyXG5cdFx0aWYoY2FyZHMubGVuZ3RoIDwgNSlcclxuXHRcdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdFx0XHJcblx0XHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3dEFyciA9IGNBcnJbNl07XHJcblx0XHRpZih3dEFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0Zm9yKHZhciBpID0gd3RBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRjYXJkc0Fyci5wdXNoKHd0QXJyW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdFx0Ly/ojrflj5boirHoibJcclxuXHRnZXRTdWl0OiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgYXJyID0gW1tdLFtdLFtdLFtdXVxyXG5cdFx0Zm9yKHZhciBpPTA7IGkgPCBjYXJkcy5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciBzdWl0ID0gY2FyZHNbaV0udHlwZVxyXG5cdFx0XHRhcnJbc3VpdF0ucHVzaChjYXJkc1tpXSlcclxuXHRcdH1cclxuXHRcdHJldHVybiBhcnJcclxuXHR9LFxyXG5cdFxyXG5cdC8v5Yig6Zmk55u45ZCM54K55pWwXHJcblx0ZGVsU2FtZVBvaW50OiBmdW5jdGlvbiAoY0Fycil7XHJcblx0XHR2YXIgYXJyPVtdLCBjYXJkc0Fycj1bXVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNBcnIubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHRpZihhcnJbY0FycltpXS52YWx1ZV0gPT0gbnVsbCl7XHJcblx0XHRcdFx0YXJyW2NBcnJbaV0udmFsdWVdID0gdHJ1ZVxyXG5cdFx0XHRcdGNhcmRzQXJyLnB1c2goY0FycltpXSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyXHJcblx0fSxcclxuXHJcblx0Ly/lkIzoirHpobpcclxuXHR0b25naHVhc2h1bjogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnJcclxuXHRcdHZhciBjQXJyID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHMpXHJcblx0XHR2YXIgc3VpdEFyciA9IGNjLlBva2VyVXRpbC5nZXRTdWl0KGNBcnJbNV0pXHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IDM7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0dmFyIHNBcnIgPSBjYy5Qb2tlclV0aWwuZGVsU2FtZVBvaW50KHN1aXRBcnJbaV0pXHJcblx0XHRcdGlmKHNBcnIubGVuZ3RoID4gNCl7XHJcblx0XHRcdFx0IC8vY2MuUG9rZXJVdGlsLnNvcnRQb2tlcigxLCBzQXJyKVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKHNBcnJbMF0udmFsdWU9PTEzICYmIHNBcnJbMV0udmFsdWU9PTEyICYmIHNBcnJbMl0udmFsdWU9PTExICYmIHNBcnJbM10udmFsdWU9PTEwICYmIHNBcnJbNF0udmFsdWU9PTkpe1xyXG5cdFx0XHRcdFx0Ly9BIEsgUSBKIDEwXHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtzQXJyWzBdLHNBcnJbMV0sc0FyclsyXSxzQXJyWzNdLHNBcnJbNF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgbGVuID0gc0Fyci5sZW5ndGhcclxuXHRcdFx0XHRpZihzQXJyWzBdLnZhbHVlPT0xMyAmJiBzQXJyW2xlbi00XS52YWx1ZT09NCAmJiBzQXJyW2xlbi0zXS52YWx1ZT09MyYmIHNBcnJbbGVuLTJdLnZhbHVlPT0yJiYgc0FycltsZW4tMV0udmFsdWU9PTEpe1xyXG5cdFx0XHRcdFx0Ly9BIDIgMyA0IDVcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3NBcnJbMF0sc0FycltsZW4tMV0sc0FycltsZW4tMl0sc0FycltsZW4tM10sc0FycltsZW4tNF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgc0Fyci5sZW5ndGgtNDsgKytqKXtcclxuXHRcdFx0XHRcdGlmKHNBcnJbal0udmFsdWUgIT0gMTMpe1xyXG5cdFx0XHRcdFx0XHRpZihzQXJyW2pdLnZhbHVlPT0oc0FycltqKzFdLnZhbHVlKzEpICYmIHNBcnJbaisxXS52YWx1ZT09KHNBcnJbaisyXS52YWx1ZSsxKSAmJiBzQXJyW2orMl0udmFsdWU9PShzQXJyW2orM10udmFsdWUrMSkgJiYgc0FycltqKzNdLnZhbHVlPT0oc0FycltqKzRdLnZhbHVlKzEpKXtcclxuXHRcdFx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtzQXJyW2pdLHNBcnJbaisxXSxzQXJyW2orMl0sc0FycltqKzNdLHNBcnJbais0XV0pXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnJcclxuXHR9LFxyXG5cclxuLy/lkIzoirEo5YyF5ous5ZCM5LiA6Imy55qE5a+55a2QKVxyXG50b25naHVhOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHJcblx0ZnVuY3Rpb24gX19keihhcnIpe1xyXG5cdFx0dmFyIGR6ID0gW11cclxuXHRcdHZhciBuZHogPSBbXVxyXG5cdFx0XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKXtcclxuXHRcdFx0aWYoaSA8IGFyci5sZW5ndGgtMSAmJiBhcnJbaV0udmFsdWUgPT0gYXJyW2krMV0udmFsdWUpe1xyXG5cdFx0XHRcdGR6LnB1c2goW2FycltpXSwgYXJyW2krMV1dKVxyXG5cdFx0XHRcdGkgKz0gMlxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRuZHoucHVzaChhcnJbaV0pXHJcblx0XHRcdFx0aSsrXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB7XCJkem51bVwiOmR6Lmxlbmd0aCwgXCJkelwiOmR6LCBcIm5kelwiOm5ken1cclxuXHR9XHJcblx0XHJcblx0dmFyIGNhcmRzQXJyID0gW11cclxuXHRpZihjYXJkcy5sZW5ndGggPCA1KXtcclxuXHRcdHJldHVybiBjYXJkc0FyclxyXG5cdH1cclxuXHJcblx0dmFyIGR6TnVtQXJyID0gW11cclxuXHR2YXIgY0FyciA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKVxyXG5cdHZhciBzdWl0QXJyID0gY2MuUG9rZXJVdGlsLmdldFN1aXQoY0Fycls1XSlcclxuXHRmb3IodmFyIGkgPSAzOyBpID49IDA7IC0taSl7XHJcblx0XHR2YXIgc0FyciA9IHN1aXRBcnJbaV1cclxuXHRcdGlmKHNBcnIubGVuZ3RoID4gNCl7XHJcblx0XHRcdGR6TnVtQXJyLnB1c2goX19keihzQXJyKSlcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0ZHpOdW1BcnIuc29ydChmdW5jdGlvbih4LCB5KXsgcmV0dXJuIHguZHpudW0gPiB5LmR6bnVtfSlcclxuXHRcclxuXHR2YXIgbGlhbmdkdWkgPSBbXVxyXG5cdHZhciB5aWR1aSA9IFtdXHJcblx0dmFyIHdsZCA9IFtdXHJcblx0Zm9yKHZhciBlID0gZHpOdW1BcnIubGVuZ3RoLTE7IGUgPj0gMCA7IC0tZSlcclxuXHR7XHJcblx0XHR2YXIgdHR0ID0gZHpOdW1BcnJbZV1cclxuXHRcdGlmKHR0dC5kem51bSA+PSAyKXtcclxuXHRcdFx0aWYodHR0Lm5kei5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHQvL+S4pOWvuSvkuIDkuKpcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdHR0LmR6bnVtLTE7ICsraSl7XHJcblx0XHRcdFx0XHRmb3IodmFyIGogPSBpKzE7IGogPCB0dHQuZHpudW07ICsrail7XHJcblx0XHRcdFx0XHRcdGxpYW5nZHVpLnB1c2goW3R0dC5keltpXVswXSx0dHQuZHpbaV1bMF0sdHR0LmR6W2pdWzBdLHR0dC5keltqXVsxXSwgdHR0Lm5kelt0dHQubmR6Lmxlbmd0aC0xXV0pXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL+WvueWtkOWkquWkmuaLhuWvueWtkFxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0dHQuZHpudW0tMjsgKytpKXtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IGkrMTsgaiA8IHR0dC5kem51bS0xOyArK2ope1xyXG5cdFx0XHRcdFx0XHRsaWFuZ2R1aS5wdXNoKFt0dHQuZHpbaV1bMF0sdHR0LmR6W2ldWzBdLHR0dC5keltqXVswXSx0dHQuZHpbal1bMV0sIHR0dC5kelt0dHQuZHoubGVuZ3RoLTFdWzBdXSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHR9ZWxzZSBpZih0dHQuZHpudW0gPT0gMSl7XHJcblx0XHRcdHZhciBsZW4gPSB0dHQubmR6Lmxlbmd0aFxyXG5cdFx0XHRmb3IodmFyIGwgPSAwOyBsIDwgbGVuLTI7ICsrbCl7XHJcblx0XHRcdFx0eWlkdWkucHVzaChbdHR0LmR6WzBdWzBdLHR0dC5kelswXVsxXSx0dHQubmR6W2xdLHR0dC5uZHpbbGVuLTJdLHR0dC5uZHpbbGVuLTFdXSlcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHZhciBsZW4gPSB0dHQubmR6Lmxlbmd0aFxyXG5cdFx0XHRmb3IodmFyIGwgPSAwOyBsIDwgbGVuLTQ7ICsrbCl7XHJcblx0XHRcdFx0d2xkLnB1c2goW3R0dC5uZHpbbF0sdHR0Lm5keltsZW4tNF0sdHR0Lm5keltsZW4tM10sdHR0Lm5keltsZW4tMl0sdHR0Lm5keltsZW4tMV1dKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGxpYW5nZHVpLnNvcnQoZnVuY3Rpb24oeCwgeSl7XHJcblx0XHRpZih4WzBdLnZhbHVlID4geVswXS52YWx1ZSl7IHJldHVybiB0cnVlIH1cclxuXHRcdGVsc2UgaWYoeFswXS52YWx1ZSA9PSB5WzBdLnZhbHVlKXtcclxuXHRcdFx0aWYoeFsyXS52YWx1ZSA+IHlbMl0udmFsdWUpeyByZXR1cm4gdHJ1ZSB9XHJcblx0XHRcdGVsc2UgaWYoeFsyXS52YWx1ZSA9PSB5WzJdLnZhbHVlKXsgcmV0dXJuIHhbNF0udmFsdWUgPiB5WzRdLnZhbHVlIH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZVxyXG5cdH0pXHJcblxyXG5cdHlpZHVpLnNvcnQoZnVuY3Rpb24oeCwgeSl7XHJcblx0XHRpZih4WzBdLnZhbHVlID4geVswXS52YWx1ZSl7IHJldHVybiB0cnVlIH1cclxuXHRcdGVsc2UgaWYoeFswXS52YWx1ZSA9PSB5WzBdLnZhbHVlKXtcclxuXHRcdFx0Zm9yKHZhciBpID0gMjsgaSA8IDU7ICsraSl7XHJcblx0XHRcdFx0cmV0dXJuIHhbaV0udmFsdWUgPiB5W2ldLnZhbHVlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZVxyXG5cdH0pXHJcblx0XHJcblx0d2xkLnNvcnQoZnVuY3Rpb24oeCwgeSl7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgNTsgKytpKXtcclxuXHRcdFx0cmV0dXJuIHhbaV0udmFsdWUgPiB5W2ldLnZhbHVlXHJcblx0XHR9XHJcblx0fSlcclxuXHRcclxuXHRjYXJkc0FyciA9IGNhcmRzQXJyLmNvbmNhdChsaWFuZ2R1aS5yZXZlcnNlKCkpXHJcblx0Y2FyZHNBcnIgPSBjYXJkc0Fyci5jb25jYXQoeWlkdWkucmV2ZXJzZSgpKVxyXG5cdGNhcmRzQXJyID0gY2FyZHNBcnIuY29uY2F0KHdsZC5yZXZlcnNlKCkpXHJcblx0XHJcblx0cmV0dXJuIGNhcmRzQXJyXHJcbn0sXHJcblxyXG4gICAgLy/nu5nniYzmjpLluo8gc29ydHR5cGU6IDEg5aSn5bCP5o6S5bqPIDIg6Iqx6Imy5o6S5bqPKOeJjOWAvOaOkuW6jylcclxuICAgIHNvcnRQb2tlcjogZnVuY3Rpb24oc29ydHR5cGUsIGNhcmRsaXN0KXtcclxuXHRcdC8vY2MubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiLCBzb3J0dHlwZSlcclxuICAgICAgICBpZihzb3J0dHlwZSA9PSAyKXtcclxuICAgICAgICAgICAgY2FyZGxpc3Quc29ydChmdW5jdGlvbih4LCB5KXsgICAvL+aVsOWtl+i2iuWkp+WcqOWJjVxyXG4gICAgICAgICAgICAgICAgaWYoeCA8IHkpICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBpZih4ID4geSkgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihzb3J0dHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgY2FyZGxpc3Quc29ydChmdW5jdGlvbih4LCB5KXtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHhjYXJkID0gWyAoeC0xKS8xMywgKHgtMSklMTMgXTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHljYXJkID0gWyAoeS0xKS8xMywgKHktMSklMTMgXTtcclxuXHRcdFx0XHR2YXIgeGNhcmQgPSBjYy5Qb2tlclV0aWwuc2luZ2xlQ2FyZHNEZWNvZGUoeClcclxuXHRcdFx0XHR2YXIgeWNhcmQgPSBjYy5Qb2tlclV0aWwuc2luZ2xlQ2FyZHNEZWNvZGUoeSlcclxuXHJcblx0XHRcdFx0aWYoeGNhcmQudmFsdWUgPCB5Y2FyZC52YWx1ZSlcclxuXHRcdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHRcdGlmKHhjYXJkLnZhbHVlID4geWNhcmQudmFsdWUpXHJcblx0XHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoeGNhcmQudHlwZSA8IHljYXJkLnR5cGUpXHJcblx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHRpZih4Y2FyZC50eXBlID4geWNhcmQudHlwZSlcclxuXHRcdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHQvL+avlOi+g+aMh+WumueJjOWei2nkuIvvvJrnrKzkuozloqkg5ZKMIOesrOS4gOWiqSDmmK/lkKbnm7jlhawgOiDmmK/nm7jlhazkuoYg6L+U5ZuedHJ1ZVxyXG5cdC8vaTog56ys5LqM5aKp54mM5Z6L5pWw5a2XKDAtMTApLCBhOiDnrKzkuozloqnniYxcclxuXHQvL2I6IOesrOS4gOWiqeeJjCBcclxuXHQvL2o6IOihqOekuuesrOS6jOWiqeeJjOeahOeJjOWeiyjmnInlj6/og73nrKzkuozloqnmnInlpJrnp43niYzlnovvvIzkuIDoiKzpu5jorqTnrKzkuIDkuKrniYzlnovmnIDlpKfvvIzmiYDku6Vq5LiA6Iis6YCJMClcclxuXHRcclxuXHRpc01lc3NpcmVUaHJlZTogZnVuY3Rpb24oaSwgYSwgYiwgail7XHJcblx0XHRcclxuXHRcdC8v5LiJ5p2hRml2ZSDlkowg5LiJ5p2hdGhyZWUg5q+U6L6DXHJcblx0XHRpZiggaSA9PSA2KXtcdFxyXG5cdFx0XHRpZiggYVsyXS52YWx1ZSA8IGJbMl0udmFsdWUpe1xyXG5cdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly/kuIDlr7lGaXZlIOWSjCDkuIDlr7l0aHJlZSDmr5TovoNcclxuXHRcdGlmKCBpID09IDggKXtcdFxyXG5cdFx0XHRpZihhWzBdLnZhbHVlID09IGJbMF0udmFsdWUpe1xyXG5cdFx0XHRcdGlmKGFbMl0udmFsdWUgPCBiWzJdLnZhbHVlKXtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihhWzBdLnZhbHVlIDwgYlswXS52YWx1ZSl7XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL+S5jOm+mUZpdmUg5ZKMIOS5jOm+mXRocmVlICDmr5TovoNcclxuXHRcdGlmKGkgPT0gOSl7XHJcblx0XHRcdGlmKGFbMF0udmFsdWUgID09IGJbMF0udmFsdWUpe1xyXG5cdFx0XHRcdGlmKGFbMV0udmFsdWUgPT0gYlsxXS52YWx1ZSl7XHJcblx0XHRcdFx0XHRpZihhWzJdLnZhbHVlIDwgYlsyXS52YWx1ZSl7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2UgaWYoYVsxXS52YWx1ZSA8IGJbMV0udmFsdWUpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKCBhWzBdLnZhbHVlIDwgYlswXS52YWx1ZSl7XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlXHJcblx0fSxcclxuXHJcblx0X2dldER1aXppOiBmdW5jdGlvbihhcnIpe1xyXG5cdFx0dmFyIGR6ID0gW11cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoLTE7ICl7XHJcblx0XHRcdGlmKGkgPCBhcnIubGVuZ3RoLTEgJiYgYXJyW2ldID09IGFycltpKzFdKXtcclxuXHRcdFx0XHRkei5wdXNoKFthcnJbaV0sIGFycltpKzFdXSlcclxuXHRcdFx0XHRpICs9IDJcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0aSsrXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBkelxyXG5cdH0sXHJcblx0XHJcblx0Ly/niYzlnovkuIDmoLfmg4XlhrXkuItcclxuXHQvL+avlOi+g+aMh+WumueJjOWei2nkuIvvvJrnrKzkuInloqkg5ZKMIOesrOS6jOWiqSDmmK/lkKbnm7jlhawgIOaYr+ebuOWFrOi/lOWbnnRydWVcclxuXHQvL2k6IOesrOS4ieWiqeeJjOWeiygwLTEwKe+8jCDmr5TovoPlvZPliY1p54mM5Z6L5LiLYSxi5piv5ZCm55u45YWsXHJcblx0Ly9hOiDnrKzkuInloqnniYxcclxuXHQvL2I6IOesrOS6jOWiqeeJjFxyXG5cdGlzTWVzc2lyZUZpdmU6IGZ1bmN0aW9uKGksIGEsIGIpe1xyXG5cdFx0dmFyIHYgPSBbXSwgcyA9IFtdXHJcblx0XHRmb3IodmFyIHEgPSAwOyBxIDwgNTsgKytxKXtcclxuXHRcdFx0di5wdXNoKGFbcV0udmFsdWUpXHJcblx0XHRcdHMucHVzaChiW3FdLnZhbHVlKVxyXG5cdFx0fVxyXG5cdFx0di5zb3J0KGZ1bmN0aW9uKHgseSl7IHJldHVybiB4IDwgeSB9KVxyXG5cdFx0cy5zb3J0KGZ1bmN0aW9uKHgseSl7IHJldHVybiB4IDwgeSB9KVxyXG5cdFx0XHJcblx0XHRpZihpPT0wIHx8IGkgPT0gMilcdC8v5LqU5ZCM5oiW6ICF5Zub5bim5LiAKOmTgeaUrylcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIHZbMl0gPCBzWzJdXHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKCBpID09IDMpXHQvL+iRq+iKpijkuInluKbkuowpXHJcblx0XHR7XHRcclxuXHRcdFx0aWYodlsyXSA9PSBzWzJdKXtcclxuXHRcdFx0XHRpZih2WzBdPT12WzJdICYmIHNbMF09PXNbMl0pe1x0Ly/kuInkuKrpg73lnKjliY1cclxuXHRcdFx0XHRcdHJldHVybiB2WzNdIDwgc1szXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih2WzBdPT12WzJdICYmIHNbMl09PXNbNF0peyAvL+S4ieS4quWcqOWJjeaute+8jCDkuInkuKrlnKjlkI7nq69cclxuXHRcdFx0XHRcdHJldHVybiB2WzNdIDwgc1swXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih2WzJdPT12WzRdICYmIHNbMF09PXNbMl0pe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZbMF0gPCBzWzNdXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZbMl09PXZbNF0gJiYgc1syXT09c1s0XSl7XHJcblx0XHRcdFx0XHRyZXR1cm4gdlswXSA8IHNbMF1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZbMl0gPCBzWzJdXHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKGkgPT0gNClcdC8v5ZCM6IqxKOWkmuS4gOiJsuacieWvueWtkOeahOi/mOimgeavlOi+g+WvueWtkClcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZkeiA9IGNjLlBva2VyVXRpbC5fZ2V0RHVpemkodilcclxuXHRcdFx0dmFyIHNkeiA9IGNjLlBva2VyVXRpbC5fZ2V0RHVpemkocylcclxuXHJcblx0XHRcdGNjLmxvZyhcIkJCQkJCQkJCQkJCQkJCQkJCQkJCICAgXCIsIHZkei5sZW5ndGgsIHNkei5sZW5ndGgpXHJcblxyXG5cclxuXHRcdFx0aWYodmR6Lmxlbmd0aCA9PSBzZHoubGVuZ3RoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYodmR6Lmxlbmd0aCA+IDApXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Ly/lr7nlrZDmlbDph4/nm7jlkIxcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IHZkei5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0XHRpZihzZHpbaV1bMF0gPiB2ZHpbaV1bMF0pe1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYodmR6Lmxlbmd0aCA9PSAwKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdC8v5rKh5pyJ5a+55a2QXHJcblx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgNTsgKytqKXtcclxuXHRcdFx0XHRcdFx0aWYodltqXSA9PSBzW2pdKXtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybiB2W2pdIDwgc1tqXVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL+WvueWtkOaVsOmHj+abtOWkmlxyXG5cdFx0XHRcdGlmKHZkei5sZW5ndGggPCBzZHoubGVuZ3RoKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihpPT0xIHx8IGk9PTUgfHwgaT09OSlcdC8v5ZCM6Iqx6aG644CB6aG65a2Q44CB5LmM6b6ZXHJcblx0XHR7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCA1OyArK2ope1xyXG5cdFx0XHRcdGlmKHZbal0gPT0gc1tqXSl7XHJcblx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdltqXSA8IHNbal1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoIGk9PSA2IHx8IGk9PTcgfHwgaT09OCkgIC8v5LiJ5p2h44CB5Lik5a+544CB5LiA5a+5XHJcblx0XHR7XHJcblx0XHRcdHZhciBkel8xPVtdLCBkel8yPVtdLCB3bF8xPVtdLCB3bF8yPVtdXHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCA1OyArK2ope1xyXG5cdFx0XHRcdGlmKChqIDwgNCAmJiB2W2pdPT12W2orMV0pIHx8ICh2W2pdPT1kel8xW2R6XzEubGVuZ3RoLTFdKSl7XHJcblx0XHRcdFx0XHRkel8xLnB1c2godltqXSlcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdHdsXzEucHVzaCh2W2pdKVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoKGogPCA0ICYmIHNbal09PXNbaisxXSkgfHwgKHNbal09PWR6XzJbZHpfMi5sZW5ndGgtMV0pKXtcclxuXHRcdFx0XHRcdGR6XzIucHVzaChzW2pdKVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0d2xfMi5wdXNoKHNbal0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvL+acgOWkp+eahOWvueWtkOebuOWQjFxyXG5cdFx0XHRpZihkel8xWzBdID09IGR6XzJbMF0pe1xyXG5cdFx0XHRcdGlmKGkgPT0gNilcdC8vc2FudGlhb1xyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlmKHdsXzFbMF0gPT0gd2xfMlswXSl7XHJcblx0XHRcdFx0XHRcdHJldHVybiB3bF8xWzFdIDwgd2xfMlsxXVxyXG5cdFx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRcdHJldHVybiB3bF8xWzBdIDwgd2xfMlswXVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmKGkgPT0gNyl7IC8vbGlhbmdkdWlcclxuXHRcdFx0XHRcdGlmKGR6XzFbMl0gPT0gZHpfMlsyXSl7XHJcblx0XHRcdFx0XHRcdHJldHVybiB3bF8xWzBdIDzjgIB3bF8yWzBdXHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGR6XzFbMl0gPCBkel8yWzJdXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2UgaWYoaSA9PSA4KXsgLy95aWR1aVxyXG5cdFx0XHRcdFx0Zm9yKHZhciBtID0gMjsgbSA8IDU7ICsrbSl7XHJcblx0XHRcdFx0XHRcdGlmKHdsXzFbbV0gPCB3bF8yW21dKXtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihkel8xLmxlbmd0aCA+IDAgJiYgZHpfMi5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHRjYy5sb2coXCJkel8xWzBdID1cIiArIGR6XzFbMF0sIFwiICBkel8yWzBdID0gXCIrIGR6XzJbMF0pXHJcblx0XHRcdFx0cmV0dXJuIGR6XzFbMF0gPCBkel8yWzBdXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdC8v6I635Y+W6Ieq55Sx5pGG54mM57uE5ZCIXHJcblx0Z2V0RnJlZVN0eWxlUG9rZXJTZXQ6IGZ1bmN0aW9uKGNhcmRzQXJyKXtcclxuXHRcdHZhciBjQXJyID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHNBcnIpXHJcblxyXG5cdFx0Ly/pobrlrZBcclxuXHRcdHZhciBzekFyciA9IGNjLlBva2VyVXRpbC5zaHVuemkoY2FyZHNBcnIpXHJcblxyXG5cdFx0Ly/lkIzoirHpobpcclxuXHRcdHZhciB0aHNBcnIgPSBjYy5Qb2tlclV0aWwudG9uZ2h1YXNodW4oY2FyZHNBcnIpXHJcblx0XHRcdFxyXG5cdFx0Ly/lkIzoirFcclxuXHRcdHZhciB0aEFyciA9IGNjLlBva2VyVXRpbC50b25naHVhKGNhcmRzQXJyKVxyXG5cclxuXHRcdC8v6JGr6IqmXHJcblx0XHR2YXIgaGxBcnIgPSBjYy5Qb2tlclV0aWwuaHVsdShjYXJkc0FycilcclxuXHJcblx0XHQvL3d1dG9uZ1xyXG5cdFx0dmFyIHd0QXJyID0gY2MuUG9rZXJVdGlsLnd1dG9uZyhjYXJkc0FycilcclxuXHJcblx0XHQvL3NhbnRpYW9cclxuXHRcdHZhciBzdEFyciA9IGNBcnJbMl1cclxuXHJcblx0XHQvL2R1aXppXHJcblx0XHR2YXIgZHpBcnIgPSBjQXJyWzFdLnJldmVyc2UoKVxyXG5cclxuXHRcdC8vbGlhbmdkdWlcclxuXHRcdHZhciBsZEFyciA9IFtdXHJcblx0XHRpZihkekFyci5sZW5ndGggPj0gMil7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkekFyci5sZW5ndGg7ICsraSl7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gaSsxOyBqIDwgZHpBcnIubGVuZ3RoOyArK2ope1xyXG5cdFx0XHRcdFx0bGRBcnIucHVzaChbZHpBcnJbaV1bMF0sIGR6QXJyW2ldWzFdLCBkekFycltqXVswXSwgZHpBcnJbal1bMV1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vdGllemhpXHJcblx0XHR2YXIgdHpBcnIgPSBjQXJyWzNdXHJcblx0XHJcblx0XHR2YXIgbmFtZXMgPSBbXCLlr7nlrZBcIiwgXCLkuKTlr7lcIiwgXCLkuInmnaFcIiwgXCLpobrlrZBcIiwgXCLlkIzoirFcIixcIuiRq+iKplwiLCBcIumTgeaUr1wiLCBcIuWQjOiKsemhulwiLFwi5LqU5ZCMXCJdXHJcblx0XHR2YXIgY2FyZHR5cGUgPSBbZHpBcnIsIGxkQXJyLCBzdEFyciwgc3pBcnIsIHRoQXJyLCBobEFyciwgdHpBcnIsIHRoc0Fyciwgd3RBcnJdXHJcblx0XHR2YXIgcmV0ID0gW11cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY2FyZHR5cGUubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHR2YXIgZHQgPSB7fVxyXG5cdFx0XHRkdC5uYW1lID0gbmFtZXNbaV1cclxuXHRcdFx0ZHQudmFsdWUgPSBjYXJkdHlwZVtpXVxyXG5cdFx0XHRyZXQucHVzaChkdClcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXRcclxuXHR9LFxyXG5cclxuXHQvL+iOt+WPluaOqOiNkOS4ieWiqeeJjOe7hOWQiFxyXG5cdGdldFJlY29tbWVuZFBva2VyU2V0OiBmdW5jdGlvbihjYXJkc0Fycil7XHJcblx0XHRmdW5jdGlvbiBwcmludEFycihhLCBuYW1lKXtcclxuXHRcdFx0dmFyIHN0ciA9IG5hbWVcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHRcdHN0ciArPSAoYVtpXSArIFwiLCBcIilcclxuXHRcdFx0fVxyXG5cdFx0XHRjYy5sb2coc3RyKVxyXG5cdFx0fVxyXG5cdFx0dmFyIHQ1R3JvdXAgPSBjYy5Qb2tlclV0aWwudDVHcm91cFxyXG5cdFx0dmFyIHQzR3JvdXAgPSBjYy5Qb2tlclV0aWwudDNHcm91cFxyXG5cdFx0dmFyIGNBcnIgPSBbXSwgZXhpc3RBcnI9W10sIGNOYW1lQXJyPVtdXHJcblxyXG5cdFx0cHJpbnRBcnIoY2FyZHNBcnIsIFwi5oC754mM77yaXCIpXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgKHQ1R3JvdXAubGVuZ3RoLTEpOyArK2kpXHQvL+S4jeajgOafpeS5jOm+me+8jOWFiOaJvuesrOS4gOS4qjXlvKDnu4TlkIjvvIzku47lpKflvoDlsI9cclxuXHRcdHtcclxuXHRcdFx0dmFyIGNjQXJyID0gY2MuUG9rZXJVdGlsLl9jb3B5QXJyYXkoY2FyZHNBcnIpXHJcblx0XHRcdHZhciBjYXJkc18xID0gdDVHcm91cFtpXShjY0FycilcdFx0XHQvL+esrOS4ieWiqTXlvKDniYxcclxuXHJcblx0XHRcdGNjLmxvZyhcIk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTiAgXCIsIGNhcmRzXzEubGVuZ3RoKVxyXG5cclxuXHRcdFx0Zm9yKHZhciBsID0gMDsgbCA8IGNhcmRzXzEubGVuZ3RoOyArK2wpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYy5sb2coXCJNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0gIFwiLCBsKVxyXG5cdFx0XHRcdGNjLmxvZyhcIuaJvuWIsOesrOS4iemhv+eJjOWei++8miA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIiwgaSlcclxuXHRcdFx0XHRjYy5sb2coXCJjYXJkc18xICBjYXJkc18xIGNhcmRzXzEgbGVuZ3RoIFwiLCBpLCBjYXJkc18xLmxlbmd0aClcclxuXHRcdFx0XHR2YXIgYnJlYWtmb3IgPSBmYWxzZVxyXG5cdFx0XHRcdGZvcih2YXIgbiA9IDA7IG4gPCB0NUdyb3VwLmxlbmd0aDsgKytuKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciB0bXBDYXJkc18xID0gY2MuUG9rZXJVdGlsLmNhcmRzRW5jb2RlKGNhcmRzXzFbbF0pXHJcblx0XHRcdFx0XHRwcmludEFycih0bXBDYXJkc18xLCBcImVuY29kZeeJjO+8mlwiKVxyXG5cdFx0XHRcdFx0dmFyIHNBcnIgPSBjYy5Qb2tlclV0aWwuX2RlbENhcmRzKGNjQXJyLCB0bXBDYXJkc18xKVxyXG5cdFx0XHRcdFx0cHJpbnRBcnIoc0FyciwgXCLliankuIvniYzvvJogXCIpXHJcblx0XHRcdFx0XHR2YXIgY2FyZHNfMiA9IHQ1R3JvdXBbbl0oc0FycikgICAvL+esrOS6jOWiqTXlvKDniYxcclxuXHJcblx0XHRcdFx0XHRpZihjYXJkc18yLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGNjLmxvZyhcIuaJvuWIsOesrOS6jOmhv+a0vuaAp++8mi0tLS0tLS0tLS0tLS0tLS0tLS1cIiwgbilcclxuXHRcdFx0XHRcdFx0Y2MubG9nKFwiY2FyZHNfMiBjYXJkc18yIGNhcmRzXzIgY2FyZHNfMiBsZW5ndGggXCIsIG4sIGNhcmRzXzIubGVuZ3RoKVxyXG5cdFx0XHRcdFx0XHRpZihuIDwgaSlcclxuXHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrZm9yID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGNhcmRzXzIubGVuZ3RoOyArK2opXHJcblx0XHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY2ZsYWcgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHRcdGlmKGkgPT0gbil7XHRcdC8vMiwz5aKp54mM5Z6L5LiA5qC3XHJcblx0XHRcdFx0XHRcdFx0XHRjZmxhZyA9IGNjLlBva2VyVXRpbC5pc01lc3NpcmVGaXZlKGksIGNhcmRzXzFbbF0sIGNhcmRzXzJbal0pXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoY2ZsYWcpe1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjYy5sb2coXCLnm7jlhazllabnm7jlhazllabnm7jlhazllabnm7jlhazllabnm7jlhazllaY6IFwiLCBpKVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZighY2ZsYWcpXHJcblx0XHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRtcENhcmRzXzIgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfMltqXSlcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB0QXJyID0gY2MuUG9rZXJVdGlsLl9kZWxDYXJkcyhzQXJyLCB0bXBDYXJkc18yKSAgIC8v56ys5LiA5aKpM+W8oOeJjFxyXG5cdFx0XHRcdFx0XHRcdFx0Y2MubG9nKHRBcnIsIFwi56ys5LqM5qyh5Ymp5LiL54mM77yaXCIpXHJcblx0XHRcdFx0XHRcdFx0XHRmb3IodmFyIGsgPSAwOyBrIDwgY2MuUG9rZXJVdGlsLnQzR3JvdXAubGVuZ3RoOyArK2spXHJcblx0XHRcdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjYXJkc18zID0gY2MuUG9rZXJVdGlsLnQzR3JvdXBba10odEFycilcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNmbGFnMiA9IGZhbHNlXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihjYXJkc18zLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZigoaz09MCAmJiBuPDYpIHx8KGs9PTEgJiYgbjw4KSB8fChrPT0yICYmIG48OSkpe1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2ZsYWcyID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZigoaz09MCAmJiBuPT02KSB8fChrPT0xICYmIG49PTgpIHx8KGs9PTIgJiYgbj09OSkpe1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZmwgPSBjYy5Qb2tlclV0aWwuaXNNZXNzaXJlVGhyZWUobiwgY2FyZHNfMltqXSwgY2FyZHNfM1swXSwwKVxyXG4vKlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHR0dHQgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfMltqXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBqamogPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfM1swXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNjLmxvZyhcIk1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTSAgICAgIFwiLCBmbCwgaywgbilcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByaW50QXJyKHR0dHQsIFwi5Y+C5pWw5LiA77yaIFwiIClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByaW50QXJyKGpqaiwgXCLlj4LmlbDkuozvvJogXCIgKVxyXG4qL1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2ZsYWcyID0gKGZsID09IGZhbHNlKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoY2ZsYWcyKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZXhpc3RBcnJbMTAwMCppKzEwMCpuK2tdID09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNhcmRyZXMgPSB7XCJ0b3BcIjp7XCJjYXJkXCI6W10sIFwidHlwZVwiOi0xfSwgXCJtaWRkbGVcIjp7XCJjYXJkXCI6W10sIFwidHlwZVwiOi0xfSwgXCJib3R0b21cIjp7XCJjYXJkXCI6W10sIFwidHlwZVwiOi0xfX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhcmRyZXMudG9wLmNhcmQgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfM1swXS5zbGljZSgpKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FyZHJlcy50b3AudHlwZSA9IGtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhcmRyZXMubWlkZGxlLmNhcmQgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfMltqXS5zbGljZSgpKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FyZHJlcy5taWRkbGUudHlwZSA9IG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhcmRyZXMuYm90dG9tLmNhcmQgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUoY2FyZHNfMVtsXS5zbGljZSgpKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FyZHJlcy5ib3R0b20udHlwZSA9IGlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNBcnIucHVzaChjYXJkcmVzKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXhpc3RBcnJbMTAwMCppKzEwMCpuK2tdID0gdHJ1ZVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8v5Y+q5om+5LqU5Liq5ZCnXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihjQXJyLmxlbmd0aCA+PSA1KXtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNBcnJcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGJyZWFrZm9yKXtcclxuXHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY0FyclxyXG5cdH0sXHJcblxyXG5cdC8v6K6h566X5b6X5YiGXHJcblx0Ly9hbGxoYW5kczogU19HMTNfQWxsSGFuZHPmtojmga9cclxuXHRjYWxjdWxhdGVTY29yZTogZnVuY3Rpb24oYWxsaGFuZHMpe1xyXG5cclxuXHRcdC8v5piv5ZCm5piv54m55q6K54mM5Z6LXHJcblx0XHRmdW5jdGlvbiBpc1NwZWNpYWwoY2FyZCl7XHJcblx0XHRcdGlmKGNhcmQuc3BlYy5icmFuZCA9PSAwKXtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0fVxyXG5cclxuXHRcdC8v566X54mM5Z6L5b6X5YiG77yM6L+Y5rKh566X5omT5p6q5ZKM5YWo5Z6S5omTXHJcblx0XHQvL2NhcnM6IOW9k+WJjeWiqeeJjFNfRzEzX0FsbEhhbmRzLkJyYW5kSW5mb1xyXG5cdFx0Ly9pZHg6IOesrOWHoOWiqVxyXG5cdFx0Ly9pc1NwZWNpYWw6IOaYr+WQpuaYr+eJueauiueJjOWei1xyXG5cdFx0ZnVuY3Rpb24gZ2V0U2NvcmUoY2FyZHMsIGlkeCwgaXNTcGVjaWFsKXtcclxuXHRcdFx0dmFyIHNjb3JlID0gMTtcclxuXHRcdFx0aWYoIWlzU3BlY2lhbCl7XHJcblx0XHRcdFx0aWYoaWR4PT0xICYmIGNhcmRzLmJyYW5kPT0zKXtcdC8v5Yay5LiJXHJcblx0XHRcdFx0XHRzY29yZSArPSAyXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGlkeD09MiAmJiBjYXJkcy5icmFuZD09Nil7ICAvL+S4reWiqeiRq+iKplxyXG5cdFx0XHRcdFx0c2NvcmUgKz0gMVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihjYXJkcy5icmFuZCA9PSA5KXtcclxuXHRcdFx0XHRcdGlmKGlkeD09Mil7IHNjb3JlICs9IDE5XHR9Ly/kuK3loqnkupTlkIxcclxuXHRcdFx0XHRcdGlmKGlkeD09Myl7IHNjb3JlICs9IDkgfS8v5bC+5aKp5LqU5ZCMXHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoY2FyZHMuYnJhbmQgPT0gOCl7XHJcblx0XHRcdFx0XHRpZihpZHg9PTIpeyBzY29yZSArPSA5fS8v5Lit5aKp5ZCM6Iqx6aG6XHJcblx0XHRcdFx0XHRpZihpZHg9PTMpeyBzY29yZSArPSA0fS8v5bC+5aKp5ZCM6Iqx6aG6XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGNhcmRzLmJyYW5kID09IDcpe1xyXG5cdFx0XHRcdFx0aWYoaWR4PT0yKXsgc2NvcmUgKz0gN30vL+S4reWiqemTgeaUr1xyXG5cdFx0XHRcdFx0aWYoaWR4PT0zKXsgc2NvcmUgKz0gM30vL+WwvuWiqemTgeaUr1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzY29yZSA9IDBcclxuXHRcdFx0XHR2YXIgYnIgPSBNYXRoLmZsb29yKGNhcmRzLmJyYW5kLzEwKVxyXG5cdFx0XHRcdGlmKGJyPT0xMyl7IC8v6Z2S6b6ZXHJcblx0XHRcdFx0XHR2YXIgeXRsID0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIueWlfdGlhb19sb25nXHJcblx0XHRcdFx0XHRzY29yZSArPSAoMTA0ICogeXRsKSBcclxuXHRcdFx0XHR9ICBcclxuXHRcdFx0XHRpZihicj09MTIpeyAvL+S4gOadoem+mVxyXG5cdFx0XHRcdFx0dmFyIHl0bCA9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnlpX3RpYW9fbG9uZ1xyXG5cdFx0XHRcdFx0c2NvcmUgKz0gKDUyICogeXRsKSBcclxuXHRcdFx0XHR9ICAgXHJcblx0XHRcdFx0aWYoYnI9PTExKXsgc2NvcmUgKz0gMjYgfSAgIC8v5Y2B5LqM55qH5a2QXHJcblx0XHRcdFx0aWYoYnI9PTEwKXsgc2NvcmUgKz0gMjYgfSAgIC8v5LiJ5ZCM6Iqx6aG6XHJcblx0XHRcdFx0aWYoYnI9PTkpeyBzY29yZSArPSAyNiB9ICAgIC8v5LiJ54K45by5XHJcblx0XHRcdFx0aWYoYnIgPj0gMSAmJiBiciA8PSA4KXsgc2NvcmUgKz0gNn0gICAgICAvL+WFtuS7lueJueauiueJjOWei1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzY29yZVxyXG5cdFx0fVxyXG5cclxuXHRcdC8v5q+U6L6D5Lik5aKp54mMXHJcblx0XHQvL2NhcmQxOiDniYzlnovlkozngrnmlbAgc3BlMTrmmK/lkKbmmK/nibnmrorniYzlnotcclxuXHRcdC8vY2FyZDI6IOeJjOWei+WSjOeCueaVsCBzcGUyOuaYr+WQpuaYr+eJueauiueJjOWei1xyXG5cdFx0ZnVuY3Rpb24gY29tcGFyZUNhcmQoY2FyZDEsIHNwZTEsIGNhcmQyLCBzcGUyKXtcclxuXHRcdFx0aWYoc3BlMSAmJiAhc3BlMil7XHJcblx0XHRcdFx0cmV0dXJuIDFcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighc3BlMSAmJiAhc3BlMil7XHJcblx0XHRcdFx0aWYoY2FyZDEuYnJhbmQgPiBjYXJkMi5icmFuZCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gMVxyXG5cdFx0XHRcdH1lbHNlIGlmKGNhcmQxLmJyYW5kID09IGNhcmQyLmJyYW5kKXtcclxuXHRcdFx0XHRcdGlmKGNhcmQxLnBvaW50ID4gY2FyZDIucG9pbnQpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gMVxyXG5cdFx0XHRcdFx0fWVsc2UgaWYoY2FyZDEucG9pbnQgPT0gY2FyZDIucG9pbnQpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gMFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2UgaWYoc3BlMSAmJiBzcGUyKXtcclxuXHRcdFx0XHR2YXIgYSA9IGNhcmQxLmJyYW5kJTEwXHJcblx0XHRcdFx0dmFyIGIgPSBjYXJkMi5icmFuZCUxMFxyXG5cdFx0XHRcdGlmKCBhID4gYil7XHJcblx0XHRcdFx0XHRyZXR1cm4gMVxyXG5cdFx0XHRcdH1lbHNlIGlmKGEgPT0gYil7XHJcblx0XHRcdFx0XHRyZXR1cm4gMFxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0cmV0dXJuIC0xXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMVxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG5ld0JyYW5kSW5mbyhjdWlkKXtcclxuXHRcdFx0dmFyIGJyYW5kID0ge31cclxuXHRcdFx0YnJhbmQuY3VpZCA9IGN1aWRcclxuXHRcdFx0YnJhbmQuc2NvcmUgPSB7XCJ0b3BcIjowLCBcIm1pZGRsZVwiOjAsIFwiYm90dG9tXCI6MCwgXCJzcGVcIjowLCBcInNwZWNpYWxcIjowLCBcInF1YW5sZWlkYVwiOjB9XHJcblx0XHRcdGJyYW5kLmRhcWlhbmdsaXN0ID0gW11cclxuXHRcdFx0YnJhbmQucXVhbmxlaWRhID0gZmFsc2VcclxuXHRcdFx0cmV0dXJuIGJyYW5kXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJldCA9IFtdXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYWxsaGFuZHMucGxheWVycy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0Ly/mr4/kuKrnjqnlrrbkuIDkuKpuZXdCcmFuZEluZm/mlbDnu4TvvIzkv53lrZjoh6rlt7HotaLnmoTmlbDmja5cclxuXHRcdFx0cmV0LnB1c2gobmV3QnJhbmRJbmZvKGFsbGhhbmRzLnBsYXllcnNbaV0uY3VpZCkpXHJcblx0XHR9XHJcblxyXG5cdFx0Ly/kv53lrZjog5zliKnnmoTnjqnlrrZpZFxyXG5cclxuXHRcdHZhciBwbGF5ZXJzID0gYWxsaGFuZHMucGxheWVyc1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBsYXllcnMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBkYXRhMSA9IHBsYXllcnNbaV1cclxuXHRcdFx0dmFyIHNwZTEgPSBpc1NwZWNpYWwoZGF0YTEpXHJcblxyXG5cdFx0XHR2YXIgbGFyZ2UgPSBbXVxyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgcGxheWVycy5sZW5ndGg7ICsrailcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBkYXRhMiA9IHBsYXllcnNbal1cclxuXHRcdFx0XHR2YXIgc3BlMiA9IGlzU3BlY2lhbChkYXRhMilcclxuXHJcblx0XHRcdFx0aWYoaSA9PSBqKXtcclxuXHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL+eJueauiueJjOWei+Wkp1xyXG5cdFx0XHRcdHZhciBsYSA9IHt9XHJcblx0XHRcdFx0Ly92YXIgY21wID0gY29tcGFyZUNhcmQoZGF0YTEuc3BlYywgc3BlMSwgZGF0YTIuc3BlYywgc3BlMilcclxuXHRcdFx0XHRpZihzcGUxKXtcclxuXHRcdFx0XHRcdHZhciBzYyA9IGdldFNjb3JlKGRhdGExLnNwZWMsIDAsIHRydWUpXHJcblx0XHRcdFx0XHRyZXRbaV0uc2NvcmUuc3BlY2lhbCArPSBzY1xyXG5cclxuXHRcdFx0XHRcdC8v54m55q6K54mM5Z6L5YiG5pWw5LiN5Yqg5Yiw5omT5p6q5YiG5pWw5LqGXHJcblx0XHRcdFx0XHQvL3JldFtpXS5zY29yZS5zcGUgKz0gc2MgLy/kuInloqnpg73lpKdcclxuXHRcdFx0XHRcdC8vcmV0W2pdLnNjb3JlLnNwZSAtPSBzYyBcclxuXHRcdFx0XHRcdC8vbGEuaWR4ID0galxyXG5cdFx0XHRcdFx0Ly9sYS5zY29yZSA9IHNjKjJcclxuXHRcdFx0XHRcdC8vbGFyZ2UucHVzaChsYSlcclxuXHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL+S4gOiIrOeJjOWei1xyXG5cdFx0XHRcdHZhciB0bWIgPSAwXHJcblx0XHRcdFx0dmFyIHRibVNjb3JlID0gMFxyXG5cdFx0XHRcdHZhciBjbXAgPSBjb21wYXJlQ2FyZChkYXRhMS5kdW4wLCBzcGUxLCBkYXRhMi5kdW4wLCBzcGUyKVxyXG5cdFx0XHRcdGlmKGNtcCA9PSAxKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBzYyA9IGdldFNjb3JlKGRhdGExLmR1bjAsIDEsIHNwZTEpXHJcblx0XHRcdFx0XHRyZXRbaV0uc2NvcmUudG9wICs9IHNjXHJcblx0XHRcdFx0XHRyZXRbal0uc2NvcmUudG9wIC09IHNjXHJcblx0XHRcdFx0XHR0bWIrK1xyXG5cdFx0XHRcdFx0dGJtU2NvcmUgKz0gc2NcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNtcCA9IGNvbXBhcmVDYXJkKGRhdGExLmR1bjEsIHNwZTEsIGRhdGEyLmR1bjEsIHNwZTIpXHJcblx0XHRcdFx0aWYoY21wID09IDEpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIHNjID0gZ2V0U2NvcmUoZGF0YTEuZHVuMSwgMiwgc3BlMSlcclxuXHRcdFx0XHRcdHJldFtpXS5zY29yZS5taWRkbGUgKz0gc2NcclxuXHRcdFx0XHRcdHJldFtqXS5zY29yZS5taWRkbGUgLT0gc2NcclxuXHRcdFx0XHRcdHRtYisrXHJcblx0XHRcdFx0XHR0Ym1TY29yZSArPSBzY1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y21wID0gY29tcGFyZUNhcmQoZGF0YTEuZHVuMiwgc3BlMSwgZGF0YTIuZHVuMiwgc3BlMilcclxuXHRcdFx0XHRpZihjbXAgPT0gMSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgc2MgPSBnZXRTY29yZShkYXRhMS5kdW4yLCAzLCBzcGUxKVxyXG5cdFx0XHRcdFx0cmV0W2ldLnNjb3JlLmJvdHRvbSArPSBzY1xyXG5cdFx0XHRcdFx0cmV0W2pdLnNjb3JlLmJvdHRvbSAtPSBzY1xyXG5cdFx0XHRcdFx0dG1iKytcclxuXHRcdFx0XHRcdHRibVNjb3JlICs9IHNjXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZih0bWIgPT0gMylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHQvL+aJk+aeqlxyXG5cdFx0XHRcdFx0aWYoY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIuZGFfcWlhbmcgPT0gMyl7IC8v5Yqg5LiJ6YGTXHJcblx0XHRcdFx0XHRcdHJldFtpXS5zY29yZS5zcGUgKz0gM1xyXG5cdFx0XHRcdFx0XHRyZXRbal0uc2NvcmUuc3BlIC09IDNcclxuXHRcdFx0XHRcdFx0bGEuc2NvcmUgPSB0Ym1TY29yZSArIDNcclxuXHRcdFx0XHRcdH1lbHNlIGlmKGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLmRhX3FpYW5nID09IDIpeyAvL+WPjOWAjVxyXG5cdFx0XHRcdFx0XHRyZXRbaV0uc2NvcmUuc3BlICs9IHRibVNjb3JlXHJcblx0XHRcdFx0XHRcdHJldFtqXS5zY29yZS5zcGUgLT0gdGJtU2NvcmVcclxuXHRcdFx0XHRcdFx0bGEuc2NvcmUgPSB0Ym1TY29yZSAqIDJcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsYS5pZHggPSBqXHJcblx0XHRcdFx0XHRsYXJnZS5wdXNoKGxhKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly/lhajlnpLmiZMo5Lik5Lq65Lul5LiK5omN6IO95YWo5Z6S5omTKVxyXG5cdFx0XHRpZihsYXJnZS5sZW5ndGggPT0gKHBsYXllcnMubGVuZ3RoIC0gMSkgJiYgKHBsYXllcnMubGVuZ3RoID4gMikpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZihjYy5nYW1lbWFuYWdlci5yb29tX2luZm8uYXR0ci5xdWFuX2xlaV9kYSA9PSB0cnVlKXtcclxuXHRcdFx0XHRcdHJldFtpXS5xdWFubGVpZGEgPSB0cnVlXHJcblx0XHRcdFx0XHRmb3IodmFyIG0gPSAwOyBtIDwgbGFyZ2UubGVuZ3RoOyArK20pXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHJldFtpXS5zY29yZS5xdWFubGVpZGEgKz0gbGFyZ2VbbV0uc2NvcmVcclxuXHRcdFx0XHRcdFx0cmV0W2xhcmdlW21dLmlkeF0uc2NvcmUucXVhbmxlaWRhIC09IGxhcmdlW21dLnNjb3JlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Ly/miZPmnqpcclxuXHRcdFx0XHRmb3IodmFyIG4gPSAwOyBuIDzjgIBsYXJnZS5sZW5ndGg7ICsrbil7XHJcblx0XHRcdFx0XHQvL3JldFtpXS5zY29yZS5zcGUgKz0gbGFyZ2Vbbl0uc2NvcmVcclxuXHRcdFx0XHRcdC8vcmV0W2xhcmdlW25dLmlkeF0uc2NvcmUuc3BlIC09IGxhcmdlW25dLnNjb3JlXHJcblx0XHRcdFx0XHRyZXRbaV0uZGFxaWFuZ2xpc3QucHVzaChwbGF5ZXJzW2xhcmdlW25dLmlkeF0uY3VpZClcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH0sXHJcblxyXG5cdC8v5Yik5pat5piv5ZCm55u45YWsXHJcblx0aXNNZXNzaXJlOiBmdW5jdGlvbih0b3AsIG1pZGRsZSwgYm90dG9tKXtcclxuXHRcdHZhciB0b3B0eXBlID0gLTEsIG1pZHR5cGUgPSAtMSwgYm90dHlwZSA9IC0xXHJcblx0XHR2YXIgdG9wYXJyID0gW10sIG1pZGFyciA9IFtdLCBib3RhcnIgPSBbXVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjYy5Qb2tlclV0aWwudDNHcm91cC5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciBhcnIgPSBjYy5Qb2tlclV0aWwudDNHcm91cFtpXSh0b3ApXHJcblx0XHRcdGlmKGFyciAmJiBhcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0dG9wdHlwZSA9IGlcclxuXHRcdFx0XHR0b3BhcnIgPSBhcnJbMF1cclxuXHRcdFx0XHRicmVha1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNjLlBva2VyVXRpbC50NUdyb3VwLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIGFyciA9IGNjLlBva2VyVXRpbC50NUdyb3VwW2ldKG1pZGRsZSlcclxuXHRcdFx0aWYoYXJyICYmIGFyci5sZW5ndGggPiAwICYmIG1pZHR5cGUgPT0gLTEpe1xyXG5cdFx0XHRcdG1pZHR5cGUgPSBpXHJcblx0XHRcdFx0bWlkYXJyID0gYXJyWzBdXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBicnIgPSBjYy5Qb2tlclV0aWwudDVHcm91cFtpXShib3R0b20pXHJcblx0XHRcdGlmKGJyciAmJiBicnIubGVuZ3RoID4gMCAmJiBib3R0eXBlID09IC0xKXtcclxuXHRcdFx0XHRib3R0eXBlID0gaVxyXG5cdFx0XHRcdGJvdGFyciA9IGJyclswXVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihtaWR0eXBlICE9IC0xICYmIGJvdHR5cGUgIT0gLTEpe1xyXG5cdFx0XHRcdGJyZWFrXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwcmludEFycihhLCBzKXtcclxuXHRcdFx0dmFyIHN0ciA9IHNcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHRcdHN0ciArPSAoYVtpXS50eXBlLnRvU3RyaW5nKCkgKyBcIiAtIFwiICsgYVtpXS52YWx1ZS50b1N0cmluZygpICsgXCIsIFwiKVxyXG5cdFx0XHR9XHJcblx0XHRcdGNjLmxvZyhzdHIpXHJcblx0XHR9XHJcblxyXG5cdFx0Y2MubG9nKFwi5LiJ5aKp54mM5omA5bGe55qE57G75Z6L77yaXCIsIHRvcHR5cGUsIG1pZHR5cGUsIGJvdHR5cGUpXHJcblx0XHRwcmludEFycih0b3BhcnIsIFwi56ys5LiA5aKp54mM77yaXCIpXHJcblx0XHRwcmludEFycihtaWRhcnIsIFwi56ys5LqM5aKp54mM77yaXCIpXHJcblx0XHRwcmludEFycihib3RhcnIsIFwi56ys5LiJ5aKp54mM77yaXCIpXHJcblxyXG5cdFx0aWYoKHRvcHR5cGUgPT0gMCAmJiBtaWR0eXBlID4gNikgfHwgKHRvcHR5cGU9PTEgJiYgbWlkdHlwZT44KSl7XHJcblx0XHRcdGNjLmxvZyhcIjEsMuWiqeebuOWFrFwiKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0fVxyXG5cdFx0aWYoKHRvcHR5cGU9PTAmJm1pZHR5cGU9PTYpIHx8KHRvcHR5cGU9PTEgJiYgbWlkdHlwZT09OCkgfHwgKHRvcHR5cGU9PTImJm1pZHR5cGU9PTkpKXtcclxuXHRcdFx0aWYoY2MuUG9rZXJVdGlsLmlzTWVzc2lyZVRocmVlKG1pZHR5cGUsIG1pZGFyciwgdG9wYXJyLCAwKSl7XHJcblx0XHRcdFx0Y2MubG9nKFwiMSwy55u45YWsXCIsIG1pZHR5cGUpXHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29tcGFyZSAyZHVuIGFuZCAzZHVuXHJcblx0XHRpZihtaWR0eXBlIDwgYm90dHlwZSl7XHJcblx0XHRcdGNjLmxvZyhcIjIsM+ebuOWFrFwiLCBtaWR0eXBlLCBib3R0eXBlKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0fWVsc2UgaWYobWlkdHlwZSA9PSBib3R0eXBlKXtcclxuXHRcdFx0aWYoY2MuUG9rZXJVdGlsLmlzTWVzc2lyZUZpdmUoYm90dHlwZSwgYm90YXJyLCBtaWRhcnIpKXtcclxuXHRcdFx0XHRjYy5sb2coXCIyLDPloqnnm7jlhaxcIiwgYm90dHlwZSlcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2VcclxuXHR9LFxyXG5cclxuXHJcblxyXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHQvL+eJueauiueJjOWei+WIpOaWrSAgXHJcblx0XHJcblx0Ly8xNC5cdOS4ieWQjOiKse+8muS4reWiqeOAgeWwvuWiqeS4uuWQjOiKse+8jOWktOWiqeS4uuS4ieW8oOWQjOiKseiJsueahOeJjFxyXG5cdGlzU2FuVG9uZ0h1YTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIHRtcCA9IGNjLlBva2VyVXRpbC5fY29weUFycmF5KGNhcmRzKVxyXG5cdFx0dmFyIHRoQXJyID0gY2MuUG9rZXJVdGlsLnRvbmdodWEodG1wKVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoQXJyLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIGEgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUodGhBcnJbaV0pXHJcblx0XHRcdHZhciBiID0gY2MuUG9rZXJVdGlsLl9kZWxDYXJkcyh0bXAsIGEpXHJcblxyXG5cdFx0XHR2YXIgdGhBcnIyID0gY2MuUG9rZXJVdGlsLnRvbmdodWEoYilcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHRoQXJyMi5sZW5ndGg7ICsrail7XHJcblx0XHRcdFx0dmFyIGMgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUodGhBcnIyW2pdKVxyXG5cdFx0XHRcdHZhciBkID0gY2MuUG9rZXJVdGlsLl9kZWxDYXJkcyhiLCBjKVxyXG5cclxuXHRcdFx0XHR2YXIgc3VpdCA9IGNjLlBva2VyVXRpbC5nZXRTdWl0KGNjLlBva2VyVXRpbC5jYXJkc0RlY29kZShkKSlcclxuXHRcdFx0XHRmb3IodmFyIG0gPSAwOyBtIDwgNDsgKyttKXtcclxuXHRcdFx0XHRcdGlmKHN1aXRbbV0ubGVuZ3RoID09IDMpe1xyXG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0ge31cclxuXHRcdFx0XHRcdFx0cmV0LnRvcCA9IGQuc2xpY2UoKVxyXG5cdFx0XHRcdFx0XHRyZXQubWlkZGxlID0gYy5zbGljZSgpXHJcblx0XHRcdFx0XHRcdHJldC5ib3R0b20gPSBhLnNsaWNlKClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGxcclxuXHR9LFxyXG5cclxuXHQvLzEzLlx05LiJ6aG65a2Q77ya5Lit5aKp44CB5bC+5aKp5Li66aG65a2Q77yM5aS05aKp5Li65LiJ5byg6L+e57ut55qE54mMXHJcblx0aXNTYW5TaHVuWmk6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciB0bXAgPSBjYy5Qb2tlclV0aWwuX2NvcHlBcnJheShjYXJkcylcclxuXHRcdHZhciB0aEFyciA9IGNjLlBva2VyVXRpbC5zaHVuemkodG1wKVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoQXJyLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIGEgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUodGhBcnJbaV0pXHJcblx0XHRcdHZhciBiID0gY2MuUG9rZXJVdGlsLl9kZWxDYXJkcyh0bXAsIGEpXHJcblxyXG5cdFx0XHR2YXIgdGhBcnIyID0gY2MuUG9rZXJVdGlsLnNodW56aShiKVxyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgdGhBcnIyLmxlbmd0aDsgKytqKXtcclxuXHRcdFx0XHR2YXIgYyA9IGNjLlBva2VyVXRpbC5jYXJkc0VuY29kZSh0aEFycjJbal0pXHJcblx0XHRcdFx0dmFyIGQgPSBjYy5Qb2tlclV0aWwuX2RlbENhcmRzKGIsIGMpXHJcblxyXG5cdFx0XHRcdHZhciBlID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKGQpXHJcblxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKChlWzBdLnZhbHVlID09IGVbMV0udmFsdWUrMSAmJiBlWzFdLnZhbHVlID09IGVbMl0udmFsdWUrMSlcclxuXHRcdFx0XHR8fCAoZVswXS52YWx1ZT09IDEzICYmIGVbMV0udmFsdWU9PTIgJiYgZVsyXS52YWx1ZT09MSkpe1xyXG5cdFx0XHRcdFx0dmFyIHJldCA9IHt9XHJcblx0XHRcdFx0XHRyZXQudG9wID0gZC5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXQubWlkZGxlID0gYy5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXQuYm90dG9tID0gYS5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXR1cm4gcmV0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH0sXHJcblxyXG5cdC8vMTIuXHTlha3lr7nljYrvvJrljYHkuInlvKDniYznlLHlha3kuKrlr7nlrZDliqDkuIDlvKDlhbbku5bljZXniYznu4TmiJDjgIJcclxuXHRpc0xpdUR1aUJhbjogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIHRtcCA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKVxyXG5cdFx0aWYodG1wWzFdLmxlbmd0aCA9PSA2ICAgLy825a+5XHJcblx0XHR8fCAoKHRtcFsxXS5sZW5ndGggKyAyICogdG1wWzNdLmxlbmd0aCkgPT0gNikgIC8v5Zub5a+5K+mTgeaUr1xyXG5cdFx0KXtcclxuXHRcdFx0cmV0dXJuIHt9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH0sXHJcblxyXG5cdC8vMTEuXHTkupTlr7nkuInmnaHvvJrljYHkuInlvKDniYznlLHkupTkuKrlr7nlrZDliqDkuIDnu4TkuInmnaHnu4TmiJBcclxuXHRpc1d1RHVpU2FuVGlhbzogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIHRtcCA9IGNjLlBva2VyVXRpbC5nZXRHcm91cENhcmRzKGNhcmRzKVxyXG5cdFx0aWYodG1wWzFdLmxlbmd0aCA9PSA1ICAmJiB0bXBbMl0ubGVuZ3RoID09IDEpe1xyXG5cdFx0XHRyZXR1cm4ge31cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsXHJcblx0fSxcclxuXHJcblx0Ly8xMC5cdOWbm+Wll+S4ieadoe+8muWNgeS4ieW8oOeJjOeUseWbm+e7hOS4ieadoee7hOaIkOWKoOS4gOW8oOWNleeJjFxyXG5cdGlzU2lTYW5UaWFvOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgdG1wID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHMpXHJcblx0XHRpZih0bXBbMl0ubGVuZ3RoID09IDQpe1xyXG5cdFx0XHRyZXR1cm4ge31cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsXHJcblx0fSxcclxuXHRcclxuXHQvLzkuXHTlh5HkuIDoibLvvJrljYHkuInlvKDniYzoirHoibLlnYfkuLrnuqLoibLmiJbogIXpu5HoibJcclxuXHRpc0NvdVlpQ2U6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBhID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKGNhcmRzKVxyXG5cdFx0dmFyIHMgPSBjYy5Qb2tlclV0aWwuZ2V0U3VpdChhKVxyXG5cdFx0aWYoc1swXS5sZW5ndGggKyBzWzJdLmxlbmd0aCA9PSBjYXJkcy5sZW5ndGgpeyAgLy/lhajnuqJcclxuXHRcdFx0cmV0dXJuIHt9XHJcblx0XHR9XHJcblx0XHRpZihzWzFdLmxlbmd0aCArIHNbM10ubGVuZ3RoID09IGNhcmRzLmxlbmd0aCl7ICAvL+WFqOm7kVxyXG5cdFx0XHRyZXR1cm4ge31cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsXHJcblx0fSxcclxuXHJcblx0Ly84Llx05YWo5bCP77ya5Y2B5LiJ5byg54mM6YO95pivMuOAgTPjgIE044CBNeOAgTbjgIE344CBOO+8jOS4jeiuuuiKseiJslxyXG5cdGlzUXVhblhpYW86IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBhID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKGNhcmRzKVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHRpZihhW2ldLnZhbHVlIDwgMCB8fCBhW2ldLnZhbHVlID4gNyl7XHJcblx0XHRcdFx0cmV0dXJuIG51bGxcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt9XHJcblx0fSxcclxuXHJcblx0Ly83Llx05YWo5aSn77ya5Y2B5LiJ5byg54mM6YO95pivOOOAgTnjgIExMOOAgUrjgIFR44CBS+OAgUHvvIzkuI3orrroirHoibJcclxuXHRpc1F1YW5EYTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGEgPSBjYy5Qb2tlclV0aWwuY2FyZHNEZWNvZGUoY2FyZHMpXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSl7XHJcblx0XHRcdGlmKGFbaV0udmFsdWUgPCA3IHx8IGFbaV0udmFsdWUgPiAxMyl7XHJcblx0XHRcdFx0cmV0dXJuIG51bGxcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt9XHRcclxuXHR9LFxyXG5cclxuXHQvLzYuXHTkuInlpZfngrjlvLnvvJrlhbHkuInnu4Tpk4HmlK/lkozku7vmhI8x5byg5YW25LuW5Y2V54mM57uE5oiQ55qE54mMXHJcblx0aXNTYW5aaGFEYW46IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBhID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHMoY2FyZHMpXHJcblx0XHRpZihhWzNdLmxlbmd0aCA9PSAzKXtcclxuXHRcdFx0cmV0dXJuIHt9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH0sXHJcblxyXG5cdC8vNS5cdOS4ieWQjOiKsemhuu+8muS4reWiqeOAgeWwvuWiqeWdh+S4uuWQjOiKsemhuu+8jOWktOWiqeS4uuS4ieW8oOiKseiJsuebuOWQjOS4lOi/nue7reeahOeJjFxyXG5cdGlzU2FuVG9uZ0h1YVNodW46IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciB0bXAgPSBjYy5Qb2tlclV0aWwuX2NvcHlBcnJheShjYXJkcylcclxuXHRcdHZhciB0aEFyciA9IGNjLlBva2VyVXRpbC50b25naHVhc2h1bih0bXApXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhBcnIubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHR2YXIgYSA9IGNjLlBva2VyVXRpbC5jYXJkc0VuY29kZSh0aEFycltpXSlcclxuXHRcdFx0dmFyIGIgPSBjYy5Qb2tlclV0aWwuX2RlbENhcmRzKHRtcCwgYSlcclxuXHJcblx0XHRcdHZhciB0aEFycjIgPSBjYy5Qb2tlclV0aWwudG9uZ2h1YXNodW4oYilcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHRoQXJyMi5sZW5ndGg7ICsrail7XHJcblx0XHRcdFx0dmFyIGMgPSBjYy5Qb2tlclV0aWwuY2FyZHNFbmNvZGUodGhBcnIyW2pdKVxyXG5cdFx0XHRcdHZhciBkID0gY2MuUG9rZXJVdGlsLl9kZWxDYXJkcyhiLCBjKVxyXG5cclxuXHRcdFx0XHRjYy5Qb2tlclV0aWwuc29ydFBva2VyKDEsIGQpXHJcblx0XHRcdFx0dmFyIGUgPSBjYy5Qb2tlclV0aWwuY2FyZHNEZWNvZGUoZClcclxuXHRcdFx0XHRpZihlWzBdLnR5cGUgPT0gZVsxXS50eXBlICYmIGVbMV0udHlwZSA9PSBlWzJdLnR5cGVcclxuXHRcdFx0XHQmJiAoZVswXS52YWx1ZSA9PSBlWzFdLnZhbHVlKzEgJiYgZVsxXS52YWx1ZSA9PSBlWzJdLnZhbHVlKzEpIHx8IFxyXG5cdFx0XHRcdChlWzBdLnZhbHVlID09IDEzICYmIGVbMV0udmFsdWU9PTIgJiYgZVsyXS52YWx1ZT09MSkpe1xyXG5cdFx0XHRcdFx0dmFyIHJldCA9IHt9XHJcblx0XHRcdFx0XHRyZXQudG9wID0gZC5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXQubWlkZGxlID0gYy5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXQuYm90dG9tID0gYS5zbGljZSgpXHJcblx0XHRcdFx0XHRyZXR1cm4gcmV0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH0sXHJcblxyXG5cdC8vNC5cdOWNgeS6jOeah+aXj++8muWNgeS4ieW8oOeJjOWdh+aYr0FLUUpcclxuXHRpc1NoaWVySHVhbmd6dTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGEgPSBjYy5Qb2tlclV0aWwuY2FyZHNEZWNvZGUoY2FyZHMpXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciBiID0gYVtpXS52YWx1ZVxyXG5cdFx0XHRpZihiICE9IDEzICYmIGIgIT0gMTIgJiYgYiE9IDExICYmIGIgIT0gMTApe1xyXG5cdFx0XHRcdHJldHVybiBudWxsXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB7fVxyXG5cdH0sXHJcblxyXG5cdC8vMy5cdOS4gOadoem+me+8muS4jeWQjOiKseiJsu+8jEHliLBL5ZCE5LiA5byg55qE5Y2B5LiJ5byg54mMXHJcblx0aXNZaVRpYW9Mb25nOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgYSA9IGNjLlBva2VyVXRpbC5jYXJkc0RlY29kZShjYXJkcylcclxuXHRcdHZhciBzaWduID0gW11cclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciB2ID0gYVtpXS52YWx1ZVxyXG5cdFx0XHRpZihzaWduW3ZdID09IHRydWUpe1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdHNpZ25bdl0gPSB0cnVlXHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge31cclxuXHR9LFxyXG5cclxuXHQvLzIuXHTmuIXpvpnvvJrlkIzkuIDnp43oirHoibLvvIxB5YiwS+WQhOS4gOW8oOeahOWNgeS4ieW8oOeJjFxyXG5cdGlzUWluZ0xvbmc6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBhID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKGNhcmRzKVxyXG5cdFx0dmFyIHNpZ24gPSBbXVxyXG5cdFx0dmFyIHR5cGVudW0gPSAwLCBsYXN0dHlwZSA9IC0xXHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xyXG5cdFx0XHR2YXIgdiA9IGFbaV0udmFsdWVcclxuXHRcdFx0aWYoc2lnblt2XSA9PSB0cnVlKXtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRzaWduW3ZdID0gdHJ1ZVxyXG5cdFx0XHRpZihsYXN0dHlwZSA9PSAtMSl7XHJcblx0XHRcdFx0bGFzdHR5cGUgPSBhW2ldLnR5cGVcclxuXHRcdFx0fWVsc2UgaWYoYVtpXS50eXBlICE9IGxhc3R0eXBlKXtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge31cclxuXHR9LFxyXG5cclxuXHQvL+aJk+WNsOaJkeWFi+eJjFxyXG5cdHByaW50UG9rZXI6IGZ1bmN0aW9uKGFycil7XHJcblx0XHR2YXIgc3RyID0gXCJcIlxyXG5cdFx0XHJcblx0XHR2YXIgc3VpdFN0ciA9IFtcIuaWuVwiLCBcIuaihVwiLCBcIue6olwiLCBcIum7kVwiXVxyXG5cdFx0dmFyIHBrID0gW1wiMFwiLFwiMlwiLFwiM1wiLFwiNFwiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiLFwiMTBcIixcIkpcIixcIlFcIixcIktcIixcIkFcIl1cclxuXHRcdFxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciB2YWwgPSBhcnJbaV1cclxuXHRcdFx0XHJcblx0XHRcdHZhciBzdCA9IHN1aXRTdHJbdmFsLnR5cGVdXHJcblx0XHRcdHZhciB2YSA9IHBrW3ZhbC52YWx1ZV1cclxuXHRcdFx0c3RyICs9ICggc3QgKyB2YSArIFwiIFwiKVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRjYy5sb2coc3RyKVxyXG5cdH0sXHJcblxyXG5cdHByaW50UG9rZXJFbmNvZGU6IGZ1bmN0aW9uKGFycil7XHJcblx0XHR2YXIgZW5jb2RlQXJyID0gY2MuUG9rZXJVdGlsLmNhcmRzRGVjb2RlKGFycilcclxuXHRcdGNjLlBva2VyVXRpbC5wcmludFBva2VyKGVuY29kZUFycilcclxuXHR9XHJcbn0pO1xyXG5cclxuY2MuUG9rZXJVdGlsID0gbmV3IE0oKTtcclxuXHJcbi8v56ys5LqM5aKp44CB56ys5LiJ5aKp5q+U6L6D6KeE5YiZKDXlvKDniYwpXHJcbmNjLlBva2VyVXRpbC50NUdyb3VwID0gW107XHJcblxyXG5jYy5Qb2tlclV0aWwudDVHcm91cFswXSA9IGNjLlBva2VyVXRpbC53dXRvbmc7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzFdID0gY2MuUG9rZXJVdGlsLnRvbmdodWFzaHVuO1xyXG5jYy5Qb2tlclV0aWwudDVHcm91cFsyXSA9IGNjLlBva2VyVXRpbC50aWV6aGk7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzNdID0gY2MuUG9rZXJVdGlsLmh1bHU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzRdID0gY2MuUG9rZXJVdGlsLnRvbmdodWE7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzVdID0gY2MuUG9rZXJVdGlsLnNodW56aTtcclxuY2MuUG9rZXJVdGlsLnQ1R3JvdXBbNl0gPSBjYy5Qb2tlclV0aWwuc2FudGlhb0ZpdmU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzddID0gY2MuUG9rZXJVdGlsLmxpYW5nZHVpO1xyXG5jYy5Qb2tlclV0aWwudDVHcm91cFs4XSA9IGNjLlBva2VyVXRpbC55aWR1aUZpdmU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzldID0gY2MuUG9rZXJVdGlsLnd1bG9uZ0ZpdmU7XHJcblxyXG4vL+esrOS4gOWiqeavlOi+g+inhOWImSgz5byg54mMKVxyXG5jYy5Qb2tlclV0aWwudDNHcm91cCA9IFtdO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFswXSA9IGNjLlBva2VyVXRpbC5zYW50aWFvO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFsxXSA9IGNjLlBva2VyVXRpbC55aWR1aVRocmVlO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFsyXSA9IGNjLlBva2VyVXRpbC53dWxvbmdUaHJlZTtcclxuXHJcbi8v54m55q6K54mM5Z6L5Yik5patXHJcbmNjLlBva2VyVXRpbC5zcGVjaWFsR3JvdXAgPSBbXVxyXG5jYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwWzBdID0gY2MuUG9rZXJVdGlsLmlzUWluZ0xvbmdcclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFsxXSA9IGNjLlBva2VyVXRpbC5pc1lpVGlhb0xvbmdcclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFsyXSA9IGNjLlBva2VyVXRpbC5pc1NoaWVySHVhbmd6dVxyXG5jYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwWzNdID0gY2MuUG9rZXJVdGlsLmlzU2FuVG9uZ0h1YVNodW5cclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFs0XSA9IGNjLlBva2VyVXRpbC5pc1NhblpoYURhblxyXG5jYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwWzVdID0gY2MuUG9rZXJVdGlsLmlzUXVhbkRhXHJcbmNjLlBva2VyVXRpbC5zcGVjaWFsR3JvdXBbNl0gPSBjYy5Qb2tlclV0aWwuaXNRdWFuWGlhb1xyXG5jYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwWzddID0gY2MuUG9rZXJVdGlsLmlzQ291WWlDZVxyXG5jYy5Qb2tlclV0aWwuc3BlY2lhbEdyb3VwWzhdID0gY2MuUG9rZXJVdGlsLmlzU2lTYW5UaWFvXHJcbmNjLlBva2VyVXRpbC5zcGVjaWFsR3JvdXBbOV0gPSBjYy5Qb2tlclV0aWwuaXNXdUR1aVNhblRpYW9cclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFsxMF0gPSBjYy5Qb2tlclV0aWwuaXNMaXVEdWlCYW5cclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFsxMV0gPSBjYy5Qb2tlclV0aWwuaXNTYW5TaHVuWmlcclxuY2MuUG9rZXJVdGlsLnNwZWNpYWxHcm91cFsxMl0gPSBjYy5Qb2tlclV0aWwuaXNTYW5Ub25nSHVhIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgc3ByaXRlUzpjYy5TcHJpdGVGcmFtZSxcclxuICAgICAgICAgICAgc3ByaXRlWTpjYy5TcHJpdGVGcmFtZSxcclxuICAgICAgICAgICAgc3ByaXRlUDpjYy5TcHJpdGVGcmFtZSxcclxuICAgICAgICAgICAgaWNvbjpjYy5TcHJpdGUsXHJcbiAgICAgICAgICAgIHJvb21pZDpjYy5MYWJlbCxcclxuICAgICAgICAgICAgbXlTY29yZTpjYy5MYWJlbCxcclxuICAgICAgICAgICAgcGxheWVyXzE6Y2MuTGFiZWwsXHJcbiAgICAgICAgICAgIHBsYXllcl8yOmNjLkxhYmVsLFxyXG4gICAgICAgICAgICBwbGF5ZXJfMzpjYy5MYWJlbCxcclxuICAgICAgICAgICAgcGxheWVyXzQ6Y2MuTGFiZWwsXHJcbiAgICAgICAgICAgIHRpbWU6Y2MuTGFiZWxcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldERhdGEgOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICB0aGlzLnJvb21pZC5zdHJpbmcgPSBkYXRhLnJvb21pZC50b1N0cmluZygpXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnJhbmsgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVNjb3JlLm5vZGUuY29sb3IgPSAgY2MuQ29sb3IuV0hJVEVcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuc3ByaXRlUFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZGF0YS5yYW5rID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVNjb3JlLm5vZGUuY29sb3IgPSBjYy5Db2xvci5ZRUxMT1dcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuc3ByaXRlWVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVNjb3JlLm5vZGUuY29sb3IgPSBjYy5Db2xvci5SRURcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuc3ByaXRlU1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXlTY29yZS5zdHJpbmcgPSAnXFxuJytkYXRhLnJhbmtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gNDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5vcHBzLmxlbmd0aCA+PSBpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGRhdGEub3Bwc1tpLTFdXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcInBsYXllcl9cIiArIGkudG9TdHJpbmcoKV0uc3RyaW5nID0gb3AubmFtZS5jb25jYXQoJ1xcbicsb3AucmFuay50b1N0cmluZygpLCdcXG4nLG9wLmN1aWQudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW1wicGxheWVyX1wiICsgaS50b1N0cmluZygpXS5zdHJpbmcgPSBcIuaXoFwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0YS50aW1lKjEwMDApXHJcbiAgICAgICAgICAgIHRoaXMudGltZS5zdHJpbmcgPSBkYXRlLkZvcm1hdChcInl5eXktTU0tZGRcXG5oaDptbTpzc1wiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgTSA9IGNjLkNsYXNzKHtcclxuXHJcbiAgICBpc1Bva2VyR2FtZVNjZW5lIDogZnVuY3Rpb24oKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZSA9PSBcIlBva2VyR2FtZVwiXHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRTY2VuZTpmdW5jdGlvbihuYW1lLGNhbGwpe1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAhPSBuYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5jbG9zZUFsbCgpXHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbignVUlMb2FkaW5nJyxmdW5jdGlvbihwYW5lbCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9hZFNjZW5lQ2FsbCA9IGNhbGxcclxuICAgICAgICAgICAgICAgIHZhciBzY2VuZU5hbWUgPSBuYW1lXHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoc2NlbmVOYW1lLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRTY2VuZUNhbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRTY2VuZUNhbGwoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gbmFtZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbG9hZE1haW5TY2VuZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzY2VuZVNlbGYgPSB0aGlzXHJcbiAgICAgICAgdGhpcy5sb2FkU2NlbmUoJ01haW4nLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNjLmxvZygnbG9hZE1haW5TY2VuZScpXHJcbiAgICAgICAgICAgIGlmIChjYy5nYW1lbWFuYWdlci5yb29tX2luZm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLmdhbWVtYW5hZ2VyLmdhbWVTdGFydCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coXCJvcGVuIFVJTWFpblwiKVxyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBzY2VuZVNlbGZcclxuICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbignVUlNYWluJyxmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFmdGVyU2NlbmVMb2FkKClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgbG9hZExvZ2luU2NlbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5sb2coJ2xvYWRsb2dpbicpO1xyXG4gICAgICAgIHZhciBzY2VuZVNlbGYgPSB0aGlzXHJcbiAgICAgICAgdGhpcy5sb2FkU2NlbmUoJ0xvZ2luJyxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNjZW5lU2VsZlxyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm9wZW4oJ1VJTG9naW4nLGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5hZnRlclNjZW5lTG9hZCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZFBva2VyR2FtZVNjZW5lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MubG9nKFwiTG9hZFBva2VyR2FtZVNjZW5lXCIpO1xyXG4gICAgICAgIHZhciBzY2VuZVNlbGYgPSB0aGlzXHJcbiAgICAgICAgdGhpcy5sb2FkU2NlbmUoXCJQb2tlckdhbWVcIiwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSBzY2VuZVNlbGZcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5vcGVuKFwiVUlQb2tlckdhbWVcIixmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuYWZ0ZXJTY2VuZUxvYWQoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWZ0ZXJTY2VuZUxvYWQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLmNsb3NlQnlOYW1lKCdVSUxvYWRpbmcnKVxyXG4gICAgfVxyXG59KTtcclxuXHJcbmNjLnNjZW5lbWFuYWdlciA9IG5ldyBNKCkiLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgc2NvcmVMYWJlbDogY2MuTGFiZWwsXHJcbiAgICAgICAgc21Kc1BhbmVsOiBjYy5QcmVmYWIsXHJcbiAgICAgICAgc3BlY2lhbEpzUGFuZWw6IGNjLlByZWZhYixcclxuICAgICAgICBsYWJlbDogY2MuTGFiZWwsXHJcbiAgICAgICAgdGltZWNkOiBjYy5SaWNoVGV4dCxcclxuICAgICAgICBjb250YWluZXI6IGNjLk5vZGUsXHJcbiAgICAgICAgbWF0Y2g6IGNjLkxhYmVsLFxyXG4gICAgICAgIHRpdGxlSW1nOiBjYy5Ob2RlLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vdGhpcy5zY29yZUxhYmVsLnN0cmluZyA9IHRoaXMuZ2V0Tm93Rm9ybWF0RGF0ZSgpLnRvU3RyaW5nKClcclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwuc3RyaW5nID0gXCLmiL/pl7Tlj7fvvJpcIiArIGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5yb29tX2lkLnRvU3RyaW5nKClcclxuXHJcbiAgICAgICAgdGhpcy5jZCA9IDMwXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLnJ1bkFjdGlvbihjYy5yZXBlYXRGb3JldmVyKGNjLnNlcXVlbmNlKGNjLmRlbGF5VGltZSgxLjApLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQsIHBhcmFtKXtcclxuICAgICAgICAgICAgcGFyYW0uY2QgPSBwYXJhbS5jZCAtIDFcclxuXHJcbiAgICAgICAgICAgIHZhciByb29tQXR0cj0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHJcclxuICAgICAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMgPj0gcm9vbUF0dHIucm91bmRzKXtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnRpbWVjZC5zdHJpbmcgPSBcIjxjb2xvcj0jRkYwMDAwPlwiICsgcGFyYW0uY2QudG9TdHJpbmcoKSArIFwiPC9jPuenkuWQjuaYvuekuuaAu+e7k+eul1wiXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcGFyYW0udGltZWNkLnN0cmluZyA9IFwiPGNvbG9yPSNGRjAwMDA+XCIgKyBwYXJhbS5jZC50b1N0cmluZygpICsgXCI8L2M+56eS5ZCO6Ieq5Yqo5byA5aeL5LiL5LiA5bGAXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihwYXJhbS5jZCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIHBhcmFtLm5leHRNYXRjaCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLCB0aGlzKSkpKVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXROb3dGb3JtYXREYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICDCoMKgwqDCoHZhciBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgIMKgwqDCoMKgdmFyIHNlcGVyYXRvcjEgPSBcIi1cIjtcclxuICAgIMKgwqDCoMKgdmFyIHNlcGVyYXRvcjIgPSBcIjpcIjtcclxuICAgIMKgwqDCoMKgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcclxuICAgIMKgwqDCoMKgdmFyIHN0ckRhdGUgPSBkYXRlLmdldERhdGUoKTtcclxuICAgIMKgwqDCoMKgaWYgKG1vbnRoID49IDEgJiYgbW9udGggPD0gOSkge1xyXG4gICAgwqDCoMKgwqDCoMKgwqDCoG1vbnRoID0gXCIwXCIgKyBtb250aDtcclxuICAgIMKgwqDCoMKgfVxyXG4gICAgwqDCoMKgwqBpZiAoc3RyRGF0ZSA+PSAwICYmIHN0ckRhdGUgPD0gOSkge1xyXG4gICAgwqDCoMKgwqDCoMKgwqDCoHN0ckRhdGUgPSBcIjBcIiArIHN0ckRhdGU7XHJcbiAgICDCoMKgwqDCoH1cclxuICAgIMKgwqDCoMKgdmFyIGN1cnJlbnRkYXRlID0gZGF0ZS5nZXRGdWxsWWVhcigpICsgc2VwZXJhdG9yMSArIG1vbnRoICsgc2VwZXJhdG9yMSArIHN0ckRhdGVcclxuICAgIMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoCsgXCIgXCIgKyBkYXRlLmdldEhvdXJzKCkgKyBzZXBlcmF0b3IyICsgZGF0ZS5nZXRNaW51dGVzKClcclxuICAgIMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoCsgc2VwZXJhdG9yMiArIGRhdGUuZ2V0U2Vjb25kcygpO1xyXG4gICAgwqDCoMKgwqByZXR1cm4gY3VycmVudGRhdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGluZGF0YSl7XHJcblxyXG4gICAgICAgIHZhciBBbGxIYW5kc0RhdGEgPSBpbmRhdGEuc2VydmVyZGF0YVxyXG4gICAgICAgIHZhciBzY29yZVN1bW1hcnkgPSBpbmRhdGEuY2xpZW50ZGF0YVxyXG5cclxuICAgICAgICB2YXIgc2VsZkRhdGEgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YTtcclxuXHJcbiAgICAgICAgLy92YXIgY29udGFpbmVyID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiY29udGFpbmVyXCIpXHJcbiAgICAgICAgdmFyIHBsYXllck51bSA9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplXHJcbiAgICAgICAgLy92YXIgcG9zZXMgPSBjYy5jb25maWdtYW5hZ2VyLnN1bW1hcnlwb3NbcGxheWVyTnVtLTJdXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBsYXllck51bTsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBudWxsXHJcbiAgICAgICAgICAgIGlmKEFsbEhhbmRzRGF0YVtpXS5zcGVjLmJyYW5kICE9IDApe1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMuc3BlY2lhbEpzUGFuZWwpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMuc21Kc1BhbmVsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG5vZGUpe1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IGNjLnYyKDAsMClcclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KFwic21Kc1BhbmVsXCIpLmluaXRDYXJkKEFsbEhhbmRzRGF0YVtpXSwgc2NvcmVTdW1tYXJ5W2ldKVxyXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzLmNvbnRhaW5lclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vbm9kZS5wb3NpdGlvbiA9IHBvc2VzW2ldXHJcblxyXG4gICAgICAgICAgICBpZihBbGxIYW5kc0RhdGFbaV0uY3VpZC5lcShzZWxmRGF0YS5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICBpZihBbGxIYW5kc0RhdGFbaV0ucmFuayA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKFwiVGV4dHVyZXMvc2luZ2xld2luXCIsIHRoaXMudGl0bGVJbWcpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihBbGxIYW5kc0RhdGFbaV0ucmFuayA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKFwiVGV4dHVyZXMvc2luZ2xlbG9zZVwiLCB0aGlzLnRpdGxlSW1nKVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy9zaW5nbGVwalwiLCB0aGlzLnRpdGxlSW1nKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3ZhciBzY2FsZSA9IGNjLnZpZXcuZ2V0RnJhbWVTaXplKCkud2lkdGggLyAoMS44KmNjLnZpZXcuZ2V0RnJhbWVTaXplKCkuaGVpZ2h0KVxyXG4gICAgICAgIC8vY29udGFpbmVyLnNjYWxlID0gc2NhbGVcclxuXHJcbiAgICAgICAgdGhpcy5tYXRjaC5zdHJpbmcgPSBcIuesrFwiICsgY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMudG9TdHJpbmcoKSArIFwi5bGAXCJcclxuICAgICAgICBpZihjYy5nYW1lbWFuYWdlci5fY3VycmVudFJvdW5kcyA+PSBjYy5nYW1lbWFuYWdlci5yb29tX2luZm8uYXR0ci5yb3VuZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsLnN0cmluZyA9IFwi5oC757uT566XXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNoYXJlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbignVUlTaGFyZScsZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRUeXBlKDEpICAgXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgbmV4dE1hdGNoOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciByb29tQXR0cj0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHJcclxuICAgICAgICB2YXIgcGdhbWUgPSBjYy5maW5kKFwiVUlQb2tlckdhbWVcIikuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIilcclxuXHJcbiAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMgPj0gcm9vbUF0dHIucm91bmRzKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKVxyXG5cclxuICAgICAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuaXNQcmFjdGljZVJvb20oKSl7XHJcbiAgICAgICAgICAgICAgICAvL+e7g+S5oOWcuuimgeaooeaLn+WPkemAgeaAu+e7k+eul+a2iOaBr1xyXG4gICAgICAgICAgICAgICAgY2Mucm9ib3Quc2VuZEFsbFJvdW5kc1N1bW1hcnkoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBnYW1lLnNob3dHYW1lUmVzdWx0KClcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKVxyXG5cclxuICAgICAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuaXNQcmFjdGljZVJvb20oKSl7XHJcbiAgICAgICAgICAgICAgICAvL+e7g+S5oOWcuuimgeaooeaLn+WPkemAgeS4i+S4gOWxgOeJjOS/oeaBr1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdW5kID0gY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMgKyAxXHJcbiAgICAgICAgICAgICAgICBjYy5yb2JvdC5zZW5kUGxheWVySW5Sb29tKHJvdW5kLCAzLCAzKVxyXG4gICAgICAgICAgICAgICAgY2Mucm9ib3Quc2VuZEhhbmRsZU9mTWluZShyb3VuZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy5nYW1lbWFuYWdlci5uZXh0TWF0Y2goKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjb3JlOiBmdW5jdGlvbihzY29yZSl7XHJcbiAgICAgICAgLy90aGlzLnNjb3JlTGFiZWwuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBzY29yZS50b1N0cmluZygpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICBkaXNjb3VudDpjYy5Ob2RlLFxyXG4gICAgICAgZGlzY291bnRUZXh0OmNjLkxhYmVsLFxyXG4gICAgICAgaW1nOmNjLlNwcml0ZSxcclxuICAgICAgIG1vbmV5VGV4dDpjYy5MYWJlbCxcclxuICAgICAgIGRpYW1vbmRUZXh0OmNjLkxhYmVsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vZGlhbW9uIGRpc2NvdW50IHByaWNlIGlkIGltYWdlXHJcbiAgICBzZXREYXRhOmZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgIHRoaXMuaXRlbURhdGEgPSBkYXRhXHJcbiAgICAgICAgdGhpcy5kaWFtb25kVGV4dC5zdHJpbmcgPSBTdHJpbmcoZGF0YS5kaWFtb25kKVxyXG4gICAgICAgIGlmIChkYXRhLmRpc2NvdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY291bnQuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICB0aGlzLmRpc2NvdW50VGV4dC5zdHJpbmcgPSAn5YaF6LWgezB9JScuZm9ybWF0KGRhdGEuZGlzY291bnQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRhdGEuZGlzY291bnQuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9uZXlUZXh0LnN0cmluZyA9IFN0cmluZyhkYXRhLnByaWNlKVxyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKCdUZXh0dXJlcy8nICsgZGF0YS5pbWFnZSxjYy5TcHJpdGVGcmFtZSxmdW5jdGlvbihlcnIsc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICB0aGlzLmltZy5zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgYnV5OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8vIHRoaXMuaXRlbURhdGEuaWRcclxuICAgICAgICAvL1RPRE866LSt5LmwXHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxucmVxdWlyZSgnVUlQYW5lbCcpXHJcblxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBjaGF0UGFnZTpjYy5Ob2RlLFxyXG4gICAgICAgIGZhY2VQYWdlOmNjLk5vZGUsXHJcbiAgICAgICAgY2hhdEJhY2s6Y2MuTm9kZSxcclxuICAgICAgICBlZGl0Qm94OmNjLkVkaXRCb3gsXHJcbiAgICAgICAgY2hhdENvbnRlbnQ6Y2MuTm9kZVxyXG4gICAgfSxcclxuXHJcbiAgICBcclxuICAgIG9uVG91Y2hCZzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSlcclxuICAgIH0sXHJcblxyXG4gICAgb25DcmVhdGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICB0aGlzLmNoYXRCYWNrLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJULGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbkltbWVkaWF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKCdHdWkvV2lkZ2V0L0NoYXRTcGxpdCcsZnVuY3Rpb24oZXJyLHNwbGl0UHJlZmFiKXtcclxuICAgICAgICAgICAgc2VsZi5zcGxpdFByZWZhYiAgPSBzcGxpdFByZWZhYlxyXG4gICAgICAgICAgICBjYy5sb2FkZXIubG9hZFJlcygnR3VpL1dpZGdldC9DaGF0SXRlbScsZnVuY3Rpb24oZXJyLGNoYXRJdGVtUHJlZmFiKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuY2hhdEl0ZW1QcmVmYWIgPSBjaGF0SXRlbVByZWZhYlxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsb3NlOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNwbGl0UHJlZmFiKVxyXG4gICAgICAgICAgICBjYy5sb2FkZXIucmVsZWFzZUFzc2V0KHRoaXMuc3BsaXRQcmVmYWIpXHJcbiAgICAgICAgaWYgKHRoaXMuY2hhdEl0ZW1QcmVmYWIpXHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5yZWxlYXNlQXNzZXQodGhpcy5jaGF0SXRlbVByZWZhYilcclxuICAgICAgICB0aGlzLl9zdXBlcigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc1JlYWR5IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRQcmVmYWIgJiYgdGhpcy5jaGF0SXRlbVByZWZhYlxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYWNrQ2hhdHBhZ2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNoYXRQYWdlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLmZhY2VQYWdlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgb25DaGVja0ZhY2VwYWdlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jaGF0UGFnZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMuZmFjZVBhZ2UuYWN0aXZlID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICBwb3BCdWxsZXQgOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIHZhciBwYW5lbCA9IGNjLmd1aW1hbmFnZXIuZ2V0QnlOYW1lKCdVSVBva2VyR2FtZScpXHJcbiAgICAgICAgaWYgKHBhbmVsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MubG9nKCd0ZXN0JylcclxuICAgICAgICAgICAgcGFuZWwuc2hvd0NoYXQoY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEuY3VpZCxtc2cpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSlcclxuICAgIH0sXHJcbiAgICBzZW5kQ2hhdDpmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5lZGl0Qm94LnN0cmluZ1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZyhcIlB1YmxpY1Byb3RvLkNfU2VuZENoYXRcIilcclxuICAgICAgICAgICAgbXNnLnR5cGUgID0gMFxyXG4gICAgICAgICAgICBtc2cuZGF0YV90ZXh0ID0gc3RyXHJcbiAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIuc2VuZChtc2cpXHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZENoYXQoY2MuZ2FtZW1hbmFnZXIubWFpblBsYXllcigpLHN0cilcclxuICAgICAgICAgICAgdGhpcy5lZGl0Qm94LnN0cmluZyA9IFwiXCJcclxuICAgICAgICAgICAgdGhpcy5wb3BCdWxsZXQobXNnKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQ2hhdDpmdW5jdGlvbihwbGF5ZXIsdGV4dCl7XHJcbiAgICAgICAgaWYgKHBsYXllciAmJiB0aGlzLmlzUmVhZHkoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8v5re75Yqg5Yiw6IGK5aSp5YiX6KGoXHJcbiAgICAgICAgICAgdmFyIHNwbGl0ID0gY2MuaW5zdGFudGlhdGUodGhpcy5zcGxpdFByZWZhYik7IFxyXG4gICAgICAgICAgIHZhciBpdGVtICA9IGNjLmluc3RhbnRpYXRlKHRoaXMuY2hhdEl0ZW1QcmVmYWIpO1xyXG4gICAgICAgICAgIHZhciBzdHIgPSAnPGNvbG9yPSMwMGZmMDA+Jy5jb25jYXQocGxheWVyLm5hbWUgLCAnOjwvYz48Y29sb3I9I2ZmZWZiZT4nICwgdGV4dCAsICc8L2M+JylcclxuICAgICAgICAgICBpdGVtLmdldENvbXBvbmVudChjYy5SaWNoVGV4dCkuc3RyaW5nID0gc3RyXHJcbiAgICAgICAgICAgaXRlbS5wYXJlbnQgPSB0aGlzLmNoYXRDb250ZW50XHJcbiAgICAgICAgICAgaXRlbS5wb3NpdGlvbiA9IGNjLnAoMTEsMTIpXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgc3BsaXQucGFyZW50ID0gdGhpcy5jaGF0Q29udGVudFxyXG4gICAgICAgICAgIHNwbGl0LnBvc2l0aW9uID0gY2MucCgyMTksMSlcclxuICAgICAgICAgIH0gXHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfQ2hhdCA6IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIGlmIChtc2cuY29udGVudC50eXBlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGxheWVyID0gY2MuZ2FtZW1hbmFnZXIuZ2V0UGxheWVyKG1zZy5jdWlkKSAgXHJcbiAgICAgICAgICAgIGlmIChwbGF5ZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hhdChwbGF5ZXIsbXNnLmNvbnRlbnQuZGF0YV90ZXh0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZW5kRmFjZTpmdW5jdGlvbihldmVudCxpZCkge1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZyhcIlB1YmxpY1Byb3RvLkNfU2VuZENoYXRcIilcclxuICAgICAgICBtc2cudHlwZSAgPSAxXHJcbiAgICAgICAgbXNnLmRhdGFfaW50ID0gcGFyc2VJbnQoaWQpXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuXHJcbiAgICAgICAgdGhpcy5wb3BCdWxsZXQobXNnKVxyXG4gICAgfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBjcmVhdGVCdG4gOmNjLkJ1dHRvbixcclxuICAgICAgICBxdWFubGVpZGFUb2dnbGUgOiBjYy5Ub2dnbGUsXHJcbiAgICAgICAgZml2ZVBsYXllcjpjYy5Ub2dnbGUsXHJcbiAgICAgICAgZ2FtZUxhYmVsOmNjLkxhYmVsLFxyXG4gICAgICAgIHJvdW5kTm9kZTpjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ3JlYXRlOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYmdPcGFxdWUgPSAyMzBcclxuICAgICAgICB0aGlzLmluaXQoKTsgXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZXR0aW5nID0gY2MuZGF0YW1hbmFnZXIuZ2V0Um9vbVNldHRpbmcoKVxyXG4gICAgICAgIGlmICghc2V0dGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8v6buY6K6k6K6+572uXHJcbiAgICAgICAgICAgIHZhciB2ID0gY2MuZGF0YW1hbmFnZXIubWFpbkRhdGEucHJpY2VfbGlzdFswXVxyXG4gICAgICAgICAgICBpZiAoIXYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHYgPSBcIjEwXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHYgPSBTdHJpbmcodi5yb3VuZHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dGluZyA9IHtcclxuICAgICAgICAgICAgICAgIGlzUXVhbkxlaURhIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjaGVja3MgOiBbW1wiMFwiLFwiMFwiLFwiNTJcIl0sW1wiMVwiLFwiMFwiLHZdLFtcIjJcIixcIjBcIixcIjEwXCJdLFtcIjNcIixcIjBcIixcIjNcIl0sW1wiNFwiLFwiMFwiLFwiMVwiXSxbXCI1XCIsXCIxXCIsXCI0XCJdXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm9vbVNldHRpbmcgPSBzZXR0aW5nXHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihjYy5Ub2dnbGVHcm91cClcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGdyb3Vwc1tpXS50b2dnbGVJdGVtc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChzZXR0aW5nLmNoZWNrc1tpXVsxXSlcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IGl0ZW1zW2pdLm5vZGUubmFtZSA9PSAndG9nZ2xlJyArIChpbmRleCArIDEpXHJcbiAgICAgICAgICAgICAgICBpdGVtc1tqXS5pc0NoZWNrZWQgPSBjaGVja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTW9uZXkoKVxyXG4gICAgICAgIHRoaXMucXVhbmxlaWRhVG9nZ2xlLmlzQ2hlY2tlZCA9IHNldHRpbmcuaXNRdWFuTGVpRGFcclxuICAgICAgICB0aGlzLm9uR2FtZVR5cGVDaGFuZ2UodGhpcy5yb29tU2V0dGluZy5jaGVja3NbMF1bMV0gPT0gMSlcclxuICAgIH0sXHJcblxyXG4gICAgYWN0aXZlRml2ZVBsYXllcjpmdW5jdGlvbihiQWN0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5maXZlUGxheWVyLm5vZGUuYWN0aXZlID0gYkFjdGl2ZVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkdhbWVUeXBlQ2hhbmdlOmZ1bmN0aW9uKHNwZWNpYWwpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUZpdmVQbGF5ZXIoc3BlY2lhbClcclxuICAgICAgICBpZiAoIXNwZWNpYWwgJiYgdGhpcy5yb29tU2V0dGluZy5jaGVja3NbNV1bMV0gPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzVdWzFdID0gMVxyXG4gICAgICAgICAgICB0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1s1XVsyXSA9IDRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcGVjaWFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lTGFiZWwuc3RyaW5nID0gJzUy5byg54mM77yINOiJskEtS+WNgeS4ieW8oO+8iSdcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lTGFiZWwuc3RyaW5nID0gJzY15byg54mMICg06Imy54mM5YqgMeiJsum7keahg+eJjEEtSyknXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVNb25leSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJpY2UgPSBjYy5kYXRhbWFuYWdlci5tYWluRGF0YS5wcmljZV9saXN0XHJcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5yb3VuZE5vZGUuY2hpbGRyZW5Db3VudFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgcHJpY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm91bmROb2RlLmNoaWxkcmVuW2ldIFxyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCJcclxuICAgICAgICAgICAgICAgIHZhciBtb25leSA9IHByaWNlW2ldLm1vbmV5XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb29tU2V0dGluZy5jaGVja3NbMl1bMl0gPT0gXCIxMFwiIHx8IHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzJdWzJdID09IFwiMTJcIiApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9uZXkgPSBtb25leSAqIHBhcnNlSW50KHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzVdWzJdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0Q29tcG9uZW50KGNjLlRvZ2dsZSkuaXNDaGVja2VkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICc8Y29sb3I9I0ZGRkZGRj4nLmNvbmNhdChTdHJpbmcocHJpY2VbaV0ucm91bmRzKSwn5bGAKCcsU3RyaW5nKG1vbmV5KSwn6ZK7KSAgICAgICAgICA8L2M+JylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnPGNvbG9yPSM4OEEyQzM+Jy5jb25jYXQoU3RyaW5nKHByaWNlW2ldLnJvdW5kcyksJ+WxgCgnLFN0cmluZyhtb25leSksJ+mSuykgICAgICAgICAgPC9jPicpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBub2RlLmdldENoaWxkQnlOYW1lKCdsYWJlbCcpLmdldENvbXBvbmVudChjYy5SaWNoVGV4dClcclxuICAgICAgICAgICAgICAgIG1zZy5zdHJpbmcgPSBzdHJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25DaGVjazpmdW5jdGlvbih0b2dnbGUscGFyYW0pIHtcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheVNGWChcImNsaWNrXCIpXHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdG9nZ2xlLnRvZ2dsZUdyb3VwLnRvZ2dsZUl0ZW1zXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRvZ2dsZSA9IGl0ZW1zW2ldXHJcbiAgICAgICAgICAgIGlmICh0b2dnbGUuaXNDaGVja2VkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RycyA9IHBhcmFtLnNwbGl0KCcsJylcclxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBwYXJzZUludChzdHJzWzBdKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb29tU2V0dGluZy5jaGVja3Nbcm93XSA9IHN0cnNcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHN0cnNbMV0pXHJcbiAgICAgICAgICAgICAgICBpZiAocm93ID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkdhbWVUeXBlQ2hhbmdlKGluZGV4ID09IDEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3cgPT0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgIHN0cnNbMl0gPSBTdHJpbmcoY2MuZGF0YW1hbmFnZXIubWFpbkRhdGEucHJpY2VfbGlzdFtpbmRleF0ucm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5yb29tU2V0dGluZy5jaGVja3Nbcm93XSA9IHN0cnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdyA9PSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNb25leSgpIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93ID09IDUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGVja1F1YW5MZWlEYSh0aGlzLnF1YW5sZWlkYVRvZ2dsZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1vbmV5KClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gdG9nZ2xlLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoJ2xhYmVsJykuZ2V0Q29tcG9uZW50KGNjLlJpY2hUZXh0KVxyXG4gICAgICAgICAgICB2YXIgc3RyID0gbGFiZWwuc3RyaW5nLnJlcGxhY2UoL1xcI1swLTlBLUZhLWZdKi8sdG9nZ2xlLmlzQ2hlY2tlZCA/ICcjRkZGRkZGJyA6ICcjODhBMkMzJylcclxuICAgICAgICAgICAgbGFiZWwuc3RyaW5nID0gc3RyXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoZWNrUXVhbkxlaURhOmZ1bmN0aW9uKHRvZ2dsZSl7XHJcbiAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJjbGlja1wiKVxyXG4gICAgICAgIGlmICh0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1s1XVsxXSA9PSAzKVxyXG4gICAgICAgICAgICB0b2dnbGUuaXNDaGVja2VkID0gZmFsc2VcclxuICAgICAgICB0aGlzLnJvb21TZXR0aW5nLmlzUXVhbkxlaURhID0gdG9nZ2xlLmlzQ2hlY2tlZFxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNyZWF0ZVJvb206ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coJ1B1YmxpY1Byb3RvLkNfRzEzX0NyZWF0ZUdhbWUnKVxyXG4gICAgICAgIG1zZy5wbGF5X3R5cGUgICAgID0gcGFyc2VJbnQodGhpcy5yb29tU2V0dGluZy5jaGVja3NbMF1bMl0pXHJcbiAgICAgICAgbXNnLnJvdW5kcyAgICAgICAgPSBwYXJzZUludCh0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1sxXVsyXSlcclxuICAgICAgICBtc2cucGF5b3IgICAgICAgICA9IHBhcnNlSW50KHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzJdWzJdKVxyXG4gICAgICAgIG1zZy5kYV9xaWFuZyAgICAgID0gcGFyc2VJbnQodGhpcy5yb29tU2V0dGluZy5jaGVja3NbM11bMl0pXHJcbiAgICAgICAgbXNnLnlpX3RpYW9fbG9uZyAgPSBwYXJzZUludCh0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1s0XVsyXSlcclxuICAgICAgICBtc2cucGxheWVyX3NpemUgICA9IHBhcnNlSW50KHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzVdWzJdKVxyXG4gICAgICAgIG1zZy5xdWFuX2xlaV9kYSAgID0gdGhpcy5yb29tU2V0dGluZy5pc1F1YW5MZWlEYVxyXG5cclxuICAgICAgICBjYy5sb2coXCJtc2cucGxheV90eXBlOlwiICsgbXNnLnBsYXlfdHlwZSlcclxuICAgICAgICBjYy5sb2coXCJtc2cueWlfdGlhb19sb25nOlwiICsgbXNnLnlpX3RpYW9fbG9uZylcclxuICAgICAgICBjYy5sb2coXCJtc2cucXVhbl9sZWlfZGE6XCIgKyBtc2cucXVhbl9sZWlfZGEpXHJcblxyXG4gICAgICAgIGNjLmxvZygncGFyYW06dGhpcy5yb29tU2V0dGluZy5jaGVja3NbMF06JyArIHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzBdKVxyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIuc2VuZChtc2cpXHJcbiAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2F2ZVJvb21TZXR0aW5nKHRoaXMucm9vbVNldHRpbmcpXHJcbiAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX1Jvb21BdHRyOmZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIGlmIChtc2cucm9vbV9jb2RlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1RPRE865Yib5bu65aSx6LSlXHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB9KTtcclxuIiwiXHJcbnJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICB3ZWl4aW5MYWJlbF8wIDogY2MuTGFiZWwsXHJcbiAgICAgICAgd2VpeGluTGFiZWxfMSA6IGNjLkxhYmVsLFxyXG4gICAgICAgIHdlaXhpbkxhYmVsXzIgOiBjYy5MYWJlbCxcclxuICAgIH0sXHJcblxyXG4gICAgb25DcmVhdGUgOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0aGlzLndlaXhpbkxhYmVscyA9IFt0aGlzLndlaXhpbkxhYmVsXzAsdGhpcy53ZWl4aW5MYWJlbF8xLHRoaXMud2VpeGluTGFiZWxfMl1cclxuICAgICAgICB0aGlzLndlaXhpbk51bXMgPSBbY2MuZGF0YW1hbmFnZXIubWFpbkRhdGEud2VjaGF0MSxjYy5kYXRhbWFuYWdlci5tYWluRGF0YS53ZWNoYXQyLGNjLmRhdGFtYW5hZ2VyLm1haW5EYXRhLndlY2hhdDNdXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53ZWl4aW5MYWJlbHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLndlaXhpbkxhYmVsc1tpXS5zdHJpbmcgPSB0aGlzLndlaXhpbk51bXNbaV1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5IDogZnVuY3Rpb24oZXZlbnQsc3RySWQpe1xyXG4gICAgICAgIGNjLmRhdGFtYW5hZ2VyLmNvcHlUb0NsaXBib2FyZCh0aGlzLndlaXhpbk51bXNbcGFyc2VJbnQoc3RySWQpXSkgXHJcbiAgICB9XHJcbn0pXHJcblxyXG4iLCJcclxucmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgIFxyXG4gICAgfSxcclxuXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICBidG5DbG9zZTpjYy5CdXR0b24sXHJcbiAgICAgICBidG5Db21maXJlOmNjLkJ1dHRvbixcclxuICAgICAgIHNwQ3Vyc29yOmNjLk5vZGUsXHJcbiAgICAgICBjdXJJbmRleDowXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICB1cGRhdGVDdXJzb3I6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAodGhpcy5jdXJJbmRleCA8IDApIHRoaXMuY3VySW5kZXggPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmN1ckluZGV4IDwgNilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb29tID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdyb29taWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zcEN1cnNvci5wYXJlbnQgPSByb29tLmNoaWxkcmVuW3RoaXMuY3VySW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLnNwQ3Vyc29yLnBvc2l0aW9uID0gY2MucCgwLDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmJ0bkNsb3NlLmludGVyYWN0YWJsZSA9IHRoaXMuaXNmdWxsKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRWYWx1ZTpmdW5jdGlvbihub2RlKXtcclxuICAgICAgICByZXR1cm4gbm9kZS5nZXRDaGlsZEJ5TmFtZSgnbnVtJykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmdcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFJvb21JRDpmdW5jdGlvbigpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJvb20gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoJ3Jvb21pZCcpO1xyXG4gICAgICAgIHZhciBjcyA9IHJvb20uY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGlkcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vbS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZHNbaV0gPSB0aGlzLmdldFZhbHVlKGNzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlkcy5qb2luKFwiXCIpKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldFZhbHVlOmZ1bmN0aW9uKG5vZGUsc3RyKXtcclxuICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKCdudW0nKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHN0cjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldEN1ckluZGV4VmFsdWU6ZnVuY3Rpb24oc3RyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pc2Z1bGwoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb29tID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdyb29taWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShyb29tLmNoaWxkcmVuW3RoaXMuY3VySW5kZXhdLHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaXNmdWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VySW5kZXggPT0gNjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlc2V0VmFsdWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcm9vbSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSgncm9vbWlkJyk7XHJcbiAgICAgICAgdmFyIGNzID0gcm9vbS5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VySW5kZXg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoY3NbaV0sXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VySW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBkZWxldGVWYWx1ZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1ckluZGV4ID49IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAtLXRoaXMuY3VySW5kZXg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckluZGV4IDwgMCkgdGhpcy5jdXJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VySW5kZXhWYWx1ZShcIlwiKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbnB1dFZhbHVlIDogZnVuY3Rpb24obnVtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzZnVsbCgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJJbmRleFZhbHVlKG51bSk7XHJcbiAgICAgICAgICAgICsrdGhpcy5jdXJJbmRleDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgdmFyIGtleWJvYXJkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdrZXlib2FyZCcpO1xyXG4gICAgICAgdmFyIGNzID0ga2V5Ym9hcmQuY2hpbGRyZW47XHJcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleWJvYXJkLmNoaWxkcmVuQ291bnQ7KytpKVxyXG4gICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYnRuID0gY3NbaV0uZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbik7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgYnRuLm5vZGUub24oJ2NsaWNrJyxmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcImJ0bl9yZXNldFwiKVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2V0VmFsdWUoKTsgICAgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PSBcImJ0bl9kZWxldGVcIilcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuZGVsZXRlVmFsdWUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dFZhbHVlKG5vZGUuZ2V0Q2hpbGRCeU5hbWUoJ251bScpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ0bkNsb3NlLmludGVyYWN0YWJsZSA9IHRoaXMuaXNmdWxsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xpY2tfYnRuQ2xvc2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbmNsaWNrX2J0bkNvbWZpcmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKCdQdWJsaWNQcm90by5DX0cxM19KaW9uR2FtZScpXHJcbiAgICAgICAgbXNnLnJvb21faWQgPSB0aGlzLmdldFJvb21JRCgpXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICBjb25zb2xlLmxvZygncmVxdWlyZSBqb2luIHJvb206JyArIG1zZy5yb29tX2lkKTtcclxuICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBvbkNyZWF0ZSA6IGZ1bmN0aW9uKCkgIHtcclxuICAgICAgICB0aGlzLmJnT3BhcXVlID0gMjU1XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfVxyXG59KTtcclxuIiwicmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGJ0bldYTG9naW46Y2MuQnV0dG9uLFxyXG4gICAgICAgIGJ0bkd1ZXN0TG9naW46Y2MuQnV0dG9uLFxyXG5cclxuICAgICAgICBwcmVmYWJTdW1tYXJ5OiBjYy5QcmVmYWIsXHJcbiAgICAgICAgdHh0VmVyc2lvbjpjYy5MYWJlbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNjLmNvbmZpZ21hbmFnZXIudGVzdENsaWVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHh0VmVyc2lvbi5zdHJpbmcgPSBjYy5jb25maWdtYW5hZ2VyLnZlcnNpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50eHRWZXJzaW9uLnN0cmluZyA9IGNjLmNvbmZpZ21hbmFnZXIudmVyc2lvblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNjLnN5cy5pc01vYmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuV1hMb2dpbi5ub2RlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghY2MubmV0bWFuYWdlci5zZXJ2ZXJJbmZvLmFwcGxlX3JldmlldylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idG5HdWVzdExvZ2luLm5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYy5uZXRtYW5hZ2VyLmlzV1hJbnN0YWxsKCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idG5HdWVzdExvZ2luLm5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ0bldYTG9naW4ubm9kZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5QkdNKCdiYWNrZ3JvdW5kJylcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2MubmV0bWFuYWdlci5pc1dYSW5zdGFsbCgpICYmIGNjLm5ldG1hbmFnZXIuY2hlY2tXZWl4aW4oKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubG9naW4oMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG5cclxuLypcclxuICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiU3VtbWFyeSlcclxuICAgICAgICBub2RlLnBhcmVudCA9IHRoaXMubm9kZVxyXG4gICAgICAgIG5vZGUucG9zaXRpb24gPSBjYy52MigwLCAwKTsgXHJcblxyXG5cclxuICAgICAgICB2YXIgY29tID0gbm9kZS5nZXRDb21wb25lbnQoXCJTY29yZVN1bW1hcnlcIilcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZS5nZXRDaGlsZEJ5TmFtZShcImNvbnRhaW5lclwiKVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MubG9nKGkpXHJcbiAgICAgICAgICAgIHZhciBuZCA9IGNjLmluc3RhbnRpYXRlKGNvbS5zbUpzUGFuZWwpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBuZC5wb3NpdGlvbiA9IGNjLnYyKDAsMClcclxuICAgICAgICAgICAgLy9uZC5nZXRDb21wb25lbnQoXCJzbUpzUGFuZWxcIikuaW5pdENhcmQoQWxsSGFuZHNEYXRhW2ldLCBzY29yZVN1bW1hcnlbaV0pXHJcbiAgICAgICAgICAgIG5kLnBhcmVudCA9IGNvbnRhaW5lclxyXG5cclxuICAgICAgICAgICAgY2MubG9nKFwiPT09PT09PT1cIiwgY29tLnNtSnNQYW5lbCwgbmQsIG5kLnBhcmVudClcclxuICAgICAgICAgICAvLyBuZC5wb3NpdGlvbiA9IHBvc2VzW2ldXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYy5sb2coXCJjYy52aWV3LmdldEZyYW1lU2l6ZSgpLndpZHRoID0gXCIsIGNjLnZpZXcuZ2V0RnJhbWVTaXplKCkud2lkdGgpXHJcbiAgICAgICAgdmFyIHNjYWxlID0gY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aCAvICgxLjgqY2Mudmlldy5nZXRGcmFtZVNpemUoKS5oZWlnaHQpXHJcbiAgICAgICAgY29udGFpbmVyLnNjYWxlID0gc2NhbGVcclxuKi9cclxuICAgIH0sXHJcblxyXG4gICAgc2V0SVA6ZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB2YXIgaXAgPSBldmVudC5zdHJpbmdcclxuICAgICAgICBpZiAoaXAgIT0gXCJcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmNvbmZpZ21hbmFnZXIuc2VydmVySVAgPSBpcFxyXG4gICAgICAgICAgICBjYy5sb2coJ0lQOicgKyBpcClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBsb2NrVUk6ZnVuY3Rpb24oYkxvY2spe1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICAgIHZhciBpbnRlcmFjdGFibGUgPSAhYkxvY2tcclxuICAgICAgICB0aGlzLmJ0bldYTG9naW4uaW50ZXJhY3RhYmxlID0gaW50ZXJhY3RhYmxlXHJcbiAgICAgICAgdGhpcy5idG5HdWVzdExvZ2luLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vVE866L2s6I+K6IqxIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgbG9naW46ZnVuY3Rpb24odHlwZSl7XHJcbiAgICAgICAgdGhpcy5sb2NrVUkodHJ1ZSlcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLmxvZ2luKHR5cGUpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvL3dlY2hhdCBsb2dpblxyXG4gICAgb25DbGlja19idG5XWExvZ2luOmZ1bmN0aW9uKGV2ZW50KXtcclxuXHJcbiAgICAgICAgdGhpcy5sb2dpbigxKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy/ov5Tlm57ljY/orq4gXHJcbiAgICBQdWJsaWNQcm90b19TX0xvZ2luUmV0OmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgdGhpcy5sb2NrVUkoZmFsc2UpXHJcblxyXG4gICAgICAgIGlmIChtc2cucmV0X2NvZGUgPT0gMSlcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICBjYy5zY2VuZW1hbmFnZXIubG9hZE1haW5TY2VuZSgpXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goXCLnmbvlvZXlpLHotKUs6ZSZ6K+v5Luj56CBOlwiICttc2cucmV0X2NvZGUpXHJcbiAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIubG9naW5PdXQoKSBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbk1lc3NhZ2VFcnJvcjpmdW5jdGlvbihlcnJvcmlkKXtcclxuICAgICAgICB0aGlzLmxvY2tVSShmYWxzZSlcclxuICAgIH0sXHJcblxyXG4gICAgLy9ndWVzdCBsb2dpblxyXG4gICAgb25DbGlja19idG5HdWVzdExvZ2luIDogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmxvZ2luKDApXHJcbiAgICB9LFxyXG5cclxuICAgIC8veGlleWkgXHJcbiAgICBvbkNsaWNrX1hpZXlpOiBmdW5jdGlvbigpe1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBmdW5jTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIG5hbWVMYWJlbDogY2MuTGFiZWwsXHJcbiAgICAgICAgbm90aWNlTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIG5vdGljZU1hc2s6Y2MuTm9kZSxcclxuICAgICAgICBub3RpY2VUZXh0OmNjLkxhYmVsLFxyXG4gICAgICAgIG9wZW5pZFRleHQ6IGNjLkxhYmVsLFxyXG4gICAgICAgIGNvaW5UZXh0OiBjYy5MYWJlbCxcclxuICAgICAgICBkaWFtb25kVGV4dDogY2MuTGFiZWwsXHJcbiAgICAgICAgbW92ZVNwZWVkIDogMjAsXHJcbiAgICAgICAgaGVhZEljb246Y2MuU3ByaXRlLFxyXG4gICAgICAgIGhlYWROb2RlOiBjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25DcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5sb2coXCJuYW1lID0gXCIgKyBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5uaWNrX25hbWUpO1xyXG4gICAgICAgIHRoaXMubmFtZUxhYmVsLnN0cmluZyA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLm5pY2tfbmFtZTtcclxuICAgICAgICB0aGlzLm9wZW5pZFRleHQuc3RyaW5nID0gXCJJRDogXCIgKyBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5jdWlkLnRvU3RyaW5nKClcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheUJHTSgnYmFja2dyb3VuZCcpXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgICAgIGNjLmdhbWVtYW5hZ2VyLmdhbWVTdGFydCgpXHJcblxyXG4gICAgICAgIHRoaXMuaGVhZE5vZGUuY3VpZCA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWRcclxuICAgICAgICBjYy5kYXRhbWFuYWdlci5sb2FkSGVhZEltZyhjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS51cmwsdGhpcy5oZWFkSWNvbilcclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoTWFpblBsYXllck1vbmV5KClcclxuICAgICAgICB0aGlzLm5vdGljZVRpbWUgPSAwXHJcblxyXG4gICAgICAgIGlmIChjYy5kYXRhbWFuYWdlci5ub3RpY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGljZVRleHQuc3RyaW5nID0gY2MuZGF0YW1hbmFnZXIubm90aWNlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNjLmRhdGFtYW5hZ2VyLmhhc09wZW5Ob3RpY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm9wZW4oXCJVSU5vdGljZVwiKVxyXG4gICAgICAgICAgICBjYy5kYXRhbWFuYWdlci5oYXNPcGVuTm90aWNlID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihkdCkge1xyXG4gICAgICAgIHRoaXMuZnVuY05vZGUuc2NhbGVZID0gdGhpcy5mdW5jTm9kZS53aWR0aC8gODQwLjA7XHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfTm90aWNlIDogZnVuY3Rpb24oZGF0YSl7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT0gMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWNlVGV4dC5zdHJpbmcgPSBkYXRhLnRleHRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICByZWZyZXNoTWFpblBsYXllck1vbmV5OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuY29pblRleHQuc3RyaW5nID0gY2MuZ2FtZW1hbmFnZXIuY29pbi50b1N0cmluZygpXHJcbiAgICAgICAgdGhpcy5kaWFtb25kVGV4dC5zdHJpbmcgPSBjYy5nYW1lbWFuYWdlci5kaWFtb25kLnRvU3RyaW5nKClcclxuICAgIH0sXHJcblxyXG4gICAgbG9nOiBmdW5jdGlvbihzdHIpe1xyXG4gICAgICAgIGNjLmxvZyhzdHIpXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBvcGVuTGlhbnhpUm9vbTogZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5yb2JvdC5yZXNldCgpXHJcbiAgICAgICAgY2Mucm9ib3QuY3JlYXRlUHJhY3RpY2VSb29tKClcclxuICAgICAgICBjYy5yb2JvdC5zZW5kUGxheWVySW5Sb29tKDAsIDAsIDIpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBtc2dUZXh0OmNjLkxhYmVsLFxyXG4gICAgICAgIG9rQnRuOmNjLk5vZGUsXHJcbiAgICAgICAgY2FuY2VsQnRuOiBjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNZXNzYWdlOmZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIHRoaXMubXNnVGV4dC5zdHJpbmcgPSBtc2dcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q2FsbDpmdW5jdGlvbihjYWxsKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbFxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDYW5jZWxDYWxsOiBmdW5jdGlvbihjYWxsKXtcclxuICAgICAgICB0aGlzLmNhbmNlbENhbGwgPSBjYWxsXHJcbiAgICAgICAgdGhpcy5va0J0bi5wb3NpdGlvbiA9IGNjLnYyKC0xMjAsIC0xMTEpXHJcbiAgICAgICAgdGhpcy5jYW5jZWxCdG4uYWN0aXZlID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICBvbk9rZXk6ZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25DYW5jZWxLZXk6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5jYW5jZWxDYWxsKXtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxDYWxsKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICB9XHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgdGl0bGU6IGNjLlJpY2hUZXh0LFxyXG4gICAgICAgIHdlYnZpZXc6Y2MuUmljaFRleHQsXHJcbiAgICAgICAgc2h1bWluZzogY2MuUmljaFRleHQsXHJcbiAgICAgICAgcmlxaTogY2MuUmljaFRleHRcclxuICAgIH0sXHJcblxyXG4gICAgb25DcmVhdGUgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8v5Y+R6YCB6K+35rGC5YWs5ZGK55qE5raI5oGvXHJcbiAgICAgICAgaWYgKGNjLmRhdGFtYW5hZ2VyLmdtTm90aWNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0cnMgPSBjYy5kYXRhbWFuYWdlci5nbU5vdGljZS5zcGxpdChcIiQkJFwiKTtcclxuICAgICAgICAgICAgaWYoc3Rycy5sZW5ndGggPiAwKSB0aGlzLnRpdGxlLnN0cmluZyA9IHN0cnNbMF1cclxuICAgICAgICAgICAgaWYoc3Rycy5sZW5ndGggPiAxKSB0aGlzLndlYnZpZXcuc3RyaW5nID0gc3Ryc1sxXVxyXG4gICAgICAgICAgICBpZihzdHJzLmxlbmd0aCA+IDIpIHRoaXMuc2h1bWluZy5zdHJpbmcgPSBzdHJzWzJdXHJcbiAgICAgICAgICAgIGlmKHN0cnMubGVuZ3RoID4gMykgdGhpcy5yaXFpLnN0cmluZyA9IHN0cnNbM11cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5DbG9zZUNsaWNrZWQ6ZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgfSxcclxuXHJcbn0pO1xyXG4iLCJpZiAoY2MudWlwYW5lbCA9PSB1bmRlZmluZWQpXHJcbntcclxuICAgIGNjLmxvZygndWlwYW5lbCBpbml0JylcclxuICAgIGNjLnVpcGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICAgICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG4gICAgICAgIHByb3BlcnRpZXM6e1xyXG4gICAgICAgICAgICBiZ09wYXF1ZToyMDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjdG9yOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuaXNNb2RlbCA9IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFZpc2libGU6ZnVuY3Rpb24oYlZpc2libGUpe1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gYlZpc2libGVcclxuICAgICAgICAgICAgaWYgKGJWaXNpYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgb25DcmVhdGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNb2RlbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgICAgICAgICBjYy5sb2FkZXIubG9hZFJlcygnR3VpL01vZGFsQmcnLGZ1bmN0aW9uKGVycixwcmVmYWIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBjYy5pbnN0YW50aWF0ZShwcmVmYWIpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZy5wYXJlbnQgPSBzZWxmLm5vZGVcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnLnNldFNpYmxpbmdJbmRleCgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZygnc2VsZi5iZy5vcGFjaXR5OicgKyBzZWxmLmJnLm9wYWNpdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZy5vcGFjaXR5ID0gc2VsZi5iZ09wYXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZygnc2VsZi5iZy5vcGFjaXR5OicgKyBzZWxmLmJnLm9wYWNpdHkpXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZy5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9TVEFSVCxmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uVG91Y2hCZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbkltbWVkaWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG9uVG91Y2hCZzpmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIG9uQ2xvc2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmcub2ZmKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJUKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBvblNob3c6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBvbkhpZGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBjbG9zZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBjYy5sb2coXCJjbG9zZVwiKVxyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLmNsb3NlKHRoaXMpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb3BlblVJOmZ1bmN0aW9uKGV2ZW50LG5hbWUpe1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm9wZW4obmFtZSkgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93T3JPcGVuVUk6ZnVuY3Rpb24oZXZlbnQsbmFtZSl7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIuc2hvd09yT3BlblVJKG5hbWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZWxlY3Q6ZnVuY3Rpb24ocGFyZW50Tm9kZSxpbmRleCl7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHBhcmVudE5vZGUuY2hpbGRyZW5Db3VudFxyXG4gICAgICAgICAgICB2YXIgY3MgPSBwYXJlbnROb2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3NbaV0uYWN0aXZlID0gaSA9PSBpbmRleFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93Q29taW5nU29vbkRsZzpmdW5jdGlvbihldmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCflip/og73mmoLmnKrlvIDmlL7vvIzmlazor7fmnJ/lvoXvvIEnKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIG9yaWdpblBva2VyOiBjYy5Ob2RlLFxyXG4gICAgICAgIG1vdmVQb2tlcjogY2MuTm9kZSxcclxuICAgICAgICBwcmVmYWJIZWFkSWNvbjogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyU29ydDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyTGlzdDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyRmxvcDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHJvb21OdW06Y2MuTGFiZWwsXHJcbiAgICAgICAgbXlIZWFkSWNvbjogY2MuTm9kZSxcclxuICAgICAgICBzdGFydEFuaW1hdGlvbjogY2MuTm9kZSxcclxuICAgICAgICByZWNvcmRCdG46Y2MuTm9kZSxcclxuICAgICAgICByZWNvcmRQYW5lbDpjYy5Ob2RlLFxyXG5cclxuICAgICAgICBwcmVmYWJKaWVzdWFuOiBjYy5QcmVmYWIsXHJcbiAgICAgICAgcHJlZmFiQmlnSmllc3VhbjogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYldhaXRNYXRjaDogY2MuUHJlZmFiLFxyXG5cclxuICAgICAgICBwcmVmYWJQbGF5ZXIyOiBjYy5QcmVmYWIsXHJcbiAgICAgICAgcHJlZmFiUGxheWVyMzogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBsYXllcjQ6IGNjLlByZWZhYixcclxuICAgICAgICBwcmVmYWJQbGF5ZXI1OiBjYy5QcmVmYWIsXHJcblxyXG4gICAgICAgIGppZXN1YW5Ub3A6IGNjLk5vZGUsXHJcbiAgICAgICAgamllc3Vhbk1pZGVsOiBjYy5Ob2RlLFxyXG4gICAgICAgIGppZXN1YW5Cb3R0dG9tOiBjYy5Ob2RlLFxyXG4gICAgICAgIGppZXN1YW5EYXFpYW5nOiBjYy5Ob2RlLFxyXG5cclxuICAgICAgICBxdWFubGVpZGFOb2RlOiBjYy5Ob2RlLFxyXG4gICAgICAgIHdhaXRMYWJlbDogY2MuTm9kZSxcclxuXHJcbiAgICAgICAgdGltZUxhYmVsIDogY2MuTGFiZWwsXHJcblxyXG4gICAgICAgIHNoYXJlQnRuOiBjYy5CdXR0b24sXHJcbiAgICAgICAgX3Bva2VyTGlzdDogbnVsbCxcclxuICAgICAgICBfaGVhZEljb25zOiBudWxsLFxyXG4gICAgICAgIF9wb2tlckZsb3BzOiBudWxsLFxyXG4gICAgICAgIF9jdXJTaHVmZmxlSWR4OjAsXHJcbiAgICAgICAgX3BsYXllckhlYWRzOiBudWxsLFxyXG4gICAgICAgIF9rYWlzaGliaXBhaTogbnVsbCxcclxuICAgICAgICBfbWF0Y2hQb2ludExhYmVsOiBudWxsLFxyXG4gICAgICAgIF9vcHRpb25MYWJlbDogbnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkNyZWF0ZTogZnVuY3Rpb24gKCkgeyAgICBcclxuICAgICAgICB0aGlzLl9wb2tlckxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgdGhpcy5idWJibGVQcmVmYWIgPSBjYy5sb2FkZXIubG9hZFJlcygnR3VpL1dpZGdldC9DaGF0QnViYmxlJyxmdW5jdGlvbihlcnIscHJlZmFiKXtcclxuICAgICAgICAgICAgc2VsZi5idWJibGVQcmVmYWIgPSBwcmVmYWJcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLnJlY29yZEJ0bi5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9TVEFSVCwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgc2VsZi5vblN0YXJ0UmVjb3JkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRCdG4ub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfQ0FOQ0VMLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBzZWxmLm9uQ2FuY2VsUmVjb3JkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRCdG4ub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfRU5ELCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBzZWxmLm9uU3RvcFJlY29yZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9rYWlzaGliaXBhaSA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS9rYWlzaGliaXBhaVwiKVxyXG4gICAgICAgIHRoaXMuX21hdGNoUG9pbnRMYWJlbCA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS90aXRsZS9tYXRjaFBvaW50XCIpXHJcbiAgICAgICAgdGhpcy5fb3B0aW9uTGFiZWwgPSBjYy5maW5kKFwiVUlQb2tlckdhbWUvdGl0bGUvb3B0aW9uXCIpXHJcbiAgICAgICAgdGhpcy5fcHJlZmFiUGxheWVycyA9IFt0aGlzLnByZWZhYlBsYXllcjIsIHRoaXMucHJlZmFiUGxheWVyMywgdGhpcy5wcmVmYWJQbGF5ZXI0LCB0aGlzLnByZWZhYlBsYXllcjVdXHJcblxyXG4gICAgICAgIHRoaXMucm9vbU51bS5zdHJpbmcgPSBjYy5nYW1lbWFuYWdlci5yb29tX2luZm8ucm9vbV9pZDtcclxuICAgICAgICB0aGlzLmluaXRSb29tKGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplKTtcclxuICAgICAgICB0aGlzLm9uUGxheWVySW5Sb29tKGNjLmdhbWVtYW5hZ2VyLl9wbGF5ZXJzKTtcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheUJHTSgnYmFja2dyb3VuZCcpXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKTtcclxuXHJcbiAgICAgICAgY2MubG9nKFwi5Yid5aeL5YyW56uL54mM55WM6Z2i77yM5Yid5aeL5YyW56uL54mM55WM6Z2i77yM5Yid5aeL5YyW56uL54mM55WM6Z2i77yMXCIpXHJcbiAgICAgICAgdGhpcy5pbml0T25saW5lU3RhdGUoKVxyXG4gICAgICAgIGNjLmdhbWVtYW5hZ2VyLm5vcm1hbFByb2Nlc3MgPSB0cnVlXHJcbiAgICAgICAgY2MuaW1tYW5hZ2VyLmluaXQoKVxyXG5cclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gMFxyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZSgpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKHRoaXMuYnViYmxlUHJlZmFiKVxyXG4gICAgICAgICAgICBjYy5sb2FkZXIucmVsZWFzZUFzc2V0KHRoaXMuYnViYmxlUHJlZmFiKVxyXG4gICAgICAgIGNjLmdhbWVtYW5hZ2VyLmdhbWVPdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdFJvb206IGZ1bmN0aW9uKHBsYXllck51bSl7XHJcbiAgICAgICAgaWYocGxheWVyTnVtID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZihwbGF5ZXJOdW0gPT0gMSlcclxuICAgICAgICAgICAgcGxheWVyTnVtID0gMjtcclxuXHJcbiAgICAgICAgY2MubG9nKFwiaW5pdCByb29tLCBwYWx5ZXIgbnVtYmVyID0gXCIgKyBwbGF5ZXJOdW0pO1xyXG4gICAgICAgIGlmKHBsYXllck51bSA8PSAxIHx8IHBsYXllck51bSA+IDUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuX3ByZWZhYlBsYXllcnNbcGxheWVyTnVtLTJdKVxyXG4gICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLm5vZGVcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy/njqnlrrblpLTlg49cclxuICAgICAgICB0aGlzLl9wbGF5ZXJIZWFkcyA9IG9iai5nZXRDaGlsZEJ5TmFtZShcImhlYWRzXCIpLmNoaWxkcmVuXHJcbiAgICAgICAgY2MubG9nKFwidGhpcy5fcGxheWVySGVhZHMgc2l6ZSA9IFwiICsgdGhpcy5fcGxheWVySGVhZHMubGVuZ3RoKVxyXG5cclxuICAgICAgICAvL+WPkeeJjOWbvueJh1xyXG4gICAgICAgIHRoaXMuX3Bva2VyTGlzdCA9IFtdO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2Vyc1wiKVxyXG4gICAgICAgIHRoaXMuX3Bva2VyTGlzdC5wdXNoKHBhcmVudE5vZGUuY2hpbGRyZW5bMF0pXHJcbiAgICAgICAgdmFyIHBsYXllcnNOb2RlID0gb2JqLmdldENoaWxkQnlOYW1lKFwiUG9rZXJzXCIpXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBsYXllcnNOb2RlLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bva2VyTGlzdC5wdXNoKHBsYXllcnNOb2RlLmNoaWxkcmVuW2ldKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5sb2coXCJ0aGlzLl9wb2tlckxpc3Qgc2l6ZSA9IFwiICsgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aClcclxuXHJcbiAgICAgICAgLy/mr5TniYxcclxuICAgICAgICB0aGlzLl9wb2tlckZsb3BzID0gW10gLy/or6XmlbDnu4TljIXmi6zoh6rlt7FcclxuICAgICAgICB2YXIgZmxvcFBhcmVudCA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS9Qb2tlckZsb3BzXCIpXHJcbiAgICAgICAgdGhpcy5fcG9rZXJGbG9wcy5wdXNoKGZsb3BQYXJlbnQuY2hpbGRyZW5bMF0pICAgLy/oh6rlt7HnmoRcclxuICAgICAgICB2YXIgZmxvcE5vZGUgPSBvYmouZ2V0Q2hpbGRCeU5hbWUoXCJQb2tlckZsb3BzXCIpXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZsb3BOb2RlLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bva2VyRmxvcHMucHVzaChmbG9wTm9kZS5jaGlsZHJlbltpXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MubG9nKFwidGhpcy5fcG9rZXJGbG9wcyBzaXplID0gXCIgKyB0aGlzLl9wb2tlckZsb3BzLmxlbmd0aClcclxuICAgICAgICB0aGlzLnJlZnJlc2hOZXdNYXRjaFN0YXRlKClcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9rZXJMaXN0U2hvdzogZnVuY3Rpb24odmlzaWJsZSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bva2VyTGlzdC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bva2VyTGlzdFtpXS5hY3RpdmUgPSB2aXNpYmxlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aOiee6v+WQjuWkhOeQhlxyXG4gICAgaW5pdE9ubGluZVN0YXRlOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICBjYy5sb2coY2MuZ2FtZW1hbmFnZXIubm9ybWFsUHJvY2VzcywgY2MuZ2FtZW1hbmFnZXIuX3NlbGZTdGF0dXMsIGNjLmdhbWVtYW5hZ2VyLl9jdXJyZW50Um91bmRzKVxyXG5cclxuICAgICAgICBpZihjYy5nYW1lbWFuYWdlci5ub3JtYWxQcm9jZXNzID09IGZhbHNlKXtcclxuXHJcbiAgICAgICAgICAgIC8v6YCJ54mM5pe25o6J57q/77yM55u05o6l5pi+56S66YCJ54mM55WM6Z2iXHJcbiAgICAgICAgICAgIGlmKGNjLmdhbWVtYW5hZ2VyLl9zZWxmU3RhdHVzID09IDMgJiYgY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMgIT0gMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9rZXJTb3J0ID0gY2MuaW5zdGFudGlhdGUodGhpcy5wcmVmYWJQb2tlclNvcnQpO1xyXG4gICAgICAgICAgICAgICAgcG9rZXJTb3J0LnBhcmVudCA9IHRoaXMubm9kZTtcclxuICAgICAgICAgICAgICAgIHBva2VyU29ydC5wb3NpdGlvbiA9IGNjLnYyKDAsIDApOyBcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBva2VyTGlzdFNob3coZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBva2VyRmxvcFNob3codHJ1ZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy/miJHlt7Llh7rniYzvvIzkvYbmoYzkuIrov5jmnInlhbbku5bkurrmnKrlh7rniYzvvIzmmL7npLrnrYnlvoXkuK1cclxuICAgICAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuX3NlbGZTdGF0dXMgPT0gNCAmJiBjYy5nYW1lbWFuYWdlci5fb3RoZXJTdGF0dXMgPT0gMyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dXYWl0U3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb2tlckxpc3RTaG93KGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb2tlckZsb3BTaG93KHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICBcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9rZXJGbG9wU2hvdzogZnVuY3Rpb24odmlzaWJsZSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bva2VyRmxvcHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckZsb3BzW2ldLmFjdGl2ZSA9IHZpc2libGVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5paw55qE5LiA5bGA5byA5aeL5Yi35paw5pWw5o2uXHJcbiAgICByZWZyZXNoTmV3TWF0Y2hTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wb2tlckxpc3RbaV1cclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckxpc3RcIikucmVzZXRTdGF0ZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICBub2RlLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKS5yZXNldFN0YXRlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQb2tlckxpc3RTaG93KGZhbHNlKVxyXG4gICAgICAgIHRoaXMuc2V0UG9rZXJGbG9wU2hvdyhmYWxzZSlcclxuICAgICAgICB0aGlzLl9jdXJTaHVmZmxlSWR4ID0gMFxyXG5cclxuICAgICAgICB2YXIgcm9vbUF0dHI9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyXHJcbiAgICAgICAgdmFyIHB0TGFiZWwgPSBjYy5nYW1lbWFuYWdlci5fY3VycmVudFJvdW5kcyArIFwiL1wiICsgcm9vbUF0dHIucm91bmRzXHJcbiAgICAgICAgdGhpcy5fbWF0Y2hQb2ludExhYmVsLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gcHRMYWJlbFxyXG5cclxuICAgICAgICB2YXIgb3B0aW9uTGFiZWwgPSBcIuaUr+S7mDpcIlxyXG4gICAgICAgIGlmIChyb29tQXR0ci5wYXlvciA9PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9wdGlvbkxhYmVsID0gb3B0aW9uTGFiZWwgKyBcIuaIv+S4u1wiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJvb21BdHRyLnBheW9yID09IDExKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3B0aW9uTGFiZWwgPSBvcHRpb25MYWJlbCArIFwi5YiG5pGKXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocm9vbUF0dHIucGF5b3IgPT0gMTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvcHRpb25MYWJlbCA9IG9wdGlvbkxhYmVsICsgXCLlpKfotaLlrrZcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm9vbUF0dHIuZGFfcWlhbmcgPT0gMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICBvcHRpb25MYWJlbCA9IG9wdGlvbkxhYmVsLmNvbmNhdChcIixcIixTdHJpbmcocm9vbUF0dHIucGxheWVyX3NpemUpICwgXCLkurrmuLjmiI8s5omT5p6q57+75YCNXCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9wdGlvbkxhYmVsID0gb3B0aW9uTGFiZWwuY29uY2F0KFwiLFwiLFN0cmluZyhyb29tQXR0ci5wbGF5ZXJfc2l6ZSkgLCBcIuS6uua4uOaIjyzmiZPmnqorXCIsU3RyaW5nKHJvb21BdHRyLmRhX3FpYW5nKSxcIumBk1wiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJvb21BdHRyLnF1YW5fbGVpX2RhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3B0aW9uTGFiZWwgPSBvcHRpb25MYWJlbCArIFwiLOWFqOWekuaJk1wiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocm9vbUF0dHIucGxheV90eXBlID09IDY1KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3B0aW9uTGFiZWwgPSBvcHRpb25MYWJlbCArICcs5aSa5LiA6ImyJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvcHRpb25MYWJlbCA9IG9wdGlvbkxhYmVsICsgJyzmma7pgJonXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuX29wdGlvbkxhYmVsLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gb3B0aW9uTGFiZWxcclxuICAgIH0sXHJcblxyXG4gICAgX3JlZnJlc2hIZWFkSW5mbzogZnVuY3Rpb24obm9kZSwgZGF0YSl7XHJcbiAgICAgICAgaWYobm9kZSA9PSBudWxsIClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgaWNvbiA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJpY29uXCIpXHJcbiAgICAgICAgdmFyIGRlZmljb24gPSBub2RlLmdldENoaWxkQnlOYW1lKFwiZGVmYXVsdFwiKVxyXG5cclxuICAgICAgICBpZihkYXRhID09IG51bGwgfHwgcGFyc2VJbnQoZGF0YS5jdWlkKSA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWNvbi5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZGVmaWNvbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpY29uLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGRlZmljb24uYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBub2RlLmN1aWQgPSBkYXRhLmN1aWRcclxuXHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGljb24uZ2V0Q2hpbGRCeU5hbWUoXCJuYW1lXCIpXHJcbiAgICAgICAgICAgIGlmKGxhYmVsICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBkYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb2luID0gaWNvbi5nZXRDaGlsZEJ5TmFtZShcImNvaW5udW1cIilcclxuICAgICAgICAgICAgdmFyIHJhbmsgPSBjYy5nYW1lbWFuYWdlci5nZXRDdXJNYXRjaFJhbmsoZGF0YS5jdWlkKVxyXG4gICAgICAgICAgICBpZihjb2luICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29pbi5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9ICByYW5rLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByZXBhcmUgPSBpY29uLmdldENoaWxkQnlOYW1lKFwieWl6aHVuYmVpXCIpXHJcbiAgICAgICAgICAgIGlmKHByZXBhcmUgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAvL3ByZXBhcmUuYWN0aXZlID0gKGRhdGEuc3RhdHVzID09IDIpO1xyXG4gICAgICAgICAgICAgICAgaWYoZGF0YS5zdGF0dXMgPT0gMil7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoXCJUZXh0dXJlcy9GaWdodC95aXpodW5iZWlUWFRcIiwgcHJlcGFyZSlcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGRhdGEuc3RhdHVzID09IDMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKFwiVGV4dHVyZXMvbGlwYWl6aG9uZ1RYVFwiLCBwcmVwYXJlKVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v546p5a625aS05YOPXHJcbiAgICAgICAgICAgIHZhciBpY29uID0gaWNvbi5nZXRDaGlsZEJ5TmFtZShcImhlYWRJQ09OXCIpXHJcbiAgICAgICAgICAgIGlmKGljb24pe1xyXG4gICAgICAgICAgICAgICAgLy8gY2MuZ3VpbWFuYWdlci5tc2dCb3goXCJkYXRhLmltZ3VybDpcIiArIGRhdGEuaW1ndXJsKVxyXG4gICAgICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIubG9hZEhlYWRJbWcoZGF0YS5pbWd1cmwsIGljb24uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yi35paw5aS05YOP5LiL6Z2i55qE56ev5YiGXHJcbiAgICBfcmVmcmVzaEhlYWRTY29yZTogZnVuY3Rpb24oKXtcclxuICAgICAgICBmdW5jdGlvbiBfX19nZXRDb2luTm9kZShwYXJub2RlKXtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJpY29uXCIpLmdldENoaWxkQnlOYW1lKFwiY29pbm51bVwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubXlIZWFkSWNvbi5jdWlkICYmIHRoaXMubXlIZWFkSWNvbi5jdWlkICl7XHJcbiAgICAgICAgICAgIHZhciBteXNjb3JlID0gY2MuZ2FtZW1hbmFnZXIuZ2V0Q3VyTWF0Y2hSYW5rKHRoaXMubXlIZWFkSWNvbi5jdWlkKVxyXG4gICAgICAgICAgICB2YXIgbmQgPSBfX19nZXRDb2luTm9kZSh0aGlzLm15SGVhZEljb24pXHJcbiAgICAgICAgICAgIGlmKG5kICYmIG5kLmdldENvbXBvbmVudChjYy5MYWJlbCkpe1xyXG4gICAgICAgICAgICAgICAgbmQuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBteXNjb3JlLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BsYXllckhlYWRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX3BsYXllckhlYWRzW2ldXHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIgJiYgaGVhZGVyLmN1aWQgKXtcclxuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IGNjLmdhbWVtYW5hZ2VyLmdldEN1ck1hdGNoUmFuayhoZWFkZXIuY3VpZClcclxuICAgICAgICAgICAgICAgIHZhciBuZCA9IF9fX2dldENvaW5Ob2RlKGhlYWRlcilcclxuICAgICAgICAgICAgICAgIGlmKG5kICYmIG5kLmdldENvbXBvbmVudChjYy5MYWJlbCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5kLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gc2NvcmUudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRIZWFkZXIgOiBmdW5jdGlvbihjdWlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXlIZWFkSWNvbi5jdWlkICYmIGN1aWQuZXEodGhpcy5teUhlYWRJY29uLmN1aWQpKSByZXR1cm4gdGhpcy5teUhlYWRJY29uXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wbGF5ZXJIZWFkcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLl9wbGF5ZXJIZWFkc1tpXVxyXG4gICAgICAgICAgICBpZiAoaGVhZGVyICYmIGhlYWRlci5jdWlkICYmIGN1aWQuZXEoaGVhZGVyLmN1aWQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goXCLmlbDmja7plJnor69nZXRIZWFkZXJcIiArIGN1aWQudG9TdHJpbmcoKSArIFwiIC0gXCIgKyB0aGlzLl9wbGF5ZXJIZWFkcy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RmxvcDogZnVuY3Rpb24oY3VpZCl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bva2VyRmxvcHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgZmxvcCA9IHRoaXMuX3Bva2VyRmxvcHNbaV1cclxuICAgICAgICAgICAgaWYoZmxvcCAmJiBmbG9wLmN1aWQgJiYgY3VpZC5lcShmbG9wLmN1aWQpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbG9wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KFwi5pWw5o2u6ZSZ6K+vZ2V0RmxvcFwiICsgY3VpZC50b1N0cmluZygpICsgXCIgLSBcIiArIHRoaXMuX3Bva2VyRmxvcHMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIHNob3dXYWl0U3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy53YWl0U3RhdGVOb2RlID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLndhaXRTdGF0ZU5vZGUgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnByZWZhYldhaXRNYXRjaClcclxuICAgICAgICAgICAgdGhpcy53YWl0U3RhdGVOb2RlLnBhcmVudCA9IHRoaXMubm9kZVxyXG4gICAgICAgICAgICB0aGlzLndhaXRTdGF0ZU5vZGUucG9zaXRpb24gPSAgY2MudjIoMCwwKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25QbGF5ZXJJblJvb206IGZ1bmN0aW9uKHBsYXllcnNkYXRhKXtcclxuXHJcbiAgICAgICAgLy/mnInml7blgJnkvJrlh7rnjrDov5vlhaXmiL/pl7TvvIxpbml0Um9vbei/mOacquiwg+eUqFxyXG4gICAgICAgIGlmKHRoaXMuX3BsYXllckhlYWRzID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmluaXRSb29tKGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNjLmxvZyhcIm9uUGxheWVySW5Sb29tIGxlbmd0aCA9IFwiICsgcGxheWVyc2RhdGEubGVuZ3RoKVxyXG4gICAgICAgIGlmKHBsYXllcnNkYXRhLmxlbmd0aCA9PSAwKXsgXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgc29ydGRhdGEgPSBbXTtcclxuICAgICAgICB2YXIgc2VsZklkeCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGZEYXRhID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGE7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBsYXllcnNkYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYocGxheWVyc2RhdGFbaV0uY3VpZC5lcShzZWxmRGF0YS5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICBzZWxmSWR4ID0gaTtcclxuICAgICAgICAgICAgICAgIC8vY2MuZmluZChcIlVJUG9rZXJHYW1lL3N0YXJ0QnRuXCIpLmFjdGl2ZSA9IChwbGF5ZXJzZGF0YVtpXS5zdGF0dXMgPT0gMCk7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coXCLmiJHnmoTnirbmgIHvvJogXCIgKyBwbGF5ZXJzZGF0YVtpXS5zdGF0dXMpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRCdG4gPSBjYy5maW5kKFwiVUlQb2tlckdhbWUvc3RhcnRCdG5cIilcclxuICAgICAgICAgICAgICAgIHN0YXJ0QnRuLmFjdGl2ZSA9IChwbGF5ZXJzZGF0YVtpXS5zdGF0dXMgPCAyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hIZWFkSW5mbyh0aGlzLm15SGVhZEljb24sIHBsYXllcnNkYXRhW2ldKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9rZXJGbG9wc1swXS5jdWlkID0gcGxheWVyc2RhdGFbaV0uY3VpZFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBleGlzdFBsYXllck51bSA9IDBcclxuICAgICAgICB2YXIgd2FpdFBsYXllck51bSA9IDBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGxheWVyc2RhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZighcGxheWVyc2RhdGFbaV0uY3VpZC5lcSgwKSl7XHJcbiAgICAgICAgICAgICAgICBleGlzdFBsYXllck51bSsrXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHBsYXllcnNkYXRhW2ldLnN0YXR1cyA9PSAyKXtcclxuICAgICAgICAgICAgICAgIHdhaXRQbGF5ZXJOdW0rK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLndhaXRMYWJlbC5hY3RpdmUgPSAod2FpdFBsYXllck51bSA9PSAxKVxyXG5cclxuICAgICAgICB0aGlzLnNoYXJlQnRuLm5vZGUuYWN0aXZlID0gKGV4aXN0UGxheWVyTnVtICE9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gc2VsZklkeCArIDE7IGkgPCBwbGF5ZXJzZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHNvcnRkYXRhLnB1c2gocGxheWVyc2RhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZklkeDsgKytpKXtcclxuICAgICAgICAgICAgc29ydGRhdGEucHVzaChwbGF5ZXJzZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgZm9yKCA7IGkgPCBzb3J0ZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcGxheWVySGVhZHNbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hIZWFkSW5mbyhub2RlLCBzb3J0ZGF0YVtpXSlcclxuICAgICAgICAgICAgdGhpcy5fcG9rZXJGbG9wc1tpKzFdLmN1aWQgPSBzb3J0ZGF0YVtpXS5jdWlkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IoIDsgaSA8IHRoaXMuX3BsYXllckhlYWRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wbGF5ZXJIZWFkc1tpXVxyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoSGVhZEluZm8obm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bva2VyRmxvcHNbaSsxXS5jdWlkID0gMFxyXG4gICAgICAgIH1cclxuLypcclxuICAgICAgICB2YXIgYWxyZWFkeSA9IDBcclxuICAgICAgICB2YXIgYWxyZWFkeUlkeCA9IFtdXHJcblxyXG4gICAgICAgIHNvcnRkYXRhLnNwbGljZSgwLCAwLCBwbGF5ZXJzZGF0YVtzZWxmSWR4XSlcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc29ydGRhdGEubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICBpZihzb3J0ZGF0YVtqXS5zdGF0dXMgPT0gNCl7XHJcbiAgICAgICAgICAgICAgICArK2FscmVhZHlcclxuICAgICAgICAgICAgICAgIGFscmVhZHlJZHgucHVzaChqKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFscmVhZHkgPT0gc29ydGRhdGEubGVuZ3RoKSAvL+aJgOacieS6uumDveeQhuWlveeJjOS6hlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bva2VyRmxvcHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9rZXJGbG9wc1tpXS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIikuc2V0U3RhdGUodHJ1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBpZihhbHJlYWR5SWR4LmluZGV4T2YoaSkgIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bva2VyRmxvcHNbaV0uZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpLnNldFN0YXRlKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9rZXJGbG9wc1tpXS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIikuc2V0U3RhdGUodHJ1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuKi9cclxuICAgIH0sXHJcblxyXG4gICAgc2hvd0NoYXQgOiBmdW5jdGlvbihjdWlkLGNvbnRlbnQpIHtcclxuICAgICAgICBjYy5sb2coY3VpZClcclxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5nZXRIZWFkZXIoY3VpZClcclxuICAgICAgICBpZiAoaGVhZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuYnViYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlLmRlc3Ryb3koKVxyXG4gICAgICAgICAgICAgICAgaGVhZGVyLmJ1YmJsZSA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2MubG9nKFwidGhpcy5idWJibGVQcmVmYWI6XCIgKyB0aGlzLmJ1YmJsZVByZWZhYilcclxuICAgICAgICAgICAgaWYgKCFoZWFkZXIuYnViYmxlICYmIHRoaXMuYnViYmxlUHJlZmFiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlID0gY2MuaW5zdGFudGlhdGUodGhpcy5idWJibGVQcmVmYWIpXHJcbiAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlLnBhcmVudCA9IGNjLmRpcmVjdG9yLmdldFNjZW5lKClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyID09IHRoaXMubXlIZWFkSWNvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlLnBvc2l0aW9uID0gaGVhZGVyLmNvbnZlcnRUb1dvcmxkU3BhY2UgKGNjLnAoNTAsMCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wbGF5ZXJIZWFkcy5sZW5ndGggPiAyICYmIHRoaXMuX3BsYXllckhlYWRzWzBdID09IGhlYWRlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlLnBvc2l0aW9uID0gaGVhZGVyLmNvbnZlcnRUb1dvcmxkU3BhY2UgKGNjLnAoMCw1MCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmJ1YmJsZS5zY2FsZVggPSAtMVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGhlYWRlci5idWJibGUuZ2V0Q29tcG9uZW50KCdDaGF0QnViYmxlJylcclxuICAgICAgICAgICAgICAgICAgICBjLnRleHQubm9kZS5zY2FsZVggPSAtMVxyXG4gICAgICAgICAgICAgICAgICAgIGMuZmFjZS5ub2RlLnNjYWxlWCA9IC0xXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmJ1YmJsZS5wb3NpdGlvbiA9IGhlYWRlci5jb252ZXJ0VG9Xb3JsZFNwYWNlIChjYy5wKDEwMCw1MCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIuYnViYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVsbGVyID0gaGVhZGVyLmJ1YmJsZS5nZXRDb21wb25lbnQoXCJDaGF0QnViYmxlXCIpXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVsbGVyLnNob3dUZXh0KGNvbnRlbnQuZGF0YV90ZXh0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudC50eXBlID09IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVsbGVyLnNob3dGYWNlKGNvbnRlbnQuZGF0YV9pbnQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50LnR5cGUgPT0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlLnVybCA9IGNvbnRlbnQuZGF0YV90ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgYnVsbGVyLnNob3dWb2ljZShjb250ZW50LmRhdGFfdGV4dClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgIT0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZWR1bGVyID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyLnVuc2NoZWR1bGVBbGxGb3JUYXJnZXQoYnVsbGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZSAoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGVyLm5vZGUuZGVzdHJveSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxidWxsZXIsMCwwLDMsZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUGxheUNvbXBsZXRlZCA6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jbGVhclZvaWNlQnViYmxlKHRoaXMubXlIZWFkSWNvbikpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BsYXllckhlYWRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5fcGxheWVySGVhZHNbaV1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyVm9pY2VCdWJibGUoaGVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJWb2ljZUJ1YmJsZSA6IGZ1bmN0aW9uKGhlYWRlcikge1xyXG4gICAgICAgIGlmIChoZWFkZXIgJiYgaGVhZGVyLmJ1YmJsZSAmJiBoZWFkZXIuYnViYmxlLnVybClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGhlYWRlci5idWJibGUuZGVzdHJveSgpXHJcbiAgICAgICAgICAgIGhlYWRlci5idWJibGUgPSBudWxsXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy/ogYrlpKnmtojmga9cclxuICAgIFB1YmxpY1Byb3RvX1NfQ2hhdCA6IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIHRoaXMuc2hvd0NoYXQobXNnLmN1aWQsbXNnLmNvbnRlbnQpXHJcbiAgICB9LFxyXG5cclxuICAgIGdpdmV1cCA6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwidHVpY2h1ZmFuZ2ppYW5cIilcclxuXHJcbiAgICAgICAgaWYoIWNjLmdhbWVtYW5hZ2VyLmlzUHJhY3RpY2VSb29tKCkpe1xyXG4gICAgICAgICAgICB2YXIgcm9vbU51bSA9IDBcclxuICAgICAgICAgICAgZm9yKHZhciBpID0wIDsgaSA8IGNjLmdhbWVtYW5hZ2VyLl9wbGF5ZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIGlmKGNjLmdhbWVtYW5hZ2VyLl9wbGF5ZXJzW2ldLmN1aWQgIT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vbU51bSsrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYocm9vbU51bSA9PSAxKXtcclxuICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94V2l0aENhbmNlbChcIueOsOWcqOmAgOWHuuaIv+mXtOS4jeaJo+mZpOi0ueeUqO+8jOaYr+WQpumAgOWHuu+8n1wiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmdhbWVtYW5hZ2VyLmdpdmV1cCgpXHJcbiAgICAgICAgICAgICAgICB9LCBudWxsKVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94V2l0aENhbmNlbChcIuS9oOaYr+WQpuehruWumuemu+W8gOaIv+mXtO+8n1wiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmdhbWVtYW5hZ2VyLmdpdmV1cCgpXHJcbiAgICAgICAgICAgICAgICB9LCBudWxsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94V2l0aENhbmNlbChcIuS9oOehruWumuimgemAgOWHuue7g+S5oOaIv+WQl++8n1wiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgY2Muc2NlbmVtYW5hZ2VyLmxvYWRNYWluU2NlbmUoKVxyXG4gICAgICAgICAgICB9LCBudWxsKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX1BsYXllclF1aXRlZCA6IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICBjYy5zY2VuZW1hbmFnZXIubG9hZE1haW5TY2VuZSgpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5byA5aeL5paw55qE5LiA5bGAXHJcbiAgICBuZXdNYXRjaFN0YXJ0OiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hOZXdNYXRjaFN0YXRlKClcclxuXHJcbiAgICAgICAgLy/liLfmlrDlpLTlg4/kuIvnmoTnp6/liIZcclxuICAgICAgICB0aGlzLl9yZWZyZXNoSGVhZFNjb3JlKClcclxuXHJcbiAgICAgICAgdmFyIGFjdGlvbiA9IGNjLnNlcXVlbmNlKGNjLmRlbGF5VGltZSgwLjcpLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQscGFyYW0pe1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRhcmdldC5nZXRDb21wb25lbnQoXCJVSVBva2VyR2FtZVwiKVxyXG4gICAgICAgICAgICBzZWxmLnN0YXJ0QW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLnN0YXJ0QW5pbWF0aW9uLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnN0b3AoKVxyXG4gICAgICAgICAgICBzZWxmLmZhcGFpKClcclxuICAgICAgICB9LCB0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2thaXNoaWJpcGFpLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24uZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikucGxheShcInN0YXJ0YW5pXCIpXHJcbiAgICAgICAgdGhpcy5ub2RlLnJ1bkFjdGlvbihhY3Rpb24pXHJcbiAgICB9LFxyXG5cclxuICAgIGNsaWNrU3RhcnRCdG46IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoIWNjLmdhbWVtYW5hZ2VyLmlzUHJhY3RpY2VSb29tKCkpe1xyXG4gICAgICAgICAgICAvL+WPkemAgeWHhuWkh+a2iOaBr1xyXG4gICAgICAgICAgICBjYy5maW5kKFwiVUlQb2tlckdhbWUvc3RhcnRCdG5cIikuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZygnUHVibGljUHJvdG8uQ19HMTNfUmVhZHlGbGFnJylcclxuICAgICAgICAgICAgbXNnLnJlYWR5ID0gdHJ1ZVxyXG4gICAgICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL+esrOS4gOWxgFxyXG4gICAgICAgICAgICBjYy5yb2JvdC5zZW5kUGxheWVySW5Sb29tKDEsIDMsIDMpXHJcbiAgICAgICAgICAgIGNjLnJvYm90LnNlbmRIYW5kbGVPZk1pbmUoMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKCdHQU1FX1NUQVJUJylcclxuICAgIH0sXHJcblxyXG4gICAgZmFwYWk6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5zZXRQb2tlckxpc3RTaG93KHRydWUpXHJcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2tlci5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubW92ZVBva2VyLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGFuaU5hbWUgPSBcImFjX2NhcmRtb3ZlXCIrY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemVcclxuICAgICAgICBjYy5sb2coXCLmkq3mlL7liqjnlLvvvJogXCIsIGFuaU5hbWUpXHJcbiAgICAgICAgdGhpcy5tb3ZlUG9rZXIuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikucGxheShhbmlOYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIGNhcmRsaXN0ID0gdGhpcy5fcG9rZXJMaXN0WzBdXHJcbiAgICAgICAgdmFyIHBva2VycyA9IGNjLmdhbWVtYW5hZ2VyLmdldEN1ck1hdGhQb2tlcnMoKVxyXG4gICAgICAgIGNjLmxvZyhcImNhcmRsaXN0LmNoaWxkcmVuQ291bnQgPSBcIiArIGNhcmRsaXN0LmNoaWxkcmVuQ291bnQpXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNhcmRsaXN0LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBjYXJkID0gY2FyZGxpc3QuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgdmFyIHZhbCA9IHBva2Vyc1tpXVxyXG4gICAgICAgICAgICAvL2NjLmxvZyhcInBva2VyIHZhbHVlICBcIiArIHZhbClcclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZSh2YWwsIGNhcmQpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkeeJjGV2ZW5057uT5p2f5omT5byAUG9rZXJTb3J06YCJ54mM55WM6Z2iXHJcbiAgICBvbkFuaW1Db21wbGV0ZWQ6IGZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICBpZihpbmRleCA8IDEgfHwgaW5kZXggPiA1KXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheVNGWCgnZmFwYWknKVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coW2luZGV4LCB0aGlzLl9jdXJTaHVmZmxlSWR4LCB0aGlzLl9wb2tlckxpc3RbaW5kZXgtMV0uY2hpbGRyZW5Db3VudCBdKTtcclxuICAgICAgICB0aGlzLl9wb2tlckxpc3RbaW5kZXgtMV0uY2hpbGRyZW5bdGhpcy5fY3VyU2h1ZmZsZUlkeF0uYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYoaW5kZXggPT0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemUpe1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJTaHVmZmxlSWR4Kys7XHJcbiAgICAgICAgICAgIHZhciBhbmlOYW1lID0gXCJhY19jYXJkbW92ZVwiK2NjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplXHJcbiAgICAgICAgICAgIHRoaXMubW92ZVBva2VyLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnBsYXkoYW5pTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuX2N1clNodWZmbGVJZHggPj0gMTIpe1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVQb2tlci5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKS5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVBva2VyLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblBva2VyLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy/miZPlvIDpgInniYznlYzpnaJcclxuICAgICAgICAgICAgdmFyIHBva2VyU29ydCA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiUG9rZXJTb3J0KTtcclxuICAgICAgICAgICAgLy92YXIgcG9rZXJTb3J0ID0gY2MuZ3VpbWFuYWdlci5vcGVuKFwiUG9rZXJTb3J0XCIpXHJcbiAgICAgICAgICAgIHBva2VyU29ydC5wYXJlbnQgPSB0aGlzLm5vZGU7XHJcbiAgICAgICAgICAgIHBva2VyU29ydC5wb3NpdGlvbiA9IGNjLnYyKDAsIDApOyBcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGl0bGVTaG93KGZhbHNlKVxyXG5cclxuICAgICAgICAgICAgLy90aGlzLl9wb2tlckxpc3RbMF0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9rZXJMaXN0U2hvdyhmYWxzZSlcclxuICAgICAgICAgICAgdGhpcy5zZXRQb2tlckZsb3BTaG93KHRydWUpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBiZWdpbkZsb3A6IGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG5cclxuICAgICAgICBwYXJhbS5fa2Fpc2hpYmlwYWkuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAvL2NjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKFwiVGV4dHVyZXMvRmlnaHQvdG91ZHVuYnBUWFRcIiwgcGFyYW0uX2thaXNoaWJpcGFpKVxyXG4gICAgICAgIC8vY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJNX2thaXNoaWJpcGFpbGluZ3NoZW5nXCIpXHJcbiAgICAgICAgLy9jYy5maW5kKFwiVUlQb2tlckdhbWUvamllc3VhblwiKS5hY3RpdmUgPSB0cnVlXHJcblxyXG4gICAgICAgIHRoaXMubXlIZWFkSWNvbi5nZXRDaGlsZEJ5TmFtZShcImljb25cIikuZ2V0Q2hpbGRCeU5hbWUoXCJ5aXpodW5iZWlcIikuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICBmb3IodmFyIGkgPSAwIDsgaSA8IHRoaXMuX3BsYXllckhlYWRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wbGF5ZXJIZWFkc1tpXVxyXG4gICAgICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKFwiaWNvblwiKS5nZXRDaGlsZEJ5TmFtZShcInlpemh1bmJlaVwiKS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/mmL7npLrmgLvnu5PnrpfpobXpnaJcclxuICAgIHNob3dHYW1lUmVzdWx0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiQmlnSmllc3VhbilcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzLm5vZGVcclxuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IGNjLnYyKDAsIDApOyBcclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoXCJHYW1lUmVzdWx0XCIpLmluaXRpYWxpemVHYW1lUmVzdWx0KGNjLmdhbWVtYW5hZ2VyLmFsbFJvdW5kc0RhdGEpXHJcbiAgICB9LFxyXG5cclxuICAgIGVuZEZsb3A6IGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG4gICAgICAgIHBhcmFtLl9rYWlzaGliaXBhaS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIC8vY2MuZmluZChcIlVJUG9rZXJHYW1lL2ppZXN1YW5cIikuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAvL2NjLlBva2VyVXRpbC5yZXBsYWNlU3ByaXRlKFwiVGV4dHVyZXMvRmlnaHQva2Fpc2hpYmlwYWlUWFRcIiwgcGFyYW0uX2thaXNoaWJpcGFpKVxyXG5cclxuICAgICAgICBwYXJhbS5qaWVzdWFuVG9wLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgcGFyYW0uamllc3Vhbk1pZGVsLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgcGFyYW0uamllc3VhbkJvdHR0b20uYWN0aXZlID0gZmFsc2VcclxuICAgICAgICBwYXJhbS5qaWVzdWFuRGFxaWFuZy5hY3RpdmUgPSBmYWxzZVxyXG5cclxuICAgICAgICAvL+aJk+W8gOe7k+eul+mhtemdolxyXG4gICAgICAgIHZhciByb29tQXR0cj0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHJcclxuICAgICAgICB2YXIgbXljdWlkID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEuY3VpZFxyXG4gICAgICAgIHZhciBjb20gPSBjYy5maW5kKFwiVUlQb2tlckdhbWVcIikuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIilcclxuXHJcbi8qXHJcbiAgICAgICAgaWYoY2MuZ2FtZW1hbmFnZXIuX2N1cnJlbnRSb3VuZHMgPj0gcm9vbUF0dHIucm91bmRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnByZWZhYkJpZ0ppZXN1YW4pXHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gdGhpcy5ub2RlXHJcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBjYy52MigwLCAwKTsgXHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KFwiR2FtZVJlc3VsdFwiKS5pbml0aWFsaXplR2FtZVJlc3VsdChjYy5nYW1lbWFuYWdlci5hbGxSb3VuZHNEYXRhKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiovXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiSmllc3VhbilcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjb20ubm9kZVxyXG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gY2MudjIoMCwgMCk7IFxyXG5cclxuICAgICAgICAgICAgdmFyIGFsbGRhdGEgPSB7fVxyXG4gICAgICAgICAgICBhbGxkYXRhLnNlcnZlcmRhdGEgPSBjb20uX0FsbEhhbmRzRGF0YVxyXG4gICAgICAgICAgICBhbGxkYXRhLmNsaWVudGRhdGEgPSBjb20uX2N1clNjb3JlU3VtbWFyeVxyXG5cclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoXCJTY29yZVN1bW1hcnlcIikuaW5pdGlhbGl6ZShhbGxkYXRhKVxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbS5fQWxsSGFuZHNEYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIGlmKG15Y3VpZC5lcShjb20uX0FsbEhhbmRzRGF0YVtpXS5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLmdldENvbXBvbmVudChcIlNjb3JlU3VtbWFyeVwiKS5zZXRTY29yZShjb20uX0FsbEhhbmRzRGF0YVtpXS5yYW5rKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBteXNjb3JlID0gY29tLl9BbGxIYW5kc0RhdGFbaV0ucmFua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG15c2NvcmUgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJ3aW5cIilcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihteXNjb3JlIDwgMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwibG9zZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbi8qXHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbihcIlNjb3JlU3VtbWFyeVwiLCBmdW5jdGlvbihwYW5lbCl7ICBcclxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5cIiwgY29tLCBjb20uX2N1clNjb3JlU3VtbWFyeSlcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYy5ndWltYW5hZ2VyLmRpc3BhY2hNc2coXCJpbml0aWFsaXplXCIsIGFsbGRhdGEpXHJcbiAgICAgICAgICAgICAgICBjYy5sb2coXCIhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFcIilcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb20uX0FsbEhhbmRzRGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBpZihteWN1aWQuZXEoY29tLl9BbGxIYW5kc0RhdGFbaV0uY3VpZCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIuZGlzcGFjaE1zZyhcInNldFNjb3JlXCIsIGNvbS5fQWxsSGFuZHNEYXRhW2ldLnJhbmspXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgIH0pXHJcbiovXHJcbiAgICAgICAgfSAgIFxyXG4gICAgfSxcclxuXHJcbiAgICAvL+esrOS4gOWiqeavlOWujOS6i+S7tlxyXG4gICAgdG9wRmxvcEVuZDogZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgLy9jYy5Qb2tlclV0aWwucmVwbGFjZVNwcml0ZShcIlRleHR1cmVzL0ZpZ2h0L3pob25nZHVuYnBUWFRcIiwgcGFyYW0uX2thaXNoaWJpcGFpKVxyXG4gICAgICAgIHBhcmFtLmppZXN1YW5Ub3AuYWN0aXZlID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+esrOS6jOWiqeavlOWujOS6i+S7tlxyXG4gICAgbWlkZGxlRmxvcEVuZDogZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgLy9jYy5Qb2tlclV0aWwucmVwbGFjZVNwcml0ZShcIlRleHR1cmVzL0ZpZ2h0L3dlaWR1bmJwVFhUXCIsIHBhcmFtLl9rYWlzaGliaXBhaSlcclxuICAgICAgICBwYXJhbS5qaWVzdWFuTWlkZWwuYWN0aXZlID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+esrOS4ieWiqeavlOWujOS6i+S7tiBcclxuICAgIGJvdHRvbUZsb3BFbmQ6IGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG4gICAgICAgIHBhcmFtLmppZXN1YW5Cb3R0dG9tLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICBwYXJhbS5qaWVzdWFuRGFxaWFuZy5hY3RpdmUgPSB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgIF9zY29yZVN0cjogZnVuY3Rpb24obnVtKXtcclxuICAgICAgICBpZihudW0gPCAwKXtcclxuICAgICAgICAgICAgcmV0dXJuICBudW0udG9TdHJpbmcoKVxyXG4gICAgICAgIH1lbHNlIGlmKG51bSA+IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIrXCIgKyBudW0udG9TdHJpbmcoKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9zZXRTY29yZTogZnVuY3Rpb24obm9kZSwgbmFtZSwgbnVtKXtcclxuICAgICAgICB2YXIgbGIgPSBub2RlLmdldENoaWxkQnlOYW1lKG5hbWUpLmdldENvbXBvbmVudChjYy5MYWJlbClcclxuICAgICAgICBpZihsYil7XHJcbiAgICAgICAgICAgIGxiLnN0cmluZyA9IHRoaXMuX3Njb3JlU3RyKG51bSlcclxuICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2V0U2NvcmVGb250KG51bT49MCwgbGIpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcmVmcmVzaER1blNjb3JlOiBmdW5jdGlvbihkYXRhbGlzdCl7XHJcbiAgICAgICAgdmFyIHNlbGZEYXRhID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGE7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGFsaXN0Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhbGlzdFtpXVxyXG4gICAgICAgICAgICBpZihzZWxmRGF0YS5jdWlkLmVxKGRhdGEuY3VpZCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMuamllc3VhblRvcCwgXCJzY29yZVwiLCBkYXRhLnNjb3JlLnRvcClcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMuamllc3Vhbk1pZGVsLCBcInNjb3JlXCIsIGRhdGEuc2NvcmUubWlkZGxlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U2NvcmUodGhpcy5qaWVzdWFuQm90dHRvbSwgXCJzY29yZVwiLCBkYXRhLnNjb3JlLmJvdHRvbSlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMuamllc3VhbkRhcWlhbmcsIFwic2NvcmVcIiwgZGF0YS5zY29yZS5zcGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5YWo5Z6S5omTYWN0aW9uXHJcbiAgICBfcXVhbmxlaWRhRnVuYzogZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJkYXFpYW5nX3ppZGFuXCIpXHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gcGFyYW1bMF1cclxuICAgICAgICB2YXIgY3VpZCA9IHBhcmFtWzFdXHJcblxyXG4gICAgICAgIHNlbGYucXVhbmxlaWRhTm9kZS56SW5kZXggPSAxMFxyXG4gICAgICAgIHNlbGYucXVhbmxlaWRhTm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgc2VsZi5xdWFubGVpZGFOb2RlLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnBsYXkoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9wb2tlckZsb3BzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGZsb3AgPSBzZWxmLl9wb2tlckZsb3BzW2ldXHJcbiAgICAgICAgICAgIGlmKGZsb3AgJiYgIWN1aWQuZXEoZmxvcC5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICBmbG9wLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKS5zdGFydERhbktvbmdBbmltKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/miZPmnqpcclxuICAgIF9kYXFpYW5nRnVuYzogZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSBwYXJhbVswXVxyXG4gICAgICAgIHZhciBzY3VpZCA9IHBhcmFtWzFdXHJcbiAgICAgICAgdmFyIGRjdWlkID0gcGFyYW1bMl1cclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIucGxheVNGWChcImRhcWlhbmdfemlkYW5cIilcclxuXHJcbiAgICAgICAgdmFyIHNpZHggPSAwXHJcbiAgICAgICAgdmFyIGRpZHggPSAwXHJcbiAgICAgICAgdmFyIHNmbG9wID0gbnVsbFxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBmbG9wID0gc2VsZi5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICAgaWYoZmxvcCAmJiBmbG9wLmN1aWQgJiYgc2N1aWQuZXEoZmxvcC5jdWlkKSl7XHJcbiAgICAgICAgICAgICAgICAgZmxvcC5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIikuc3RhcnREYVFpYW5nQW5pbSgpXHJcbiAgICAgICAgICAgICAgICAgc2lkeCA9IGlcclxuICAgICAgICAgICAgICAgICBzZmxvcCA9IGZsb3BcclxuICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICBpZihmbG9wICYmIGZsb3AuY3VpZCAmJiBkY3VpZC5lcShmbG9wLmN1aWQpKXtcclxuICAgICAgICAgICAgICAgICBmbG9wLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKS5zdGFydERhbktvbmdBbmltKClcclxuICAgICAgICAgICAgICAgICBkaWR4ID0gaVxyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFuZ2xlQXJyID0gbnVsbFxyXG4gICAgICAgIHZhciByb29tX251bSA9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplXHJcbiAgICAgICAgaWYocm9vbV9udW0gPT0gMyl7IGFuZ2xlQXJyID0gY2MuY29uZmlnbWFuYWdlci5kcUFuZ2xlWzNdIH1cclxuICAgICAgICBlbHNlIGlmKHJvb21fbnVtID09IDQpeyBhbmdsZUFyciA9IGNjLmNvbmZpZ21hbmFnZXIuZHFBbmdsZVs0XSB9XHJcbiAgICAgICAgZWxzZSBpZihyb29tX251bSA9PSA1KXsgYW5nbGVBcnIgPSBjYy5jb25maWdtYW5hZ2VyLmRxQW5nbGVbNV0gfVxyXG5cclxuICAgICAgICBpZihhbmdsZUFyciAmJiBzZmxvcCAmJiBhbmdsZUFycltzaWR4XVtkaWR4XSl7XHJcbiAgICAgICAgICAgIHZhciBhZyA9IGFuZ2xlQXJyW3NpZHhdW2RpZHhdXHJcbiAgICAgICAgICAgIHZhciBuZCA9IHNmbG9wLmdldENoaWxkQnlOYW1lKFwic2hvdXFpYW5nXCIpXHJcbiAgICAgICAgICAgIGlmKG5kKXtcclxuICAgICAgICAgICAgICAgIG5kLnJvdGF0aW9uID0gYWcueFxyXG4gICAgICAgICAgICAgICAgbmQuc2NhbGVYID0gYWcueVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aJk+aeque7k+adn1xyXG4gICAgX2RhcWFuZ0VuZDogZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcmFtLl9wb2tlckZsb3BzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGZsb3AgPSBwYXJhbS5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICBpZihmbG9wKXtcclxuICAgICAgICAgICAgICAgIGZsb3AuZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpLmVuZERhbktvbmdBbmltKClcclxuICAgICAgICAgICAgICAgIGZsb3AuZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpLmVuZERhUWlhbmdBbmltKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/mlLbliLDnu5PnrpfniYzmtojmga/vvIzlvIDlp4votbDmr5TniYzmtYHnqItcclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX0FsbEhhbmRzOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGlmKG1zZy5wbGF5ZXJzLmxlbmd0aCAhPSBjYy5nYW1lbWFuYWdlci5yb29tX2luZm8uYXR0ci5wbGF5ZXJfc2l6ZSl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIuaUtuWIsOe7k+eul+eJjOaVsOaNrumUmeivr1wiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIENvcHlBY3Rpb25BcnJheShkc3RBcnIsIHNyY0Fycil7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPOOAgHNyY0Fyci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBkc3RBcnIucHVzaChzcmNBcnJbaV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMud2FpdFN0YXRlTm9kZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy53YWl0U3RhdGVOb2RlLmRlc3Ryb3koKVxyXG4gICAgICAgICAgICB0aGlzLndhaXRTdGF0ZU5vZGUgPSBudWxsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYy5sb2coXCLlvIDlp4vorqHnrpflvpfliIZcIilcclxuICAgICAgICB2YXIgcmV0ID0gY2MuUG9rZXJVdGlsLmNhbGN1bGF0ZVNjb3JlKG1zZylcclxuICAgICAgICB0aGlzLl9jdXJTY29yZVN1bW1hcnkgPSByZXRcclxuXHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaER1blNjb3JlKHRoaXMuX2N1clNjb3JlU3VtbWFyeSlcclxuXHJcbiAgICAgICAgLy/lnKjnu4PkuaDlnLropoHkv53lrZjmlbDmja5cclxuICAgICAgICBpZihjYy5nYW1lbWFuYWdlci5pc1ByYWN0aWNlUm9vbSgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2Mucm9ib3Quc2F2ZU1hdGNoUmVzdWx0KHJldClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZm9yKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSlcclxuICAgICAgICAvL3tcclxuICAgICAgICAvLyAgIGNjLmxvZyhyZXRbaV0uc2NvcmUudG9wLCByZXRbaV0uc2NvcmUubWlkZGxlLCByZXRbaV0uc2NvcmUuYm90dG9tLCByZXRbaV0uc2NvcmUuc3BlKVxyXG4gICAgICAgIC8vfVxyXG5cclxuICAgICAgICBjYy5sb2coXCLnu5PmnZ/orqHnrpfmr5TliIZcIilcclxuXHJcbiAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJNX2thaXNoaWJpcGFpbGluZ3NoZW5nXCIpXHJcblxyXG4gICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YSA9IG1zZy5wbGF5ZXJzXHJcblxyXG4gICAgICAgIC8v5a+554mM5LiJ5aKp6L+b6KGM5o6S5bqPXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5wbGF5ZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYobXNnLnBsYXllcnNbaV0uc3BlYy5icmFuZCA9PSAwKXsgLy/pnZ7nibnmrorniYzlnotcclxuICAgICAgICAgICAgICAgIHZhciBjID0gbXNnLnBsYXllcnNbaV0uY2FyZHNcclxuICAgICAgICAgICAgICAgIHZhciB0cCA9IFtjWzBdLCBjWzFdLCBjWzJdXVxyXG4gICAgICAgICAgICAgICAgdmFyIG1wID0gW2NbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN11dXHJcbiAgICAgICAgICAgICAgICB2YXIgYm8gPSBbY1s4XSwgY1s5XSwgY1sxMF0sIGNbMTFdLCBjWzEyXV1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcnQgPSBbXVxyXG4gICAgICAgICAgICAgICAgdmFyIHRiID0gbXNnLnBsYXllcnNbaV0uZHVuMC5icmFuZFxyXG4gICAgICAgICAgICAgICAgaWYodGIgPT0gMyl7IHJ0ID0gY2MuUG9rZXJVdGlsLnNhbnRpYW8odHApIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGIgPT0gMSl7IHJ0ID0gY2MuUG9rZXJVdGlsLnlpZHVpVGhyZWUodHApfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0YiA9PSAwKXsgcnQgPSBjYy5Qb2tlclV0aWwud3Vsb25nVGhyZWUodHApfVxyXG4gICAgICAgICAgICAgICAgaWYocnQubGVuZ3RoID4gMCAmJiBydFswXS5sZW5ndGggPT0gMyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhID0gY2MuUG9rZXJVdGlsLmNhcmRzRW5jb2RlKHJ0WzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YVtpXS5jYXJkc1swXSA9IGNhWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fQWxsSGFuZHNEYXRhW2ldLmNhcmRzWzFdID0gY2FbMV1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9BbGxIYW5kc0RhdGFbaV0uY2FyZHNbMl0gPSBjYVsyXVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYiA9IG1zZy5wbGF5ZXJzW2ldLmR1bjEuYnJhbmRcclxuICAgICAgICAgICAgICAgIHZhciBtcmV0ID0gY2MuUG9rZXJVdGlsLnQ1R3JvdXBbOS1tYl0obXApXHJcbiAgICAgICAgICAgICAgICBpZihtcmV0Lmxlbmd0aCA+IDAgJiYgbXJldFswXS5sZW5ndGggPT0gNSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhID0gY2MuUG9rZXJVdGlsLmNhcmRzRW5jb2RlKG1yZXRbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fQWxsSGFuZHNEYXRhW2ldLmNhcmRzWzNdID0gY2FbMF1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9BbGxIYW5kc0RhdGFbaV0uY2FyZHNbNF0gPSBjYVsxXVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YVtpXS5jYXJkc1s1XSA9IGNhWzJdXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fQWxsSGFuZHNEYXRhW2ldLmNhcmRzWzZdID0gY2FbM11cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9BbGxIYW5kc0RhdGFbaV0uY2FyZHNbN10gPSBjYVs0XVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiYiA9IG1zZy5wbGF5ZXJzW2ldLmR1bjIuYnJhbmRcclxuICAgICAgICAgICAgICAgIHZhciBicmV0ID0gY2MuUG9rZXJVdGlsLnQ1R3JvdXBbOS1iYl0oYm8pXHJcbiAgICAgICAgICAgICAgICBpZihicmV0Lmxlbmd0aCA+IDAgJiYgYnJldFswXS5sZW5ndGggPT0gNSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhID0gY2MuUG9rZXJVdGlsLmNhcmRzRW5jb2RlKGJyZXRbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fQWxsSGFuZHNEYXRhW2ldLmNhcmRzWzhdID0gY2FbMF1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9BbGxIYW5kc0RhdGFbaV0uY2FyZHNbOV0gPSBjYVsxXVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YVtpXS5jYXJkc1sxMF0gPSBjYVsyXVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YVtpXS5jYXJkc1sxMV0gPSBjYVszXVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0FsbEhhbmRzRGF0YVtpXS5jYXJkc1sxMl0gPSBjYVs0XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhY3Rpb25zID0gW10sIGFjdGlvbjE9W10sIGFjdGlvbjI9W10sYWN0aW9uMz1bXVxyXG5cclxuICAgICAgICBhY3Rpb25zLnB1c2goY2Muc2VxdWVuY2UoY2MuZGVsYXlUaW1lKDEpLCBjYy5jYWxsRnVuYyh0aGlzLmJlZ2luRmxvcCwgdGhpcywgdGhpcykpKVxyXG5cclxuICAgICAgICB2YXIgc3BlY2lhbHMgPSBbXVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cucGxheWVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBwbGF5ZXJkYXRhID0gbXNnLnBsYXllcnNbaV1cclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEZsb3AocGxheWVyZGF0YS5jdWlkKVxyXG5cclxuICAgICAgICAgICAgaWYocGxheWVyZGF0YS5zcGVjLmJyYW5kID09IDApeyAgLy/pnZ7nibnmrorniYzlnotcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUgJiYgbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIikpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb2VudCA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9lbnQuaW5pdFBva2VyVmFsdWVzKHBsYXllcmRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uMS5wdXNoKGNvbXBvZW50LnRvcEZsb3BBY3Rpb24oY29tcG9lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjIucHVzaChjb21wb2VudC5taWRkbGVGbG9wQWN0aW9uKGNvbXBvZW50KSlcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24zLnB1c2goY29tcG9lbnQuYm90dG9tRmxvcEFjdGlvbihjb21wb2VudCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgLy/nibnmrorniYzlnotcclxuICAgICAgICAgICAgICAgIHZhciBzID0ge31cclxuICAgICAgICAgICAgICAgIHMuZGF0YSA9IHBsYXllcmRhdGFcclxuICAgICAgICAgICAgICAgIHMubm9kZSA9IG5vZGVcclxuICAgICAgICAgICAgICAgIHNwZWNpYWxzLnB1c2gocylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ29weUFjdGlvbkFycmF5KGFjdGlvbnMsIGFjdGlvbjEpXHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKHRoaXMudG9wRmxvcEVuZCwgdGhpcywgdGhpcyksIGNjLmRlbGF5VGltZSgwLjIpKSlcclxuXHJcbiAgICAgICAgQ29weUFjdGlvbkFycmF5KGFjdGlvbnMsIGFjdGlvbjIpXHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKHRoaXMubWlkZGxlRmxvcEVuZCwgdGhpcywgdGhpcyksIGNjLmRlbGF5VGltZSgwLjIpKSlcclxuXHJcbiAgICAgICAgQ29weUFjdGlvbkFycmF5KGFjdGlvbnMsIGFjdGlvbjMpXHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKHRoaXMuYm90dG9tRmxvcEVuZCwgdGhpcywgdGhpcyksIGNjLmRlbGF5VGltZSgwLjIpKSlcclxuXHJcbiAgICAgICAgLy/mkq3lrozmma7pgJrmr5TovoPlkI7mkq3nibnmrorniYzlnotcclxuICAgICAgICBpZihzcGVjaWFscy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNwZWNpYWxzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc3BlY2lhbHNbaV0ubm9kZVxyXG4gICAgICAgICAgICAgICAgaWYobm9kZSAmJiBub2RlLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvZW50ID0gbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIilcclxuICAgICAgICAgICAgICAgICAgICBjb21wb2VudC5pbml0UG9rZXJWYWx1ZXMoc3BlY2lhbHNbaV0uZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goY29tcG9lbnQuc3BlY2lhbEZsb3BBY3Rpb24oY29tcG9lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaChjYy5kZWxheVRpbWUoMC41KSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8v5byA5aeL5omT5p6q5Yqo55S7XHJcbiAgICAgICAgdmFyIHF1YW5sZWlkYUFjdCA9IG51bGxcclxuICAgICAgICB2YXIgZGFxaWFuZ0FjdCA9IFtdXHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIHZhciBicmFuZCA9IHJldFtqXVxyXG4gICAgICAgICAgICBpZihicmFuZC5xdWFubGVpZGEgPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICBpZihxdWFubGVpZGFBY3QgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVhbmxlaWRhQWN0ID0gY2Muc2VxdWVuY2UoY2MuY2FsbEZ1bmMoZnVuY3Rpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIHsgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJNX3F1YW5sZWlkYVwiKSB9LCB0aGlzKSxjYy5kZWxheVRpbWUoMS4wKSwgY2MuY2FsbEZ1bmModGhpcy5fcXVhbmxlaWRhRnVuYywgdGhpcywgW3RoaXMsIGJyYW5kLmN1aWRdKSwgY2MuZGVsYXlUaW1lKDMpLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQsIHBhcmFtKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucXVhbmxlaWRhTm9kZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5xdWFubGVpZGFOb2RlLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnN0b3AoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5fZGFxYW5nRW5kKHRhcmdldCwgcGFyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcywgdGhpcykpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coXCLlh7rplJnkuobvvIzmgI7kuYjkvJrmnInlpJrkuKrlhajlnpLmiZN+fn5cIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihicmFuZC5kYXFpYW5nbGlzdC5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgbSA9IDA7IG0gPCBicmFuZC5kYXFpYW5nbGlzdC5sZW5ndGg7ICsrbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jYy5sb2coXCI9PT09PT09PT09PT09PT1cIiwgdGhpcywgYnJhbmQuY3VpZCwgYnJhbmQuZGFxaWFuZ2xpc3RbbV0pXHJcbiAgICAgICAgICAgICAgICAgICAgZGFxaWFuZ0FjdC5wdXNoKGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKGZ1bmN0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICB7IGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwiTV9kYXFpYW5nXCIpIH0sIHRoaXMpLGNjLmRlbGF5VGltZSgwLjUpLGNjLmNhbGxGdW5jKHRoaXMuX2RhcWlhbmdGdW5jLCB0aGlzLCBbdGhpcywgYnJhbmQuY3VpZCwgYnJhbmQuZGFxaWFuZ2xpc3RbbV1dKSwgY2MuZGVsYXlUaW1lKDAuOCksIGNjLmNhbGxGdW5jKHRoaXMuX2RhcWFuZ0VuZCwgdGhpcywgdGhpcykpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihxdWFubGVpZGFBY3QgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChxdWFubGVpZGFBY3QpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGRhcWlhbmdBY3QubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIENvcHlBY3Rpb25BcnJheShhY3Rpb25zLCBkYXFpYW5nQWN0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKGNjLmNhbGxGdW5jKHRoaXMuZW5kRmxvcCwgdGhpcywgdGhpcykpXHJcbiAgICAgICAgdGhpcy5fa2Fpc2hpYmlwYWkuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIGNjLmxvZyhcIuW8gOWni+aSreaUvuWKqOeUu1wiKVxyXG4gICAgICAgIHRoaXMubm9kZS5ydW5BY3Rpb24oY2Muc2VxdWVuY2UoYWN0aW9ucykpXHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BSZWNvcmQgOiBmdW5jdGlvbihjYW5jZWwpIHtcclxuICAgICAgICBjYy5sb2coJ+e7k+adn+W9lemfsy4uLicpXHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydFJlY29yZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkUGFuZWwuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0UmVjb3JkID0gZmFsc2VcclxuICAgICAgICAgICAgY2MuaW1tYW5hZ2VyLnN0b3BSZWNvcmQoY2FuY2VsKVxyXG4gICAgICAgICAgICAvLyBjYy5hdWRpb21hbmFnZXIucmVzdW1lQWxsKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydFJlY29yZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkdFRpbWUgPSAobmV3IERhdGUoKSAtIHRoaXMuc3RhcnRSZWNvcmRUaW1lKSAvIDEwMDBcclxuICAgICAgICAgICAgaWYgKGR0VGltZSA+PSAxNSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wUmVjb3JkKGZhbHNlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgKz0gZHRcclxuICAgICAgICBpZiAodGhpcy5sYXN0VXBkYXRlVGltZSA+PSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUaW1lKClcclxuICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSAtPSAxXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblN0YXJ0UmVjb3JkIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFJlY29yZFRpbWUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgdGhpcy5yZWNvcmRQYW5lbC5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0UmVjb3JkID0gdHJ1ZVxyXG5cclxuICAgICAgICBjYy5sb2coJ+W8gOWni+W9lemfsy4uLicpXHJcbiAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBhdXNlQWxsKClcclxuICAgICAgICBjYy5pbW1hbmFnZXIuc3RhcnRSZWNvcmQoKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb25DYW5jZWxSZWNvcmQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0b3BSZWNvcmQodHJ1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgb25TdG9wUmVjb3JkIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkKGZhbHNlKVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUaXRsZVNob3c6IGZ1bmN0aW9uKHNob3cpe1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwidGl0bGVcIilcclxuICAgICAgICBpZihub2RlKXtcclxuICAgICAgICAgICAgbm9kZS5hY3RpdmUgPSBzaG93XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUaW1lIDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICAgIHRoaXMudGltZUxhYmVsLnN0cmluZyA9IGRhdGUuRm9ybWF0KFwieXl5eS1NTS1kZCBoaDptbTpzc1wiKVxyXG4gICAgfSxcclxuXHJcbiAgICBzaGFyZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwbGF5ZXIgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YVxyXG5cclxuICAgICAgICB2YXIgcm9vbV9pbmZvID0gY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvXHJcbiAgICAgICAgdmFyIGF0dHIgPSByb29tX2luZm8uYXR0clxyXG4gICAgICAgIHZhciB0aXRsZSA9ICfmlpfpmLXljYHkuInmsLQoJy5jb25jYXQoU3RyaW5nKGF0dHIucGxheWVyX3NpemUpLCfkurrlnLopJylcclxuICAgICAgICB2YXIgdGV4dCA9ICfjgJDmiL/lj7c6Jy5jb25jYXQoU3RyaW5nKHJvb21faW5mby5yb29tX2lkKSwn44CR44CQ5bGA5pWwOicsYXR0ci5yb3VuZHMsJ+WxgOOAkScpXHJcbiAgICAgICAgY2MubG9nKFwiYXR0ci5wbGF5X3R5cGUgOlwiICsgYXR0ci5wbGF5X3R5cGUgKVxyXG4gICAgICAgIGlmIChhdHRyLnBsYXlfdHlwZSA9PSA2NSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0ICsgJ+OAkOWkmuS4gOiJsueOqeazleOAkSdcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQgKyAn44CQ5pmu6YCa546p5rOV44CRJ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGF0dHIucGF5b3IgPT0gMTApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArICfjgJDluoTlrrbmlK/ku5jjgJEnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0dHIucGF5b3IgPT0gMTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArICfjgJDlnYfmkYrmlK/ku5jjgJEnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0dHIucGF5b3IgPT0gMTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArICfjgJDlpKfotaLlrrbmlK/ku5jjgJEnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXR0ci5kYV9xaWFuZyA9PSAzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQgKyAn44CQ5omT5p6qKzPpgZPjgJEnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0ICsgJ+OAkOaJk+aequWPjOWAjeOAkSdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhdHRyLnF1YW5fbGVpX2RhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQgKyAn44CQ5YWo5Z6S5omT44CRJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNoYXJlVG9XZWl4aW5GcmllbmQodGl0bGUsdGV4dClcclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG59KTtcclxuIiwicmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgXHRwYWdlSUQgOiAwLFxyXG4gICAgXHRpdGVtczpjYy5Ob2RlLFxyXG4gICAgICAgIHRvdGFsVG9kYXlMYWJlbDpjYy5MYWJlbCxcclxuICAgICAgICBzY29yZVRvZGF5TGFibGU6Y2MuTGFiZWwsXHJcbiAgICAgICAgdG90YWxXZWVrTGFiZWw6Y2MuTGFiZWwsXHJcbiAgICAgICAgc2NvcmVXZWVrTGFiZWw6Y2MuTGFiZWwsXHJcbiAgICAgICAgYnRuVXA6Y2MuQnV0dG9uLFxyXG4gICAgICAgIGJ0bkRvd246Y2MuQnV0dG9uLFxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNyZWF0ZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZyhcIlB1YmxpY1Byb3RvLkNfRzEzX1JlcUdhbWVIaXN0b3J5Q291bnRcIilcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKSBcclxuXHJcbiAgICAgICAgLy/or7fmsYLmjpLlkI1cclxuICAgIFx0dGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICByZXF1aXJlUGFnZSA6IGZ1bmN0aW9uKGV2ZW50LHBhZ2Upe1xyXG4gICAgICAgIHRoaXMubG9ja0J1dHRvbih0cnVlKVxyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZyhcIlB1YmxpY1Byb3RvLkNfRzEzX1JlcUdhbWVIaXN0b3J5RGV0aWFsXCIpXHJcbiAgICAgICAgbXNnLnBhZ2UgPSB0aGlzLnBhZ2UgKyBwYXJzZUludChwYWdlKVxyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIuc2VuZChtc2cpIFxyXG4gICAgICAgIHRoaXMucGFnZSA9IG1zZy5wYWdlXHJcbiAgICAgICAgY2MubG9nKFwicGFnZTpcIiArIHRoaXMucGFnZSlcclxuICAgIH0sXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfR2FtZUhpc3RvcnlDb3VudCA6IGZ1bmN0aW9uKG1zZykge1xyXG5cclxuICAgICAgICB0aGlzLnRvdGFsVG9kYXlMYWJlbC5zdHJpbmcgPSBTdHJpbmcobXNnLnRvZGF5X2dhbWUpXHJcbiAgICAgICAgdGhpcy5zY29yZVRvZGF5TGFibGUuc3RyaW5nID0gU3RyaW5nKG1zZy50b2RheV9yYW5rKVxyXG4gICAgICAgIHRoaXMudG90YWxXZWVrTGFiZWwuc3RyaW5nID0gU3RyaW5nKG1zZy53ZWVrX2dhbWUpXHJcbiAgICAgICAgdGhpcy5zY29yZVdlZWtMYWJlbC5zdHJpbmcgPSBTdHJpbmcobXNnLndlZWtfcmFuaylcclxuXHJcbiAgICAgICAgdGhpcy5tc2dEYXRhID0gbXNnXHJcblxyXG4gICAgICAgIHRoaXMubWF4UGFnZSA9IE1hdGguY2VpbChtc2cudG90YWwgLyA0KVxyXG4gICAgICAgIGlmICh0aGlzLm1heFBhZ2UgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wYWdlID0gMFxyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVQYWdlKG51bGwsMClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGxvY2tCdXR0b24gOiBmdW5jdGlvbihsb2NrKSB7XHJcbiAgICAgICAgaWYgKGxvY2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ0blVwLmludGVyYWN0YWJsZSAgID0gZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5idG5Eb3duLmludGVyYWN0YWJsZSA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2UgPCB0aGlzLm1heFBhZ2UgLSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bkRvd24uaW50ZXJhY3RhYmxlID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2UgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ0blVwLmludGVyYWN0YWJsZSA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfR2FtZUhpc3RvcnlEZXRpYWwgOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGNjLmxvZyhcIm1zZy5pdGVtczpcIiArIG1zZy5pdGVtcy5sZW5ndGgpXHJcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0dmFyIGNoaWxkID0gdGhpcy5pdGVtcy5nZXRDaGlsZEJ5TmFtZShpLnRvU3RyaW5nKCkpXHJcbiAgICBcdFx0aWYgKGNoaWxkKVxyXG4gICAgXHRcdHtcclxuICAgIFx0XHRcdHZhciBpdGVtID0gY2hpbGQuZ2V0Q29tcG9uZW50KCdSZWNvcmRJdGVtJylcclxuICAgIFx0XHRcdGlmIChpdGVtKVxyXG4gICAgXHRcdFx0e1xyXG4gICAgXHRcdFx0XHRpdGVtLnNldERhdGEobXNnLml0ZW1zW2ldKS8vbXNnLmhpc3RvcnlbaV0pXHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICAgICAgdGhpcy5sb2NrQnV0dG9uKGZhbHNlKVxyXG4gICAgfVxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuICAgIFxyXG4gICAgcHJvcGVydGllcyA6IHtcclxuICAgICAgICBtdXNpY0JhcjpjYy5Qcm9ncmVzc0JhcixcclxuICAgICAgICBlZmZlY3RCYXI6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgbXVzaWNTbGlkZXI6Y2MuU2xpZGVyLFxyXG4gICAgICAgIGVmZmVjdFNsaWRlcjpjYy5TbGlkZXIsXHJcbiAgICAgICAgbXVzaWNJY29uOmNjLk5vZGUsXHJcbiAgICAgICAgZWZmZWN0SWNvbjpjYy5Ob2RlLFxyXG4gICAgICAgIGJ0bkxhYmVsOmNjLkxhYmVsXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ3JlYXRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGJnVmFsdWUgPWNjLmF1ZGlvbWFuYWdlci5nZXRCR01Wb2x1bWUoKVxyXG4gICAgICAgIHRoaXMuc2V0TXVzaWNQZXIoYmdWYWx1ZSlcclxuICAgICAgICB0aGlzLnVwYXRlTXVzaWMoYmdWYWx1ZSlcclxuXHJcbiAgICAgICAgdmFyIGVmVmFsdWUgPSBjYy5hdWRpb21hbmFnZXIuZ2V0U0ZYVm9sdW1lKClcclxuICAgICAgICB0aGlzLnNldEVmZmVjdFBlcihlZlZhbHVlKVxyXG4gICAgICAgIHRoaXMudXBhdGVFZmZlY3QoZWZWYWx1ZSlcclxuXHJcbiAgICAgICAgaWYgKGNjLnNjZW5lbWFuYWdlci5pc1Bva2VyR2FtZVNjZW5lKCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ0bkxhYmVsLnN0cmluZyA9IFwi6YCA5Ye65oi/6Ze0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5idG5MYWJlbC5zdHJpbmcgPSBcIuWIh+aNoui0puWPt1wiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdXBlcigpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xvc2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIuc2F2ZSgpXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVJY29uOiBmdW5jdGlvbihpY29uTm9kZSx2YWx1ZSkge1xyXG4gICAgXHR0aGlzLnNlbGVjdChpY29uTm9kZSx2YWx1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgdXBhdGVNdXNpYzpmdW5jdGlvbihwcm9ncmVzcykge1xyXG4gICAgICAgIHRoaXMubXVzaWNCYXIucHJvZ3Jlc3MgPSBwcm9ncmVzc1xyXG4gICAgICAgIGlmIChwcm9ncmVzcyA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVJY29uKHRoaXMubXVzaWNJY29uLDApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWNvbih0aGlzLm11c2ljSWNvbiwxKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBhdGVFZmZlY3Q6ZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcclxuICAgICAgICB0aGlzLmVmZmVjdEJhci5wcm9ncmVzcyA9IHByb2dyZXNzXHJcbiAgICAgICAgaWYgKHByb2dyZXNzID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUljb24odGhpcy5lZmZlY3RJY29uLDApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWNvbih0aGlzLmVmZmVjdEljb24sMSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uTXVzaWNDaGFuZ2U6ZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICBcdHZhciBwcm9ncmVzcyA9IHRhcmdldC5wcm9ncmVzc1xyXG4gICAgICAgIHRoaXMudXBhdGVNdXNpYyhwcm9ncmVzcylcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIuc2V0QkdNVm9sdW1lKHByb2dyZXNzKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkVmZmVjdENoYW5nZTpmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgIFx0dmFyIHByb2dyZXNzID0gdGFyZ2V0LnByb2dyZXNzXHJcbiAgICAgICAgdGhpcy51cGF0ZUVmZmVjdChwcm9ncmVzcylcclxuICAgICAgICBjYy5hdWRpb21hbmFnZXIuc2V0U0ZYVm9sdW1lKHByb2dyZXNzKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYW5nZVVJRDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmIChjYy5zY2VuZW1hbmFnZXIuaXNQb2tlckdhbWVTY2VuZSgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5nYW1lbWFuYWdlci5naXZldXAoKVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZVwiKVxyXG4gICAgICAgICAgICBpZihub2RlICYmIG5vZGUuZ2V0Q29tcG9uZW50KFwiVUlQb2tlckdhbWVcIikpe1xyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoXCJVSVBva2VyR2FtZVwiKS5naXZldXAoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgLy9UT0RPOuWIh+aNoui0puWPt1xyXG4gICAgICAgICAgIGNjLm5ldG1hbmFnZXIubG9naW5PdXQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TXVzaWNQZXI6ZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4oMSxNYXRoLm1heCh2YWx1ZSwwKSk7XHJcbiAgICBcdHRoaXMubXVzaWNTbGlkZXIucHJvZ3Jlc3MgPSB2YWx1ZVxyXG4gICAgICAgIC8vIHRoaXMubXVzaWNCYXIucHJvZ3Jlc3MgPSB2YWx1ZVxyXG4gICAgICAgIC8vIGNjLmxvZygnc2V0TXVzaWNQZXI6JyArIHZhbHVlKVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFZmZlY3RQZXI6ZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4oMSxNYXRoLm1heCh2YWx1ZSwwKSlcclxuICAgIFx0dGhpcy5lZmZlY3RTbGlkZXIucHJvZ3Jlc3MgPSB2YWx1ZTtcclxuICAgICAgICAvLyB0aGlzLmVmZmVjdEJhci5wcm9ncmVzcyA9IHZhbHVlXHJcbiAgICAgICAgLy8gY2MubG9nKCdzZXRFZmZlY3RQZXI6JyArIHZhbHVlKVxyXG4gICAgfVxyXG5cclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBiZWZvclNoYXJlIDogZnVuY3Rpb24oKVxyXG4gICAge1xyXG4gICAgXHR0aGlzLmNsb3NlKClcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHlwZSA6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICB0aGlzLnNoYXJlVHlwZSA9IHR5cGVcclxuICAgIH0sXHJcblxyXG4gICAgU2hhcmVUb1Jpbmc6IGZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgIFx0dGhpcy5iZWZvclNoYXJlKClcclxuICAgICAgICBpZiAodGhpcy5zaGFyZVR5cGUgPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIuc2hhcmVTY3JlZW5Ub1dlaVhpblJpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5uZXRtYW5hZ2VyLnNoYXJlVG9XZWlYaW5SaW5nKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFNoYXJlVG9GcmllbmQ6IGZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgIFx0dGhpcy5iZWZvclNoYXJlKClcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2hhcmVUeXBlID09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5uZXRtYW5hZ2VyLnNoYXJlU2NyZWVuVG9XZWlYaW5GcmllbmQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5uZXRtYW5hZ2VyLnNoYXJlVG9XZWl4aW5GcmllbmQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgbXNnVGV4dDpjYy5MYWJlbCxcclxuICAgICAgICBva0J0bjpjYy5Ob2RlLFxyXG4gICAgICAgIGNhbmNlbEJ0bjogY2MuTm9kZSxcclxuICAgICAgICBpbWc6Y2MuU3ByaXRlXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNwZWljYWwgOiBmdW5jdGlvbihjb20sIGlkLCBwb2tlckRhdGEpIHtcclxuICAgICAgICB0aGlzLl9zcGVjaWFsQ2FyZCA9IHBva2VyRGF0YVxyXG4gICAgICAgIHRoaXMuX3BhcmVudENvbSA9IGNvbVxyXG5cclxuICAgICAgICB2YXIgY2ZnID0gY2MuY29uZmlnbWFuYWdlci5zcGVjaWFsRmxvcENmZ1sxMy1pZF1cclxuICAgICAgICBpZihjZmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3ByID0gdGhpcy5pbWdcclxuICAgICAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoY2ZnLnRleHJlcywgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICAgICAgc3ByLnNwcml0ZUZyYW1lID0gc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbk9LIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fcGFyZW50Q29tLnNlbmRTcGVjaWFsQ2FyZCgpXHJcblxyXG4gICAgICAgIC8vdGhpcy5jbG9zZSgpXHJcbiAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNhbmNlbDpmdW5jdGlvbigpIHtcclxuICAgICAgICAvL3RoaXMuY2xvc2UoKVxyXG4gICAgICAgIHRoaXMubm9kZS5kZXN0cm95KClcclxuICAgIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgbmFtZUxhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICBpZExhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICBpcExhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICBoZWFkTm9kZTogY2MuTm9kZSxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFVzZXJJbmZvOiBmdW5jdGlvbihwbGF5ZXJkYXRhKXtcclxuICAgICAgICB0aGlzLm5hbWVMYWJlbC5zdHJpbmcgPSBwbGF5ZXJkYXRhLm5hbWVcclxuICAgICAgICB0aGlzLmlkTGFiZWwuc3RyaW5nID0gXCJJRDogIFwiICsgcGxheWVyZGF0YS5jdWlkLnRvU3RyaW5nKClcclxuICAgICAgICB0aGlzLmlwTGFiZWwuc3RyaW5nID0gXCJJUDogIFwiICsgcGxheWVyZGF0YS5pcHN0ci50b1N0cmluZygpXHJcbiAgICAgICAgY2MuZGF0YW1hbmFnZXIubG9hZEhlYWRJbWcocGxheWVyZGF0YS5pbWd1cmwsIHRoaXMuaGVhZE5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIHRpcDpjYy5SaWNoVGV4dCxcclxuICAgICAgIGJ0bnM6Y2MuTm9kZSxcclxuICAgICAgIHZvdGVJdGVtczpjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIG9uU2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSBjYy5nYW1lbWFuYWdlci52b3RlSW5mb1xyXG4gICAgICAgIHRoaXMucmVtYWluX3NlY29uZHMgID0gaW5mby5yZW1haW5fc2Vjb25kc1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKVxyXG4gICAgICAgIHRoaXMudXBkYXRlX3N0YXJ0X3RpbWUgPSBkLmdldFRpbWUoKSAvIDEwMDBcclxuICAgICAgICB0aGlzLnZvdGVTcG9uc29yTmFtZSA9IGNjLmdhbWVtYW5hZ2VyLmdldFBsYXllcihpbmZvLnNwb25zb3IpLm5hbWVcclxuICAgICAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZSgpXHJcbiAgICAgICAgICAgIHZhciBzID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgICAgICBzLnNjaGVkdWxlKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVRpbWUoKVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzLm5vZGUsMSx0aGlzLnJlbWFpbl9zZWNvbmRzLDEsZmFsc2UpXHJcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZSA9IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVm90ZShpbmZvKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25DbG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wVXBkYXRlVGltZSgpXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUaW1lOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKVxyXG4gICAgICAgIGNjLmxvZygndGhpcy5yZW1haW5fc2Vjb25kczonICsgdGhpcy5yZW1haW5fc2Vjb25kcylcclxuICAgICAgICB2YXIgdGltZSA9IE1hdGgubWF4KDAsTWF0aC5mbG9vcih0aGlzLnJlbWFpbl9zZWNvbmRzIC0gKGQuZ2V0VGltZSgpIC8gMTAwMCAtIHRoaXMudXBkYXRlX3N0YXJ0X3RpbWUpKSlcclxuXHJcbiAgICAgICAgdGhpcy50aXAuc3RyaW5nID0gJzxjb2xvcj0jMDBmZjAwPueOqeWutjxjb2xvcj0jMGZmZmZmPicuY29uY2F0KHRoaXMudm90ZVNwb25zb3JOYW1lLFxyXG4gICAgICAgICc8L2NvbG9yPueUs+ivt+ino+aVo+aIv+mXtCAo5Ymp5L2ZPGNvbG9yPSMwZmZmZmY+JyxTdHJpbmcodGltZSksXHJcbiAgICAgICAgJzwvY29sb3I+56eSLOi2heaXtuacquWQjOaEj+m7mOiupOWQjOaEjyk8L2M+Jyk7XHJcbiAgICAgICAgaWYgKHRpbWUgPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFVwZGF0ZVRpbWUoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RvcFVwZGF0ZVRpbWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBjYy5kaXJlY3Rvci5nZXRTY2hlZHVsZXIoKTtcclxuICAgICAgICAgICAgcy51bnNjaGVkdWxlQWxsRm9yVGFyZ2V0KHRoaXMubm9kZSkgXHJcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZSA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZvdGU6ZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgIC8v5pu05paw5oqV56WoXHJcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52b3RlSXRlbXMuY2hpbGRyZW5Db3VudFxyXG4gICAgICAgIHZhciBjcyA9IHRoaXMudm90ZUl0ZW1zLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBteXVpZCA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSA8IGluZm8udm90ZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXl1aWQuZXEoaW5mby52b3Rlc1tpXS5jdWlkKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ0bnMuYWN0aXZlID0gaW5mby52b3Rlc1tpXS52b3RlID09IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVm90ZUl0ZW0oY3NbaV0saW5mby52b3Rlc1tpXSlcclxuICAgICAgICAgICAgICAgIGNzW2ldLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNzW2ldLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHZvdGVUb1N0cmluZzogZnVuY3Rpb24odm90ZSkge1xyXG4gICAgICAgIGlmICh2b3RlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxjb2xvcj0jNTk4QkQwPuetieW+heaKleelqDwvYz4nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZvdGUgPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPGNvbG9yPSM2RUQ5MDE+5ZCM5oSPPC9jPidcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmF0ZSA9PSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8Y29sb3I9I2ZmMDAwMD7mi5Lnu508L2M+J1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVm90ZUl0ZW06ZnVuY3Rpb24oaXRlbSxpbmZvKSB7XHJcbiAgICAgICAgdmFyIG5hbWVOb2RlID0gaXRlbS5nZXRDaGlsZEJ5TmFtZSgnbmFtZScpXHJcbiAgICAgICAgdmFyIHN0YXRlTm9kZSA9IGl0ZW0uZ2V0Q2hpbGRCeU5hbWUoJ3N0YXRlJylcclxuICAgICAgICB2YXIgc3RhdGVMYWJlbCA9IHN0YXRlTm9kZS5nZXRDb21wb25lbnQoY2MuUmljaFRleHQpXHJcbiAgICAgICAgbmFtZU5vZGUuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIoaW5mby5jdWlkKS5uYW1lXHJcbiAgICAgICAgc3RhdGVMYWJlbC5zdHJpbmcgPSB0aGlzLnZvdGVUb1N0cmluZyhpbmZvLnZvdGUpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnVzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy/mi5Lnu51cclxuICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coJ1B1YmxpY1Byb3RvLkNfRzEzX1ZvdGVGb0Fib3J0R2FtZScpXHJcbiAgICAgICAgbXNnLnZvdGUgPSAyXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICB0aGlzLmJ0bnMuYWN0aXZlID0gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgYWdyZWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZygnUHVibGljUHJvdG8uQ19HMTNfVm90ZUZvQWJvcnRHYW1lJylcclxuICAgICAgICBtc2cudm90ZSA9IDFcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG4gICAgICAgIHRoaXMuYnRucy5hY3RpdmUgPSBmYWxzZVxyXG4gICAgfVxyXG4gICAgXHJcbn0pO1xyXG4iLCJcclxucmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgd2FpdExhYmVsOmNjLkxhYmVsXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRNZXNzYWdlOmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgdGhpcy53YWl0TGFiZWwuc3RyaW5nID0gbXNnXHJcbiAgICB9XHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgdXNlcm5hbWU6IGNjLkxhYmVsLFxyXG4gICAgICAgd2lubnVtOiBjYy5MYWJlbCxcclxuICAgICAgIGRhcWlhbmdudW06IGNjLkxhYmVsLFxyXG4gICAgICAgcXVhbmxlaWRhbnVtOiBjYy5MYWJlbCxcclxuICAgICAgIHpvbmdmZW46IGNjLkxhYmVsLFxyXG4gICAgICAgd2luc3RhdGU6IGNjLk5vZGUsXHJcbiAgICAgICBsb3Nlc3RhdGU6IGNjLk5vZGUsXHJcbiAgICAgICB0b3V4aWFuZzogY2MuTm9kZSxcclxuICAgICAgIHVzZXJpZDogY2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBfc2NvcmVTdHI6IGZ1bmN0aW9uKG51bSl7XHJcblxyXG4gICAgICAgIGlmKG51bSA8IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtLnRvU3RyaW5nKClcclxuICAgICAgICB9ZWxzZSBpZihudW0gPiAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiK1wiICsgbnVtLnRvU3RyaW5nKClcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMFwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfc2V0U2NvcmUobGIsIG51bSl7XHJcbiAgICAgICAgbGIuc3RyaW5nID0gdGhpcy5fc2NvcmVTdHIobnVtKVxyXG4gICAgICAgIGNjLmRhdGFtYW5hZ2VyLnNldFNjb3JlRm9udChudW0+PTAsIGxiKVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB2YXIgcGxheWVyID0gY2MuZ2FtZW1hbmFnZXIuZ2V0UGxheWVyKGRhdGEuY3VpZClcclxuICAgICAgICBpZihwbGF5ZXIgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUuc3RyaW5nID0gcGxheWVyLm5hbWVcclxuICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIubG9hZEhlYWRJbWcocGxheWVyLmltZ3VybCwgdGhpcy50b3V4aWFuZy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aW5udW0uc3RyaW5nID0gZGF0YS53aW4udG9TdHJpbmcoKVxyXG4gICAgICAgIHRoaXMuZGFxaWFuZ251bS5zdHJpbmcgPSBkYXRhLmRhcWlhbmcudG9TdHJpbmcoKVxyXG4gICAgICAgIHRoaXMucXVhbmxlaWRhbnVtLnN0cmluZyA9IGRhdGEucXVhbmxlaWRhLnRvU3RyaW5nKClcclxuICAgICAgICAvL3RoaXMuem9uZ2Zlbi5zdHJpbmcgPSBkYXRhLnJhbmsudG9TdHJpbmcoKVxyXG4gICAgICAgIHRoaXMudXNlcmlkLnN0cmluZyA9IGRhdGEuY3VpZC50b1N0cmluZygpXHJcblxyXG4gICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMuem9uZ2ZlbiwgZGF0YS5yYW5rKVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTdGF0ZTpmdW5jdGlvbih3aW4sIGxvc2Upe1xyXG4gICAgICAgIHRoaXMud2luc3RhdGUuYWN0aXZlID0gd2luXHJcbiAgICAgICAgdGhpcy5sb3Nlc3RhdGUuYWN0aXZlID0gbG9zZVxyXG4gICAgfVxyXG59KTtcclxuIiwiLypcclxuIGJ5dGVidWZmZXIuanMgKGMpIDIwMTUgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIEJhY2tpbmcgYnVmZmVyOiBBcnJheUJ1ZmZlciwgQWNjZXNzb3I6IFVpbnQ4QXJyYXlcclxuIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vYnl0ZWJ1ZmZlci5qcyBmb3IgZGV0YWlsc1xyXG4qL1xyXG4oZnVuY3Rpb24oayxtKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJsb25nXCJdLG0pO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHJlcXVpcmUmJlwib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiZtb2R1bGUmJm1vZHVsZS5leHBvcnRzKXt2YXIgcj1tb2R1bGUsczt0cnl7cz1yZXF1aXJlKFwibG9uZ1wiKX1jYXRjaCh1KXt9cz1tKHMpO3IuZXhwb3J0cz1zfWVsc2Uoay5kY29kZUlPPWsuZGNvZGVJT3x8e30pLkJ5dGVCdWZmZXI9bShrLmRjb2RlSU8uTG9uZyl9KSh0aGlzLGZ1bmN0aW9uKGspe2Z1bmN0aW9uIG0oYSl7dmFyIGI9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYjxhLmxlbmd0aD9hLmNoYXJDb2RlQXQoYisrKTpudWxsfX1mdW5jdGlvbiByKCl7dmFyIGE9W10sYj1bXTtyZXR1cm4gZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gYi5qb2luKFwiXCIpK3cuYXBwbHkoU3RyaW5nLGEpOzEwMjQ8YS5sZW5ndGgrXHJcbmFyZ3VtZW50cy5sZW5ndGgmJihiLnB1c2gody5hcHBseShTdHJpbmcsYSkpLGEubGVuZ3RoPTApO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEsYXJndW1lbnRzKX19ZnVuY3Rpb24gcyhhLGIsYyxkLGYpe3ZhciBsO2w9OCpmLWQtMTt2YXIgZz0oMTw8bCktMSxlPWc+PjEsaD0tNztmPWM/Zi0xOjA7dmFyIGs9Yz8tMToxLHA9YVtiK2ZdO2YrPWs7Yz1wJigxPDwtaCktMTtwPj49LWg7Zm9yKGgrPWw7MDxoO2M9MjU2KmMrYVtiK2ZdLGYrPWssaC09OCk7bD1jJigxPDwtaCktMTtjPj49LWg7Zm9yKGgrPWQ7MDxoO2w9MjU2KmwrYVtiK2ZdLGYrPWssaC09OCk7aWYoMD09PWMpYz0xLWU7ZWxzZXtpZihjPT09ZylyZXR1cm4gbD9OYU46SW5maW5pdHkqKHA/LTE6MSk7bCs9TWF0aC5wb3coMixkKTtjLT1lfXJldHVybihwPy0xOjEpKmwqTWF0aC5wb3coMixjLWQpfWZ1bmN0aW9uIHUoYSxiLGMsZCxmLGwpe3ZhciBnLGU9OCpsLWYtMSxoPSgxPDxlKS0xLGs9aD4+MSxwPTIzPT09Zj9cclxuTWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO2w9ZD8wOmwtMTt2YXIgbT1kPzE6LTEsbj0wPmJ8fDA9PT1iJiYwPjEvYj8xOjA7Yj1NYXRoLmFicyhiKTtpc05hTihiKXx8SW5maW5pdHk9PT1iPyhiPWlzTmFOKGIpPzE6MCxkPWgpOihkPU1hdGguZmxvb3IoTWF0aC5sb2coYikvTWF0aC5MTjIpLDE+YiooZz1NYXRoLnBvdygyLC1kKSkmJihkLS0sZyo9MiksYj0xPD1kK2s/YitwL2c6YitwKk1hdGgucG93KDIsMS1rKSwyPD1iKmcmJihkKyssZy89MiksZCtrPj1oPyhiPTAsZD1oKToxPD1kK2s/KGI9KGIqZy0xKSpNYXRoLnBvdygyLGYpLGQrPWspOihiPWIqTWF0aC5wb3coMixrLTEpKk1hdGgucG93KDIsZiksZD0wKSk7Zm9yKDs4PD1mO2FbYytsXT1iJjI1NSxsKz1tLGIvPTI1NixmLT04KTtkPWQ8PGZ8Yjtmb3IoZSs9ZjswPGU7YVtjK2xdPWQmMjU1LGwrPW0sZC89MjU2LGUtPTgpO2FbYytsLW1dfD0xMjgqbn12YXIgaD1mdW5jdGlvbihhLGIsYyl7XCJ1bmRlZmluZWRcIj09PVxyXG50eXBlb2YgYSYmKGE9aC5ERUZBVUxUX0NBUEFDSVRZKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPWguREVGQVVMVF9FTkRJQU4pO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9aC5ERUZBVUxUX05PQVNTRVJUKTtpZighYyl7YXw9MDtpZigwPmEpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHlcIik7Yj0hIWI7Yz0hIWN9dGhpcy5idWZmZXI9MD09PWE/djpuZXcgQXJyYXlCdWZmZXIoYSk7dGhpcy52aWV3PTA9PT1hP251bGw6bmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO3RoaXMub2Zmc2V0PTA7dGhpcy5tYXJrZWRPZmZzZXQ9LTE7dGhpcy5saW1pdD1hO3RoaXMubGl0dGxlRW5kaWFuPWI7dGhpcy5ub0Fzc2VydD1jfTtoLlZFUlNJT049XCI1LjAuMVwiO2guTElUVExFX0VORElBTj0hMDtoLkJJR19FTkRJQU49ITE7aC5ERUZBVUxUX0NBUEFDSVRZPTE2O2guREVGQVVMVF9FTkRJQU49aC5CSUdfRU5ESUFOO2guREVGQVVMVF9OT0FTU0VSVD0hMTtoLkxvbmc9a3x8XHJcbm51bGw7dmFyIGU9aC5wcm90b3R5cGU7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2lzQnl0ZUJ1ZmZlcl9fXCIse3ZhbHVlOiEwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExfSk7dmFyIHY9bmV3IEFycmF5QnVmZmVyKDApLHc9U3RyaW5nLmZyb21DaGFyQ29kZTtoLmFjY2Vzc29yPWZ1bmN0aW9uKCl7cmV0dXJuIFVpbnQ4QXJyYXl9O2guYWxsb2NhdGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgaChhLGIsYyl9O2guY29uY2F0PWZ1bmN0aW9uKGEsYixjLGQpe2lmKFwiYm9vbGVhblwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYilkPWMsYz1iLGI9dm9pZCAwO2Zvcih2YXIgZj0wLGw9MCxnPWEubGVuZ3RoLGU7bDxnOysrbCloLmlzQnl0ZUJ1ZmZlcihhW2xdKXx8KGFbbF09aC53cmFwKGFbbF0sYikpLGU9YVtsXS5saW1pdC1hW2xdLm9mZnNldCwwPGUmJihmKz1lKTtpZigwPT09ZilyZXR1cm4gbmV3IGgoMCxjLGQpO2I9bmV3IGgoZixjLGQpO2ZvcihsPVxyXG4wO2w8ZzspYz1hW2wrK10sZT1jLmxpbWl0LWMub2Zmc2V0LDA+PWV8fChiLnZpZXcuc2V0KGMudmlldy5zdWJhcnJheShjLm9mZnNldCxjLmxpbWl0KSxiLm9mZnNldCksYi5vZmZzZXQrPWUpO2IubGltaXQ9Yi5vZmZzZXQ7Yi5vZmZzZXQ9MDtyZXR1cm4gYn07aC5pc0J5dGVCdWZmZXI9ZnVuY3Rpb24oYSl7cmV0dXJuITA9PT0oYSYmYS5fX2lzQnl0ZUJ1ZmZlcl9fKX07aC50eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5QnVmZmVyfTtoLndyYXA9ZnVuY3Rpb24oYSxiLGMsZCl7XCJzdHJpbmdcIiE9PXR5cGVvZiBiJiYoZD1jLGM9YixiPXZvaWQgMCk7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXN3aXRjaChcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPVwidXRmOFwiKSxiKXtjYXNlIFwiYmFzZTY0XCI6cmV0dXJuIGguZnJvbUJhc2U2NChhLGMpO2Nhc2UgXCJoZXhcIjpyZXR1cm4gaC5mcm9tSGV4KGEsYyk7Y2FzZSBcImJpbmFyeVwiOnJldHVybiBoLmZyb21CaW5hcnkoYSxjKTtjYXNlIFwidXRmOFwiOnJldHVybiBoLmZyb21VVEY4KGEsXHJcbmMpO2Nhc2UgXCJkZWJ1Z1wiOnJldHVybiBoLmZyb21EZWJ1ZyhhLGMpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrYik7fWlmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7aWYoaC5pc0J5dGVCdWZmZXIoYSkpcmV0dXJuIGI9ZS5jbG9uZS5jYWxsKGEpLGIubWFya2VkT2Zmc2V0PS0xLGI7aWYoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpYj1uZXcgaCgwLGMsZCksMDxhLmxlbmd0aCYmKGIuYnVmZmVyPWEuYnVmZmVyLGIub2Zmc2V0PWEuYnl0ZU9mZnNldCxiLmxpbWl0PWEuYnl0ZU9mZnNldCthLmJ5dGVMZW5ndGgsYi52aWV3PW5ldyBVaW50OEFycmF5KGEuYnVmZmVyKSk7ZWxzZSBpZihhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpYj1uZXcgaCgwLGMsZCksMDxhLmJ5dGVMZW5ndGgmJihiLmJ1ZmZlcj1hLGIub2Zmc2V0PTAsYi5saW1pdD1hLmJ5dGVMZW5ndGgsYi52aWV3PTA8XHJcbmEuYnl0ZUxlbmd0aD9uZXcgVWludDhBcnJheShhKTpudWxsKTtlbHNlIGlmKFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSlmb3IoYj1uZXcgaChhLmxlbmd0aCxjLGQpLGIubGltaXQ9YS5sZW5ndGgsYz0wO2M8YS5sZW5ndGg7KytjKWIudmlld1tjXT1hW2NdO2Vsc2UgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7cmV0dXJuIGJ9O2Uud3JpdGVCaXRTZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZighKGEgaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBCaXRTZXQ6IE5vdCBhbiBhcnJheVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+XHJcbnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQ9YixmPWEubGVuZ3RoLGU9Zj4+MyxnPTAsaDtmb3IoYis9dGhpcy53cml0ZVZhcmludDMyKGYsYik7ZS0tOyloPSEhYVtnKytdJjF8KCEhYVtnKytdJjEpPDwxfCghIWFbZysrXSYxKTw8MnwoISFhW2crK10mMSk8PDN8KCEhYVtnKytdJjEpPDw0fCghIWFbZysrXSYxKTw8NXwoISFhW2crK10mMSk8PDZ8KCEhYVtnKytdJjEpPDw3LHRoaXMud3JpdGVCeXRlKGgsYisrKTtpZihnPGYpe2ZvcihoPWU9MDtnPGY7KWh8PSghIWFbZysrXSYxKTw8ZSsrO3RoaXMud3JpdGVCeXRlKGgsYisrKX1yZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yix0aGlzKTpiLWR9O2UucmVhZEJpdFNldD1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO3ZhciBjPXRoaXMucmVhZFZhcmludDMyKGEpLFxyXG5kPWMudmFsdWUsZj1kPj4zLGU9MCxnPVtdO2ZvcihhKz1jLmxlbmd0aDtmLS07KWM9dGhpcy5yZWFkQnl0ZShhKyspLGdbZSsrXT0hIShjJjEpLGdbZSsrXT0hIShjJjIpLGdbZSsrXT0hIShjJjQpLGdbZSsrXT0hIShjJjgpLGdbZSsrXT0hIShjJjE2KSxnW2UrK109ISEoYyYzMiksZ1tlKytdPSEhKGMmNjQpLGdbZSsrXT0hIShjJjEyOCk7aWYoZTxkKWZvcihmPTAsYz10aGlzLnJlYWRCeXRlKGErKyk7ZTxkOylnW2UrK109ISEoYz4+ZisrJjEpO2ImJih0aGlzLm9mZnNldD1hKTtyZXR1cm4gZ307ZS5yZWFkQnl0ZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiK2E+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrXHJcbmIrXCIgKCtcIithK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQ9dGhpcy5zbGljZShiLGIrYSk7YyYmKHRoaXMub2Zmc2V0Kz1hKTtyZXR1cm4gZH07ZS53cml0ZUJ5dGVzPWUuYXBwZW5kO2Uud3JpdGVJbnQ4PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn1iKz0xO3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO3RoaXMudmlld1tiLTFdPWE7YyYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gdGhpc307ZS53cml0ZUJ5dGU9ZS53cml0ZUludDg7ZS5yZWFkSW50OD1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlld1thXTsxMjg9PT0oYSYxMjgpJiYoYT0tKDI1NS1hKzEpKTtiJiYodGhpcy5vZmZzZXQrPVxyXG4xKTtyZXR1cm4gYX07ZS5yZWFkQnl0ZT1lLnJlYWRJbnQ4O2Uud3JpdGVVaW50OD1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTE7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7XHJcbnRoaXMudmlld1tiLTFdPWE7YyYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gdGhpc307ZS53cml0ZVVJbnQ4PWUud3JpdGVVaW50ODtlLnJlYWRVaW50OD1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlld1thXTtiJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiBhfTtlLnJlYWRVSW50OD1lLnJlYWRVaW50ODtlLndyaXRlSW50MTY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7XHJcbmMmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTI7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7Yi09Mjt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3W2IrMV09KGEmNjUyODApPj4+OCx0aGlzLnZpZXdbYl09YSYyNTUpOih0aGlzLnZpZXdbYl09KGEmNjUyODApPj4+XHJcbjgsdGhpcy52aWV3W2IrMV09YSYyNTUpO2MmJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIHRoaXN9O2Uud3JpdGVTaG9ydD1lLndyaXRlSW50MTY7ZS5yZWFkSW50MTY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsyPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsyKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MDt0aGlzLmxpdHRsZUVuZGlhbj8oYz10aGlzLnZpZXdbYV0sY3w9dGhpcy52aWV3W2ErMV08PDgpOihjPXRoaXMudmlld1thXTw8OCxjfD10aGlzLnZpZXdbYSsxXSk7MzI3Njg9PT0oYyYzMjc2OCkmJlxyXG4oYz0tKDY1NTM1LWMrMSkpO2ImJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIGN9O2UucmVhZFNob3J0PWUucmVhZEludDE2O2Uud3JpdGVVaW50MTY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz0yO3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbmI+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtiLT0yO3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXdbYisxXT0oYSY2NTI4MCk+Pj44LHRoaXMudmlld1tiXT1hJjI1NSk6KHRoaXMudmlld1tiXT0oYSY2NTI4MCk+Pj44LHRoaXMudmlld1tiKzFdPWEmMjU1KTtjJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiB0aGlzfTtlLndyaXRlVUludDE2PWUud3JpdGVVaW50MTY7ZS5yZWFkVWludDE2PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn12YXIgYz0wO3RoaXMubGl0dGxlRW5kaWFuPyhjPXRoaXMudmlld1thXSxjfD10aGlzLnZpZXdbYSsxXTw8OCk6KGM9dGhpcy52aWV3W2FdPDw4LGN8PXRoaXMudmlld1thKzFdKTtiJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiBjfTtlLnJlYWRVSW50MTY9ZS5yZWFkVWludDE2O2Uud3JpdGVJbnQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrXHJcbmIrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9NDt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtiLT00O3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXdbYiszXT1hPj4+MjQmMjU1LHRoaXMudmlld1tiKzJdPWE+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMV09YT4+PjgmMjU1LHRoaXMudmlld1tiXT1hJjI1NSk6KHRoaXMudmlld1tiXT1hPj4+MjQmMjU1LHRoaXMudmlld1tiKzFdPWE+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMl09YT4+PjgmMjU1LHRoaXMudmlld1tiKzNdPWEmMjU1KTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtlLndyaXRlSW50PWUud3JpdGVJbnQzMjtlLnJlYWRJbnQzMj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJVxyXG4xKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MDt0aGlzLmxpdHRsZUVuZGlhbj8oYz10aGlzLnZpZXdbYSsyXTw8MTYsY3w9dGhpcy52aWV3W2ErMV08PDgsY3w9dGhpcy52aWV3W2FdLGMrPXRoaXMudmlld1thKzNdPDwyND4+PjApOihjPXRoaXMudmlld1thKzFdPDwxNixjfD10aGlzLnZpZXdbYSsyXTw8OCxjfD10aGlzLnZpZXdbYSszXSxjKz10aGlzLnZpZXdbYV08PDI0Pj4+MCk7YiYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gY3wwfTtlLnJlYWRJbnQ9ZS5yZWFkSW50MzI7ZS53cml0ZVVpbnQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7XHJcbmlmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz00O3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO2ItPTQ7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiKzNdPWE+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09YT4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1hPj4+OCYyNTUsdGhpcy52aWV3W2JdPVxyXG5hJjI1NSk6KHRoaXMudmlld1tiXT1hPj4+MjQmMjU1LHRoaXMudmlld1tiKzFdPWE+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMl09YT4+PjgmMjU1LHRoaXMudmlld1tiKzNdPWEmMjU1KTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtlLndyaXRlVUludDMyPWUud3JpdGVVaW50MzI7ZS5yZWFkVWludDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPTA7dGhpcy5saXR0bGVFbmRpYW4/KGM9dGhpcy52aWV3W2ErXHJcbjJdPDwxNixjfD10aGlzLnZpZXdbYSsxXTw8OCxjfD10aGlzLnZpZXdbYV0sYys9dGhpcy52aWV3W2ErM108PDI0Pj4+MCk6KGM9dGhpcy52aWV3W2ErMV08PDE2LGN8PXRoaXMudmlld1thKzJdPDw4LGN8PXRoaXMudmlld1thKzNdLGMrPXRoaXMudmlld1thXTw8MjQ+Pj4wKTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBjfTtlLnJlYWRVSW50MzI9ZS5yZWFkVWludDMyO2smJihlLndyaXRlSW50NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpYT1rLmZyb21OdW1iZXIoYSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpYT1rLmZyb21TdHJpbmcoYSk7ZWxzZSBpZighKGEmJmEgaW5zdGFuY2VvZiBrKSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtpZihcIm51bWJlclwiIT09XHJcbnR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9ay5mcm9tTnVtYmVyKGEpOlwic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9ay5mcm9tU3RyaW5nKGEpKTtiKz04O3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO2ItPTg7dmFyIGQ9YS5sb3csZj1hLmhpZ2g7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiKzNdPWQ+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09ZD4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1kPj4+OCYyNTUsdGhpcy52aWV3W2JdPWQmMjU1LGIrPTQsdGhpcy52aWV3W2IrM109XHJcbmY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1mPj4+OCYyNTUsdGhpcy52aWV3W2JdPWYmMjU1KToodGhpcy52aWV3W2JdPWY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1mPj4+OCYyNTUsdGhpcy52aWV3W2IrM109ZiYyNTUsYis9NCx0aGlzLnZpZXdbYl09ZD4+PjI0JjI1NSx0aGlzLnZpZXdbYisxXT1kPj4+MTYmMjU1LHRoaXMudmlld1tiKzJdPWQ+Pj44JjI1NSx0aGlzLnZpZXdbYiszXT1kJjI1NSk7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc30sZS53cml0ZUxvbmc9ZS53cml0ZUludDY0LGUucmVhZEludDY0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO1xyXG5hPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wLGQ9MDt0aGlzLmxpdHRsZUVuZGlhbj8oYz10aGlzLnZpZXdbYSsyXTw8MTYsY3w9dGhpcy52aWV3W2ErMV08PDgsY3w9dGhpcy52aWV3W2FdLGMrPXRoaXMudmlld1thKzNdPDwyND4+PjAsYSs9NCxkPXRoaXMudmlld1thKzJdPDwxNixkfD10aGlzLnZpZXdbYSsxXTw8OCxkfD10aGlzLnZpZXdbYV0sZCs9dGhpcy52aWV3W2ErM108PDI0Pj4+MCk6KGQ9dGhpcy52aWV3W2ErMV08PDE2LGR8PXRoaXMudmlld1thKzJdPDw4LGR8PXRoaXMudmlld1thKzNdLGQrPXRoaXMudmlld1thXTw8MjQ+Pj4wLGErPTQsYz10aGlzLnZpZXdbYSsxXTw8MTYsY3w9dGhpcy52aWV3W2ErMl08PDgsY3w9dGhpcy52aWV3W2ErM10sYys9dGhpcy52aWV3W2FdPDwyND4+PjApO1xyXG5hPW5ldyBrKGMsZCwhMSk7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX0sZS5yZWFkTG9uZz1lLnJlYWRJbnQ2NCxlLndyaXRlVWludDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKWE9ay5mcm9tTnVtYmVyKGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWE9ay5mcm9tU3RyaW5nKGEpO2Vsc2UgaWYoIShhJiZhIGluc3RhbmNlb2YgaykpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK1xyXG5iK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fVwibnVtYmVyXCI9PT10eXBlb2YgYT9hPWsuZnJvbU51bWJlcihhKTpcInN0cmluZ1wiPT09dHlwZW9mIGEmJihhPWsuZnJvbVN0cmluZyhhKSk7Yis9ODt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtiLT04O3ZhciBkPWEubG93LGY9YS5oaWdoO3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXdbYiszXT1kPj4+MjQmMjU1LHRoaXMudmlld1tiKzJdPWQ+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMV09ZD4+PjgmMjU1LHRoaXMudmlld1tiXT1kJjI1NSxiKz00LHRoaXMudmlld1tiKzNdPWY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1mPj4+OCYyNTUsdGhpcy52aWV3W2JdPWYmMjU1KToodGhpcy52aWV3W2JdPWY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1mPj4+OCYyNTUsXHJcbnRoaXMudmlld1tiKzNdPWYmMjU1LGIrPTQsdGhpcy52aWV3W2JdPWQ+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09ZD4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1kPj4+OCYyNTUsdGhpcy52aWV3W2IrM109ZCYyNTUpO2MmJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIHRoaXN9LGUud3JpdGVVSW50NjQ9ZS53cml0ZVVpbnQ2NCxlLnJlYWRVaW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs4PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs4KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MCxkPTA7dGhpcy5saXR0bGVFbmRpYW4/XHJcbihjPXRoaXMudmlld1thKzJdPDwxNixjfD10aGlzLnZpZXdbYSsxXTw8OCxjfD10aGlzLnZpZXdbYV0sYys9dGhpcy52aWV3W2ErM108PDI0Pj4+MCxhKz00LGQ9dGhpcy52aWV3W2ErMl08PDE2LGR8PXRoaXMudmlld1thKzFdPDw4LGR8PXRoaXMudmlld1thXSxkKz10aGlzLnZpZXdbYSszXTw8MjQ+Pj4wKTooZD10aGlzLnZpZXdbYSsxXTw8MTYsZHw9dGhpcy52aWV3W2ErMl08PDgsZHw9dGhpcy52aWV3W2ErM10sZCs9dGhpcy52aWV3W2FdPDwyND4+PjAsYSs9NCxjPXRoaXMudmlld1thKzFdPDwxNixjfD10aGlzLnZpZXdbYSsyXTw8OCxjfD10aGlzLnZpZXdbYSszXSxjKz10aGlzLnZpZXdbYV08PDI0Pj4+MCk7YT1uZXcgayhjLGQsITApO2ImJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIGF9LGUucmVhZFVJbnQ2ND1lLnJlYWRVaW50NjQpO2Uud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxyXG50eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYSBudW1iZXIpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTQ7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7dSh0aGlzLnZpZXcsYSxiLTQsdGhpcy5saXR0bGVFbmRpYW4sMjMsNCk7YyYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gdGhpc307ZS53cml0ZUZsb2F0PWUud3JpdGVGbG9hdDMyO2UucmVhZEZsb2F0MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJlxyXG4oYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9cyh0aGlzLnZpZXcsYSx0aGlzLmxpdHRsZUVuZGlhbiwyMyw0KTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBhfTtlLnJlYWRGbG9hdD1lLnJlYWRGbG9hdDMyO2Uud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhIG51bWJlcilcIik7XHJcbmlmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTg7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7dSh0aGlzLnZpZXcsYSxiLTgsdGhpcy5saXR0bGVFbmRpYW4sNTIsOCk7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc307ZS53cml0ZURvdWJsZT1lLndyaXRlRmxvYXQ2NDtlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PVxyXG5hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXModGhpcy52aWV3LGEsdGhpcy5saXR0bGVFbmRpYW4sNTIsOCk7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX07ZS5yZWFkRG91YmxlPWUucmVhZEZsb2F0NjQ7aC5NQVhfVkFSSU5UMzJfQllURVM9NTtoLmNhbGN1bGF0ZVZhcmludDMyPWZ1bmN0aW9uKGEpe2E+Pj49MDtyZXR1cm4gMTI4PmE/MToxNjM4ND5hPzI6MjA5NzE1Mj5hPzM6MjY4NDM1NDU2PmE/NDo1fTtoLnppZ1phZ0VuY29kZTMyPWZ1bmN0aW9uKGEpe3JldHVybigoYXw9MCk8PDFeYT4+MzEpPj4+MH07aC56aWdaYWdEZWNvZGUzMj1mdW5jdGlvbihhKXtyZXR1cm4gYT4+PjFeLShhJlxyXG4xKXwwfTtlLndyaXRlVmFyaW50MzI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQ9aC5jYWxjdWxhdGVWYXJpbnQzMihhKSxmO2IrPWQ7Zj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZiYmdGhpcy5yZXNpemUoKGYqPTIpPmI/ZjpiKTtcclxuYi09ZDtmb3IoYT4+Pj0wOzEyODw9YTspZj1hJjEyN3wxMjgsdGhpcy52aWV3W2IrK109ZixhPj4+PTc7dGhpcy52aWV3W2IrK109YTtyZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yix0aGlzKTpkfTtlLndyaXRlVmFyaW50MzJaaWdaYWc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy53cml0ZVZhcmludDMyKGguemlnWmFnRW5jb2RlMzIoYSksYil9O2UucmVhZFZhcmludDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn12YXIgYz0wLGQ9MCxmO2Rve2lmKCF0aGlzLm5vQXNzZXJ0JiZhPnRoaXMubGltaXQpdGhyb3cgYT1FcnJvcihcIlRydW5jYXRlZFwiKSxhLnRydW5jYXRlZD0hMCxhO2Y9dGhpcy52aWV3W2ErK107NT5jJiYoZHw9KGYmMTI3KTw8NypjKTsrK2N9d2hpbGUoMCE9PShmJjEyOCkpO2R8PTA7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsZCk6e3ZhbHVlOmQsbGVuZ3RoOmN9fTtlLnJlYWRWYXJpbnQzMlppZ1phZz1mdW5jdGlvbihhKXthPXRoaXMucmVhZFZhcmludDMyKGEpO1wib2JqZWN0XCI9PT10eXBlb2YgYT9hLnZhbHVlPWguemlnWmFnRGVjb2RlMzIoYS52YWx1ZSk6YT1oLnppZ1phZ0RlY29kZTMyKGEpO3JldHVybiBhfTtrJiYoaC5NQVhfVkFSSU5UNjRfQllURVM9MTAsaC5jYWxjdWxhdGVWYXJpbnQ2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGE/YT1rLmZyb21OdW1iZXIoYSk6XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1rLmZyb21TdHJpbmcoYSkpO3ZhciBiPWEudG9JbnQoKT4+PlxyXG4wLGM9YS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCk+Pj4wO2E9YS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCk+Pj4wO3JldHVybiAwPT1hPzA9PWM/MTYzODQ+Yj8xMjg+Yj8xOjI6MjA5NzE1Mj5iPzM6NDoxNjM4ND5jPzEyOD5jPzU6NjoyMDk3MTUyPmM/Nzo4OjEyOD5hPzk6MTB9LGguemlnWmFnRW5jb2RlNjQ9ZnVuY3Rpb24oYSl7XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9ay5mcm9tTnVtYmVyKGEsITEpOlwic3RyaW5nXCI9PT10eXBlb2YgYT9hPWsuZnJvbVN0cmluZyhhLCExKTohMSE9PWEudW5zaWduZWQmJihhPWEudG9TaWduZWQoKSk7cmV0dXJuIGEuc2hpZnRMZWZ0KDEpLnhvcihhLnNoaWZ0UmlnaHQoNjMpKS50b1Vuc2lnbmVkKCl9LGguemlnWmFnRGVjb2RlNjQ9ZnVuY3Rpb24oYSl7XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9ay5mcm9tTnVtYmVyKGEsITEpOlwic3RyaW5nXCI9PT10eXBlb2YgYT9hPWsuZnJvbVN0cmluZyhhLCExKTohMSE9PWEudW5zaWduZWQmJlxyXG4oYT1hLnRvU2lnbmVkKCkpO3JldHVybiBhLnNoaWZ0UmlnaHRVbnNpZ25lZCgxKS54b3IoYS5hbmQoay5PTkUpLnRvU2lnbmVkKCkubmVnYXRlKCkpLnRvU2lnbmVkKCl9LGUud3JpdGVWYXJpbnQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWsuZnJvbU51bWJlcihhKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlhPWsuZnJvbVN0cmluZyhhKTtlbHNlIGlmKCEoYSYmYSBpbnN0YW5jZW9mIGspKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitcclxuYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31cIm51bWJlclwiPT09dHlwZW9mIGE/YT1rLmZyb21OdW1iZXIoYSwhMSk6XCJzdHJpbmdcIj09PXR5cGVvZiBhP2E9ay5mcm9tU3RyaW5nKGEsITEpOiExIT09YS51bnNpZ25lZCYmKGE9YS50b1NpZ25lZCgpKTt2YXIgZD1oLmNhbGN1bGF0ZVZhcmludDY0KGEpLGY9YS50b0ludCgpPj4+MCxlPWEuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpPj4+MCxnPWEuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpPj4+MDtiKz1kO3ZhciB0PXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj50JiZ0aGlzLnJlc2l6ZSgodCo9Mik+Yj90OmIpO2ItPWQ7c3dpdGNoKGQpe2Nhc2UgMTA6dGhpcy52aWV3W2IrOV09Zz4+PjcmMTtjYXNlIDk6dGhpcy52aWV3W2IrOF09OSE9PWQ/Z3wxMjg6ZyYxMjc7Y2FzZSA4OnRoaXMudmlld1tiKzddPTghPT1kP2U+Pj4yMXwxMjg6ZT4+PjIxJjEyNztjYXNlIDc6dGhpcy52aWV3W2IrNl09XHJcbjchPT1kP2U+Pj4xNHwxMjg6ZT4+PjE0JjEyNztjYXNlIDY6dGhpcy52aWV3W2IrNV09NiE9PWQ/ZT4+Pjd8MTI4OmU+Pj43JjEyNztjYXNlIDU6dGhpcy52aWV3W2IrNF09NSE9PWQ/ZXwxMjg6ZSYxMjc7Y2FzZSA0OnRoaXMudmlld1tiKzNdPTQhPT1kP2Y+Pj4yMXwxMjg6Zj4+PjIxJjEyNztjYXNlIDM6dGhpcy52aWV3W2IrMl09MyE9PWQ/Zj4+PjE0fDEyODpmPj4+MTQmMTI3O2Nhc2UgMjp0aGlzLnZpZXdbYisxXT0yIT09ZD9mPj4+N3wxMjg6Zj4+PjcmMTI3O2Nhc2UgMTp0aGlzLnZpZXdbYl09MSE9PWQ/ZnwxMjg6ZiYxMjd9cmV0dXJuIGM/KHRoaXMub2Zmc2V0Kz1kLHRoaXMpOmR9LGUud3JpdGVWYXJpbnQ2NFppZ1phZz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLndyaXRlVmFyaW50NjQoaC56aWdaYWdFbmNvZGU2NChhKSxiKX0sZS5yZWFkVmFyaW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxyXG50eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPWEsZD0wLGY9MCxlPTAsZz0wLGc9dGhpcy52aWV3W2ErK10sZD1nJjEyNztpZihnJjEyOCYmKGc9dGhpcy52aWV3W2ErK10sZHw9KGcmMTI3KTw8NyxnJjEyOHx8dGhpcy5ub0Fzc2VydCYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBnKSYmKGc9dGhpcy52aWV3W2ErK10sZHw9KGcmMTI3KTw8MTQsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykmJihnPXRoaXMudmlld1thKytdLGR8PShnJjEyNyk8PDIxLGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxcclxuZj1nJjEyNyxnJjEyOHx8dGhpcy5ub0Fzc2VydCYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBnKSYmKGc9dGhpcy52aWV3W2ErK10sZnw9KGcmMTI3KTw8NyxnJjEyOHx8dGhpcy5ub0Fzc2VydCYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBnKSYmKGc9dGhpcy52aWV3W2ErK10sZnw9KGcmMTI3KTw8MTQsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykmJihnPXRoaXMudmlld1thKytdLGZ8PShnJjEyNyk8PDIxLGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxlPWcmMTI3LGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxlfD0oZyYxMjcpPDw3LGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpKXRocm93IEVycm9yKFwiQnVmZmVyIG92ZXJydW5cIik7ZD1rLmZyb21CaXRzKGR8Zjw8MjgsZj4+PjR8XHJcbmU8PDI0LCExKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxkKTp7dmFsdWU6ZCxsZW5ndGg6YS1jfX0sZS5yZWFkVmFyaW50NjRaaWdaYWc9ZnVuY3Rpb24oYSl7KGE9dGhpcy5yZWFkVmFyaW50NjQoYSkpJiZhLnZhbHVlIGluc3RhbmNlb2Ygaz9hLnZhbHVlPWguemlnWmFnRGVjb2RlNjQoYS52YWx1ZSk6YT1oLnppZ1phZ0RlY29kZTY0KGEpO3JldHVybiBhfSk7ZS53cml0ZUNTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO3ZhciBkLGY9YS5sZW5ndGg7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2ZvcihkPTA7ZDxmOysrZClpZigwPT09YS5jaGFyQ29kZUF0KGQpKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8XHJcbjAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31mPW4uY2FsY3VsYXRlVVRGMTZhc1VURjgobShhKSlbMV07Yis9ZisxO2Q9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7Yi09ZisxO24uZW5jb2RlVVRGMTZ0b1VURjgobShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXdbYisrXT1hfS5iaW5kKHRoaXMpKTt0aGlzLnZpZXdbYisrXT0wO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmZ9O2UucmVhZENTdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxyXG50eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPWEsZCxmPS0xO24uZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKXtpZigwPT09ZilyZXR1cm4gbnVsbDtpZihhPj10aGlzLmxpbWl0KXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYStcIiA8IFwiK3RoaXMubGltaXQpO2Y9dGhpcy52aWV3W2ErK107cmV0dXJuIDA9PT1mP251bGw6Zn0uYmluZCh0aGlzKSxkPXIoKSwhMCk7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsZCgpKTp7c3RyaW5nOmQoKSxsZW5ndGg6YS1jfX07ZS53cml0ZUlTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cclxuXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQ9YixmO2Y9bi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpLHRoaXMubm9Bc3NlcnQpWzFdO2IrPTQrZjt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTtiLT00K2Y7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiK1xyXG4zXT1mPj4+MjQmMjU1LHRoaXMudmlld1tiKzJdPWY+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMV09Zj4+PjgmMjU1LHRoaXMudmlld1tiXT1mJjI1NSk6KHRoaXMudmlld1tiXT1mPj4+MjQmMjU1LHRoaXMudmlld1tiKzFdPWY+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMl09Zj4+PjgmMjU1LHRoaXMudmlld1tiKzNdPWYmMjU1KTtiKz00O24uZW5jb2RlVVRGMTZ0b1VURjgobShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXdbYisrXT1hfS5iaW5kKHRoaXMpKTtpZihiIT09ZCs0K2YpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitiK1wiID09IFwiKyhiKzQrZikpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZH07ZS5yZWFkSVN0cmluZz1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xyXG5hK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9YSxkPXRoaXMucmVhZFVpbnQzMihhKSxkPXRoaXMucmVhZFVURjhTdHJpbmcoZCxoLk1FVFJJQ1NfQllURVMsYSs9NCk7YSs9ZC5sZW5ndGg7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsZC5zdHJpbmcpOntzdHJpbmc6ZC5zdHJpbmcsbGVuZ3RoOmEtY319O2guTUVUUklDU19DSEFSUz1cImNcIjtoLk1FVFJJQ1NfQllURVM9XCJiXCI7ZS53cml0ZVVURjhTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xyXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQsZj1iO2Q9bi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpKVsxXTtiKz1kO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO2ItPWQ7bi5lbmNvZGVVVEYxNnRvVVRGOChtKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlld1tiKytdPWF9LmJpbmQodGhpcykpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZn07ZS53cml0ZVN0cmluZz1lLndyaXRlVVRGOFN0cmluZztoLmNhbGN1bGF0ZVVURjhDaGFycz1mdW5jdGlvbihhKXtyZXR1cm4gbi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpKVswXX07aC5jYWxjdWxhdGVVVEY4Qnl0ZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIG4uY2FsY3VsYXRlVVRGMTZhc1VURjgobShhKSlbMV19O1xyXG5oLmNhbGN1bGF0ZVN0cmluZz1oLmNhbGN1bGF0ZVVURjhCeXRlcztlLnJlYWRVVEY4U3RyaW5nPWZ1bmN0aW9uKGEsYixjKXtcIm51bWJlclwiPT09dHlwZW9mIGImJihjPWIsYj12b2lkIDApO3ZhciBkPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYztkJiYoYz10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj1oLk1FVFJJQ1NfQ0hBUlMpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrMCkgPD0gXCIrXHJcbnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZj0wLGU9YyxnO2lmKGI9PT1oLk1FVFJJQ1NfQ0hBUlMpe2c9cigpO24uZGVjb2RlVVRGOChmdW5jdGlvbigpe3JldHVybiBmPGEmJmM8dGhpcy5saW1pdD90aGlzLnZpZXdbYysrXTpudWxsfS5iaW5kKHRoaXMpLGZ1bmN0aW9uKGEpeysrZjtuLlVURjh0b1VURjE2KGEsZyl9KTtpZihmIT09YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2YrXCIgPT0gXCIrYSk7cmV0dXJuIGQ/KHRoaXMub2Zmc2V0PWMsZygpKTp7c3RyaW5nOmcoKSxsZW5ndGg6Yy1lfX1pZihiPT09aC5NRVRSSUNTX0JZVEVTKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YythPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK1xyXG5jK1wiICgrXCIrYStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBrPWMrYTtuLmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCl7cmV0dXJuIGM8az90aGlzLnZpZXdbYysrXTpudWxsfS5iaW5kKHRoaXMpLGc9cigpLHRoaXMubm9Bc3NlcnQpO2lmKGMhPT1rKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYytcIiA9PSBcIitrKTtyZXR1cm4gZD8odGhpcy5vZmZzZXQ9YyxnKCkpOntzdHJpbmc6ZygpLGxlbmd0aDpjLWV9fXRocm93IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIG1ldHJpY3M6IFwiK2IpO307ZS5yZWFkU3RyaW5nPWUucmVhZFVURjhTdHJpbmc7ZS53cml0ZVZTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuaWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGQ9YixmLGU7Zj1uLmNhbGN1bGF0ZVVURjE2YXNVVEY4KG0oYSksdGhpcy5ub0Fzc2VydClbMV07ZT1oLmNhbGN1bGF0ZVZhcmludDMyKGYpO2IrPWUrZjt2YXIgZz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZyYmdGhpcy5yZXNpemUoKGcqPTIpPmI/ZzpiKTtiLT1lK2Y7Yis9dGhpcy53cml0ZVZhcmludDMyKGYsYik7bi5lbmNvZGVVVEYxNnRvVVRGOChtKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlld1tiKytdPWF9LmJpbmQodGhpcykpO2lmKGIhPT1kK2YrZSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK1xyXG5iK1wiID09IFwiKyhiK2YrZSkpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZH07ZS5yZWFkVlN0cmluZz1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz1hLGQ9dGhpcy5yZWFkVmFyaW50MzIoYSksZD10aGlzLnJlYWRVVEY4U3RyaW5nKGQudmFsdWUsaC5NRVRSSUNTX0JZVEVTLGErPWQubGVuZ3RoKTthKz1kLmxlbmd0aDtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxkLnN0cmluZyk6e3N0cmluZzpkLnN0cmluZyxcclxubGVuZ3RoOmEtY319O2UuYXBwZW5kPWZ1bmN0aW9uKGEsYixjKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYiljPWIsYj12b2lkIDA7dmFyIGQ9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2QmJihjPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YSBpbnN0YW5jZW9mIGh8fChhPWgud3JhcChhLGIpKTtiPWEubGltaXQtYS5vZmZzZXQ7aWYoMD49YilyZXR1cm4gdGhpcztjKz1iO3ZhciBmPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yz5mJiZ0aGlzLnJlc2l6ZSgoZio9Mik+XHJcbmM/ZjpjKTtjLT1iO3RoaXMudmlldy5zZXQoYS52aWV3LnN1YmFycmF5KGEub2Zmc2V0LGEubGltaXQpLGMpO2Eub2Zmc2V0Kz1iO2QmJih0aGlzLm9mZnNldCs9Yik7cmV0dXJuIHRoaXN9O2UuYXBwZW5kVG89ZnVuY3Rpb24oYSxiKXthLmFwcGVuZCh0aGlzLGIpO3JldHVybiB0aGlzfTtlLmFzc2VydD1mdW5jdGlvbihhKXt0aGlzLm5vQXNzZXJ0PSFhO3JldHVybiB0aGlzfTtlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGh9O2UuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLm9mZnNldD0wO3RoaXMubGltaXQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDt0aGlzLm1hcmtlZE9mZnNldD0tMTtyZXR1cm4gdGhpc307ZS5jbG9uZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgaCgwLHRoaXMubGl0dGxlRW5kaWFuLHRoaXMubm9Bc3NlcnQpO2E/KGIuYnVmZmVyPW5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSxiLnZpZXc9bmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIpKTpcclxuKGIuYnVmZmVyPXRoaXMuYnVmZmVyLGIudmlldz10aGlzLnZpZXcpO2Iub2Zmc2V0PXRoaXMub2Zmc2V0O2IubWFya2VkT2Zmc2V0PXRoaXMubWFya2VkT2Zmc2V0O2IubGltaXQ9dGhpcy5saW1pdDtyZXR1cm4gYn07ZS5jb21wYWN0PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrXHJcbmIrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKDA9PT1hJiZiPT09dGhpcy5idWZmZXIuYnl0ZUxlbmd0aClyZXR1cm4gdGhpczt2YXIgYz1iLWE7aWYoMD09PWMpcmV0dXJuIHRoaXMuYnVmZmVyPXYsdGhpcy52aWV3PW51bGwsMDw9dGhpcy5tYXJrZWRPZmZzZXQmJih0aGlzLm1hcmtlZE9mZnNldC09YSksdGhpcy5saW1pdD10aGlzLm9mZnNldD0wLHRoaXM7dmFyIGQ9bmV3IEFycmF5QnVmZmVyKGMpLGY9bmV3IFVpbnQ4QXJyYXkoZCk7Zi5zZXQodGhpcy52aWV3LnN1YmFycmF5KGEsYikpO3RoaXMuYnVmZmVyPWQ7dGhpcy52aWV3PWY7MDw9dGhpcy5tYXJrZWRPZmZzZXQmJih0aGlzLm1hcmtlZE9mZnNldC09YSk7dGhpcy5vZmZzZXQ9MDt0aGlzLmxpbWl0PWM7cmV0dXJuIHRoaXN9O2UuY29weT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT1cclxudHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihhPT09YilyZXR1cm4gbmV3IGgoMCx0aGlzLmxpdHRsZUVuZGlhbix0aGlzLm5vQXNzZXJ0KTt2YXIgYz1iLWEsZD1uZXcgaChjLHRoaXMubGl0dGxlRW5kaWFuLHRoaXMubm9Bc3NlcnQpO2Qub2Zmc2V0PTA7ZC5saW1pdD1jOzA8PWQubWFya2VkT2Zmc2V0JiYoZC5tYXJrZWRPZmZzZXQtPWEpO3RoaXMuY29weVRvKGQsMCxhLGIpO3JldHVybiBkfTtlLmNvcHlUbz1mdW5jdGlvbihhLFxyXG5iLGMsZCl7dmFyIGYsZTtpZighdGhpcy5ub0Fzc2VydCYmIWguaXNCeXRlQnVmZmVyKGEpKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdGFyZ2V0OiBOb3QgYSBCeXRlQnVmZmVyXCIpO2I9KGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiKT9hLm9mZnNldDpifDA7Yz0oZj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGMpP3RoaXMub2Zmc2V0OmN8MDtkPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgZD90aGlzLmxpbWl0OmR8MDtpZigwPmJ8fGI+YS5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQgcmFuZ2U6IDAgPD0gXCIrYitcIiA8PSBcIithLmJ1ZmZlci5ieXRlTGVuZ3RoKTtpZigwPmN8fGQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt2YXIgZz1kLWM7aWYoMD09PWcpcmV0dXJuIGE7YS5lbnN1cmVDYXBhY2l0eShiK2cpO1xyXG5hLnZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShjLGQpLGIpO2YmJih0aGlzLm9mZnNldCs9Zyk7ZSYmKGEub2Zmc2V0Kz1nKTtyZXR1cm4gdGhpc307ZS5lbnN1cmVDYXBhY2l0eT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO3JldHVybiBiPGE/dGhpcy5yZXNpemUoKGIqPTIpPmE/YjphKTp0aGlzfTtlLmZpbGw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtkJiYoYj10aGlzLm9mZnNldCk7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYwPGEubGVuZ3RoJiYoYT1hLmNoYXJDb2RlQXQoMCkpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9XHJcbjA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2M+Pj49MDtpZigwPmJ8fGI+Y3x8Yz50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2IrXCIgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoYj49YylyZXR1cm4gdGhpcztmb3IoO2I8YzspdGhpcy52aWV3W2IrK109YTtkJiYodGhpcy5vZmZzZXQ9Yik7cmV0dXJuIHRoaXN9O2UuZmxpcD1mdW5jdGlvbigpe3RoaXMubGltaXQ9dGhpcy5vZmZzZXQ7dGhpcy5vZmZzZXQ9MDtyZXR1cm4gdGhpc307ZS5tYXJrPWZ1bmN0aW9uKGEpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3RoaXMub2Zmc2V0OmE7XHJcbmlmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO310aGlzLm1hcmtlZE9mZnNldD1hO3JldHVybiB0aGlzfTtlLm9yZGVyPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0JiZcImJvb2xlYW5cIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO3RoaXMubGl0dGxlRW5kaWFuPSEhYTtyZXR1cm4gdGhpc307ZS5MRT1mdW5jdGlvbihhKXt0aGlzLmxpdHRsZUVuZGlhbj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGE/ISFhOiEwO3JldHVybiB0aGlzfTtlLkJFPWZ1bmN0aW9uKGEpe3RoaXMubGl0dGxlRW5kaWFuPVxyXG5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGE/IWE6ITE7cmV0dXJuIHRoaXN9O2UucHJlcGVuZD1mdW5jdGlvbihhLGIsYyl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBifHxcInN0cmluZ1wiIT09dHlwZW9mIGIpYz1iLGI9dm9pZCAwO3ZhciBkPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYztkJiYoYz10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWEgaW5zdGFuY2VvZiBofHwoYT1oLndyYXAoYSxiKSk7Yj1hLmxpbWl0LWEub2Zmc2V0O2lmKDA+PWIpcmV0dXJuIHRoaXM7dmFyIGY9Yi1jO2lmKDA8Zil7dmFyIGU9bmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgrXHJcbmYpLGc9bmV3IFVpbnQ4QXJyYXkoZSk7Zy5zZXQodGhpcy52aWV3LnN1YmFycmF5KGMsdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksYik7dGhpcy5idWZmZXI9ZTt0aGlzLnZpZXc9Zzt0aGlzLm9mZnNldCs9ZjswPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0Kz1mKTt0aGlzLmxpbWl0Kz1mO2MrPWZ9ZWxzZSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7dGhpcy52aWV3LnNldChhLnZpZXcuc3ViYXJyYXkoYS5vZmZzZXQsYS5saW1pdCksYy1iKTthLm9mZnNldD1hLmxpbWl0O2QmJih0aGlzLm9mZnNldC09Yik7cmV0dXJuIHRoaXN9O2UucHJlcGVuZFRvPWZ1bmN0aW9uKGEsYil7YS5wcmVwZW5kKHRoaXMsYik7cmV0dXJuIHRoaXN9O2UucHJpbnREZWJ1Zz1mdW5jdGlvbihhKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmKGE9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7YSh0aGlzLnRvU3RyaW5nKCkrXCJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIrXHJcbnRoaXMudG9EZWJ1ZyghMCkpfTtlLnJlbWFpbmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbWl0LXRoaXMub2Zmc2V0fTtlLnJlc2V0PWZ1bmN0aW9uKCl7MDw9dGhpcy5tYXJrZWRPZmZzZXQ/KHRoaXMub2Zmc2V0PXRoaXMubWFya2VkT2Zmc2V0LHRoaXMubWFya2VkT2Zmc2V0PS0xKTp0aGlzLm9mZnNldD0wO3JldHVybiB0aGlzfTtlLnJlc2l6ZT1mdW5jdGlvbihhKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKDA+YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogMCA8PSBcIithKTt9aWYodGhpcy5idWZmZXIuYnl0ZUxlbmd0aDxhKXthPW5ldyBBcnJheUJ1ZmZlcihhKTt2YXIgYj1uZXcgVWludDhBcnJheShhKTtiLnNldCh0aGlzLnZpZXcpO3RoaXMuYnVmZmVyPWE7dGhpcy52aWV3PWJ9cmV0dXJuIHRoaXN9O1xyXG5lLnJldmVyc2U9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihhPT09YilyZXR1cm4gdGhpcztBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKHRoaXMudmlldy5zdWJhcnJheShhLGIpKTtyZXR1cm4gdGhpc307XHJcbmUuc2tpcD1mdW5jdGlvbihhKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MH12YXIgYj10aGlzLm9mZnNldCthO2lmKCF0aGlzLm5vQXNzZXJ0JiYoMD5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogMCA8PSBcIit0aGlzLm9mZnNldCtcIiArIFwiK2ErXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7dGhpcy5vZmZzZXQ9YjtyZXR1cm4gdGhpc307ZS5zbGljZT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcclxuYT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz10aGlzLmNsb25lKCk7Yy5vZmZzZXQ9YTtjLmxpbWl0PWI7cmV0dXJuIGN9O2UudG9CdWZmZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vZmZzZXQsYz10aGlzLmxpbWl0O2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsaW1pdDogTm90IGFuIGludGVnZXJcIik7XHJcbmM+Pj49MDtpZigwPmJ8fGI+Y3x8Yz50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2IrXCIgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoIWEmJjA9PT1iJiZjPT09dGhpcy5idWZmZXIuYnl0ZUxlbmd0aClyZXR1cm4gdGhpcy5idWZmZXI7aWYoYj09PWMpcmV0dXJuIHY7YT1uZXcgQXJyYXlCdWZmZXIoYy1iKTsobmV3IFVpbnQ4QXJyYXkoYSkpLnNldCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShiLGMpLDApO3JldHVybiBhfTtlLnRvQXJyYXlCdWZmZXI9ZS50b0J1ZmZlcjtlLnRvU3RyaW5nPWZ1bmN0aW9uKGEsYixjKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuXCJCeXRlQnVmZmVyQUIob2Zmc2V0PVwiK3RoaXMub2Zmc2V0K1wiLG1hcmtlZE9mZnNldD1cIit0aGlzLm1hcmtlZE9mZnNldCtcIixsaW1pdD1cIit0aGlzLmxpbWl0K1wiLGNhcGFjaXR5PVwiK3RoaXMuY2FwYWNpdHkoKStcclxuXCIpXCI7XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoYz1iPWE9XCJ1dGY4XCIpO3N3aXRjaChhKXtjYXNlIFwidXRmOFwiOnJldHVybiB0aGlzLnRvVVRGOChiLGMpO2Nhc2UgXCJiYXNlNjRcIjpyZXR1cm4gdGhpcy50b0Jhc2U2NChiLGMpO2Nhc2UgXCJoZXhcIjpyZXR1cm4gdGhpcy50b0hleChiLGMpO2Nhc2UgXCJiaW5hcnlcIjpyZXR1cm4gdGhpcy50b0JpbmFyeShiLGMpO2Nhc2UgXCJkZWJ1Z1wiOnJldHVybiB0aGlzLnRvRGVidWcoKTtjYXNlIFwiY29sdW1uc1wiOnJldHVybiB0aGlzLnRvQ29sdW1ucygpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrYSk7fX07dmFyIHg9ZnVuY3Rpb24oKXtmb3IodmFyIGE9e30sYj1bNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMyxcclxuMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNDMsNDddLGM9W10sZD0wLGY9Yi5sZW5ndGg7ZDxmOysrZCljW2JbZF1dPWQ7YS5lbmNvZGU9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGQsZjtudWxsIT09KGQ9YSgpKTspYyhiW2Q+PjImNjNdKSxmPShkJjMpPDw0LG51bGwhPT0oZD1hKCkpPyhmfD1kPj40JjE1LGMoYlsoZnxkPj40JjE1KSY2M10pLGY9KGQmMTUpPDwyLG51bGwhPT0oZD1hKCkpPyhjKGJbKGZ8ZD4+NiYzKSY2M10pLGMoYltkJjYzXSkpOihjKGJbZiY2M10pLGMoNjEpKSk6KGMoYltmJjYzXSksYyg2MSksYyg2MSkpfTthLmRlY29kZT1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGQoYSl7dGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBjb2RlOiBcIithKTt9Zm9yKHZhciBmLGUsaDtudWxsIT09KGY9YSgpKTspaWYoZT1jW2ZdLFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZSYmZChmKSxudWxsIT09KGY9YSgpKSYmXHJcbihoPWNbZl0sXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBoJiZkKGYpLGIoZTw8Mj4+PjB8KGgmNDgpPj40KSxudWxsIT09KGY9YSgpKSkpe2U9Y1tmXTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGUpaWYoNjE9PT1mKWJyZWFrO2Vsc2UgZChmKTtiKChoJjE1KTw8ND4+PjB8KGUmNjApPj4yKTtpZihudWxsIT09KGY9YSgpKSl7aD1jW2ZdO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgaClpZig2MT09PWYpYnJlYWs7ZWxzZSBkKGYpO2IoKGUmMyk8PDY+Pj4wfGgpfX19O2EudGVzdD1mdW5jdGlvbihhKXtyZXR1cm4vXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChhKX07cmV0dXJuIGF9KCk7ZS50b0Jhc2U2ND1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7YXw9MDtifD0wO2lmKDA+YXx8Yj50aGlzLmNhcGFjaXR5fHxcclxuYT5iKXRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO3ZhciBjO3guZW5jb2RlKGZ1bmN0aW9uKCl7cmV0dXJuIGE8Yj90aGlzLnZpZXdbYSsrXTpudWxsfS5iaW5kKHRoaXMpLGM9cigpKTtyZXR1cm4gYygpfTtoLmZyb21CYXNlNjQ9ZnVuY3Rpb24oYSxiKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO3ZhciBjPW5ldyBoKGEubGVuZ3RoLzQqMyxiKSxkPTA7eC5kZWNvZGUobShhKSxmdW5jdGlvbihhKXtjLnZpZXdbZCsrXT1hfSk7Yy5saW1pdD1kO3JldHVybiBjfTtoLmJ0b2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGguZnJvbUJpbmFyeShhKS50b0Jhc2U2NCgpfTtoLmF0b2I9ZnVuY3Rpb24oYSl7cmV0dXJuIGguZnJvbUJhc2U2NChhKS50b0JpbmFyeSgpfTtlLnRvQmluYXJ5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtcclxuYXw9MDtifD0wO2lmKDA+YXx8Yj50aGlzLmNhcGFjaXR5KCl8fGE+Yil0aHJvdyBSYW5nZUVycm9yKFwiYmVnaW4sIGVuZFwiKTtpZihhPT09YilyZXR1cm5cIlwiO2Zvcih2YXIgYz1bXSxkPVtdO2E8YjspYy5wdXNoKHRoaXMudmlld1thKytdKSwxMDI0PD1jLmxlbmd0aCYmKGQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxjKSksYz1bXSk7cmV0dXJuIGQuam9pbihcIlwiKStTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxjKX07aC5mcm9tQmluYXJ5PWZ1bmN0aW9uKGEsYil7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcInN0clwiKTtmb3IodmFyIGM9MCxkPWEubGVuZ3RoLGYsZT1uZXcgaChkLGIpO2M8ZDspe2Y9YS5jaGFyQ29kZUF0KGMpO2lmKDI1NTxmKXRocm93IFJhbmdlRXJyb3IoXCJpbGxlZ2FsIGNoYXIgY29kZTogXCIrZik7ZS52aWV3W2MrK109Zn1lLmxpbWl0PWQ7cmV0dXJuIGV9O2UudG9EZWJ1Zz1mdW5jdGlvbihhKXtmb3IodmFyIGI9XHJcbi0xLGM9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCxkLGY9XCJcIixlPVwiXCIsZz1cIlwiO2I8Yzspey0xIT09YiYmKGQ9dGhpcy52aWV3W2JdLGY9MTY+ZD9mKyhcIjBcIitkLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKTpmK2QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksYSYmKGUrPTMyPGQmJjEyNz5kP1N0cmluZy5mcm9tQ2hhckNvZGUoZCk6XCIuXCIpKTsrK2I7aWYoYSYmMDxiJiYwPT09YiUxNiYmYiE9PWMpe2Zvcig7NTE+Zi5sZW5ndGg7KWYrPVwiIFwiO2crPWYrZStcIlxcblwiO2Y9ZT1cIlwifWY9Yj09PXRoaXMub2Zmc2V0JiZiPT09dGhpcy5saW1pdD9mKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCIhXCI6XCJ8XCIpOmI9PT10aGlzLm9mZnNldD9mKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCJbXCI6XCI8XCIpOmI9PT10aGlzLmxpbWl0P2YrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIl1cIjpcIj5cIik6ZisoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiJ1wiOmF8fDAhPT1iJiZiIT09Yz9cIiBcIjpcIlwiKX1pZihhJiZcIiBcIiE9PVxyXG5mKXtmb3IoOzUxPmYubGVuZ3RoOylmKz1cIiBcIjtnKz1mK2UrXCJcXG5cIn1yZXR1cm4gYT9nOmZ9O2guZnJvbURlYnVnPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLmxlbmd0aDtiPW5ldyBoKChkKzEpLzN8MCxiLGMpO2Zvcih2YXIgZj0wLGU9MCxnLGs9ITEsbT0hMSxuPSExLHA9ITEscT0hMTtmPGQ7KXtzd2l0Y2goZz1hLmNoYXJBdChmKyspKXtjYXNlIFwiIVwiOmlmKCFjKXtpZihtfHxufHxwKXtxPSEwO2JyZWFrfW09bj1wPSEwfWIub2Zmc2V0PWIubWFya2VkT2Zmc2V0PWIubGltaXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCJ8XCI6aWYoIWMpe2lmKG18fHApe3E9ITA7YnJlYWt9bT1wPSEwfWIub2Zmc2V0PWIubGltaXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCJbXCI6aWYoIWMpe2lmKG18fG4pe3E9ITA7YnJlYWt9bT1uPSEwfWIub2Zmc2V0PWIubWFya2VkT2Zmc2V0PWU7az0hMTticmVhaztjYXNlIFwiPFwiOmlmKCFjKXtpZihtKXtxPSEwO2JyZWFrfW09ITB9Yi5vZmZzZXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCJdXCI6aWYoIWMpe2lmKHB8fFxyXG5uKXtxPSEwO2JyZWFrfXA9bj0hMH1iLmxpbWl0PWIubWFya2VkT2Zmc2V0PWU7az0hMTticmVhaztjYXNlIFwiPlwiOmlmKCFjKXtpZihwKXtxPSEwO2JyZWFrfXA9ITB9Yi5saW1pdD1lO2s9ITE7YnJlYWs7Y2FzZSBcIidcIjppZighYyl7aWYobil7cT0hMDticmVha31uPSEwfWIubWFya2VkT2Zmc2V0PWU7az0hMTticmVhaztjYXNlIFwiIFwiOms9ITE7YnJlYWs7ZGVmYXVsdDppZighYyYmayl7cT0hMDticmVha31nPXBhcnNlSW50KGcrYS5jaGFyQXQoZisrKSwxNik7aWYoIWMmJihpc05hTihnKXx8MD5nfHwyNTU8ZykpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nXCIpO2Iudmlld1tlKytdPWc7az0hMH1pZihxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBJbnZhbGlkIHN5bWJvbCBhdCBcIitmKTt9aWYoIWMpe2lmKCFtfHwhcCl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTWlzc2luZyBvZmZzZXQgb3IgbGltaXRcIik7XHJcbmlmKGU8Yi5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmcgKGlzIGl0IGhleD8pIFwiK2UrXCIgPCBcIitkKTt9cmV0dXJuIGJ9O2UudG9IZXg9ZnVuY3Rpb24oYSxiKXthPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT90aGlzLm9mZnNldDphO2I9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiP3RoaXMubGltaXQ6YjtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIitcclxudGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWZvcih2YXIgYz1BcnJheShiLWEpLGQ7YTxiOylkPXRoaXMudmlld1thKytdLDE2PmQ/Yy5wdXNoKFwiMFwiLGQudG9TdHJpbmcoMTYpKTpjLnB1c2goZC50b1N0cmluZygxNikpO3JldHVybiBjLmpvaW4oXCJcIil9O2guZnJvbUhleD1mdW5jdGlvbihhLGIsYyl7aWYoIWMpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2lmKDAhPT1hLmxlbmd0aCUyKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBMZW5ndGggbm90IGEgbXVsdGlwbGUgb2YgMlwiKTt9dmFyIGQ9YS5sZW5ndGg7Yj1uZXcgaChkLzJ8MCxiKTtmb3IodmFyIGYsZT0wLGc9MDtlPGQ7ZSs9Mil7Zj1wYXJzZUludChhLnN1YnN0cmluZyhlLGUrMiksMTYpO2lmKCFjJiYoIWlzRmluaXRlKGYpfHwwPmZ8fDI1NTxmKSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgbm9uLWhleCBjaGFyYWN0ZXJzXCIpO1xyXG5iLnZpZXdbZysrXT1mfWIubGltaXQ9ZztyZXR1cm4gYn07dmFyIG49ZnVuY3Rpb24oKXt2YXIgYT17TUFYX0NPREVQT0lOVDoxMTE0MTExLGVuY29kZVVURjg6ZnVuY3Rpb24oYSxjKXt2YXIgZD1udWxsO1wibnVtYmVyXCI9PT10eXBlb2YgYSYmKGQ9YSxhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9KTtmb3IoO251bGwhPT1kfHxudWxsIT09KGQ9YSgpKTspMTI4PmQ/YyhkJjEyNyk6KDIwNDg+ZD9jKGQ+PjYmMzF8MTkyKTooNjU1MzY+ZD9jKGQ+PjEyJjE1fDIyNCk6KGMoZD4+MTgmN3wyNDApLGMoZD4+MTImNjN8MTI4KSksYyhkPj42JjYzfDEyOCkpLGMoZCY2M3wxMjgpKSxkPW51bGx9LGRlY29kZVVURjg6ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGQsZixlLGcsaD1mdW5jdGlvbihhKXthPWEuc2xpY2UoMCxhLmluZGV4T2YobnVsbCkpO3ZhciBiPUVycm9yKGEudG9TdHJpbmcoKSk7Yi5uYW1lPVwiVHJ1bmNhdGVkRXJyb3JcIjtiLmJ5dGVzPWE7dGhyb3cgYjt9O251bGwhPT0oZD1hKCkpOylpZigwPT09XHJcbihkJjEyOCkpYyhkKTtlbHNlIGlmKDE5Mj09PShkJjIyNCkpbnVsbD09PShmPWEoKSkmJmgoW2QsZl0pLGMoKGQmMzEpPDw2fGYmNjMpO2Vsc2UgaWYoMjI0PT09KGQmMjQwKSludWxsIT09KGY9YSgpKSYmbnVsbCE9PShlPWEoKSl8fGgoW2QsZixlXSksYygoZCYxNSk8PDEyfChmJjYzKTw8NnxlJjYzKTtlbHNlIGlmKDI0MD09PShkJjI0OCkpbnVsbCE9PShmPWEoKSkmJm51bGwhPT0oZT1hKCkpJiZudWxsIT09KGc9YSgpKXx8aChbZCxmLGUsZ10pLGMoKGQmNyk8PDE4fChmJjYzKTw8MTJ8KGUmNjMpPDw2fGcmNjMpO2Vsc2UgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RhcnRpbmcgYnl0ZTogXCIrZCk7fSxVVEYxNnRvVVRGODpmdW5jdGlvbihhLGMpe2Zvcih2YXIgZCxlPW51bGw7bnVsbCE9PShkPW51bGwhPT1lP2U6YSgpKTspNTUyOTY8PWQmJjU3MzQzPj1kJiZudWxsIT09KGU9YSgpKSYmNTYzMjA8PWUmJjU3MzQzPj1lPyhjKDEwMjQqKGQtNTUyOTYpK2UtNTYzMjArNjU1MzYpLFxyXG5lPW51bGwpOmMoZCk7bnVsbCE9PWUmJmMoZSl9LFVURjh0b1VURjE2OmZ1bmN0aW9uKGEsYyl7dmFyIGQ9bnVsbDtcIm51bWJlclwiPT09dHlwZW9mIGEmJihkPWEsYT1mdW5jdGlvbigpe3JldHVybiBudWxsfSk7Zm9yKDtudWxsIT09ZHx8bnVsbCE9PShkPWEoKSk7KTY1NTM1Pj1kP2MoZCk6KGQtPTY1NTM2LGMoKGQ+PjEwKSs1NTI5NiksYyhkJTEwMjQrNTYzMjApKSxkPW51bGx9LGVuY29kZVVURjE2dG9VVEY4OmZ1bmN0aW9uKGIsYyl7YS5VVEYxNnRvVVRGOChiLGZ1bmN0aW9uKGIpe2EuZW5jb2RlVVRGOChiLGMpfSl9LGRlY29kZVVURjh0b1VURjE2OmZ1bmN0aW9uKGIsYyl7YS5kZWNvZGVVVEY4KGIsZnVuY3Rpb24oYil7YS5VVEY4dG9VVEYxNihiLGMpfSl9LGNhbGN1bGF0ZUNvZGVQb2ludDpmdW5jdGlvbihhKXtyZXR1cm4gMTI4PmE/MToyMDQ4PmE/Mjo2NTUzNj5hPzM6NH0sY2FsY3VsYXRlVVRGODpmdW5jdGlvbihhKXtmb3IodmFyIGMsZD0wO251bGwhPT0oYz1hKCkpOylkKz1cclxuMTI4PmM/MToyMDQ4PmM/Mjo2NTUzNj5jPzM6NDtyZXR1cm4gZH0sY2FsY3VsYXRlVVRGMTZhc1VURjg6ZnVuY3Rpb24oYil7dmFyIGM9MCxkPTA7YS5VVEYxNnRvVVRGOChiLGZ1bmN0aW9uKGEpeysrYztkKz0xMjg+YT8xOjIwNDg+YT8yOjY1NTM2PmE/Mzo0fSk7cmV0dXJuW2MsZF19fTtyZXR1cm4gYX0oKTtlLnRvVVRGOD1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitcclxuYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYzt0cnl7bi5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpe3JldHVybiBhPGI/dGhpcy52aWV3W2ErK106bnVsbH0uYmluZCh0aGlzKSxjPXIoKSl9Y2F0Y2goZCl7aWYoYSE9PWIpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIithK1wiICE9IFwiK2IpO31yZXR1cm4gYygpfTtoLmZyb21VVEY4PWZ1bmN0aW9uKGEsYixjKXtpZighYyYmXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7dmFyIGQ9bmV3IGgobi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpLCEwKVsxXSxiLGMpLGU9MDtuLmVuY29kZVVURjE2dG9VVEY4KG0oYSksZnVuY3Rpb24oYSl7ZC52aWV3W2UrK109YX0pO2QubGltaXQ9ZTtyZXR1cm4gZH07cmV0dXJuIGh9KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgIHRoaXMubm9kZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgY2MuYXVkaW9tYW5hZ2VyLnBsYXlTRlgoXCJjbGlja1wiKVxyXG4gICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5sb2coXCJvbmxvYWQgYmVnaW5cIilcclxuXHJcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUuRm9ybWF0ID0gZnVuY3Rpb24gKGZtdCkgeyAvL2F1dGhvcjogbWVpenogICBcclxuICAgICAgICB2YXIgbyA9IHsgIFxyXG4gICAgICAgICAgICBcIk0rXCI6IHRoaXMuZ2V0TW9udGgoKSArIDEsIC8v5pyI5Lu9ICAgXHJcbiAgICAgICAgICAgIFwiZCtcIjogdGhpcy5nZXREYXRlKCksIC8v5pelICAgXHJcbiAgICAgICAgICAgIFwiaCtcIjogdGhpcy5nZXRIb3VycygpLCAvL+Wwj+aXtiAgIFxyXG4gICAgICAgICAgICBcIm0rXCI6IHRoaXMuZ2V0TWludXRlcygpLCAvL+WIhiAgIFxyXG4gICAgICAgICAgICBcInMrXCI6IHRoaXMuZ2V0U2Vjb25kcygpLCAvL+enkiAgIFxyXG4gICAgICAgICAgICBcInErXCI6IE1hdGguZmxvb3IoKHRoaXMuZ2V0TW9udGgoKSArIDMpIC8gMyksIC8v5a2j5bqmICAgXHJcbiAgICAgICAgICAgIFwiU1wiOiB0aGlzLmdldE1pbGxpc2Vjb25kcygpIC8v5q+r56eSICAgXHJcbiAgICAgICAgfTsgIFxyXG4gICAgICAgIGlmICgvKHkrKS8udGVzdChmbXQpKSBmbXQgPSBmbXQucmVwbGFjZShSZWdFeHAuJDEsICh0aGlzLmdldEZ1bGxZZWFyKCkgKyBcIlwiKS5zdWJzdHIoNCAtIFJlZ0V4cC4kMS5sZW5ndGgpKTsgIFxyXG4gICAgICAgIGZvciAodmFyIGsgaW4gbykgIFxyXG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChcIihcIiArIGsgKyBcIilcIikudGVzdChmbXQpKSBmbXQgPSBmbXQucmVwbGFjZShSZWdFeHAuJDEsIChSZWdFeHAuJDEubGVuZ3RoID09IDEpID8gKG9ba10pIDogKChcIjAwXCIgKyBvW2tdKS5zdWJzdHIoKFwiXCIgKyBvW2tdKS5sZW5ndGgpKSk7ICBcclxuICAgICAgICByZXR1cm4gZm10OyAgXHJcbiAgICAgICAgfSAgXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5pbml0KCk7XHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5yZWdpc3RlckhhbmRsZXIoY2MuZGF0YW1hbmFnZXIpO1xyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIucmVnaXN0ZXJIYW5kbGVyKGNjLmdhbWVtYW5hZ2VyKTtcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnJlZ2lzdGVySGFuZGxlcihjYy5ndWltYW5hZ2VyKTtcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnJlZ2lzdGVySGFuZGxlcihjYy5yb2JvdCk7XHJcblxyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5pbml0KClcclxuXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5yZWNvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgY2MubG9nKCdvbmxvYWQnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBsb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiTG9uZ1wiXSA9IGZhY3RvcnkoKTtcclxuXHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4gICAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbiAgICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4gICAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbiAgICAvL1xyXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4gICAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuICAgIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuICAgIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIC8vXHJcbiAgICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuICAgIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gICAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIC8qIGlzIGNvbXBhdGlibGUgKi8gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHZhbC51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuT05FID0gT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgICAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICAgICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICAgICAgcmVzID0gWkVSTztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTG9uZztcclxufSk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBwcm90b2J1Zi5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJieXRlYnVmZmVyXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKSwgdHJ1ZSk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJQcm90b0J1ZlwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJ5dGVCdWZmZXJcIl0pO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oQnl0ZUJ1ZmZlciwgaXNDb21tb25KUykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgUHJvdG9CdWYgbmFtZXNwYWNlLlxyXG4gICAgICogQGV4cG9ydHMgUHJvdG9CdWZcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgdmFyIFByb3RvQnVmID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKG5ldzogQnl0ZUJ1ZmZlciwgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuQnl0ZUJ1ZmZlciA9IEJ5dGVCdWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzogTG9uZywgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTG9uZyA9IEJ5dGVCdWZmZXIuTG9uZyB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdG9CdWYuanMgdmVyc2lvbi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuVkVSU0lPTiA9IFwiNS4wLjFcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmUgdHlwZXMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYXJpbnQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml4ZWQgNjQgYml0cyB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExlbmd0aCBkZWxpbWl0ZWQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSA9IDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmQgZ3JvdXAgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVkIDMyIGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMiA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYWNrYWJsZSB3aXJlIHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0LFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHlwZXMuXHJcbiAgICAgKiBAZGljdFxyXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyLCBkZWZhdWx0VmFsdWU6ICp9Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5UWVBFUyA9IHtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXHJcbiAgICAgICAgXCJpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidWludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJ1aW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwidWludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5VWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNpbnQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJib29sXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJib29sXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkb3VibGVcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImRvdWJsZVwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdHJpbmdcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0sXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJieXRlc1wiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwgLy8gb3ZlcnJpZGRlbiBpbiB0aGUgY29kZSwgbXVzdCBiZSBhIHVuaXF1ZSBpbnN0YW5jZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMixcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAgUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuVVpFUk8gOiB1bmRlZmluZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ZpeGVkNjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZsb2F0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJlbnVtXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJlbnVtXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1lc3NhZ2VcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ3JvdXBcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVAsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZCBtYXAga2V5IHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48IU9iamVjdC48c3RyaW5nLHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXIsIGRlZmF1bHRWYWx1ZTogKn0+Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NQVBfS0VZX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXVxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gZmllbGQgaWQuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLklEX01JTiA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIGZpZWxkIGlkLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5JRF9NQVggPSAweDFGRkZGRkZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgZmllbGQgbmFtZXMgd2lsbCBiZSBjb252ZXJ0ZWQgZnJvbSB1bmRlcnNjb3JlIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UuIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiAgTXVzdCBiZSBzZXQgcHJpb3IgdG8gcGFyc2luZy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIG1lc3NhZ2VzIGFyZSBwb3B1bGF0ZWQgd2l0aCAoc2V0WCwgc2V0X3gpIGFjY2Vzc29ycyBmb3IgZWFjaCBmaWVsZC4gVGhpcyBjYW4gYmUgZGlzYWJsZWQgYnlcclxuICAgICAqICBzZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCBwcmlvciB0byBidWlsZGluZyBtZXNzYWdlcy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZUFjY2Vzc29ycyA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlcyBhcmUgcG9wdWxhdGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMgaWYgYSBmaWVsZCBpcyBub3QgcHJlc2VudCBvbiB0aGUgd2lyZS4gVG8gZGlzYWJsZVxyXG4gICAgICogIHRoaXMgYmVoYXZpb3IsIHNldCB0aGlzIHNldHRpbmcgdG8gYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZURlZmF1bHRzID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5VdGlsXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlV0aWwgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3RvQnVmIHV0aWxpdGllcy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5VdGlsXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBVdGlsID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZsYWcgaWYgcnVubmluZyBpbiBub2RlIG9yIG5vdC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbC5JU19OT0RFID0gISEoXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzKycnID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIXByb2Nlc3NbJ2Jyb3dzZXInXVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gTm8gZGVwZW5kZW5jaWVzIHBsZWFzZSwgcmVmOiBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL3htbGh0dHAuaHRtbFxyXG4gICAgICAgICAgICB2YXIgWE1MSHR0cEZhY3RvcmllcyA9IFtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKX0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P1hNTEh0dHBSZXF1ZXN0fSAqL1xyXG4gICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wO2k8WE1MSHR0cEZhY3Rvcmllcy5sZW5ndGg7aSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkgeyB4aHIgPSBYTUxIdHRwRmFjdG9yaWVzW2ldKCk7IH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXhocilcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHhocjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGZXRjaGVzIGEgcmVzb3VyY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUmVzb3VyY2UgcGF0aFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIHJlc291cmNlJ3MgY29udGVudHMuIElmIG9taXR0ZWQgdGhlIHJlc291cmNlIHdpbGxcclxuICAgICAgICAgKiAgIGJlIGZldGNoZWQgc3luY2hyb25vdXNseS4gSWYgdGhlIHJlcXVlc3QgZmFpbGVkLCBjb250ZW50cyB3aWxsIGJlIG51bGwuXHJcbiAgICAgICAgICogQHJldHVybiB7P3N0cmluZ3x1bmRlZmluZWR9IFJlc291cmNlIGNvbnRlbnRzIGlmIGNhbGxiYWNrIGlzIG9taXR0ZWQgKG51bGwgaWYgdGhlIHJlcXVlc3QgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWQuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWwuZmV0Y2ggPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChVdGlsLklTX05PREUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIrZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhociA9IFV0aWwuWEhSKCk7XHJcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgY2FsbGJhY2sgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8geGhyLnNldFJlcXVlc3RIZWFkZXIoJ1VzZXItQWdlbnQnLCAnWE1MSFRUUC8xLjAnKTtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIHJlbW90ZSAqLyB4aHIuc3RhdHVzID09IDIwMCB8fCAvKiBsb2NhbCAqLyAoeGhyLnN0YXR1cyA9PSAwICYmIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlsLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXyhbYS16QS1aXSkvZywgZnVuY3Rpb24gKCQwLCAkMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBVdGlsO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhbmd1YWdlIGV4cHJlc3Npb25zLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywhUmVnRXhwPn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTGFuZyA9IHtcclxuXHJcbiAgICAgICAgLy8gQ2hhcmFjdGVycyBhbHdheXMgZW5kaW5nIGEgc3RhdGVtZW50XHJcbiAgICAgICAgREVMSU06IC9bXFxzXFx7XFx9PTs6XFxbXFxdLCdcIlxcKFxcKTw+XS9nLFxyXG5cclxuICAgICAgICAvLyBGaWVsZCBydWxlc1xyXG4gICAgICAgIFJVTEU6IC9eKD86cmVxdWlyZWR8b3B0aW9uYWx8cmVwZWF0ZWR8bWFwKSQvLFxyXG5cclxuICAgICAgICAvLyBGaWVsZCB0eXBlc1xyXG4gICAgICAgIFRZUEU6IC9eKD86ZG91YmxlfGZsb2F0fGludDMyfHVpbnQzMnxzaW50MzJ8aW50NjR8dWludDY0fHNpbnQ2NHxmaXhlZDMyfHNmaXhlZDMyfGZpeGVkNjR8c2ZpeGVkNjR8Ym9vbHxzdHJpbmd8Ynl0ZXMpJC8sXHJcblxyXG4gICAgICAgIC8vIE5hbWVzXHJcbiAgICAgICAgTkFNRTogL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXHJcblxyXG4gICAgICAgIC8vIFR5cGUgZGVmaW5pdGlvbnNcclxuICAgICAgICBUWVBFREVGOiAvXlthLXpBLVpdW2EtekEtWl8wLTldKiQvLFxyXG5cclxuICAgICAgICAvLyBUeXBlIHJlZmVyZW5jZXNcclxuICAgICAgICBUWVBFUkVGOiAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSskLyxcclxuXHJcbiAgICAgICAgLy8gRnVsbHkgcXVhbGlmaWVkIHR5cGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIEZRVFlQRVJFRjogL14oPzpcXC5bYS16QS1aXVthLXpBLVpfMC05XSopKyQvLFxyXG5cclxuICAgICAgICAvLyBBbGwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUjogL14tPyg/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddK3woWzAtOV0qKFxcLlswLTldKik/KFtFZV1bKy1dP1swLTldKyk/KXxpbmZ8bmFuKSQvLFxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfREVDOiAvXig/OlsxLTldWzAtOV0qfDApJC8sXHJcblxyXG4gICAgICAgIC8vIEhleGFkZWNpbWFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfSEVYOiAvXjBbeFhdWzAtOWEtZkEtRl0rJC8sXHJcblxyXG4gICAgICAgIC8vIE9jdGFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfT0NUOiAvXjBbMC03XSskLyxcclxuXHJcbiAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9GTFQ6IC9eKFswLTldKihcXC5bMC05XSopPyhbRWVdWystXT9bMC05XSspP3xpbmZ8bmFuKSQvLFxyXG5cclxuICAgICAgICAvLyBCb29sZWFuc1xyXG4gICAgICAgIEJPT0w6IC9eKD86dHJ1ZXxmYWxzZSkkL2ksXHJcblxyXG4gICAgICAgIC8vIElkIG51bWJlcnNcclxuICAgICAgICBJRDogL14oPzpbMS05XVswLTldKnwwfDBbeFhdWzAtOWEtZkEtRl0rfDBbMC03XSspJC8sXHJcblxyXG4gICAgICAgIC8vIE5lZ2F0aXZlIGlkIG51bWJlcnMgKGVudW0gdmFsdWVzKVxyXG4gICAgICAgIE5FR0lEOiAvXlxcLT8oPzpbMS05XVswLTldKnwwfDBbeFhdWzAtOWEtZkEtRl0rfDBbMC03XSspJC8sXHJcblxyXG4gICAgICAgIC8vIFdoaXRlc3BhY2VzXHJcbiAgICAgICAgV0hJVEVTUEFDRTogL1xccy8sXHJcblxyXG4gICAgICAgIC8vIEFsbCBzdHJpbmdzXHJcbiAgICAgICAgU1RSSU5HOiAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKXwoPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZyxcclxuXHJcbiAgICAgICAgLy8gRG91YmxlIHF1b3RlZCBzdHJpbmdzXHJcbiAgICAgICAgU1RSSU5HX0RROiAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKS9nLFxyXG5cclxuICAgICAgICAvLyBTaW5nbGUgcXVvdGVkIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkdfU1E6IC8oPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5Eb3RQcm90byA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZykge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXRpZXMgdG8gcGFyc2UgLnByb3RvIGZpbGVzLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEb3RQcm90byA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRva2VuaXplci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJcclxuICAgICAgICAgKiBAY2xhc3MgcHJvdG90eXBlIHRva2VuaXplclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byBQcm90byB0byB0b2tlbml6ZVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihwcm90bykge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNvdXJjZSB0byBwYXJzZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBwcm90bytcIlwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgaW5kZXguXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgbGluZS5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5saW5lID0gMTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUb2tlbiBzdGFjay5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9wZW5pbmcgY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IHN0cmluZyByZWFkLCBpZiBhbnkuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc3RyaW5nT3BlbiA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG9rZW5pemVyUHJvdG90eXBlID0gVG9rZW5pemVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSBzdHJpbmcgYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5fcmVhZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLl9zdHJpbmdPcGVuID09PSAnXCInXHJcbiAgICAgICAgICAgICAgICA/IExhbmcuU1RSSU5HX0RRXHJcbiAgICAgICAgICAgICAgICA6IExhbmcuU1RSSU5HX1NRO1xyXG4gICAgICAgICAgICByZS5sYXN0SW5kZXggPSB0aGlzLmluZGV4IC0gMTsgLy8gSW5jbHVkZSB0aGUgb3BlbiBxdW90ZVxyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHRoaXMuc291cmNlKTtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW50ZXJtaW5hdGVkIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlLmxhc3RJbmRleDtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuX3N0cmluZ09wZW4pO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJpbmdPcGVuID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzIGJ5IG9uZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUb2tlbiBvciBgbnVsbGAgb24gRU9GXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmluZ09wZW4gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcGVhdCxcclxuICAgICAgICAgICAgICAgIHByZXYsXHJcbiAgICAgICAgICAgICAgICBuZXh0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCB3aGl0ZSBzcGFjZXNcclxuICAgICAgICAgICAgICAgIHdoaWxlIChMYW5nLldISVRFU1BBQ0UudGVzdChuZXh0ID0gdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykgeyAvLyBMaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnNvdXJjZS5jaGFyQXQoKyt0aGlzLmluZGV4KSAhPT0gJ1xcbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobmV4dCA9IHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSkgPT09ICcqJykgeyAvKiBCbG9jayAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmluZGV4ID09PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgIT09ICcqJyB8fCBuZXh0ICE9PSAnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnLyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICBMYW5nLkRFTElNLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IExhbmcuREVMSU0udGVzdCh0aGlzLnNvdXJjZS5jaGFyQXQoZW5kKyspKTtcclxuICAgICAgICAgICAgaWYgKCFkZWxpbSlcclxuICAgICAgICAgICAgICAgIHdoaWxlKGVuZCA8IHRoaXMuc291cmNlLmxlbmd0aCAmJiAhTGFuZy5ERUxJTS50ZXN0KHRoaXMuc291cmNlLmNoYXJBdChlbmQpKSlcclxuICAgICAgICAgICAgICAgICAgICArK2VuZDtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggPSBlbmQpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09IFwiJ1wiKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nT3BlbiA9IHRva2VuO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbMF07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2tpcHMgYSBzcGVjaWZpYyB0b2tlbiBhbmQgdGhyb3dzIGlmIGl0IGRpZmZlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBhY3R1YWwgdG9rZW4gZGlmZmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCAnXCIrYWN0dWFsK1wiJywgJ1wiK2V4cGVjdGVkK1wiJyBleHBlY3RlZFwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbWl0cyBhbiBvcHRpb25hbCB0b2tlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgb3B0aW9uYWwgdG9rZW5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB0b2tlbiBleGlzdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2tlbml6ZXJQcm90b3R5cGUub21pdCA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJUb2tlbml6ZXIoaW5kZXgvbGVuZ3RoKVwiXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJUb2tlbml6ZXIgKFwiK3RoaXMuaW5kZXgrXCIvXCIrdGhpcy5zb3VyY2UubGVuZ3RoK1wiIGF0IGxpbmUgXCIrdGhpcy5saW5lK1wiKVwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRG90UHJvdG8uVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFBhcnNlci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXJcclxuICAgICAgICAgKiBAY2xhc3MgcHJvdG90eXBlIHBhcnNlclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRva2VuaXplci5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudG4gPSBuZXcgVG9rZW5pemVyKHNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBwYXJzaW5nIHByb3RvMyBvciBub3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wcm90bzMgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQYXJzZXJQcm90b3R5cGUgPSBQYXJzZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgdGhlIHNvdXJjZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9wTGV2ZWwgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJbUk9PVF1cIiwgLy8gdGVtcG9yYXJ5XHJcbiAgICAgICAgICAgICAgICBcInBhY2thZ2VcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImVudW1zXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpbXBvcnRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgXCJzZXJ2aWNlc1wiOiBbXVxyXG4gICAgICAgICAgICAgICAgLy8gXCJzeW50YXhcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIGhlYWQgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2VhaztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZCB8fCB0b3BMZXZlbFtcInBhY2thZ2VcIl0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdwYWNrYWdlJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcGFja2FnZSBuYW1lOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFtcInBhY2thZ2VcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5leHBlY3RlZCAnaW1wb3J0J1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicHVibGljXCIgfHwgKHdlYWsgPSB0b2tlbiA9PT0gXCJ3ZWFrXCIpKSAvLyB0b2tlbiBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuX3JlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspIC8vIGltcG9ydCBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxbXCJpbXBvcnRzXCJdLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bnRheCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdzeW50YXgnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodG9wTGV2ZWxbXCJzeW50YXhcIl0gPSB0aGlzLl9yZWFkU3RyaW5nKCkpID09PSBcInByb3RvM1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG8zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UodG9wTGV2ZWwsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFbnVtKHRvcExldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvcHRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24odG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlKHRvcExldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdleHRlbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQodG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgJ1wiICsgdG9rZW4gKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIlBhcnNlIGVycm9yIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIiArIGUubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRvcExldmVsW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvcExldmVsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzb3VyY2UpLnBhcnNlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gQ29udmVyc2lvbiAtLS0tLS1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBudW1lcmljYWwgc3RyaW5nIHRvIGFuIGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG1heUJlTmVnYXRpdmVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1rSWQodmFsdWUsIG1heUJlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gLTEsXHJcbiAgICAgICAgICAgICAgICBzaWduID0gMTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PSAnLScpIHtcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUl9ERUMudGVzdCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMSksIDgpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgaWQgdmFsdWU6IFwiICsgKHNpZ24gPCAwID8gJy0nIDogJycpICsgdmFsdWUpO1xyXG4gICAgICAgICAgICBpZCA9IChzaWduKmlkKXwwOyAvLyBGb3JjZSB0byAzMmJpdFxyXG4gICAgICAgICAgICBpZiAoIW1heUJlTmVnYXRpdmUgJiYgaWQgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGlkIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBudW1lcmljYWwgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1rTnVtYmVyKHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IDE7XHJcbiAgICAgICAgICAgIGlmICh2YWwuY2hhckF0KDApID09ICctJykge1xyXG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVJfREVDLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsLCAxMCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0hFWC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsLnN1YnN0cmluZygxKSwgOCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ2luZicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPT09ICduYW4nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfRkxULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbnVtYmVyIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0tLSBSZWFkaW5nIC0tLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHN0cmluZy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgIGRlbGltO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBkZWxpbSA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGltICE9PSBcIidcIiAmJiBkZWxpbSAhPT0gJ1wiJylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc3RyaW5nIGRlbGltaXRlcjogXCIrZGVsaW0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoZGVsaW0pO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09ICdcIicpOyAvLyBtdWx0aSBsaW5lP1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtYXlCZVR5cGVSZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfGJvb2xlYW58c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9yZWFkVmFsdWUgPSBmdW5jdGlvbihtYXlCZVR5cGVSZWYpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5wZWVrKCksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnXCInIHx8IHRva2VuID09PSBcIidcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVIudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWtOdW1iZXIodG9rZW4pO1xyXG4gICAgICAgICAgICBpZiAoTGFuZy5CT09MLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0b2tlbi50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpO1xyXG4gICAgICAgICAgICBpZiAobWF5QmVUeXBlUmVmICYmIExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHZhbHVlOiBcIit0b2tlbik7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIFBhcnNpbmcgY29uc3RydWN0cyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYSBuYW1lc3BhY2Ugb3B0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNMaXN0XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlT3B0aW9uID0gZnVuY3Rpb24ocGFyZW50LCBpc0xpc3QpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCksXHJcbiAgICAgICAgICAgICAgICBjdXN0b20gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGFsbG93IG9wdGlvbnMgb2YgdGhlIGZvcm0gZ29vZ2xlLnByb3RvYnVmLiogc2luY2UgdGhleSB3aWxsIGp1c3QgZ2V0IGlnbm9yZWQgYW55d2F5c1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCEvZ29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QodG9rZW4pKSAvLyBGSVhNRTogV2h5IHNob3VsZCB0aGF0IG5vdCBiZSBhIHZhbGlkIHR5cGVyZWY/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9wdGlvbiBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgIGlmIChjdXN0b20pIHsgLy8gKG15X21ldGhvZF9vcHRpb24pLmZvbywgKG15X21ldGhvZF9vcHRpb24pLCBzb21lX21ldGhvZF9vcHRpb24sIChmb28ubXlfb3B0aW9uKS5iYXJcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnKScpO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9ICcoJytuYW1lKycpJztcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5GUVRZUEVSRUYudGVzdCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPScpO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNMaXN0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuIG9wdGlvbiBvbiB0aGUgc3BlY2lmaWVkIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb24ob3B0aW9ucywgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW25hbWVdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9uc1tuYW1lXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IFsgb3B0aW9uc1tuYW1lXSBdO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXS5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGFuIG9wdGlvbiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlT3B0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gJ3snKSB7IC8vIFBsYWluIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50W1wib3B0aW9uc1wiXSwgbmFtZSwgdGhpcy5fcmVhZFZhbHVlKHRydWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gQWdncmVnYXRlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9wdGlvbiBuYW1lOiBcIiArIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50bi5vbWl0KFwiOlwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudFtcIm9wdGlvbnNcIl0sIG5hbWUgKyBcIi5cIiArIHRva2VuLCB0aGlzLl9yZWFkVmFsdWUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIHNlcnZpY2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZVNlcnZpY2UgPSBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHNlcnZpY2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICB2YXIgc3ZjID0ge1xyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBcInJwY1wiOiB7fSxcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihzdmMpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdycGMnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU2VydmljZVJQQyhzdmMpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBzZXJ2aWNlIHRva2VuOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgcGFyZW50W1wic2VydmljZXNcIl0ucHVzaChzdmMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIFJQQyBzZXJ2aWNlIGRlZmluaXRpb24gb2YgdGhlIGZvcm0gWydycGMnLCBuYW1lLCAocmVxdWVzdCksICdyZXR1cm5zJywgKHJlc3BvbnNlKV0uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBzdmMgU2VydmljZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlU2VydmljZVJQQyA9IGZ1bmN0aW9uKHN2Yykge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwicnBjXCIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBycGMgc2VydmljZSBtZXRob2QgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0ge1xyXG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0XCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBcInJlcXVlc3Rfc3RyZWFtXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJyZXNwb25zZV9zdHJlYW1cIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge31cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiKFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgPT09IFwic3RyZWFtXCIpIHtcclxuICAgICAgICAgICAgICBtZXRob2RbXCJyZXF1ZXN0X3N0cmVhbVwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBycGMgc2VydmljZSByZXF1ZXN0IHR5cGU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgbWV0aG9kW1wicmVxdWVzdFwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIpXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSAhPT0gXCJyZXR1cm5zXCIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcnBjIHNlcnZpY2UgcmVxdWVzdCB0eXBlIGRlbGltaXRlcjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIoXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gXCJzdHJlYW1cIikge1xyXG4gICAgICAgICAgICAgIG1ldGhvZFtcInJlc3BvbnNlX3N0cmVhbVwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXRob2RbXCJyZXNwb25zZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIpXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICd7Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09ICdvcHRpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIHRva2VuOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudG4ub21pdChcIjtcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmNbdHlwZV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgc3ZjW3R5cGVdID0ge307XHJcbiAgICAgICAgICAgIHN2Y1t0eXBlXVtuYW1lXSA9IG1ldGhvZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYSBtZXNzYWdlIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3Q9fSBmbGQgRmllbGQgZGVmaW5pdGlvbiBpZiB0aGlzIGlzIGEgZ3JvdXBcclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlID0gZnVuY3Rpb24ocGFyZW50LCBmbGQpIHtcclxuICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSAhIWZsZCxcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwiZmllbGRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJlbnVtc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge30sXHJcbiAgICAgICAgICAgICAgICBcInNlcnZpY2VzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvbmVvZnNcIjoge31cclxuICAgICAgICAgICAgICAgIC8vIFwiZXh0ZW5zaW9uc1wiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgXCIrKGlzR3JvdXAgPyBcImdyb3VwXCIgOiBcIm1lc3NhZ2VcIikrXCIgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICBtc2dbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgZmxkW1wiaWRcIl0gPSBta0lkKHRoaXMudG4ubmV4dCgpKTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcImlzR3JvdXBcIl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1snICYmIGZsZClcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGZsZCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChtc2csIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9uZW9mXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlT25lT2YobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImVudW1cIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0obXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1lc3NhZ2VcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1zZyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJzZXJ2aWNlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlKG1zZyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJleHRlbnNpb25zXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5oYXNPd25Qcm9wZXJ0eShcImV4dGVuc2lvbnNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IG1zZ1tcImV4dGVuc2lvbnNcIl0uY29uY2F0KHRoaXMuX3BhcnNlRXh0ZW5zaW9uUmFuZ2VzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IHRoaXMuX3BhcnNlRXh0ZW5zaW9uUmFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwicmVzZXJ2ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlnbm9yZWQoKTsgLy8gVE9ET1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZXh0ZW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBydWxlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIHRva2VuOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChtc2cpO1xyXG4gICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhbiBpZ25vcmVkIHN0YXRlbWVudC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VJZ25vcmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRuLnBlZWsoKSAhPT0gJzsnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBGaWVsZCBydWxlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEZpZWxkIHR5cGUgaWYgYWxyZWFkeSBrbm93biAobmV2ZXIga25vd24gZm9yIG1hcHMpXHJcbiAgICAgICAgICogQHJldHVybnMgeyFPYmplY3R9IEZpZWxkIGRlc2NyaXB0b3JcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihtc2csIHJ1bGUsIHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLlJVTEUudGVzdChydWxlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIHJ1bGU6IFwiK3J1bGUpO1xyXG4gICAgICAgICAgICB2YXIgZmxkID0ge1xyXG4gICAgICAgICAgICAgICAgXCJydWxlXCI6IHJ1bGUsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgaWYgKHJ1bGUgPT09IFwibWFwXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0eXBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPCcpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodG9rZW4pICYmICFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG1lc3NhZ2UgZmllbGQgdHlwZTogXCIgKyB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJrZXl0eXBlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoJywnKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPicpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIG5hbWU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZmxkW1wibmFtZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcImlkXCJdID0gbWtJZCh0aGlzLnRuLm5leHQoKSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMoZmxkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcgPyB0eXBlIDogdGhpcy50bi5uZXh0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcIkEgW2xlZ2FjeV0gZ3JvdXAgc2ltcGx5IGNvbWJpbmVzIGEgbmVzdGVkIG1lc3NhZ2UgdHlwZSBhbmQgYSBmaWVsZCBpbnRvIGEgc2luZ2xlIGRlY2xhcmF0aW9uLiBJbiB5b3VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSwgeW91IGNhbiB0cmVhdCB0aGlzIG1lc3NhZ2UganVzdCBhcyBpZiBpdCBoYWQgYSBSZXN1bHQgdHlwZSBmaWVsZCBjYWxsZWQgcmVzdWx0ICh0aGUgbGF0dGVyIG5hbWUgaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXItY2FzZSBzbyB0aGF0IGl0IGRvZXMgbm90IGNvbmZsaWN0IHdpdGggdGhlIGZvcm1lcikuXCJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JwID0gdGhpcy5fcGFyc2VNZXNzYWdlKG1zZywgZmxkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9eW0EtWl0vLnRlc3QoZ3JwW1wibmFtZVwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdpbGxlZ2FsIGdyb3VwIG5hbWU6ICcrZ3JwW1wibmFtZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IGdycFtcIm5hbWVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1wibmFtZVwiXSA9IGdycFtcIm5hbWVcIl0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodHlwZSkgJiYgIUxhbmcuVFlQRVJFRi50ZXN0KHR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCB0eXBlOiBcIiArIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIG5hbWU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcImlkXCJdID0gbWtJZCh0aGlzLnRuLm5leHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwiW1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9ucyhmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXS5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbGQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBvbmVvZi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlT25lT2YgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9uZW9mIG5hbWU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbixcclxuICAgICAgICAgICAgICAgIGZsZDtcclxuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSBcIn1cIikge1xyXG4gICAgICAgICAgICAgICAgZmxkID0gdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcIm9uZW9mXCJdID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZsZFtcImlkXCJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBtc2dbXCJvbmVvZnNcIl1bbmFtZV0gPSBmaWVsZHM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgc2V0IG9mIGZpZWxkIG9wdGlvbiBkZWZpbml0aW9ucy5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlRmllbGRPcHRpb25zID0gZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIltcIik7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ucGVlaygpKSAhPT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIixcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihmbGQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYW4gZW51bS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VFbnVtID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIHZhciBlbm0gPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIGVubVtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gJ30nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oZW5tKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIj1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IG1rSWQodGhpcy50bi5uZXh0KCksIHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJbXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKHsgXCJvcHRpb25zXCI6IHt9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5tW1widmFsdWVzXCJdLnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBtc2dbXCJlbnVtc1wiXS5wdXNoKGVubSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGV4dGVuc2lvbiAvIHJlc2VydmVkIHJhbmdlcy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUFycmF5LjwhQXJyYXkuPG51bWJlcj4+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZUV4dGVuc2lvblJhbmdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWluXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFByb3RvQnVmLklEX01JTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWF4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFByb3RvQnVmLklEX01BWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBta051bWJlcih0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG4ucGVlaygpICE9PSBcInRvXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy50bi5vbWl0KFwiLFwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGFuIGV4dGVuZCBibG9jay5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlRXh0ZW5kID0gZnVuY3Rpb24ocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmQgcmVmZXJlbmNlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBcInJlZlwiOiB0b2tlbixcclxuICAgICAgICAgICAgICAgIFwiZmllbGRzXCI6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBydWxlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQoZXh0LCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmQgdG9rZW46IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBwYXJlbnRbXCJtZXNzYWdlc1wiXS5wdXNoKGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gR2VuZXJhbCAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGFyc2VyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlBhcnNlciBhdCBsaW5lIFwiK3RoaXMudG4ubGluZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERvdFByb3RvLlBhcnNlciA9IFBhcnNlcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIERvdFByb3RvO1xyXG5cclxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlJlZmxlY3QgPSAoZnVuY3Rpb24oUHJvdG9CdWYpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlcy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWZsZWN0ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBSZWZsZWN0IGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gcGFyZW50IFBhcmVudCBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRlciByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuQnVpbGRlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JqZWN0IG5hbWUgaW4gbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlQucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRQcm90b3R5cGUgPSBULnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gRnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgb2YgXCIuUEFUSC5UTy5USElTXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHB0ciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHB0ci5uYW1lK1wiLlwiK25hbWU7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUmVmbGVjdCBvYmplY3QgKGl0cyBmdWxseSBxdWFsaWZpZWQgbmFtZSkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUNsYXNzIFNldCB0byB0cnVlIHRvIGluY2x1ZGUgdGhlIGNsYXNzIG5hbWUuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbmNsdWRlQ2xhc3MgPyB0aGlzLmNsYXNzTmFtZSArIFwiIFwiIDogXCJcIikgKyB0aGlzLmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGlzIHR5cGUuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgdHlwZSBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBiZSBidWlsdCBkaXJlY3RseVwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuVCA9IFQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgTmFtZXNwYWNlIHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgTmFtZXNwYWNlIG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZHJlbiBpbnNpZGUgdGhlIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIChlLmcuLCBwcm90bzIgb3IgcHJvdG8zKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCBcInByb3RvMlwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmFtZXNwYWNlUHJvdG90eXBlID0gTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lc3BhY2UncyBjaGlsZHJlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuVD19IHR5cGUgRmlsdGVyIHR5cGUgKHJldHVybnMgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZSBvbmx5KS4gRGVmYXVsdHMgdG8gbnVsbCAoYWxsIGNoaWxkcmVuKS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBjaGlsZCBDaGlsZFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY2hpbGQgY2Fubm90IGJlIGFkZGVkIChkdXBsaWNhdGUpXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKG90aGVyID0gdGhpcy5nZXRDaGlsZChjaGlsZC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkICYmIG90aGVyLm5hbWUgIT09IG90aGVyLm9yaWdpbmFsTmFtZSAmJiB0aGlzLmdldENoaWxkKG90aGVyLm9yaWdpbmFsTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIubmFtZSA9IG90aGVyLm9yaWdpbmFsTmFtZTsgLy8gUmV2ZXJ0IHByZXZpb3VzIGZpcnN0IChlZmZlY3RpdmVseSBrZWVwcyBib3RoIG9yaWdpbmFscylcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChjaGlsZC5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjaGlsZC5vcmlnaW5hbE5hbWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgbmFtZSBpbiBuYW1lc3BhY2UgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGQubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgY2hpbGQgYnkgaXRzIG5hbWUgb3IgaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gVGhlIGNoaWxkIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9ySWQgPT09ICdudW1iZXInID8gJ2lkJyA6ICduYW1lJztcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT09IG5hbWVPcklkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlcyBhIHJlZmxlY3Qgb2JqZWN0IGluc2lkZSBvZiB0aGlzIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IHFuIFF1YWxpZmllZCBuYW1lIHRvIHJlc29sdmVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IFRoZSByZXNvbHZlZCB0eXBlIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSB0eXBlb2YgcW4gPT09ICdzdHJpbmcnID8gcW4uc3BsaXQoXCIuXCIpIDogcW4sXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0W2ldID09PSBcIlwiKSB7IC8vIEZ1bGx5IHF1YWxpZmllZCBuYW1lLCBlLmcuIFwiLk15Lk1lc3NhZ2UnXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCB8fCAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5UKSB8fCAoZXhjbHVkZU5vbk5hbWVzcGFjZSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gY2hpbGQ7IGkrKztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBwYXJ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlIHNlYXJjaCB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlc29sdmUocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChwdHIgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwdHI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBpZiBhbnksIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVH0gdCBSZWZsZWN0aW9uIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb3IsIGlmIHRoZXJlIGlzIG5vbmUsIHRoZSBmcW5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLnFuID0gZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IFtdLCBwdHIgPSB0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnVuc2hpZnQocHRyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9PSBudWxsKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbGVuPTE7IGxlbiA8PSBwYXJ0Lmxlbmd0aDsgbGVuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBxbiA9IHBhcnQuc2xpY2UocGFydC5sZW5ndGgtbGVuKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ID09PSB0aGlzLnJlc29sdmUocW4sIHQgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFuLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0LmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLEZ1bmN0aW9ufE9iamVjdD59IFJ1bnRpbWUgbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgdmFyIG5zID0ge307XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1jaGlsZHJlbi5sZW5ndGgsIGNoaWxkOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICBuc1tjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBuYW1lc3BhY2UncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZE9wdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0ID0ge30sXHJcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPWtleXMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW9ucyBhcmUgbm90IHJlc29sdmVkLCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAodmFsIGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb3B0W2tleV0gPSB2YWwuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBvcHRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFJldHVybnMgdGhlIG9wdGlvbiB2YWx1ZSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBhbGwgb3B0aW9ucyBhcmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9uc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnNbbmFtZV0gOiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0Lk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbGVtZW50IGltcGxlbWVudGF0aW9uIHRoYXQgY2hlY2tzIGFuZCBjb252ZXJ0cyB2YWx1ZXMgZm9yIGFcclxuICAgICAgICAgKiBwYXJ0aWN1bGFyIGZpZWxkIHR5cGUsIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW4gRWxlbWVudCByZXByZXNlbnRzIGEgc2luZ2xlIHZhbHVlOiBlaXRoZXIgdGhlIHZhbHVlIG9mIGEgc2luZ3VsYXIgZmllbGQsXHJcbiAgICAgICAgICogb3IgYSB2YWx1ZSBjb250YWluZWQgaW4gb25lIGVudHJ5IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwIGZpZWxkLiBUaGlzXHJcbiAgICAgICAgICogY2xhc3MgZG9lcyBub3QgaW1wbGVtZW50IHRoZXNlIGhpZ2hlci1sZXZlbCBjb25jZXB0czsgaXQgb25seSBlbmNhcHN1bGF0ZXNcclxuICAgICAgICAgKiB0aGUgbG93LWxldmVsIHR5cGVjaGVja2luZyBhbmQgY29udmVyc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19IHR5cGUgUmVzb2x2ZWQgZGF0YSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH0gcmVzb2x2ZWRUeXBlIFJlc29sdmVkIHR5cGUsIGlmIHJlbGV2YW50XHJcbiAgICAgICAgICogKGUuZy4gc3VibWVzc2FnZSBmaWVsZCkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc01hcEtleSBJcyB0aGlzIGVsZW1lbnQgYSBNYXAga2V5PyBUaGUgdmFsdWUgd2lsbCBiZVxyXG4gICAgICAgICAqIGNvbnZlcnRlZCB0byBzdHJpbmcgZm9ybSBpZiBzby5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ludGF4IFN5bnRheCBsZXZlbCBvZiBkZWZpbmluZyBtZXNzYWdlIHR5cGUsIGUuZy4sXHJcbiAgICAgICAgICogcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoaXMgZWxlbWVudCAoZm9yIGVycm9yXHJcbiAgICAgICAgICogbWVzc2FnZXMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCByZXNvbHZlZFR5cGUsIGlzTWFwS2V5LCBzeW50YXgsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IHR5cGUsIGFzIGEgc3RyaW5nIChlLmcuLCBpbnQzMikuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCB0eXBlIHJlZmVyZW5jZSB0byBzdWJtZXNzYWdlIG9yIGVudW0gZGVmaW5pdGlvbiwgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IHJlc29sdmVkVHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGlzIGEgbWFwIGtleS5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzTWFwS2V5ID0gaXNNYXBLZXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIG9mIGRlZmluaW5nIG1lc3NhZ2UgdHlwZSwgZS5nLiwgcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgdGhpcyBlbGVtZW50IChmb3IgZXJyb3IgbWVzc2FnZXMpXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTWFwS2V5ICYmIFByb3RvQnVmLk1BUF9LRVlfVFlQRVMuaW5kZXhPZih0eXBlKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbWFwIGtleSB0eXBlOiBcIiArIHR5cGUubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyBhIChuZXcpIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fSBGaWVsZCB0eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IERlZmF1bHQgdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0RlZmF1bHQodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFByb3RvQnVmLlRZUEVTW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUuZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZGVmYXVsdCB2YWx1ZSBmb3IgdHlwZSBcIit0eXBlLm5hbWUrXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBmaWVsZCBpbiBwcm90bzMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gdGhlIGZpZWxkIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUgPSBta0RlZmF1bHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2VzIGEgTG9uZyBmcm9tIGEgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAqICBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubG93ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUuaGlnaCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnVuc2lnbmVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lIHx8ICcnKSArICh0aGlzLmlzTWFwS2V5ID8gJ21hcCcgOiAndmFsdWUnKSArICcgZWxlbWVudCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBzZXQgZm9yIGFuIGVsZW1lbnQgb2YgdGhpcyB0eXBlIChzaW5ndWxhclxyXG4gICAgICAgICAqIGZpZWxkIG9yIG9uZSBlbGVtZW50IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwKS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gVmVyaWZpZWQsIG1heWJlIGFkanVzdGVkLCB2YWx1ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHZlcmlmaWVkIGZvciB0aGlzIGVsZW1lbnQgc2xvdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3NlbGYudG9TdHJpbmcodHJ1ZSkrXCIgb2YgdHlwZSBcIitzZWxmLnR5cGUubmFtZStcIjogXCIrdmFsK1wiIChcIittc2crXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5zaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAodmFsdWUgPT09IHZhbHVlICYmIHZhbHVlICUgMSAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZXMgTG9uZy5qc1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWtMb25nKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgbnVtYmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiK3ZhbHVlOyAvLyBDb252ZXJ0IFN0cmluZyBvYmplY3QgdG8gc3RyaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci53cmFwKHZhbHVlLCBcImJhc2U2NFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc29sdmVkVHlwZS5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXS5uYW1lID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzW2ldLmlkID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSAncHJvdG8zJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm90bzM6IGp1c3QgbWFrZSBzdXJlIGl0J3MgYW4gaW50ZWdlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDQyOTQ5NjcyOTUgfHwgdmFsdWUgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGluIHJhbmdlIGZvciB1aW50MzJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvMiByZXF1aXJlcyBlbnVtIHZhbHVlcyB0byBiZSB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh2YWx1ZSwgXCJub3QgYSB2YWxpZCBlbnVtIHZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlzbWF0Y2hlZCB0eXBlOiBDb252ZXJ0IHRvIG9iamVjdCAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy9pc3N1ZXMvMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGxldCdzIHRyeSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gYSBrZXktdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlZFR5cGUuY2xhenopKHZhbHVlKTsgLy8gTWF5IHRocm93IGZvciBhIGh1bmRyZWQgb2YgcmVhc29uc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmRlZmluZWQgdHlwZSBcIit0aGlzLnR5cGUrXCIpXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgb24gdGhlIHdpcmUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS5jYWxjdWxhdGVMZW5ndGggPSBmdW5jdGlvbihpZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gMDsgLy8gTm90aGluZyB0byBlbmNvZGVcclxuICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxyXG4gICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSkgOiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUucmVtYWluaW5nKCkpICsgdmFsdWUucmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKChpZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgRmllbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZW5jb2RlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmVuY29kZVZhbHVlID0gZnVuY3Rpb24oaWQsIHZhbHVlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gYnVmZmVyOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91IHVzZSBpbnQzMiBvciBpbnQ2NCBhcyB0aGUgdHlwZSBmb3IgYSBuZWdhdGl2ZSBudW1iZXIsIHRoZSByZXN1bHRpbmcgdmFyaW50IGlzIGFsd2F5cyB0ZW4gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb25nIOKAkyBpdCBpcywgZWZmZWN0aXZlbHksIHRyZWF0ZWQgbGlrZSBhIHZlcnkgbGFyZ2UgdW5zaWduZWQgaW50ZWdlci5cIiAoc2VlICMxMjIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzJaaWdaYWcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgYXMtaXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NFppZ1phZyh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCBzaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJvb2xcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnID8gMCA6ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVlN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUucmVtYWluaW5nKCkrXCIgYnl0ZXMgcmVtYWluaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2T2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJiKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKGlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgb25lIGVsZW1lbnQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFRoZSBmaWVsZCB3aXJlIHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIGZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm4geyp9IERlY29kZWQgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCB3aXJlVHlwZSwgaWQpIHtcclxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlICE9IHRoaXMudHlwZS53aXJlVHlwZSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB3aXJlIHR5cGUgZm9yIGVsZW1lbnRcIik7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzJaaWdaYWcoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgMzJiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRJbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKS50b1Vuc2lnbmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0WmlnWmFnKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIDY0Yml0IHNpZ25lZFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlICh2YXJpbnQpXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIEJ1aWxkZXIuTWVzc2FnZSNzZXQgd2lsbCBhbHJlYWR5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEZsb2F0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVlN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuY2xvbmUoKTsgLy8gT2Zmc2V0IGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubGltaXQgPSB2YWx1ZS5vZmZzZXQrbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCBuQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCAtMSwgaWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgZGVjb2RlIHR5cGVcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIHRoZSBjYW5vbmljYWwgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTGVnYWwgb25seSB3aGVuIGlzTWFwS2V5IGlzIHRydWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS52YWx1ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFwS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInZhbHVlRnJvbVN0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShwYXJzZUludChzdHIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTG9uZy1iYXNlZCBmaWVsZHMgc3VwcG9ydCBjb252ZXJzaW9ucyBmcm9tIHN0cmluZyBhbHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5VmFsdWUoc3RyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT09IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShzdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgdmFsdWUgZnJvbSB0aGUgY2Fub25pY2FsIGVsZW1lbnQgdHlwZSB0byBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHNob3VsZCBiZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZUZyb21TdHJpbmcodmFsdWVUb1N0cmluZyh2YWwpKWAgcmV0dXJuc1xyXG4gICAgICAgICAqIGEgdmFsdWUgZXF1aXZhbGVudCB0byBgdmVyaWZ5VmFsdWUodmFsKWAgZm9yIGV2ZXJ5IGxlZ2FsIHZhbHVlIG9mIGB2YWxgXHJcbiAgICAgICAgICogYWNjb3JkaW5nIHRvIHRoaXMgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtYXkgYmUgdXNlZCB3aGVuIHRoZSBlbGVtZW50IG11c3QgYmUgc3RvcmVkIG9yIHVzZWQgYXMgYSBzdHJpbmcsXHJcbiAgICAgICAgICogZS5nLiwgYXMgYSBtYXAga2V5IG9uIGFuIE9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIExlZ2FsIG9ubHkgd2hlbiBpc01hcEtleSBpcyB0cnVlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyBmb3JtIG9mIHRoZSB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidmFsdWVUb1N0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoXCJiaW5hcnlcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbGVtZW50ID0gRWxlbWVudDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcGFyZW50IFBhcmVudCBtZXNzYWdlIG9yIG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzR3JvdXAgYHRydWVgIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXAsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTWVzc2FnZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuc2lvbnMgcmFuZ2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVudGltZSBtZXNzYWdlIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzpQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pc0dyb3VwID0gISFpc0dyb3VwO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjYWNoZWQgY29sbGVjdGlvbnMgYXJlIHVzZWQgdG8gZWZmaWNpZW50bHkgaXRlcmF0ZSBvdmVyIG9yIGxvb2sgdXAgZmllbGRzIHdoZW4gZGVjb2RpbmcuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FjaGVkIGZpZWxkcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9BcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlZCBmaWVsZHMgYnkgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxudW1iZXIsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxzdHJpbmcsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeU5hbWUgPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2VQcm90b3R5cGUgPSBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gTWVzc2FnZSBjbGFzc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcnVudGltZSBNZXNzYWdlIGNsYXNzIGluIGl0cyBvd24gc2NvcGVcclxuICAgICAgICAgICAgdmFyIGNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvbmVvZnMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQGNsYXNzIEJhcmVib25lIG9mIGFsbCBydW50aW1lIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj58c3RyaW5nfSB2YWx1ZXMgUHJlc2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFyX2FyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHZpcnR1YWwgb25lb2YgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1vbmVvZnMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvbmVvZnNbaV0ubmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBmaWVsZHMgYW5kIHNldCBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wLCBrPWZpZWxkcy5sZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5yZXBlYXRlZCA/IFtdIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZC5tYXAgPyBuZXcgUHJvdG9CdWYuTWFwKGZpZWxkKSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpZWxkLnJlcXVpcmVkIHx8IFQuc3ludGF4ID09PSAncHJvdG8zJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHZhbHVlcyAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IF9hbm90aGVyXyBNZXNzYWdlICovICh0eXBlb2YgdmFsdWVzLmVuY29kZSAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZXMgaW5zdGFuY2VvZiBNZXNzYWdlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgcmVwZWF0ZWQgZmllbGQgKi8gIUFycmF5LmlzQXJyYXkodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgTWFwICovICEodmFsdWVzIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgQnl0ZUJ1ZmZlciAqLyAhQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBMb25nICovICEoUHJvdG9CdWYuTG9uZyAmJiB2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5Mb25nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYXJndW1lbnRzLCBpbiBkZWNsYXJhdGlvbiBvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTAsIGs9YXJndW1lbnRzLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUgPSBhcmd1bWVudHNbaV0pICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCB2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlUHJvdG90eXBlID0gTWVzc2FnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpOyAvLyBNYXkgdGhyb3cgaWYgaXQncyBhbiBlbnVtIG9yIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIHJlcGVhdGVkIGZpZWxkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGFkZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS4kYWRkID0gTWVzc2FnZVByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IU9iamVjdC48c3RyaW5nLCo+fSBrZXlPck9iaiBTdHJpbmcga2V5IG9yIHBsYWluIG9iamVjdCBob2xkaW5nIG11bHRpcGxlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoKnxib29sZWFuKT19IHZhbHVlIFZhbHVlIHRvIHNldCBpZiBrZXkgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgZm9yIGFuIGFjdHVhbCBmaWVsZCAvIHByb3BlciB2YWx1ZSB0eXBlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5T3JPYmosIHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlPck9iaiAmJiB0eXBlb2Yga2V5T3JPYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQXNzZXJ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlrZXkgaW4ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5T3JPYmouaGFzT3duUHJvcGVydHkoaWtleSkgJiYgdHlwZW9mICh2YWx1ZSA9IGtleU9yT2JqW2lrZXldKSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGlrZXksIHZhbHVlLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5T3JPYmpdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5T3JPYmorXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXlPck9iaitcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gKHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5T3JPYmpdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdOyAvLyBWaXJ0dWFsIGZpZWxkIHJlZmVyZW5jZXMgY3VycmVudGx5IHNldCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQub25lb2YubmFtZV0gPSBmaWVsZC5uYW1lOyAvLyBQb2ludCB2aXJ0dWFsIGZpZWxkIGF0IHRoaXMgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvKiB2YWx1ZSA9PT0gbnVsbCAmJiAqL2N1cnJlbnRGaWVsZCA9PT0ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gbnVsbDsgLy8gQ2xlYXIgdmlydHVhbCBmaWVsZCAoY3VycmVudCBmaWVsZCBleHBsaWNpdGx5IGNsZWFyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIGZvciBbQGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHNldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygqfGJvb2xlYW4pPX0gdmFsdWUgVmFsdWUgdG8gc2V0IGlmIGtleSBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLiRzZXQgPSBNZXNzYWdlUHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuJGdldCA9IE1lc3NhZ2VQcm90b3R5cGUuZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHNldHRlcnMgZm9yIGV4dGVuc2lvbiBmaWVsZHMgYXMgdGhlc2UgYXJlIG5hbWVkIGJ5IHRoZWlyIGZxblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChULmJ1aWxkZXIub3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0W1NvbWVWYWx1ZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhfW2EtekEtWl0pL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnXycsJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lID0gTmFtZS5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV0gRklYTUU6IERvIHdlIHJlYWxseSBuZWVkIHRoZXNlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgZmllbGQncyB1bmJvdW5kIHNldHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBmaWVsZCdzIHVuYm91bmQgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwic2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJzZXRcIitOYW1lXSA9IHNldHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcInNldF9cIituYW1lKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBhbm90aGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgdGhlIHZhbHVlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wic2V0X1wiK25hbWVdID0gc2V0dGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwiZ2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wiZ2V0XCIrTmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFQuZ2V0Q2hpbGQoXCJnZXRfXCIrbmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJnZXRfXCIrbmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW4tL2RlY29kaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRlbmNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9WZXJpZnkgV2hldGhlciB0byBub3QgdmVyaWZ5IGZpZWxkIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ5dGVCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBhIEJ5dGVCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVmVyaWZ5ID0gYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFQuZW5jb2RlKHRoaXMsIGJ1ZmZlci5MRSgpLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOZXcgPyBidWZmZXIuZmxpcCgpIDogYnVmZmVyKS5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHNwZWNpZmllZCBkYXRhIHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gZGF0YSBEYXRhIHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShkYXRhKS5lbmNvZGUoYnVmZmVyLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBlbmMsIG5vVmVyaWZ5KS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoZW5jLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9BcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9BcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlUHJvdG90eXBlLmVuY29kZUFCO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQsIG5vdCBydW5uaW5nIHVuZGVyIG5vZGUuanMgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICogIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0J1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CYXNlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgYmFzZTY0IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlNjQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICogIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9IZXhcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3Qgb3IgZmllbGQgdmFsdWUgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNsb25lXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmFyeUFzQmFzZTY0IFdoZXRoZXIgdG8gaW5jbHVkZSBiaW5hcnkgZGF0YSBhcyBiYXNlNjQgc3RyaW5ncyBvciBhcyBhIGJ1ZmZlciBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UPX0gcmVzb2x2ZWRUeXBlIFRoZSByZXNvbHZlZCBmaWVsZCB0eXBlIGlmIGEgZmllbGRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBDbG9uZWQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xvbmVSYXcob2JqLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIHJlc29sdmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBlbnVtIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFR5cGUgJiYgcmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFByb3RvQnVmLlJlZmxlY3QuRW51bS5nZXROYW1lKHJlc29sdmVkVHlwZS5vYmplY3QsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzLXRocm91Z2ggc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bGwuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBCeXRlQnVmZmVycyB0byByYXcgYnVmZmVyIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeUFzQmFzZTY0ID8gb2JqLnRvQmFzZTY0KCkgOiBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IExvbmdzIHRvIHByb3BlciBvYmplY3RzIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZy5pc0xvbmcob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdzQXNTdHJpbmdzID8gb2JqLnRvU3RyaW5nKCkgOiBQcm90b0J1Zi5Mb25nLmZyb21WYWx1ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2tdID0gY2xvbmVSYXcodiwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzLCByZXNvbHZlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbWFwcyB0byBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXQgPSBvYmouZW50cmllcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gaXQubmV4dCgpOyAhZS5kb25lOyBlID0gaXQubmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbb2JqLmtleUVsZW0udmFsdWVUb1N0cmluZyhlLnZhbHVlWzBdKV0gPSBjbG9uZVJhdyhlLnZhbHVlWzFdLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIG9iai52YWx1ZUVsZW0ucmVzb2x2ZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iai4kdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIChmaWVsZCA9IHR5cGUuZ2V0Q2hpbGQoaSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIGZpZWxkLnJlc29sdmVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlJ3MgcmF3IHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBiaW5hcnlBc0Jhc2U2NCBXaGV0aGVyIHRvIGluY2x1ZGUgYmluYXJ5IGRhdGEgYXMgYmFzZTY0IHN0cmluZ3MgaW5zdGVhZCBvZiBCdWZmZXJzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvbmdzQXNTdHJpbmdzIFdoZXRoZXIgdG8gZW5jb2RlIGxvbmdzIGFzIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWJpbmFyeUFzQmFzZTY0LCAhIWxvbmdzQXNTdHJpbmdzLCB0aGlzLiR0eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZSB0byBKU09OLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVKU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVJhdyh0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJpbmFyeS1hcy1iYXNlNjQgKi8gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsb25ncy1hcy1zdHJpbmdzICovIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSByZW1haW5pZyBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIGxlbmd0aCwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMgPSBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuTEUoKSwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgdmFyaW50MzIgbGVuZ3RoLWRlbGltaXRlZCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIgb3Igc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhQnVmZmVyfHN0cmluZ30gYnVmZmVyIEJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2Ugb3IgYG51bGxgIGlmIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGF2YWlsYWJsZSB5ZXRcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyLCBlbmMgPyBlbmMgOiBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcik7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmID0gYnVmZmVyLm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IG9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuc2xpY2UoYnVmZmVyLm9mZnNldCwgYnVmZmVyLm9mZnNldCArIGxlbikuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlNjQgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUhleCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiaGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUpTT05cclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcclxuICAgICAgICAgICAgICAgICAqIG1pc3NpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlSlNPTiA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShKU09OLnBhcnNlKHN0cikpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVdGlsaXR5XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIi5GdWxseS5RdWFsaWZpZWQuTWVzc2FnZU5hbWVcIlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLiRvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uc1M7IC8vIGNjIG5lZWRzIHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuJHR5cGVcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJHR5cGVTO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UsICckb3B0aW9ucycsIHsgXCJ2YWx1ZVwiOiBULmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IE1lc3NhZ2VbXCIkb3B0aW9uc1wiXSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZVByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgIH0pKFByb3RvQnVmLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXRpYyBlbnVtcyBhbmQgcHJvdG90eXBlZCBzdWItbWVzc2FnZXMgLyBjYWNoZWQgY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGk8azsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbnVtIHx8IGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZSB8fCBjaGlsZCBpbnN0YW5jZW9mIFNlcnZpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhenouaGFzT3duUHJvcGVydHkoY2hpbGQubmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBvdmVycmlkZSBzdGF0aWMgcHJvcGVydHkgJ1wiK2NoaWxkLm5hbWUrXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXp6W2NoaWxkLm5hbWVdID0gY2hpbGQuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmJ1aWxkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzLnB1c2goY2hpbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWRbY2hpbGQuaWRdID0gY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lW2NoaWxkLm5hbWVdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5PbmVPZikgJiYgIShjaGlsZCBpbnN0YW5jZW9mIEV4dGVuc2lvbikpIC8vIE5vdCBidWlsdFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMuY2hpbGRyZW5baV0udG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6eiA9IGNsYXp6O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgYSBydW50aW1lIG1lc3NhZ2UncyBjb250ZW50cyB0byB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gd3JpdGUgdG9cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub1ZlcmlmeSBXaGV0aGVyIHRvIG5vdCB2ZXJpZnkgZmllbGQgdmFsdWVzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZyBvciB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBmb3IgYW5vdGhlciByZWFzb25cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihtZXNzYWdlLCBidWZmZXIsIG5vVmVyaWZ5KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZE1pc3NpbmcgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmllbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoLCB2YWw7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuX2ZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2VbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVxdWlyZWQgJiYgdmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRNaXNzaW5nID0gZmllbGQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5lbmNvZGUobm9WZXJpZnkgPyB2YWwgOiBmaWVsZC52ZXJpZnlWYWx1ZSh2YWwpLCBidWZmZXIsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWVsZE1pc3NpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZE1pc3NpbmcpO1xyXG4gICAgICAgICAgICAgICAgZXJyW1wiZW5jb2RlZFwiXSA9IGJ1ZmZlcjsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICB0aHJvdyhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbj0wLCBpPTAsIGs9dGhpcy5fZmllbGRzLmxlbmd0aCwgZmllbGQsIHZhbDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gbWVzc2FnZVtmaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSBmaWVsZC5jYWxjdWxhdGUodmFsLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTa2lwcyBhbGwgZGF0YSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZ3JvdXAgaGFzIGJlZW4gcmVhY2hlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRJZCBFeHBlY3RlZCBHUk9VUEVORCBpZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IGJ1ZiBCeXRlQnVmZmVyXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBhIHZhbHVlIGFzIGJlZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiB0aGUgZW5kIGhhcyBiZWVuIHJlYWNoZWRcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgd2Fzbid0IHBvc3NpYmxlIHRvIGZpbmQgdGhlIGVuZCBvZiB0aGUgZ3JvdXAgKGJ1ZmZlciBvdmVycnVuIG9yIGVuZCB0YWcgbWlzbWF0Y2gpXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gc2tpcFRpbGxHcm91cEVuZChleHBlY3RlZElkLCBidWYpIHtcclxuICAgICAgICAgICAgdmFyIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKSwgLy8gVGhyb3dzIG9uIE9PQlxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3LFxyXG4gICAgICAgICAgICAgICAgaWQgPSB0YWcgPj4+IDM7XHJcbiAgICAgICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZG8gdGFnID0gYnVmLnJlYWRVaW50OCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGFnICYgMHg4MCkgPT09IDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKTsgLy8gcmVhZHMgdGhlIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gdGFnOyAgICAgICAgLy8gc2tpcHMgbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGV4cGVjdGVkSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBHUk9VUEVORCBhZnRlciB1bmtub3duIGdyb3VwOiBcIitpZCtcIiAoXCIrZXhwZWN0ZWRJZCtcIiBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBpbiB1bmtub3duIGdyb3VwIFwiK2V4cGVjdGVkSWQrXCI6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYW4gZW5jb2RlZCBtZXNzYWdlIGFuZCByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHJlbWFpbmluZyBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZXhwZWN0ZWRHcm91cEVuZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbGVuZ3RoLCBleHBlY3RlZEdyb3VwRW5kSWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgKHRoaXMuY2xhenopKCksXHJcbiAgICAgICAgICAgICAgICB0YWcsIHdpcmVUeXBlLCBpZCwgZmllbGQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgc3RhcnQrbGVuZ3RoIHx8IChsZW5ndGggPT09IC0xICYmIGJ1ZmZlci5yZW1haW5pbmcoKSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0YWcgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gZXhwZWN0ZWRHcm91cEVuZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgPSB0aGlzLl9maWVsZHNCeUlkW2lkXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIm1lc3NhZ2VzIGNyZWF0ZWQgYnkgeW91ciBuZXcgY29kZSBjYW4gYmUgcGFyc2VkIGJ5IHlvdXIgb2xkIGNvZGU6IG9sZCBiaW5hcmllcyBzaW1wbHkgaWdub3JlIHRoZSBuZXcgZmllbGQgd2hlbiBwYXJzaW5nLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1ZmZlcikpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIHVua25vd24gZmllbGQgXCIraWQrXCIgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIiNkZWNvZGU6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0ucHVzaChmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcikpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5dmFsID0gZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXS5zZXQoa2V5dmFsWzBdLCBrZXl2YWxbMV0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSBtc2dbZmllbGQub25lb2YubmFtZV07IC8vIFZpcnR1YWwgZmllbGQgcmVmZXJlbmNlcyBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2N1cnJlbnRGaWVsZF0gPSBudWxsOyAvLyBDbGVhciBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5vbmVvZi5uYW1lXSA9IGZpZWxkLm5hbWU7IC8vIFBvaW50IHZpcnR1YWwgZmllbGQgYXQgdGhpcyBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudCBhbmQgc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25hbCBmaWVsZHMgdGhhdCBhcmUgbm90XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9maWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnW2ZpZWxkLm5hbWVdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSBcInByb3RvM1wiKSB7IC8vIFByb3RvMyBzZXRzIGRlZmF1bHQgdmFsdWVzIGJ5IHNwZWNpZmljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiOiBcIiArIGZpZWxkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJbXCJkZWNvZGVkXCJdID0gbXNnOyAvLyBTdGlsbCBleHBvc2Ugd2hhdCB3ZSBnb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFByb3RvQnVmLnBvcHVsYXRlRGVmYXVsdHMgJiYgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBGaWVsZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IGtleXR5cGUgS2V5IGRhdGEgdHlwZSwgaWYgYW55LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZj19IG9uZW9mIEVuY2xvc2luZyBPbmVPZlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEZpZWxkID0gZnVuY3Rpb24oYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwga2V5dHlwZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMsIG9uZW9mLCBzeW50YXgpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2UuRmllbGRcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcXVpcmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PT0gXCJyZXF1aXJlZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVwZWF0ZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBtYXAgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gcnVsZSA9PT0gXCJtYXBcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIGtleSB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWZcclxuICAgICAgICAgICAgICogdHlwZSBpZiByZXNvbHZlZC4gVmFsaWQgb25seSBpZiB0aGlzLm1hcCA9PT0gdHJ1ZSwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn18bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlUeXBlID0ga2V5dHlwZSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgdHlwZS4gVHlwZSByZWZlcmVuY2Ugc3RyaW5nIGlmIHVucmVzb2x2ZWQsIHByb3RvYnVmIHR5cGUgaWZcclxuICAgICAgICAgICAgICogcmVzb2x2ZWQuIEluIGEgbWFwIGZpZWxkLCB0aGlzIGlzIHRoZSB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHR5cGUgcmVmZXJlbmNlIGluc2lkZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVHxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIG1lc3NhZ2UgZmllbGQgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqIEBkaWN0XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NpbmcgT25lT2YuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9uZW9mID0gb25lb2YgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCAncHJvdG8yJztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IHRoaXMubmFtZTsgLy8gVXNlZCB0byByZXZlcnQgY2FtZWxjYXNlIHRyYW5zZm9ybWF0aW9uIG9uIG5hbWluZyBjb2xsaXNpb25zXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCBpbXBsZW1lbnRhdGlvbi4gQ3JlYXRlZCBpbiBidWlsZCgpIGFmdGVyIHR5cGVzIGFyZSByZXNvbHZlZC5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLkVsZW1lbnR9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5IGVsZW1lbnQgaW1wbGVtZW50YXRpb24sIGZvciBtYXAgZmllbGRzLiBDcmVhdGVkIGluIGJ1aWxkKCkgYWZ0ZXJcclxuICAgICAgICAgICAgICogdHlwZXMgYXJlIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuRWxlbWVudH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkZXIub3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gJiYgISh0aGlzIGluc3RhbmNlb2YgTWVzc2FnZS5FeHRlbnNpb25GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBQcm90b0J1Zi5VdGlsLnRvQ2FtZWxDYXNlKHRoaXMubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRmllbGRQcm90b3R5cGUgPSBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBmaWVsZC5cclxuICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcy50eXBlLCB0aGlzLnJlc29sdmVkVHlwZSwgZmFsc2UsIHRoaXMuc3ludGF4LCB0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQgPSBuZXcgRWxlbWVudCh0aGlzLmtleVR5cGUsIHVuZGVmaW5lZCwgdHJ1ZSwgdGhpcy5zeW50YXgsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbiBwcm90bzMsIGZpZWxkcyBkbyBub3QgaGF2ZSBmaWVsZCBwcmVzZW5jZSwgYW5kIGV2ZXJ5IGZpZWxkIGlzIHNldCB0b1xyXG4gICAgICAgICAgICAvLyBpdHMgdHlwZSdzIGRlZmF1bHQgdmFsdWUgKFwiXCIsIDAsIDAuMCwgb3IgZmFsc2UpLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmICF0aGlzLnJlcGVhdGVkICYmICF0aGlzLm1hcClcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkZWZhdWx0IHZhbHVlcyBhcmUgcHJlc2VudCB3aGVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNbJ2RlZmF1bHQnXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodGhpcy5vcHRpb25zWydkZWZhdWx0J10pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIHNldCBmb3IgdGhpcyBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgdmFsdWUgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHsqfSBWZXJpZmllZCwgbWF5YmUgYWRqdXN0ZWQsIHZhbHVlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0IGZvciB0aGlzIGZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICBza2lwUmVwZWF0ZWQgPSBza2lwUmVwZWF0ZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCh2YWwsIG1zZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIitzZWxmLnRvU3RyaW5nKHRydWUpK1wiIG9mIHR5cGUgXCIrc2VsZi50eXBlLm5hbWUrXCI6IFwiK3ZhbCtcIiAoXCIrbXNnK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsgLy8gTlVMTCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZWRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmIHRoaXMudHlwZSAhPT0gUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInByb3RvMyBmaWVsZCB3aXRob3V0IGZpZWxkIHByZXNlbmNlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkICYmICFza2lwUmVwZWF0ZWQpIHsgLy8gUmVwZWF0ZWQgdmFsdWVzIGFzIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLmVsZW1lbnQudmVyaWZ5VmFsdWUodmFsdWVbaV0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwICYmICFza2lwUmVwZWF0ZWQpIHsgLy8gTWFwIHZhbHVlcyBhcyBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhIE1hcCwgYXR0ZW1wdCB0byBjb252ZXJ0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIFByb3RvQnVmLk1hcCBvciByYXcgb2JqZWN0IGZvciBtYXAgZmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvdG9CdWYuTWFwKHRoaXMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFsbCBub24tcmVwZWF0ZWQgZmllbGRzIGV4cGVjdCBubyBhcnJheVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0ZWQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJubyBhcnJheSBleHBlY3RlZFwiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmVyaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZmllbGQgd2lsbCBoYXZlIGEgcHJlc2VuY2Ugb24gdGhlIHdpcmUgZ2l2ZW4gaXRzXHJcbiAgICAgICAgICogdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWZXJpZmllZCBmaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaWVsZCB3aWxsIGJlIHByZXNlbnQgb24gdGhlIHdpcmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWVsZFByb3RvdHlwZS5oYXNXaXJlUHJlc2VuY2UgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggIT09ICdwcm90bzMnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uZW9mICYmIG1lc3NhZ2VbdGhpcy5vbmVvZi5uYW1lXSA9PT0gdGhpcy5uYW1lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sb3cgIT09IDAgfHwgdmFsdWUuaGlnaCAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAuMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucmVtYWluaW5nKCkgPiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIGZpZWxkIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmVyaWZpZWQgZmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBlbmNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBidWZmZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBVbnJlc29sdmVkIHR5cGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7IC8vIE9wdGlvbmFsIG9taXR0ZWRcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJPbmx5IHJlcGVhdGVkIGZpZWxkcyBvZiBwcmltaXRpdmUgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCwgb3IgNjQtYml0IHdpcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlcykgY2FuIGJlIGRlY2xhcmVkICdwYWNrZWQnLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiQWxsIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmllbGQgYXJlIHBhY2tlZCBpbnRvIGEgc2luZ2xlIGtleS12YWx1ZSBwYWlyIHdpdGggd2lyZSB0eXBlIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGxlbmd0aC1kZWxpbWl0ZWQpLiBFYWNoIGVsZW1lbnQgaXMgZW5jb2RlZCB0aGUgc2FtZSB3YXkgaXQgd291bGQgYmUgbm9ybWFsbHksIGV4Y2VwdCB3aXRob3V0IGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFnIHByZWNlZGluZyBpdC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmVuc3VyZUNhcGFjaXR5KGJ1ZmZlci5vZmZzZXQgKz0gMSk7IC8vIFdlIGRvIG5vdCBrbm93IHRoZSBsZW5ndGggeWV0LCBzbyBsZXQncyBhc3N1bWUgYSB2YXJpbnQgb2YgbGVuZ3RoIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldDsgLy8gUmVtZW1iZXIgd2hlcmUgdGhlIGNvbnRlbnRzIGJlZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmVuY29kZVZhbHVlKHRoaXMuaWQsIHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLm9mZnNldC1zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmludExlbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHsgLy8gV2UgbmVlZCB0byBtb3ZlIHRoZSBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKHN0YXJ0LCBidWZmZXIub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHZhcmludExlbi0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIobGVuLCBzdGFydC12YXJpbnRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91ciBtZXNzYWdlIGRlZmluaXRpb24gaGFzIHJlcGVhdGVkIGVsZW1lbnRzICh3aXRob3V0IHRoZSBbcGFja2VkPXRydWVdIG9wdGlvbiksIHRoZSBlbmNvZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgaGFzIHplcm8gb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2l0aCB0aGUgc2FtZSB0YWcgbnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWVbaV0sIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIG91dCBlYWNoIG1hcCBlbnRyeSBhcyBhIHN1Ym1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2YWwsIGtleSwgbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHN1Ym1lc3NhZ2UgKGtleSwgdmFsKSBwYWlyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5RWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMSwga2V5KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCgyIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDIsIHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJtZXNzYWdlIHdpdGggd2lyZSB0eXBlIG9mIGxlbmd0aC1kZWxpbWl0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihsZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBrZXkgYW5kIHZhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuZW5jb2RlVmFsdWUoMSwga2V5LCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigoMiA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSgyLCB2YWwsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1dpcmVQcmVzZW5jZSh2YWx1ZSwgbWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGZpZWxkJ3MgdmFsdWUgb24gdGhlIG5ldHdvcmsgbGV2ZWwuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWVsZFByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBVbnJlc29sdmVkIHR5cGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBPcHRpb25hbCBvbWl0dGVkXHJcbiAgICAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG5pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiYgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUy5pbmRleE9mKHRoaXMudHlwZS53aXJlVHlwZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSArPSB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKHRoaXMuaWQsIHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG5pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBuaTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgodGhpcy5pZCwgdmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIG1hcCBlbnRyeSBiZWNvbWVzIGEgc3VibWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5LCBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgc3VibWVzc2FnZSAoa2V5LCB2YWwpIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMSA8PCAzKSB8IHRoaXMua2V5VHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgxLCBrZXkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMiwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXaXJlUHJlc2VuY2UodmFsdWUsIG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCh0aGlzLmlkLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIExlYWRpbmcgd2lyZSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBSZXBlYXRlZCBXaGV0aGVyIHRvIHNraXAgdGhlIHJlcGVhdGVkIGNoZWNrIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZTogYXJyYXkgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMsIFtrZXksIHZhbHVlXSBmb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICBtYXAgZmllbGRzLCBvciBhbiBpbmRpdmlkdWFsIHZhbHVlIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHdpcmVUeXBlLCBidWZmZXIsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGV4cGVjdCB3aXJlVHlwZSB0byBtYXRjaCB0aGUgdW5kZXJseWluZyB0eXBlJ3Mgd2lyZVR5cGUgdW5sZXNzIHdlIHNlZVxyXG4gICAgICAgICAgICAvLyBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZCwgb3IgdW5sZXNzIHRoaXMgaXMgYSBtYXAgZmllbGQuXHJcbiAgICAgICAgICAgIHZhciB3aXJlVHlwZU9LID1cclxuICAgICAgICAgICAgICAgICghdGhpcy5tYXAgJiYgd2lyZVR5cGUgPT0gdGhpcy50eXBlLndpcmVUeXBlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFza2lwUmVwZWF0ZWQgJiYgdGhpcy5yZXBlYXRlZCAmJiB0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiZcclxuICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLm1hcCAmJiB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgIGlmICghd2lyZVR5cGVPSylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIGZpZWxkIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlK1wiIChcIit0aGlzLnR5cGUud2lyZVR5cGUrXCIgZXhwZWN0ZWQpXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSAmJiB0aGlzLnJlcGVhdGVkICYmIHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIub2Zmc2V0ICsgbkJ5dGVzOyAvLyBMaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLm9mZnNldCA8IG5CeXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZWNvZGUodGhpcy50eXBlLndpcmVUeXBlLCBidWZmZXIsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB2YWx1ZSBvdGhlcndpc2UuLi5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIG1hcHMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvbmUgKGtleSwgdmFsdWUpIHN1Ym1lc3NhZ2UsIGFuZCByZXR1cm4gW2tleSwgdmFsdWVdXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLmtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgb2YgYnl0ZXMgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK25CeXRlcytcIiByZXF1aXJlZCBidXQgZ290IG9ubHkgXCIrYnVmZmVyLnJlbWFpbmluZygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBzdWItYnVmZmVyIG9mIHRoaXMga2V5L3ZhbHVlIHN1Ym1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHZhciBtc2didWYgPSBidWZmZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIG1zZ2J1Zi5saW1pdCA9IG1zZ2J1Zi5vZmZzZXQgKyBuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobXNnYnVmLnJlbWFpbmluZygpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBtc2didWYucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlFbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZWxlbWVudC5kZWNvZGUobXNnYnVmLCB3aXJlVHlwZSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB0YWcgaW4gbWFwIGZpZWxkIGtleS92YWx1ZSBzdWJtZXNzYWdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2luZ3VsYXIgYW5kIG5vbi1wYWNrZWQgcmVwZWF0ZWQgZmllbGQgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmRlY29kZShidWZmZXIsIHdpcmVUeXBlLCB0aGlzLmlkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCA9IEZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgRXh0ZW5zaW9uRmllbGQuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFeHRlbnNpb25GaWVsZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIEZpZWxkLmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgLyoga2V5dHlwZSA9ICovIG51bGwsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbnNpb24gcmVmZXJlbmNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9ufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIEZpZWxkXHJcbiAgICAgICAgRXh0ZW5zaW9uRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA9IEV4dGVuc2lvbkZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgT25lT2YuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZU9mIG5hbWVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgT25lT2YgPSBmdW5jdGlvbihidWlsZGVyLCBtZXNzYWdlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBtZXNzYWdlLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQ+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuT25lT2ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLk9uZU9mID0gT25lT2Y7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRW51bS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IFJlZmxlY3Qgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgRW51bSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBzeW50YXggVGhlIHN5bnRheCBsZXZlbCAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVudW0gPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJ1bnRpbWUgZW51bSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fG51bGx9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgbmFtZSBvZiBhbiBlbnVtIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuRW51bX0gZW5tIFJ1bnRpbWUgZW51bVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBFbnVtIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgez9zdHJpbmd9IE5hbWUgb3IgYG51bGxgIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW0uZ2V0TmFtZSA9IGZ1bmN0aW9uKGVubSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbm0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGtleTsgaTxrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVubVtrZXkgPSBrZXlzW2ldXSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRW51bVByb3RvdHlwZSA9IEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoaXMgZW51bSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYnVpbGQgV2hldGhlciB0byByZWJ1aWxkIG9yIG5vdCwgZGVmYXVsdHMgdG8gZmFsc2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW1Qcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdCAmJiAhcmVidWlsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdDtcclxuICAgICAgICAgICAgdmFyIGVubSA9IG5ldyBQcm90b0J1Zi5CdWlsZGVyLkVudW0oKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oRW51bS5WYWx1ZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz12YWx1ZXMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGVubVt2YWx1ZXNbaV1bJ25hbWUnXV0gPSB2YWx1ZXNbaV1bJ2lkJ107XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW5tLCAnJG9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0aGlzLmJ1aWxkT3B0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID0gZW5tO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbnVtID0gRW51bTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtIFZhbHVlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkVudW19IGVubSBFbnVtIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZhbHVlID0gZnVuY3Rpb24oYnVpbGRlciwgZW5tLCBuYW1lLCBpZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgZW5tLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtLlZhbHVlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIGVudW0gdmFsdWUgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICBWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LkVudW0uVmFsdWUgPSBWYWx1ZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXh0ZW5zaW9uIChmaWVsZCkuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb25cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkfSBmaWVsZCBFeHRlbnNpb24gZmllbGRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRXh0ZW5zaW9uID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lLCBmaWVsZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbmRlZCBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgIEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcnZpY2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSByb290IFJvb3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHJvb3QsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgYnVpbGRlciwgcm9vdCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWx0IHJ1bnRpbWUgc2VydmljZSBjbGFzcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlKX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNlcnZpY2VQcm90b3R5cGUgPSBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgc2VydmljZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90XHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFNlcnZpY2UgY2xhc3NcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNlcnZpY2VQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xheno7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJ1bnRpbWUgU2VydmljZSBjbGFzcyBpbiBpdHMgb3duIHNjb3BlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgU2VydmljZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKT19IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uIHJlY2VpdmluZyB0aGUgbWV0aG9kIG5hbWUgYW5kIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgc2VydmljZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJwY0ltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2VydmljZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjcnBjSW1wbFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHshZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGwgfHwgZnVuY3Rpb24obmFtZSwgbXNnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgYSB1c2VyIGhhcyB0byBpbXBsZW1lbnQ6IEEgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSwgdGhlIGFjdHVhbCBtZXNzYWdlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgKHR5cGUgY2hlY2tlZCkgYW5kIHRoZSBjYWxsYmFjayB0aGF0J3MgZWl0aGVyIHByb3ZpZGVkIHdpdGggdGhlIGVycm9yIGFzIGl0cyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBvciBudWxsIGFuZCB0aGUgYWN0dWFsIHJlc3BvbnNlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy93aWtpL1NlcnZpY2VzXCIpKSwgMCk7IC8vIE11c3QgYmUgYXN5bmMhXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBTZXJ2aWNlUHJvdG90eXBlID0gU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGdpdmVuIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5bTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBpbnN0YW5jZSdzIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNbTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8Qnl0ZUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nKT0pfSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmdcclxuICAgICAgICAgICAgICAgICAqICB0aGUgZXJyb3IgaWYgYW55IGFuZCB0aGUgcmVzcG9uc2UgZWl0aGVyIGFzIGEgcHJlLXBhcnNlZCBtZXNzYWdlIG9yIGFzIGl0cyByYXcgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJwYyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cnBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmljZSNNZXRob2QobWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2VQcm90b3R5cGVbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBnaXZlbiBhcyBhIGJ1ZmZlciwgZGVjb2RlIHRoZSByZXF1ZXN0LiBXaWxsIHRocm93IGEgVHlwZUVycm9yIGlmIG5vdCBhIHZhbGlkIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY2xhenouZGVjb2RlKEJ5dGVCdWZmZXIud3JhcChyZXEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcSA9PT0gbnVsbCB8fCB0eXBlb2YgcmVxICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGFyZ3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IG5ldyBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eihyZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbChtZXRob2QuZnFuKCksIHJlcSwgZnVuY3Rpb24oZXJyLCByZXMpIHsgLy8gQXNzdW1lcyB0aGF0IHRoaXMgaXMgcHJvcGVybHkgYXN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2FsZXNjZSB0byBlbXB0eSBzdHJpbmcgd2hlbiBzZXJ2aWNlIHJlc3BvbnNlIGhhcyBlbXB0eSBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZXMgPSBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenouZGVjb2RlKHJlcyk7IH0gY2F0Y2ggKG5vdEFCdWZmZXIpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJJbGxlZ2FsIHJlc3BvbnNlIHR5cGUgcmVjZWl2ZWQgaW4gc2VydmljZSBtZXRob2QgXCIrIFQubmFtZStcIiNcIittZXRob2QubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgZXJyKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2aWNlLk1ldGhvZChycGNJbXBsLCBtZXNzYWdlLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihycGNJbXBsLCByZXEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VydmljZShycGNJbXBsKVttZXRob2QubmFtZV0ocmVxLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBtZXRob2QuYnVpbGRPcHQoKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlUHJvdG90eXBlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVttZXRob2QubmFtZV1bXCIkb3B0aW9uc1wiXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KShycGNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNlcnZpY2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS4kb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnNTOyAvLyBjYyBuZWVkcyB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjJG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICRvcHRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLiR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlUztcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSMkdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkdHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBULmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbXCIkb3B0aW9uc1wiXSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VydmljZTtcclxuXHJcbiAgICAgICAgICAgIH0pKFByb3RvQnVmLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuU2VydmljZSA9IFNlcnZpY2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic3RyYWN0IHNlcnZpY2UgbWV0aG9kLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlfSBzdmMgU2VydmljZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBNZXRob2QgPSBmdW5jdGlvbihidWlsZGVyLCBzdmMsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHN2YywgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5NZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBNZXRob2RQcm90b3R5cGUgPSBNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbWV0aG9kJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kI2J1aWxkT3B0XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWV0aG9kUHJvdG90eXBlLmJ1aWxkT3B0ID0gTmFtZXNwYWNlUHJvdG90eXBlLmJ1aWxkT3B0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LlNlcnZpY2UuTWV0aG9kID0gTWV0aG9kO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSUEMgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBSZXNwb25zZSBtZXNzYWdlIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVlc3Rfc3RyZWFtIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZXNwb25zZV9zdHJlYW0gV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUlBDTWV0aG9kID0gZnVuY3Rpb24oYnVpbGRlciwgc3ZjLCBuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcmVxdWVzdF9zdHJlYW0sIHJlc3BvbnNlX3N0cmVhbSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBNZXRob2QuY2FsbCh0aGlzLCBidWlsZGVyLCBzdmMsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlNlcnZpY2UuUlBDTWV0aG9kXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVxdWVzdCBtZXNzYWdlIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE5hbWUgPSByZXF1ZXN0O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZU5hbWUgPSByZXNwb25zZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdF9zdHJlYW07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlU3RyZWFtID0gcmVzcG9uc2Vfc3RyZWFtO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHJlcXVlc3QgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIG1lc3NhZ2UgdHlwZS5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRXh0ZW5kcyBNZXRob2RcclxuICAgICAgICBSUENNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXRob2QucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCA9IFJQQ01ldGhvZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Q7XHJcblxyXG4gICAgfSkoUHJvdG9CdWYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuQnVpbGRlciA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZywgUmVmbGVjdCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ1aWxkZXIuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICAgICAqIEBjbGFzcyBQcm92aWRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBidWlsZCBwcm90b2NvbCBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJ1aWxkZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubnMgPSBuZXcgUmVmbGVjdC5OYW1lc3BhY2UodGhpcywgbnVsbCwgXCJcIik7IC8vIEdsb2JhbCBuYW1lc3BhY2VcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UgcG9pbnRlci5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgYnVpbGRpbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfE9iamVjdD58bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmlsZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbXBvcnQgcm9vdCBvdmVycmlkZS5cclxuICAgICAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJ1aWxkZXJQcm90b3R5cGUgPSBCdWlsZGVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gRGVmaW5pdGlvbiB0ZXN0cyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzTWVzc2FnZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgZG8gbm90IGNvbnRhaW4gdmFsdWVzIChlbnVtKSBvciBycGMgbWV0aG9kcyAoc2VydmljZSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkZWZbXCJycGNcIl0gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgbWVzc2FnZSBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2UgZmllbGRzIHJlcXVpcmUgYSBzdHJpbmcgcnVsZSwgbmFtZSBhbmQgdHlwZSBhbmQgYW4gaWRcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJydWxlXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInR5cGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJpZFwiXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYW4gZW51bS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzRW51bSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gRW51bXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gPT09ICd1bmRlZmluZWQnIHx8ICFBcnJheS5pc0FycmF5KGRlZltcInZhbHVlc1wiXSkgfHwgZGVmW1widmFsdWVzXCJdLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhIHNlcnZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5pc1NlcnZpY2UgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgLy8gU2VydmljZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lIGFuZCBhbiBycGMgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ29iamVjdCcgfHwgIWRlZltcInJwY1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhbiBleHRlbmRlZCBtZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5pc0V4dGVuZCA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIHJxdWlyZSBhIHN0cmluZyByZWZcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJyZWZcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBCdWlsZGluZyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIHBvaW50ZXIgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5ucztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBhIG5hbWVzcGFjZSBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgcGxhY2VzIHRoZSBwb2ludGVyIG9uIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2VcclxuICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KG5hbWVzcGFjZSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbmFtZXNwYWNlOiBcIituYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICBuYW1lc3BhY2Uuc3BsaXQoXCIuXCIpLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5zID0gdGhpcy5wdHIuZ2V0Q2hpbGQocGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnMgPT09IG51bGwpIC8vIEtlZXAgZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChucyA9IG5ldyBSZWZsZWN0Lk5hbWVzcGFjZSh0aGlzLCB0aGlzLnB0ciwgcGFydCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBucztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhlIHNwZWNpZmllZCBkZWZpbml0aW9ucyBhdCB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjwhT2JqZWN0Pn0gZGVmcyBNZXNzYWdlcywgZW51bXMgb3Igc2VydmljZXMgdG8gY3JlYXRlXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgbWVzc2FnZSBkZWZpbml0aW9uIGlzIGludmFsaWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZWZzKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmcylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVmcykpXHJcbiAgICAgICAgICAgICAgICBkZWZzID0gW2RlZnNdO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBkZWZzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEl0J3MgcXVpdGUgaGFyZCB0byBrZWVwIHRyYWNrIG9mIHNjb3BlcyBhbmQgbWVtb3J5IGhlcmUsIHNvIGxldCdzIGRvIHRoaXMgaXRlcmF0aXZlbHkuXHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtkZWZzXTtcclxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVmcykpIC8vIFN0YWNrIGFsd2F5cyBjb250YWlucyBlbnRpcmUgbmFtZXNwYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGEgdmFsaWQgbmFtZXNwYWNlOiBcIitKU09OLnN0cmluZ2lmeShkZWZzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRlZnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzLnNoaWZ0KCk7IC8vIE5hbWVzcGFjZXMgYWx3YXlzIGNvbnRhaW4gYW4gYXJyYXkgb2YgbWVzc2FnZXMsIGVudW1zIGFuZCBzZXJ2aWNlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnVpbGRlci5pc01lc3NhZ2UoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gbmV3IFJlZmxlY3QuTWVzc2FnZSh0aGlzLCB0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSwgZGVmW1wiaXNHcm91cFwiXSwgZGVmW1wic3ludGF4XCJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBPbmVPZnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZW9mcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wib25lb2ZzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmW1wib25lb2ZzXCJdKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQob25lb2ZzW25hbWVdID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5PbmVPZih0aGlzLCBvYmosIG5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZmllbGRzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZmllbGRzXCJdLmZvckVhY2goZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5nZXRDaGlsZChmbGRbXCJpZFwiXXwwKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgb3IgaW52YWxpZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxkW1wib3B0aW9uc1wiXSAmJiB0eXBlb2YgZmxkW1wib3B0aW9uc1wiXSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBvcHRpb25zIGluIFwiK29iai5uYW1lK1wiI1wiK2ZsZFtcIm5hbWVcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmVvZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGRbXCJvbmVvZlwiXSA9PT0gJ3N0cmluZycgJiYgIShvbmVvZiA9IG9uZW9mc1tmbGRbXCJvbmVvZlwiXV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb25lb2YgaW4gXCIrb2JqLm5hbWUrXCIjXCIrZmxkW1wibmFtZVwiXStcIjogXCIrZmxkW1wib25lb2ZcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZCA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQodGhpcywgb2JqLCBmbGRbXCJydWxlXCJdLCBmbGRbXCJrZXl0eXBlXCJdLCBmbGRbXCJ0eXBlXCJdLCBmbGRbXCJuYW1lXCJdLCBmbGRbXCJpZFwiXSwgZmxkW1wib3B0aW9uc1wiXSwgb25lb2YsIGRlZltcInN5bnRheFwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZW9mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVvZi5maWVsZHMucHVzaChmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGNoaWxkcmVuIHRvIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJPYmogPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImVudW1zXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZW51bXNcIl0uZm9yRWFjaChmdW5jdGlvbihlbm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChlbm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJtZXNzYWdlc1wiXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcIm1lc3NhZ2VzXCJdLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2gobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wic2VydmljZXNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJzZXJ2aWNlc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKHN2Yykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKHN2Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBleHRlbnNpb24gcmFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJleHRlbnNpb25zXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImV4dGVuc2lvbnNcIl1bMF0gPT09ICdudW1iZXInKSAvLyBwcmUgNS4wLjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFsgZGVmW1wiZXh0ZW5zaW9uc1wiXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zID0gZGVmW1wiZXh0ZW5zaW9uc1wiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9uIHRvcCBvZiBjdXJyZW50IG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViT2JqLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZGVmcyk7IC8vIFB1c2ggdGhlIGN1cnJlbnQgbGV2ZWwgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcyA9IHN1Yk9iajsgLy8gQ29udGludWUgcHJvY2Vzc2luZyBzdWIgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG9iajsgLy8gQW5kIG1vdmUgdGhlIHBvaW50ZXIgdG8gdGhpcyBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNFbnVtKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LkVudW0odGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0sIGRlZltcInN5bnRheFwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcInZhbHVlc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0LkVudW0uVmFsdWUodGhpcywgb2JqLCB2YWxbXCJuYW1lXCJdLCB2YWxbXCJpZFwiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzU2VydmljZShkZWYpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5TZXJ2aWNlKHRoaXMsIHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmW1wicnBjXCJdKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdGQgPSBkZWZbXCJycGNcIl1bbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuU2VydmljZS5SUENNZXRob2QodGhpcywgb2JqLCBuYW1lLCBtdGRbXCJyZXF1ZXN0XCJdLCBtdGRbXCJyZXNwb25zZVwiXSwgISFtdGRbXCJyZXF1ZXN0X3N0cmVhbVwiXSwgISFtdGRbXCJyZXNwb25zZV9zdHJlYW1cIl0sIG10ZFtcIm9wdGlvbnNcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc0V4dGVuZChkZWYpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLnB0ci5yZXNvbHZlKGRlZltcInJlZlwiXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcImZpZWxkc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGZsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZ2V0Q2hpbGQoZmxkWydpZCddfDApICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBleHRlbmRlZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmaWVsZCBpZCBpcyBhbGxvd2VkIHRvIGJlIGV4dGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5leHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxkW1wiaWRcIl0gPj0gcmFuZ2VbMF0gJiYgZmxkW1wiaWRcIl0gPD0gcmFuZ2VbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmRlZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddK1wiIChub3Qgd2l0aGluIHZhbGlkIHJhbmdlcylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZXh0ZW5zaW9uIGZpZWxkIG5hbWVzIHRvIGNhbWVsIGNhc2Ugbm90YXRpb24gaWYgdGhlIG92ZXJyaWRlIGlzIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZmxkW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFByb3RvQnVmLlV0aWwudG9DYW1lbENhc2UobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlICMxNjE6IEV4dGVuc2lvbnMgdXNlIHRoZWlyIGZ1bGx5IHF1YWxpZmllZCBuYW1lIGFzIHRoZWlyIHJ1bnRpbWUga2V5IGFuZC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQodGhpcywgb2JqLCBmbGRbXCJydWxlXCJdLCBmbGRbXCJ0eXBlXCJdLCB0aGlzLnB0ci5mcW4oKSsnLicrbmFtZSwgZmxkW1wiaWRcIl0sIGZsZFtcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmFyZSBhZGRlZCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgbmFtZXNwYWNlIGFzIGFuIGV4dGVuc2lvbiB3aGljaCBpcyB1c2VkIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmluZyB0aGVpciB0eXBlIGxhdGVyIG9uICh0aGUgZXh0ZW5zaW9uIGFsd2F5cyBrZWVwcyB0aGUgb3JpZ2luYWwgbmFtZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbmFtaW5nIGNvbGxpc2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dCA9IG5ldyBSZWZsZWN0LkV4dGVuc2lvbih0aGlzLCB0aGlzLnB0ciwgZmxkW1wibmFtZVwiXSwgZmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmV4dGVuc2lvbiA9IGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIS9cXC4/Z29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QoZGVmW1wicmVmXCJdKSkgLy8gU2lsZW50bHkgc2tpcCBpbnRlcm5hbCBleHRlbnNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImV4dGVuZGVkIG1lc3NhZ2UgXCIrZGVmW1wicmVmXCJdK1wiIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgYSB2YWxpZCBkZWZpbml0aW9uOiBcIitKU09OLnN0cmluZ2lmeShkZWYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgZ29lcyBoZXJlXHJcbiAgICAgICAgICAgICAgICBkZWZzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5wdHIucGFyZW50OyAvLyBOYW1lc3BhY2UgZG9uZSwgY29udGludWUgYXQgcGFyZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlOyAvLyBSZXF1aXJlIHJlLXJlc29sdmVcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BhZ2F0ZXMgc3ludGF4IHRvIGFsbCBjaGlsZHJlbi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudFxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVN5bnRheChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFsnbWVzc2FnZXMnXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50WydtZXNzYWdlcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFtcInN5bnRheFwiXSA9IHBhcmVudFtcInN5bnRheFwiXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVTeW50YXgoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudFsnZW51bXMnXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50WydlbnVtcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFtcInN5bnRheFwiXSA9IHBhcmVudFtcInN5bnRheFwiXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBvcnRzIGFub3RoZXIgZGVmaW5pdGlvbiBpbnRvIHRoaXMgYnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIFBhcnNlZCBpbXBvcnRcclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBJbXBvcnRlZCBmaWxlIG5hbWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gb3IgZmlsZSBjYW5ub3QgYmUgaW1wb3J0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZVtcImltcG9ydFwiXSA9IGZ1bmN0aW9uKGpzb24sIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxpbSA9ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBza2lwIGR1cGxpY2F0ZSBpbXBvcnRzXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLklTX05PREUpXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZXF1aXJlKFwicGF0aFwiKVsncmVzb2x2ZSddKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlc1tmaWxlbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7IC8vIE9iamVjdCB3aXRoIHJvb3QsIGZpbGUuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBmaWxlbmFtZS5yb290O1xyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gcmVxdWlyZShcInBhdGhcIilbJ3Jlc29sdmUnXShyb290KTtcclxuICAgICAgICAgICAgICAgIGlmIChyb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuZmlsZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gcm9vdCArIGRlbGltICsgZmlsZW5hbWUuZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlc1tmbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbXBvcnQgaW1wb3J0c1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25bJ2ltcG9ydHMnXSAmJiBqc29uWydpbXBvcnRzJ10ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydFJvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRSb290ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gSWYgYW4gaW1wb3J0IHJvb3QgaXMgc3BlY2lmaWVkLCBvdmVycmlkZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBmaWxlbmFtZVtcInJvb3RcIl07IHJlc2V0Um9vdCA9IHRydWU7IC8vIC4uLiBhbmQgcmVzZXQgYWZ0ZXJ3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZVtcImZpbGVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydFJvb3QuaW5kZXhPZihcIlxcXFxcIikgPj0gMCB8fCBmaWxlbmFtZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICdcXFxcJztcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0Um9vdCkgLy8gSWYgaW1wb3J0IHJvb3QgaXMgb3ZlcnJpZGRlbiwgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIE90aGVyd2lzZSBjb21wdXRlIGZyb20gZmlsZW5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCIvXCIpID49IDApIHsgLy8gVW5peFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogL2ZpbGUucHJvdG8gKi8gaW1wb3J0Um9vdCA9PT0gXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gXCIvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMCkgeyAvLyBXaW5kb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXFteXFxcXF0qJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSAnXFxcXCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8anNvblsnaW1wb3J0cyddLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uWydpbXBvcnRzJ11baV0gPT09ICdzdHJpbmcnKSB7IC8vIEltcG9ydCBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0Um9vdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiY2Fubm90IGRldGVybWluZSBpbXBvcnQgcm9vdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydEZpbGVuYW1lID0ganNvblsnaW1wb3J0cyddW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0RmlsZW5hbWUgPT09IFwiZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBOb3QgbmVlZGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRSb290ICsgZGVsaW0gKyBpbXBvcnRGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbaW1wb3J0RmlsZW5hbWVdID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEFscmVhZHkgaW1wb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5wcm90byQvaS50ZXN0KGltcG9ydEZpbGVuYW1lKSAmJiAhUHJvdG9CdWYuRG90UHJvdG8pICAgICAgIC8vIElmIHRoaXMgaXMgYSBsaWdodCBidWlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRGaWxlbmFtZS5yZXBsYWNlKC9cXC5wcm90byQvLCBcIi5qc29uXCIpOyAvLyBhbHdheXMgbG9hZCB0aGUgSlNPTiBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2goaW1wb3J0RmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImZhaWxlZCB0byBpbXBvcnQgJ1wiK2ltcG9ydEZpbGVuYW1lK1wiJyBpbiAnXCIrZmlsZW5hbWUrXCInOiBmaWxlIG5vdCBmb3VuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5qc29uJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpKSAvLyBBbHdheXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oSlNPTi5wYXJzZShjb250ZW50cytcIlwiKSwgaW1wb3J0RmlsZW5hbWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucGFyc2UoY29udGVudHMpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBJbXBvcnQgc3RydWN0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZW5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9cXC4oXFx3KykkLy50ZXN0KGZpbGVuYW1lKSkgLy8gV2l0aCBleHRlbnNpb246IEFwcGVuZCBfaW1wb3J0TiB0byB0aGUgbmFtZSBwb3J0aW9uIHRvIG1ha2UgaXQgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUucmVwbGFjZSgvXiguKylcXC4oXFx3KykkLywgZnVuY3Rpb24oJDAsICQxLCAkMikgeyByZXR1cm4gJDErXCJfaW1wb3J0XCIraStcIi5cIiskMjsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIFdpdGhvdXQgZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gbWFrZSBpdCB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZStcIl9pbXBvcnRcIitpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNldFJvb3QpIC8vIFJlc2V0IGltcG9ydCByb290IG92ZXJyaWRlIHdoZW4gYWxsIGltcG9ydHMgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbXBvcnQgc3RydWN0dXJlc1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSk7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydzeW50YXgnXSlcclxuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVN5bnRheChqc29uKTtcclxuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLnB0cjtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ29wdGlvbnMnXSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb25bJ29wdGlvbnMnXSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLm9wdGlvbnNba2V5XSA9IGpzb25bJ29wdGlvbnMnXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydtZXNzYWdlcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnbWVzc2FnZXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydlbnVtcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZW51bXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydzZXJ2aWNlcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnc2VydmljZXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydleHRlbmRzJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydleHRlbmRzJ10pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlcyBhbGwgbmFtZXNwYWNlIG9iamVjdHMuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjYW5ub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc29sdmUgYWxsIHJlZmxlY3RlZCBvYmplY3RzXHJcbiAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ciA9PSBudWxsIHx8IHR5cGVvZiB0aGlzLnB0ci50eXBlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBEb25lIChhbHJlYWR5IHJlc29sdmVkKVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpIHsgLy8gUmVzb2x2ZSBjaGlsZHJlblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucHRyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSB7IC8vIFJlc29sdmUgdHlwZVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodGhpcy5wdHIudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRoaXMucHRyLnR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9ICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA/IHRoaXMucHRyLmV4dGVuc2lvbi5wYXJlbnQgOiB0aGlzLnB0ci5wYXJlbnQpLnJlc29sdmUodGhpcy5wdHIudHlwZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuRW51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIuc3ludGF4ID09PSAncHJvdG8zJyAmJiByZXMuc3ludGF4ICE9PSAncHJvdG8zJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwicHJvdG8zIG1lc3NhZ2UgY2Fubm90IHJlZmVyZW5jZSBwcm90bzIgZW51bVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gcmVzLmlzR3JvdXAgPyBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdIDogUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSBQcm90b0J1Zi5UWVBFU1t0aGlzLnB0ci50eXBlXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbWFwIGZpZWxkLCBhbHNvIHJlc29sdmUgdGhlIGtleSB0eXBlLiBUaGUga2V5IHR5cGUgY2FuIGJlIG9ubHkgYSBudW1lcmljLCBzdHJpbmcsIG9yIGJvb2wgdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4sIG5vIGVudW1zIG9yIG1lc3NhZ2VzKSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGFnYWluc3QgdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodGhpcy5wdHIua2V5VHlwZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBrZXkgdHlwZSBmb3IgbWFwIGZpZWxkIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci5rZXlUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5rZXlUeXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIua2V5VHlwZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnB0ci5wYXJlbnQucmVzb2x2ZSh0aGlzLnB0ci5yZXF1ZXN0TmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlcXVlc3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlcXVlc3RUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlc3BvbnNlTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlc3BvbnNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYXMgbm90aGluZyBlbHNlIGlzIGltcGxlbWVudGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHNlcnZpY2UgdHlwZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZikgJiYgLy8gTm90IGJ1aWx0XHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb24pICYmIC8vIE5vdCBidWlsdFxyXG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZSkgLy8gQnVpbHQgaW4gZW51bVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb2JqZWN0IGluIG5hbWVzcGFjZTogXCIrdHlwZW9mKHRoaXMucHRyKStcIjogXCIrdGhpcy5wdHIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhlIHByb3RvY29sLiBUaGlzIHdpbGwgZmlyc3QgdHJ5IHRvIHJlc29sdmUgYWxsIGRlZmluaXRpb25zIGFuZCwgaWYgdGhpcyBoYXMgYmVlbiBzdWNjZXNzZnVsLFxyXG4gICAgICAgICAqIHJldHVybiB0aGUgYnVpbHQgcGFja2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pPX0gcGF0aCBTcGVjaWZpZXMgd2hhdCB0byByZXR1cm4uIElmIG9taXR0ZWQsIHRoZSBlbnRpcmUgbmFtZXNwYWNlIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHR5cGUgY291bGQgbm90IGJlIHJlc29sdmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQWxsKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQgPT09IG51bGwpIC8vIChSZS0pQnVpbGRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5ucy5idWlsZCgpO1xyXG4gICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gcGF0aC5zcGxpdChcIi5cIikgOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yZXN1bHQ7IC8vIEJ1aWxkIG5hbWVzcGFjZSBwb2ludGVyIChubyBoYXNDaGlsZCBldGMuKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFydC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChwdHJbcGFydFtpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyW3BhcnRbaV1dO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW1pbGFyIHRvIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyI2J1aWxkfSwgYnV0IGxvb2tzIHVwIHRoZSBpbnRlcm5hbCByZWZsZWN0aW9uIGRlc2NyaXB0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lpbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMgbGlrZSBmaWVsZHMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJucyB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gUmVmbGVjdGlvbiBkZXNjcmlwdG9yIG9yIGBudWxsYCBpZiBub3QgZm91bmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHBhdGgsIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPyB0aGlzLm5zLnJlc29sdmUocGF0aCwgZXhjbHVkZU5vbk5hbWVzcGFjZSkgOiB0aGlzLm5zO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJCdWlsZGVyXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJCdWlsZGVyXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gQmFzZSBjbGFzc2VzIC0tLS0tXHJcbiAgICAgICAgLy8gRXhpc3QgZm9yIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYmVpbmcgYWJsZSB0byBcIi4uLiBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVwiIGV0Yy5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuTWVzc2FnZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLkVudW1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLkVudW0gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5TZXJ2aWNlID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEJ1aWxkZXI7XHJcblxyXG4gICAgfSkoUHJvdG9CdWYsIFByb3RvQnVmLkxhbmcsIFByb3RvQnVmLlJlZmxlY3QpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLk1hcFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NYXAgPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFJlZmxlY3QpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNYXAuIEEgTWFwIGlzIGEgY29udGFpbmVyIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgbWFwXHJcbiAgICAgICAgICogZmllbGRzIG9uIG1lc3NhZ2Ugb2JqZWN0cy4gSXQgY2xvc2VseSBmb2xsb3dzIHRoZSBFUzYgTWFwIEFQSTsgaG93ZXZlcixcclxuICAgICAgICAgKiBpdCBpcyBkaXN0aW5jdCBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBleHRlcm5hbCBwb2x5ZmlsbHMgb3JcclxuICAgICAgICAgKiBvbiBFUzYgaXRzZWxmLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuTWFwXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH0gZmllbGQgTWFwIGZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IGNvbnRlbnRzIEluaXRpYWwgY29udGVudHNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTWFwID0gZnVuY3Rpb24oZmllbGQsIGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghZmllbGQubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJmaWVsZCBpcyBub3QgYSBtYXBcIik7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZpZWxkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtYXAuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8ga2V5IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FbGVtZW50fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC5rZXlUeXBlLCBudWxsLCB0cnVlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnQgaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRWxlbWVudH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC50eXBlLCBmaWVsZC5yZXNvbHZlZFR5cGUsIGZhbHNlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVybmFsIG1hcDogc3RvcmVzIG1hcHBpbmcgb2YgKHN0cmluZyBmb3JtIG9mIGtleSkgLT4gKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgICAqIHBhaXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFdlIHByb3ZpZGUgbWFwIHNlbWFudGljcyBmb3IgYXJiaXRyYXJ5IGtleSB0eXBlcywgYnV0IHdlIGJ1aWxkIG9uIHRvcFxyXG4gICAgICAgICAgICAgKiBvZiBhbiBPYmplY3QsIHdoaWNoIGhhcyBvbmx5IHN0cmluZyBrZXlzLiBJbiBvcmRlciB0byBhdm9pZCB0aGUgbmVlZFxyXG4gICAgICAgICAgICAgKiB0byBjb252ZXJ0IGEgc3RyaW5nIGtleSBiYWNrIHRvIGl0cyBuYXRpdmUgdHlwZSBpbiBtYW55IHNpdHVhdGlvbnMsXHJcbiAgICAgICAgICAgICAqIHdlIHN0b3JlIHRoZSBuYXRpdmUga2V5IHZhbHVlIGFsb25nc2lkZSB0aGUgdmFsdWUuIFRodXMsIHdlIG9ubHkgbmVlZFxyXG4gICAgICAgICAgICAgKiBhIG9uZS13YXkgbWFwcGluZyBmcm9tIGEga2V5IHR5cGUgdG8gaXRzIHN0cmluZyBmb3JtIHRoYXQgZ3VhcmFudGVlc1xyXG4gICAgICAgICAgICAgKiB1bmlxdWVuZXNzIGFuZCBlcXVhbGl0eSAoaS5lLiwgc3RyKEsxKSA9PT0gc3RyKEsyKSBpZiBhbmQgb25seSBpZiBLMVxyXG4gICAgICAgICAgICAgKiA9PT0gSzIpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHtrZXk6ICosIHZhbHVlOiAqfT59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApLmxlbmd0aDsgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgaW5pdGlhbCBjb250ZW50cyBmcm9tIGEgcmF3IG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUVsZW0udmFsdWVGcm9tU3RyaW5nKGtleXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlRWxlbS52ZXJpZnlWYWx1ZShjb250ZW50c1trZXlzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcoa2V5KV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleToga2V5LCB2YWx1ZTogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGVscGVyOiByZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciBhbiBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyIHRoZSBhcnJheVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBhbiBpdGVyYXRvclxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5SXRlcmF0b3IoYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IGFyci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYXJyW2lkeCsrXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBtYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHBhcnRpY3VsYXIga2V5IGZyb20gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBhbnkgZW50cnkgd2l0aCB0aGlzIGtleSB3YXMgZGVsZXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICB2YXIgaGFkS2V5ID0ga2V5VmFsdWUgaW4gdGhpcy5tYXA7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXlWYWx1ZV07XHJcbiAgICAgICAgICAgIHJldHVybiBoYWRLZXk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIFtrZXksIHZhbHVlXSBwYWlycyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpdGVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKFsoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLmtleSwgZW50cnkudmFsdWVdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5SXRlcmF0b3IoZW50cmllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIGtleXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaXRlcmF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc3RyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKHRoaXMubWFwW3N0cktleXNbaV1dLmtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKGtleXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB2YWx1ZXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH0gVGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLm1hcFtzdHJLZXlzW2ldXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKHZhbHVlcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRlcmF0ZXMgb3ZlciBlbnRyaWVzIGluIHRoZSBtYXAsIGNhbGxpbmcgYSBmdW5jdGlvbiBvbiBlYWNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczoqLCAqLCAqLCAqKX0gY2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHZhbHVlLCBrZXksIGFuZCBtYXAgYXJndW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gdGhpc0FyZyBUaGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCAoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYSBrZXkgaW4gdGhlIG1hcCB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5NYXB9IFRoZSBtYXAgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KTtcclxuICAgICAgICAgICAgdmFyIHZhbFZhbHVlID0gdGhpcy52YWx1ZUVsZW0udmVyaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFt0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyhrZXlWYWx1ZSldID1cclxuICAgICAgICAgICAgICAgIHsga2V5OiBrZXlWYWx1ZSwgdmFsdWU6IHZhbFZhbHVlIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBUaGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGtleSBub3QgcHJlc2VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICBpZiAoIShrZXlWYWx1ZSBpbiB0aGlzLm1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5VmFsdWVdLnZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUga2V5IGlzIHByZXNlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChrZXlWYWx1ZSBpbiB0aGlzLm1hcCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5SZWZsZWN0KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5wcm90byBzdHJpbmcgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gLnByb3RvIGZpbGUgY29udGVudHNcclxuICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkUHJvdG8gPSBmdW5jdGlvbihwcm90bywgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcixcclxuICAgICAgICAgICAgYnVpbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gUHJvdG9CdWYubG9hZEpzb24oUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnBhcnNlKHByb3RvKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLnByb3RvIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIC5wcm90byBmaWxlIGNvbnRlbnRzXHJcbiAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZyk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLnByb3RvRnJvbVN0cmluZyA9IFByb3RvQnVmLmxvYWRQcm90bzsgLy8gTGVnYWN5XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBwcm90byBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrLCBidWlsZGVyKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIGJ1aWxkZXIgPSBjYWxsYmFjayxcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBmaWxlXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRQcm90byhjb250ZW50cywgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSAucHJvdG8gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvRmlsZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8gcHJvdG8gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYucHJvdG9Gcm9tRmlsZSA9IFByb3RvQnVmLmxvYWRQcm90b0ZpbGU7IC8vIExlZ2FjeVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgZW1wdHkgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIEJ1aWxkZXIgb3B0aW9ucywgZGVmYXVsdHMgdG8gZ2xvYmFsIG9wdGlvbnMgc2V0IG9uIFByb3RvQnVmXHJcbiAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5uZXdCdWlsZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBvcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSA9IFByb3RvQnVmLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbJ3BvcHVsYXRlQWNjZXNzb3JzJ10gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBvcHRpb25zWydwb3B1bGF0ZUFjY2Vzc29ycyddID0gUHJvdG9CdWYucG9wdWxhdGVBY2Nlc3NvcnM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5CdWlsZGVyKG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLmpzb24gZGVmaW5pdGlvbiBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7ISp8c3RyaW5nfSBqc29uIEpTT04gZGVmaW5pdGlvblxyXG4gICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRKc29uID0gZnVuY3Rpb24oanNvbiwgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcixcclxuICAgICAgICAgICAgYnVpbGRlciA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFidWlsZGVyIHx8IHR5cGVvZiBidWlsZGVyICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgYnVpbGRlciA9IFByb3RvQnVmLm5ld0J1aWxkZXIoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICBidWlsZGVyW1wiaW1wb3J0XCJdKGpzb24sIGZpbGVuYW1lKTtcclxuICAgICAgICBidWlsZGVyLnJlc29sdmVBbGwoKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5qc29uIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3whe3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBqc29uIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRKc29uRmlsZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBjYWxsYmFjaywgYnVpbGRlcikge1xyXG4gICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICBlbHNlIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnID8gZmlsZW5hbWUgOiBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdLCBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZmlsZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZEpzb24oSlNPTi5wYXJzZShjb250ZW50cyksIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb3RvQnVmO1xyXG59KTtcclxuIiwiXHJcbi8v57uD5Lmg5oi/XHJcbnZhciBMb25nID0gcmVxdWlyZShcImxvbmdcIilcclxuXHJcbnZhciBNID0gY2MuQ2xhc3Moe1xyXG4gICAgXHJcbiAgICBjdG9yOiBmdW5jdGlvbigpe1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mHjee9ruaVsOaNrlxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyID0gbnVsbFxyXG4gICAgICAgIHRoaXMuU19HMTNfQWxsUm91bmRzID0ge1wicGxheWVyc1wiOltdfVxyXG5cclxuICAgICAgICAvL+WNleWxgOenr+WIhlxyXG4gICAgICAgIHRoaXMubWF0Y2hTY29yZXMgPSBbXVxyXG5cclxuICAgICAgICB0aGlzLnBsYXllcjEgPSBudWxsXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIyID0gbnVsbFxyXG4gICAgICAgIHRoaXMucGxheWVyMyA9IG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGFjaE1zZzpmdW5jdGlvbihuYW1lLGRhdGEpe1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXSA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpc1tuYW1lXShkYXRhKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2luaXRSb2JvdFBsYXllcnM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIxID0ge1wiY3VpZFwiOm5ldyBMb25nKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApLCAwKSwgIFwic3RhdHVzXCI6MCwgXCJuYW1lXCI6Y2MuZGF0YW1hbmFnZXIuY3JlYXRlUmFuZG9tTmFtZSgpLCBcInJhbmtcIjowLCBcImltZ3VybFwiOmNjLmRhdGFtYW5hZ2VyLmdldFJvYm90SGVhZEljb24oKSwgXCJpcHN0clwiOlwiMTI3LjAuMC4xXCJ9XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIyID0ge1wiY3VpZFwiOm5ldyBMb25nKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApLCAwKSwgIFwic3RhdHVzXCI6MCwgXCJuYW1lXCI6Y2MuZGF0YW1hbmFnZXIuY3JlYXRlUmFuZG9tTmFtZSgpLCBcInJhbmtcIjowLCBcImltZ3VybFwiOmNjLmRhdGFtYW5hZ2VyLmdldFJvYm90SGVhZEljb24oKSwgXCJpcHN0clwiOlwiMTI3LjAuMC4xXCJ9XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIzID0ge1wiY3VpZFwiOm5ldyBMb25nKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApLCAwKSwgIFwic3RhdHVzXCI6MCwgXCJuYW1lXCI6Y2MuZGF0YW1hbmFnZXIuY3JlYXRlUmFuZG9tTmFtZSgpLCBcInJhbmtcIjowLCBcImltZ3VybFwiOmNjLmRhdGFtYW5hZ2VyLmdldFJvYm90SGVhZEljb24oKSwgXCJpcHN0clwiOlwiMTI3LjAuMC4xXCJ9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5qih5ouf5Yib5bu65oi/6Ze0XHJcbiAgICBjcmVhdGVQcmFjdGljZVJvb206IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIFNfRzEzX1Jvb21BdHRyID0ge1wicm9vbV9pZFwiOjg4ODg4OCwgXCJhdHRyXCI6e1xyXG4gICAgICAgICAgICBcInBsYXllcl9zaXplXCI6NCwgXCJwbGF5X3R5cGVcIjo1MiwgXCJyb3VuZHNcIjoxMCwgXCJwYXlvclwiOjEwLCBcImRhX3FpYW5nXCI6MiwgXCJxdWFuX2xlaV9kYVwiOnRydWUsIFwieWlfdGlhb19sb25nXCI6MVxyXG4gICAgICAgIH19XHJcbiAgICAgICAgU19HMTNfUm9vbUF0dHIuYmFua2VyX2N1aWQgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5jdWlkXHJcbiAgICAgICAgU19HMTNfUm9vbUF0dHIucm9ib3QgPSB0cnVlICAvL+agh+iusOWcqOe7g+S5oOaIv+mXtFxyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIuZGlzcGFjaChcImRpc3BhY2hNc2dcIiwgXCJQdWJsaWNQcm90b19TX0cxM19Sb29tQXR0clwiLCBTX0cxM19Sb29tQXR0cilcclxuICAgIH0sXHJcblxyXG4gICAgLy/liLfmlrBwbGF5ZXJJblJvb21cclxuICAgIC8qIHN0YXR1c+WPluWAvFxyXG4gICAgICAgICAgICBOT05FICAgID0gMDsgLy/nqbrnirbmgIFcclxuICAgICAgICAgICAgUFJFUCAgICA9IDE7IC8v5YeG5aSHXHJcbiAgICAgICAgICAgIFJFQURZICAgPSAyOyAvL+Wwsee7qlxyXG4gICAgICAgICAgICBTT1JUICAgID0gMzsgLy/mkYbniYxcclxuICAgICAgICAgICAgQ09NUEFSRSA9IDQ7IC8v5q+U54mMXHJcbiAgICAgICAgICAgIERPTkUgICAgPSA1OyAvL+e7k+adn1xyXG4gICAgKi9cclxuICAgIHNlbmRQbGF5ZXJJblJvb206IGZ1bmN0aW9uKHJvdW5kLCBzZWxmU3RhdHVzLCByb2JvdFN0YXR1cyl7XHJcbiAgICAgICAgaWYoIXRoaXMubWFpblBsYXllcil7XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBsYXllciA9IHt9XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBsYXllci5jdWlkID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEuY3VpZFxyXG4gICAgICAgICAgICB0aGlzLm1haW5QbGF5ZXIuc3RhdHVzID0gMFxyXG4gICAgICAgICAgICB0aGlzLm1haW5QbGF5ZXIucmFuayA9IDBcclxuICAgICAgICAgICAgdGhpcy5tYWluUGxheWVyLm5hbWUgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5uaWNrX25hbWVcclxuICAgICAgICAgICAgdGhpcy5tYWluUGxheWVyLmltZ3VybCA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLnVybFxyXG4gICAgICAgICAgICB0aGlzLm1haW5QbGF5ZXIuaXBzdHIgPSBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5pcHN0clxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIXRoaXMucGxheWVyMSl7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRSb2JvdFBsYXllcnMoKVxyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG4gICAgICAgdGhpcy5tYWluUGxheWVyLnN0YXR1cyA9IHNlbGZTdGF0dXNcclxuICAgICAgIHRoaXMucGxheWVyMS5zdGF0dXMgPSByb2JvdFN0YXR1c1xyXG4gICAgICAgdGhpcy5wbGF5ZXIyLnN0YXR1cyA9IHJvYm90U3RhdHVzXHJcbiAgICAgICB0aGlzLnBsYXllcjMuc3RhdHVzID0gcm9ib3RTdGF0dXNcclxuXHJcbiAgICAgICB2YXIgU19HMTNfUGxheWVyc0luUm9vbSA9IHt9XHJcbiAgICAgICB0aGlzLmFsbHBsYXllcnMgPSBbdGhpcy5tYWluUGxheWVyLCB0aGlzLnBsYXllcjEsIHRoaXMucGxheWVyMiwgdGhpcy5wbGF5ZXIzXVxyXG5cclxuICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbHBsYXllcnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgIHRoaXMuYWxscGxheWVyc1tpXS5yYW5rID0gdGhpcy5fZ2V0TWFjaFJvdW5kU2NvcmUodGhpcy5hbGxwbGF5ZXJzW2ldLmN1aWQsIHJvdW5kKVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIFNfRzEzX1BsYXllcnNJblJvb20ucGxheWVycyA9IHRoaXMuYWxscGxheWVyc1xyXG4gICAgICAgU19HMTNfUGxheWVyc0luUm9vbS5yb3VuZHMgPSByb3VuZFxyXG4gICAgICAgY2MubmV0bWFuYWdlci5kaXNwYWNoKFwiZGlzcGFjaE1zZ1wiLCBcIlB1YmxpY1Byb3RvX1NfRzEzX1BsYXllcnNJblJvb21cIiwgU19HMTNfUGxheWVyc0luUm9vbSlcclxuXHJcbiAgICAgICAvL+WIneWni+WMluaAu+iuoeeul+a2iOaBr1xyXG4gICAgICAgaWYodGhpcy5TX0cxM19BbGxSb3VuZHMucGxheWVycy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYWxscGxheWVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgIHZhciBwbGF5ZXIgPSB7XCJ3aW5cIjowLCBcImRhcWlhbmdcIjowLCBcInF1YW5sZWlkYVwiOjAsIFwicmFua1wiOjB9XHJcbiAgICAgICAgICAgICAgIHBsYXllci5jdWlkID0gdGhpcy5hbGxwbGF5ZXJzW2ldLmN1aWRcclxuICAgICAgICAgICAgICAgdGhpcy5TX0cxM19BbGxSb3VuZHMucGxheWVycy5wdXNoKHBsYXllcilcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Y+R54mMXHJcbiAgICBzZW5kSGFuZGxlT2ZNaW5lOiBmdW5jdGlvbihyb3VuZCl7XHJcblxyXG4gICAgICAgIHZhciBjYXJkcG9vbCA9IFtdXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDUyOyArK2kpeyBjYXJkcG9vbC5wdXNoKGkrMSkgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Zub5Liq546p5a6255qE54mMXHJcbiAgICAgICAgdGhpcy5jYXJkQXJyID0gW1tdLFtdLFtdLFtdXVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNhcmRBcnIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB3aGlsZSh0aGlzLmNhcmRBcnJbaV0ubGVuZ3RoICE9IDEzKXtcclxuICAgICAgICAgICAgICAgIHZhciByYW5kb21JZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjYXJkcG9vbC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBpZihyYW5kb21JZHggPCAwIHx8IHJhbmRvbUlkeCA+PSBjYXJkcG9vbC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbUlkeCA9IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FyZEFycltpXS5wdXNoKGNhcmRwb29sW3JhbmRvbUlkeF0pXHJcbiAgICAgICAgICAgICAgICBjYXJkcG9vbC5zcGxpY2UocmFuZG9tSWR4LCAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYy5sb2coXCJyb2JvdCDlj5HniYwgXCIsIHRoaXMuY2FyZEFyclswXS5sZW5ndGgpXHJcbiAgICAgICAgdmFyIFNfRzEzX0hhbmRPZk1pbmUgPSB7fVxyXG4gICAgICAgIFNfRzEzX0hhbmRPZk1pbmUucm91bmRzID0gcm91bmRcclxuICAgICAgICBTX0cxM19IYW5kT2ZNaW5lLmNhcmRzID0gdGhpcy5jYXJkQXJyWzBdLnNsaWNlKClcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLmRpc3BhY2goXCJkaXNwYWNoTXNnXCIsIFwiUHVibGljUHJvdG9fU19HMTNfSGFuZE9mTWluZVwiLCBTX0cxM19IYW5kT2ZNaW5lKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aJgOacieS6uuavlOeJjOaVsOaNrlxyXG4gICAgLy9zZWxmY2FyZDog6Ieq5bex6YCJ5oup55qE54mMXHJcbiAgICBzZW5kQWxsSGFuZHM6IGZ1bmN0aW9uKHNwZWNpYWwsIHNlbGZjYXJkKXtcclxuICAgICAgICBpZighdGhpcy5jYXJkQXJyKXtcclxuICAgICAgICAgICAgY2MubG9nKFwi6L+Y5pyq5Y+R54mMIVwiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v6K+35rGC6K6h566X5qih5ouf54mM5bGA55qE57uT5p6cXHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19HMTNfU2ltdWxhdGlvblJvdW5kXCIpXHJcbiAgICAgICAgbXNnLnBsYXllcnMucHVzaCh7XCJjdWlkXCI6dGhpcy5hbGxwbGF5ZXJzWzBdLmN1aWQsIFwiY2FyZHNcIjpzZWxmY2FyZCwgXCJzcGVjaWFsXCI6c3BlY2lhbH0pXHJcblxyXG4gICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuYWxscGxheWVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcInByb2ludCBjYXJkczogICBcIiwgaSlcclxuICAgICAgICAgICB2YXIgcGxheWVyID0ge31cclxuICAgICAgICAgICBwbGF5ZXIuY3VpZCA9IHRoaXMuYWxscGxheWVyc1tpXS5jdWlkXHJcbiAgICAgICAgICAgcGxheWVyLmNhcmRzID0gY2Mucm9ib3QuX2NhbGN1bGF0ZVJvYm90Q2FyZCh0aGlzLmNhcmRBcnJbaV0uc2xpY2UoKSlcclxuICAgICAgICAgICBwbGF5ZXIuc3BlY2lhbCA9IGZhbHNlXHJcbiAgICAgICAgICAgbXNnLnBsYXllcnMucHVzaChwbGF5ZXIpXHJcbiAgICAgICB9XHJcbiAgICAgICAvL2NjLmxvZyhcIuivt+axguiuoeeul+aooeaLn+eJjOWxgOeahOe7k+aenCwgXCIsIG1zZy5wbGF5ZXJzLmxlbmd0aClcclxuICAgICAgIC8vY2MuUG9rZXJVdGlsLnByaW50UG9rZXJFbmNvZGUobXNnLnBsYXllcnNbMF0uY2FyZHMpXHJcbiAgICAgICAvL2NjLlBva2VyVXRpbC5wcmludFBva2VyRW5jb2RlKG1zZy5wbGF5ZXJzWzFdLmNhcmRzKVxyXG4gICAgICAgLy9jYy5Qb2tlclV0aWwucHJpbnRQb2tlckVuY29kZShtc2cucGxheWVyc1syXS5jYXJkcylcclxuICAgICAgIC8vY2MuUG9rZXJVdGlsLnByaW50UG9rZXJFbmNvZGUobXNnLnBsYXllcnNbM10uY2FyZHMpXHJcbiAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iuoeeul+acuuWZqOS6uueJjOWei+aVsOaNrlxyXG4gICAgX2NhbGN1bGF0ZVJvYm90Q2FyZDogZnVuY3Rpb24oY2FyZHMpe1xyXG4gICAgICAgdmFyIHJldCA9IGNjLlBva2VyVXRpbC5nZXRSZWNvbW1lbmRQb2tlclNldChjYXJkcylcclxuICAgICAgIGlmKHJldC5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICB2YXIgYyA9IFtdXHJcbiAgICAgICAgICAgYyA9IGMuY29uY2F0KHJldFswXS50b3AuY2FyZCwgcmV0WzBdLm1pZGRsZS5jYXJkLCByZXRbMF0uYm90dG9tLmNhcmQpXHJcbiAgICAgICAgICAgcmV0dXJuIGNcclxuICAgICAgIH1cclxuICAgICAgIHJldHVybiBjYXJkc1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0QWxsUm91bmRzUGxheWVyOiBmdW5jdGlvbihjdWlkKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5TX0cxM19BbGxSb3VuZHMucGxheWVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU19HMTNfQWxsUm91bmRzLnBsYXllcnNbaV0uY3VpZC5lcShjdWlkKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TX0cxM19BbGxSb3VuZHMucGxheWVyc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRNYWNoUm91bmRTY29yZTogZnVuY3Rpb24oY3VpZCwgcm91bmQpe1xyXG4gICAgICAgIGlmKCF0aGlzLm1hdGNoU2NvcmVzW3JvdW5kXSl7XHJcbiAgICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRjaFNjb3Jlc1tyb3VuZF0ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZih0aGlzLm1hdGNoU2NvcmVzW3JvdW5kXVtpXS5jdWlkLmVxKGN1aWQpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoU2NvcmVzW3JvdW5kXVtpXS5yYW5rXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX0NhbGNSb3VuZFNpbXVsYXRpb25SZXQ6IGZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgY2MubG9nKFwi5pS25Yiw5pyN5Yqh5Zmo6L+U5Zue55qE5qih5ouf5pWw5o2uXCIpXHJcblxyXG4gICAgICAgIHZhciByb3VuZCA9IGNjLmdhbWVtYW5hZ2VyLl9jdXJyZW50Um91bmRzICsgMVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLnJlc3VsdC5wbGF5ZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGN1aWQgPSBtc2cucmVzdWx0LnBsYXllcnNbaV0uY3VpZFxyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuX2dldEFsbFJvdW5kc1BsYXllcihjdWlkKVxyXG4gICAgICAgICAgICBpZihwKXtcclxuICAgICAgICAgICAgICAgIHAucmFuayArPSBtc2cucmVzdWx0LnBsYXllcnNbaV0ucmFua1xyXG4gICAgICAgICAgICAgICAgaWYobXNnLnJlc3VsdC5wbGF5ZXJzW2ldLnJhbmsgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICBwLndpbisrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLm1hdGNoU2NvcmVzW3JvdW5kXSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoU2NvcmVzW3JvdW5kXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzY29yZSA9IHRoaXMuX2dldE1hY2hSb3VuZFNjb3JlKGN1aWQsIHJvdW5kLTEpICsgbXNnLnJlc3VsdC5wbGF5ZXJzW2ldLnJhbmtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaFNjb3Jlc1tyb3VuZF0ucHVzaCh7XCJjdWlkXCI6Y3VpZCwgXCJyYW5rXCI6c2NvcmV9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLmRpc3BhY2goXCJkaXNwYWNoTXNnXCIsIFwiUHVibGljUHJvdG9fU19HMTNfQWxsSGFuZHNcIiwgbXNnLnJlc3VsdClcclxuICAgIH0sXHJcblxyXG4gICAgLy/nu4PkuaDlnLropoHkv53lrZjnu5PnrpfmlbDmja5cclxuICAgIHNhdmVNYXRjaFJlc3VsdDogZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuX2dldEFsbFJvdW5kc1BsYXllcihkYXRhW2ldLmN1aWQpXHJcbiAgICAgICAgICAgIGlmKHApe1xyXG4gICAgICAgICAgICAgICAgcC5kYXFpYW5nICs9IGRhdGFbaV0uZGFxaWFuZ2xpc3QubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBpZihkYXRhW2ldLnF1YW5sZWlkYSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5xdWFubGVpZGErK1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkemAgemAgee7k+eul+aVsOaNrlxyXG4gICAgc2VuZEFsbFJvdW5kc1N1bW1hcnk6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5kaXNwYWNoKFwiZGlzcGFjaE1zZ1wiLCBcIlB1YmxpY1Byb3RvX1NfRzEzX0FsbFJvdW5kc1wiLCB0aGlzLlNfRzEzX0FsbFJvdW5kcylcclxuICAgIH0sXHJcbn0pO1xyXG5cclxuY2Mucm9ib3QgPSBuZXcgTSgpOyIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICB0b3BjYXJkOiBjYy5Ob2RlLFxyXG4gICAgICAgbWlkZGxlY2FyZDogY2MuTm9kZSxcclxuICAgICAgIGJvdHRvbWNhcmQ6IGNjLk5vZGUsXHJcbiAgICAgICB6b25nZmVuOiBjYy5MYWJlbCxcclxuICAgICAgIGRhcWlhbmc6IGNjLkxhYmVsLFxyXG4gICAgICAgdXNlcm5hbWU6IGNjLkxhYmVsLFxyXG4gICAgICAgdG91eGlhbmc6IGNjLk5vZGUsXHJcbiAgICAgICBxdWFubGVpZGE6IGNjLkxhYmVsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB9LFxyXG5cclxuICAgIF9zY29yZVN0cjogZnVuY3Rpb24obnVtKXtcclxuXHJcbiAgICAgICAgaWYobnVtIDwgMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudW0udG9TdHJpbmcoKVxyXG4gICAgICAgIH1lbHNlIGlmKG51bSA+IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIrXCIgKyBudW0udG9TdHJpbmcoKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9zZXRTY29yZTogZnVuY3Rpb24obm9kZSwgbmFtZSwgbnVtKXtcclxuICAgICAgICB2YXIgbGIgPSBub2RlLmdldENoaWxkQnlOYW1lKG5hbWUpLmdldENvbXBvbmVudChjYy5MYWJlbClcclxuICAgICAgICBpZihsYil7XHJcbiAgICAgICAgICAgIGxiLnN0cmluZyA9IHRoaXMuX3Njb3JlU3RyKG51bSlcclxuICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2V0U2NvcmVGb250KG51bT49MCwgbGIpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0Q2FyZDogZnVuY3Rpb24oY2FyZGRhdGEsIHNjb3JlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcGVjaWFsID0gZmFsc2VcclxuICAgICAgICBpZihjYXJkZGF0YS5zcGVjLmJyYW5kICE9IDApe1xyXG4gICAgICAgICAgICBzcGVjaWFsID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRjID0gdGhpcy50b3BjYXJkLmdldENoaWxkQnlOYW1lKFwiY2FyZFwiKVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0Yy5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRjLmNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUoY2FyZGRhdGEuY2FyZHNbaV0sIG5vZGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdDEgPSBjYy5jb25maWdtYW5hZ2VyLnBva2VyRmxvcENmZ1tjYXJkZGF0YS5kdW4wLmJyYW5kXVxyXG4gICAgICAgIGlmKCFzcGVjaWFsKXtcclxuICAgICAgICAgICAgdGhpcy50b3BjYXJkLmdldENoaWxkQnlOYW1lKFwibmFtZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHN0MS5uYW1lXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWMgPSB0aGlzLm1pZGRsZWNhcmQuZ2V0Q2hpbGRCeU5hbWUoXCJjYXJkXCIpXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1jLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbWMuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShjYXJkZGF0YS5jYXJkc1tpKzNdLCBub2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3QyID0gY2MuY29uZmlnbWFuYWdlci5wb2tlckZsb3BDZmdbY2FyZGRhdGEuZHVuMS5icmFuZF1cclxuICAgICAgICBpZighc3BlY2lhbCl7XHJcbiAgICAgICAgICAgIHRoaXMubWlkZGxlY2FyZC5nZXRDaGlsZEJ5TmFtZShcIm5hbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBzdDIubmFtZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJjID0gdGhpcy5ib3R0b21jYXJkLmdldENoaWxkQnlOYW1lKFwiY2FyZFwiKVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYy5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGJjLmNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUoY2FyZGRhdGEuY2FyZHNbaSs4XSwgbm9kZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0MyA9IGNjLmNvbmZpZ21hbmFnZXIucG9rZXJGbG9wQ2ZnW2NhcmRkYXRhLmR1bjIuYnJhbmRdXHJcbiAgICAgICAgaWYoIXNwZWNpYWwpe1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbWNhcmQuZ2V0Q2hpbGRCeU5hbWUoXCJuYW1lXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gc3QzLm5hbWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuem9uZ2Zlbi5zdHJpbmcgPSB0aGlzLl9zY29yZVN0cihjYXJkZGF0YS5yYW5rKVxyXG4gICAgICAgIGNjLmRhdGFtYW5hZ2VyLnNldFNjb3JlRm9udChjYXJkZGF0YS5yYW5rPj0wLCB0aGlzLnpvbmdmZW4pXHJcblxyXG4gICAgICAgIHZhciBwbGF5ZXIgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIoY2FyZGRhdGEuY3VpZClcclxuICAgICAgICBpZihwbGF5ZXIgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUuc3RyaW5nID0gcGxheWVyLm5hbWVcclxuICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIubG9hZEhlYWRJbWcocGxheWVyLmltZ3VybCwgdGhpcy50b3V4aWFuZy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFzcGVjaWFsKXtcclxuICAgICAgICAgICAgLy90aGlzLnRvcGNhcmQuZ2V0Q2hpbGRCeU5hbWUoXCJzY29yZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHRoaXMuX3Njb3JlU3RyKHNjb3JlLnNjb3JlLnRvcClcclxuICAgICAgICAgICAgLy90aGlzLm1pZGRsZWNhcmQuZ2V0Q2hpbGRCeU5hbWUoXCJzY29yZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHRoaXMuX3Njb3JlU3RyKHNjb3JlLnNjb3JlLm1pZGRsZSlcclxuICAgICAgICAgICAgLy90aGlzLmJvdHRvbWNhcmQuZ2V0Q2hpbGRCeU5hbWUoXCJzY29yZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHRoaXMuX3Njb3JlU3RyKHNjb3JlLnNjb3JlLmJvdHRvbSlcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMudG9wY2FyZCwgXCJzY29yZVwiLCBzY29yZS5zY29yZS50b3ApXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMubWlkZGxlY2FyZCwgXCJzY29yZVwiLCBzY29yZS5zY29yZS5taWRkbGUpXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFNjb3JlKHRoaXMuYm90dG9tY2FyZCwgXCJzY29yZVwiLCBzY29yZS5zY29yZS5ib3R0b20pXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHZhciByayA9IE1hdGguZmxvb3IoY2FyZGRhdGEuc3BlYy5icmFuZC8xMClcclxuICAgICAgICAgICAgLy92YXIgc3RyID0gY2MuY29uZmlnbWFuYWdlci5zcGVjaWFsRmxvcENmZ1tya10ubmFtZS50b1N0cmluZygpICsgXCIgICtcIiArIHNjb3JlLnNjb3JlLnNwZWNpYWwudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICB2YXIgbGJsID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwic2NvcmVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKVxyXG4gICAgICAgICAgICBsYmwuc3RyaW5nID0gdGhpcy5fc2NvcmVTdHIoc2NvcmUuc2NvcmUuc3BlY2lhbClcclxuICAgICAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2V0U2NvcmVGb250KHNjb3JlLnNjb3JlLnNwZWNpYWw+PTAsIGxibClcclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VTcHJpdGUoY2MuY29uZmlnbWFuYWdlci5zcGVjaWFsRmxvcENmZ1tya10udGV4cmVzLCB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJQb2tlclR5cGVcIikpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGFxaWFuZy5zdHJpbmcgPSB0aGlzLl9zY29yZVN0cihzY29yZS5zY29yZS5zcGUpXHJcbiAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2V0U2NvcmVGb250KHNjb3JlLnNjb3JlLnNwZT49MCwgdGhpcy5kYXFpYW5nKVxyXG5cclxuICAgICAgICB0aGlzLnF1YW5sZWlkYS5zdHJpbmcgPSB0aGlzLl9zY29yZVN0cihzY29yZS5zY29yZS5xdWFubGVpZGEpXHJcbiAgICAgICAgY2MuZGF0YW1hbmFnZXIuc2V0U2NvcmVGb250KHNjb3JlLnNjb3JlLnF1YW5sZWlkYT49MCwgdGhpcy5xdWFubGVpZGEpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICB0aGlzLm5vZGUub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5U0ZYKFwidGFuY2h1XCIpXHJcbiAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBhY3ROb2RlOiBjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSAwXHJcblxyXG4gICAgICAgIHZhciBhY3Rpb24gPSBjYy5yZXBlYXRGb3JldmVyKGNjLnNlcXVlbmNlKGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCwgcGFyYW0pe1xyXG4gICAgICAgICAgICB2YXIgaSA9IDBcclxuICAgICAgICAgICAgZm9yKDsgaSA8IHBhcmFtLl9pbmRleDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHBhcmFtLmFjdE5vZGUuY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcig7IGkgPCBwYXJhbS5hY3ROb2RlLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5hY3ROb2RlLmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICsrcGFyYW0uX2luZGV4XHJcbiAgICAgICAgICAgIGlmKHBhcmFtLl9pbmRleCA+IHBhcmFtLmFjdE5vZGUuY2hpbGRyZW5Db3VudCl7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5faW5kZXggPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLCB0aGlzKSwgY2MuZGVsYXlUaW1lKDAuMykpKVxyXG5cclxuICAgICAgICB0aGlzLmFjdE5vZGUucnVuQWN0aW9uKGFjdGlvbilcclxuICAgIH0sXHJcblxyXG59KTsiXSwic291cmNlUm9vdCI6IiJ9