require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"AudioMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd2df2LGO/FCOJQCrG5T+a4t', 'AudioMgr');
// Scripts\Manager\AudioMgr.js

"use strict";

//音乐管理器
var M = cc.Class({

    properties: {
        bgmVolume: 1.0,
        sfxVolume: 1.0,
        bgmAudioID: -1
    },

    // use this for initialization
    init: function init() {
        var t = cc.sys.localStorage.getItem("gbmVolume");
        if (t != null) {
            this.bgmVolume = parseFloat(t);
        }

        var t = cc.sys.localStorage.getItem("sfxVolume");
        if (t != null) {
            this.sfxVolume = parseFloat(t);
        }

        cc.game.on(cc.game.EVENT_HIDE, function () {
            console.log("cc.audioEngine.pauseAll");
            cc.audioEngine.pauseAll();
        });

        cc.game.on(cc.game.EVENT_SHOW, function () {
            console.log("cc.audioEngine.resumeAll");
            cc.audioEngine.resumeAll();
        });

        cc.audioEngine.setMusicVolume(this.bgmVolume);
        cc.audioEngine.setMusicVolume(this.sfxVolume);
    },

    playBGM: function playBGM(url) {
        if (this.bg_clip) {
            cc.loader.releaseAsset(this.bg_clip);
            this.bg_clip = null;
        }
        if (!this.bg_clip) {
            var self = this;
            cc.loader.loadRes('Sound/' + url, cc.AudioClip, function (err, clip) {
                self.bg_clip = clip;
                self.bgmAudioID = cc.audioEngine.playMusic(self.bg_clip, true);
            });
        }
    },

    playSFX: function playSFX(url) {
        if (this.sfxVolume > 0) {
            var audioId = cc.audioEngine.play(audioUrl, false, this.sfxVolume);
        }
    },

    setBGMVolume: function setBGMVolume(value) {},
    setSFXVolume: function setSFXVolume(value) {},

    pauseAll: function pauseAll() {
        cc.audioEngine.pauseAll();
    },

    resumeAll: function resumeAll() {
        cc.audioEngine.resumeAll();
    }

});

cc.audiomanager = new M();

cc._RF.pop();
},{}],1:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":2}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"CardMoveEvent":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'e54abXhmzNCsJ+pA9pty28+', 'CardMoveEvent');
// Scripts\Gui\CardMoveEvent.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...

        parentNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onAnimCompleted: function onAnimCompleted(num) {
        this.parentNode.getComponent("UIPokerGame").onAnimCompleted(num);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"ChatBubble":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fb85fG/wFtIZ6gsoDziwHyw', 'ChatBubble');
// Scripts\Gui\Widget\ChatBubble.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        text: cc.Label,
        face: cc.Animation
    },

    // use this for initialization
    onLoad: function onLoad() {},

    showText: function showText(msg) {
        this.text.node.active = true;
        this.face.node.active = false;
        this.text.string = msg;
        cc.log('test:' + msg);
    },
    showFace: function showFace(id) {
        this.text.node.active = false;
        this.face.node.active = true;
        this.face.play("face_" + id);
        // this.face.spriteFrame = cc.gamemanager.createFace(id)
        // cc.log('this.face.spriteFrame:' + this.face.spriteFrame)
    }
});

cc._RF.pop();
},{}],"ConfigManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd4e15rene1Jw5lBLEELzsz9', 'ConfigManager');
// Scripts\Manager\ConfigManager.js

"use strict";

//保存一些客户端配置

var M = cc.Class({

    ctor: function ctor() {
        this.serverIP = "10.173.32.52"; //"119.23.71.237" 
        this.serverPort = 7000;

        this.nickName1 = ["上官", "欧阳", "东方", "端木", "独孤", "司马", "南宫", "夏侯", "诸葛", "皇甫", "长孙", "宇文", "轩辕", "东郭", "子车", "东阳", "子言"];

        this.nickName2 = ["雀圣", "赌侠", "赌圣", "稳赢", "不输", "好运", "自摸", "有钱", "土豪"];

        this.wndScale = cc.view.getFrameSize().height / 720;

        cc.log("getFrameSize: ", cc.view.getFrameSize().width, cc.view.getFrameSize().height);

        //房间头像位置(从自己开始逆时针方向，除自己外最多五名玩家)
        var scale = this.wndScale;
        var sx = cc.view.getFrameSize().width / 2;
        this.headIconPos = [[cc.v2(0, 188)], //2人
        [cc.v2(300 / scale, 160), cc.v2(-300 / scale, 160)], //3人
        [cc.v2((sx - 50) / scale, -40), cc.v2(0, 188), cc.v2((-sx + 50) / scale, -40)], //4人
        [cc.v2((sx - 50) / scale, -40), cc.v2(300 / scale, 150), cc.v2(-300 / scale, 150), cc.v2((-sx + 50) / scale, -40)] //5人
        ];

        this.yunyin_sdk_id = 1001664;
    }
});

cc.configmanager = new M();

cc._RF.pop();
},{}],"DataManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2307bIa+iBNorYNK5W+/1D1', 'DataManager');
// Scripts\Manager\DataManager.js

"use strict";

//数据管理器，存储全局数据
var M = cc.Class({

    ctor: function ctor() {
        this.nickName1 = ["上官", "欧阳", "东方", "端木", "独孤", "司马", "南宫", "夏侯", "诸葛", "皇甫", "长孙", "宇文", "轩辕", "东郭", "子车", "东阳", "子言"];

        this.nickName2 = ["雀圣", "赌侠", "赌圣", "稳赢", "不输", "好运", "自摸", "有钱", "土豪"];

        //主人物基本数据
        this.mainPlayerData = {};
        this.mainPlayerData.cuid = 0, this.mainPlayerData.nick_name = "", this.mainPlayerData.penid = "";
    },

    dispachMsg: function dispachMsg(name, data) {
        if (typeof this[name] == 'function') {
            this[name](data);
        }
    },

    PublicProto_S_Notice: function PublicProto_S_Notice(data) {
        cc.guimanager.msgBox(data.text);
    },

    saveRoomSetting: function saveRoomSetting(setting) {
        this.roomSetting = setting;
    },
    getRoomSetting: function getRoomSetting() {
        return this.roomSetting;
    },

    getUserOpenId: function getUserOpenId() {
        var id = cc.sys.localStorage.getItem("userOpenId");
        // if(id == null){
        {
            var num = Math.floor(Math.random() * 100000);
            id = num.toString();
            cc.sys.localStorage.setItem("userOpenId", id);
        }
        return id;
    },

    getNickName: function getNickName() {
        var nickname = cc.sys.localStorage.getItem("userNickName");
        if (nickname == null) {
            var nickName1 = cc.configmanager.nickName1;
            var nickName2 = cc.configmanager.nickName2;
            nickname = nickName1[Math.floor(Math.random() * 15)] + nickName2[Math.floor(Math.random() * 9)];
            cc.sys.localStorage.setItem("userNickName", nickname);
        }
        return nickname;
    }

});

cc.datamanager = new M();

cc._RF.pop();
},{}],"GameManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ba526NcqlNN2qgcNxBxFSq7', 'GameManager');
// Scripts\Manager\GameManager.js

"use strict";

//游戏管理器，进入房间后的数据和逻辑管理
var M = cc.Class({

    ctor: function ctor() {
        this._players = []; //房间玩家信息，包括自己

        this.initDefaultPokers();

        this._currentMatchIdx = 0; //当前是第几局，0代表测试数据
    },

    initDefaultPokers: function initDefaultPokers() {
        this._myPokerValues = [];
        this._myPokerValues.push([18, 42, 8, 7, 6, 5, 38, 26, 17, 25, 37, 21, 19]); //我手上的十三张牌, 第0局测试数据
    },

    dispachMsg: function dispachMsg(name, data) {
        if (typeof this[name] == 'function') {
            this[name](data);
        }
    },

    //创建或加入房间返回成功
    PublicProto_S_G13_RoomAttr: function PublicProto_S_G13_RoomAttr(msg) {
        if (msg.room_code != 0) {
            this.room_info = msg;
            this.gameStart();
        }
    },

    //刷新房间玩家数据
    PublicProto_S_G13_PlayersInRoom: function PublicProto_S_G13_PlayersInRoom(msg) {
        cc.log("收到加入房间消息 size =" + msg.players.length);
        this._players = [];
        for (var i = 0; i < msg.players.length; ++i) {
            var data = {};
            data.cuid = msg.players[i].cuid;
            data.status = msg.players[i].status;
            data.name = msg.players[i].name;
            this._players.push(data);
        }

        cc.guimanager.dispachMsg("onPlayerInRoom", this._players);
    },

    getPlayer: function getPlayer(id) {
        cc.log("this._players.length:" + this._players.length);
        if (this._players) {
            for (var i = 0; i < this._players.length; ++i) {
                if (this._players[i].cuid.eq(id)) {
                    return this._players[i];
                }
            }
        }
        return null;
    },

    mainPlayer: function mainPlayer() {
        return this.getPlayer(cc.datamanager.mainPlayerData.cuid);
    },

    //游戏开始调用
    gameStart: function gameStart() {
        if (this.room_info && cc.director.getScene().name == "Main") {
            cc.scenemanager.loadPokerGameScene();

            // this._faces = []
            // var self = this
            // for (var i = 1; i <= 15; ++i)
            // {
            //     (function(){
            //     var index = i
            //     var s = self
            //     var func = function(err,sf){
            //         s._faces[index - 1] = sf
            //     }
            //     cc.loader.loadRes('Textures/expression' + index,cc.SpriteFrame,func)
            //     })()
            // }
        }
    },

    //游戏结束调用
    gameOver: function gameOver() {
        this.room_info = null;
        this._players = [];
        this.initDefaultPokers();
        // for (var i = 0; i < this._faces.length; ++i)
        // {
        //     if (this._faces[i])
        //     {
        //         cc.loader.releaseAsset(this._faces[i])
        //     }
        // }
        // this._faces = null
    },

    // createFace:function(faceid){
    //     if (this._faces && faceid <= this._faces.length)
    //     {
    //         var prefab = this._faces[faceid - 1]
    //         cc.log('prefab:' + prefab)
    //         return cc.instantiate(prefab)
    //     }
    //     return null
    // },

    //获取当前局的13张牌
    getCurMathPokers: function getCurMathPokers() {
        if (this._myPokerValues.length > this._currentMatchIdx) {
            return this._myPokerValues[this._currentMatchIdx];
        }
        return [];
    },

    //收到发牌消息
    PublicProto_S_G13_HandOfMine: function PublicProto_S_G13_HandOfMine(msg) {
        cc.log("收到发牌消息, 牌数量 = " + msg.cards.length);

        if (msg.cards.length != 13) {
            cc.log("牌数据不对！");
            return;
        }

        this._myPokerValues.push(msg.cards);
        this._currentMatchIdx++;

        if (this._currentMatchIdx == 1) {
            //开始第一把
            cc.guimanager.dispachMsg("newMatchStart");
        } else {
            //第二把数据已经过来，先存储等待第一把客户端动画结束

        }
    },

    //投票协议
    PublicProto_S_G13_AbortGameOrNot: function PublicProto_S_G13_AbortGameOrNot(msg) {
        this.voteInfo = msg;
        cc.guimanager.showOrOpenUI('UIVote');
    },

    //投票失败
    PublicProto_S_G13_VoteFailed: function PublicProto_S_G13_VoteFailed(msg) {
        cc.guimanager.closeByName('UIVote');
        var name = cc.gamemanager.getPlayer(msg.opponent).name;
        cc.guimanager.msgBox('玩家:'.concat(name, ',不同意,投票未通过,游戏继续。'));
    }

});

cc.gamemanager = new M();

cc._RF.pop();
},{}],"GuiManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bc58aNIfmBAPaAtobwrO1iF', 'GuiManager');
// Scripts\Manager\GuiManager.js

'use strict';

var M = cc.Class({

    ctor: function ctor() {
        this.panels = {};
    },

    dispachMsg: function dispachMsg(name, msgdata) {
        for (var key in this.panels) {
            var list = this.panels[key];
            for (var i = 0; i < list.length; ++i) {
                var p = list[i];
                if (typeof p[name] == 'function') {
                    p[name](msgdata);
                }
            }
        }
    },

    open: function open(name, call, bvisible) {
        var self = this;
        cc.loader.loadRes('Gui/' + name, function (err, prefab) {
            if (prefab != null) {
                var obj = cc.instantiate(prefab);
                obj.parent = cc.director.getScene();
                var panel = obj.getComponent(cc.uipanel);
                if (call != null) call(panel);
                var list = self.panels[name];
                if (!list) {
                    cc.log('add list:' + name);
                    list = [];
                    self.panels[name] = list;
                }
                panel.onCreate();
                if (bvisible == undefined) panel.setVisible(true);else {
                    panel.setVisible(bvisible);
                }

                list.push(panel);
                return panel;
            } else {
                cc.log('open panel fail:' + name);
            }
        });
    },

    showOrOpenUI: function showOrOpenUI(name) {
        var panel = this.getByName(name);
        if (panel) {
            panel.setVisible(true);
        } else {
            this.open(name, null, true);
        }
    },

    msgBox: function msgBox(msg, func) {
        this.open('UIMessageBox', function (panel) {
            panel.setMessage(msg);
            panel.setCall(func);
        });
    },

    wait: function wait(msg) {
        cc.log(msg);
        this.open('UIWaiting', function (panel) {
            panel.setMessage(msg);
        });
    },

    closeWait: function closeWait() {
        this.closeByName('UIWaiting');
    },

    destroyPanel: function destroyPanel(panel) {
        if (panel && panel.node) {
            panel.onClose();
            panel.node.destroy();
        }
    },

    close: function close(panel) {
        for (var key in this.panels) {
            var list = this.panels[key];
            if (list) {
                for (var i = list.length - 1; i >= 0; --i) {
                    if (list[i] == panel) {
                        this.destroyPanel(panel);
                        list.slice(i, 1);
                        return;
                    }
                }
            }
        }
    },

    getByName: function getByName(panelName) {
        var list = this.panels[panelName];
        if (list) {
            if (list.length > 0) {
                return list[0];
            }
        }
        return null;
    },

    closeByName: function closeByName(panelName) {
        var list = this.panels[panelName];
        cc.log('begin closeByname:' + panelName);
        if (list) {
            for (var i = 0; i < list.length; ++i) {
                this.destroyPanel(list[i]);
            }
            this.panels[panelName] = [];
        }
    },

    closeAll: function closeAll() {
        cc.log('close All:' + this.panels.length);
        for (var key in this.panels) {
            cc.log('key:' + key);
            var list = this.panels[key];
            if (list) {
                for (var i = 0; i < list.length; ++i) {
                    cc.log('destroyPanel:' + list.length);
                    this.destroyPanel(list[i]);
                }
            }
        }
        this.panels = {};
    }
});
cc.guimanager = new M();

cc._RF.pop();
},{}],"IMManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '547ddsUQMJPQYDrIA5KcdTB', 'IMManager');
// Scripts\Manager\IMManager.js

'use strict';

var M = cc.Class({

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    init: function init() {
        var me = cc.datamanager.mainPlayerData;
        cc.log('yunvasdk:' + yunvasdk.IMDispatchMsgNode);
        cc.log('this.im0:' + this.im);
        this.im = yunvasdk.IMDispatchMsgNode.getInstance();
        cc.log('this.im1:' + this.im);
        this.im.initSDK(cc.configmanager.yunyin_sdk_id);
        this.im.cpLogin(me.nick_name, me.cuid);
        this.im.setListener(this, this.onMessage);
    },

    onMessage: function onMessage(data) {
        var self = this;
        cc.info('收到语音消息:' + data);
        var rsp = JSON.parse(data);
        switch (rsp.name) {
            case "YVSDK_UPLOAD_COMPLETED":
                //上传成功
                {
                    if (self._onUpload) self._onUpload();
                }
                break;
            case "YVSDK_STOP_RECORD":
                {
                    if (self._onStopRecord) self._onStopRecord();
                }
                break;
        }
    },

    setCall: function setCall(onUpload, onStopRecord) {
        this._onUpload = onUpload;
        this._onStopRecord = onStopRecord;
    }
});

cc.immanager = new M();

cc._RF.pop();
},{}],"MainGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0975fZx1UJEDqmd0lBtMyYs', 'MainGame');
// Scripts\Gui\MainGame.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RF.pop();
},{}],"NetManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ba6d9dJZGBATpJFt+e5rKLY', 'NetManager');
// Scripts\Manager\NetManager.js

'use strict';

var M = cc.Class({
  ctor: function ctor() {
    require('long');
    require('bytebuffer');
    this.ProtoBuf = require('protobuf');
    this.handler = [];
    this.firstLogin = true;
  },

  init: function init() {

    this.messages = {};
    var self = this;
    this.loadProto('Proto/client', function (builder) {
      self.buildMessage(builder, 'PublicProto.C_Login');
      self.buildMessage(builder, 'PublicProto.S_LoginRet');
      self.buildMessage(builder, 'PublicProto.S_Notice');
      self.buildMessage(builder, 'PublicProto.C_SendChat');
      self.buildMessage(builder, 'PublicProto.S_Chat');
      self.buildMessage(builder, 'PublicProto.C_G13_JionGame');
      self.buildMessage(builder, 'PublicProto.C_G13_CreateGame');
      self.buildMessage(builder, 'PublicProto.S_G13_PlayersInRoom');
      self.buildMessage(builder, 'PublicProto.S_G13_RoomAttr');
      self.buildMessage(builder, 'PublicProto.C_G13_GiveUp');
      self.buildMessage(builder, 'PublicProto.S_G13_VoteFailed');
      self.buildMessage(builder, 'PublicProto.S_G13_AbortGameOrNot');
      self.buildMessage(builder, 'PublicProto.C_G13_VoteFoAbortGame');
      self.buildMessage(builder, 'PublicProto.S_G13_PlayerQuited');
      self.buildMessage(builder, 'PublicProto.C_G13_ReadyFlag');
      self.buildMessage(builder, 'PublicProto.S_G13_PlayersInRoom');
      self.buildMessage(builder, 'PublicProto.S_G13_HandOfMine');
      self.buildMessage(builder, 'PublicProto.C_G13_BringOut');
      self.buildMessage(builder, 'PublicProto.S_G13_AllHands');
    });
    this.loadProtoID();
  },

  loadProto: function loadProto(path, call) {
    var self = this;
    cc.loader.loadRes(path, function (err, proto) {
      var builder = self.ProtoBuf.protoFromString(proto);
      call(builder);
    });
  },

  buildMessage: function buildMessage(builder, name) {
    this.messages[name] = builder.build(name);
  },

  loadProtoID: function loadProtoID() {
    var self = this;
    cc.loader.loadRes('Proto/protoid', function (err, protoid) {
      self.id_name_map = JSON.parse(protoid);
    });
  },

  id_name_convert: function id_name_convert(id_or_name) {
    return this.proto_id_name_map[id_or_name];
  },

  connect: function connect(ip, port, func) {
    if (this.jbsocket == null) this.jbsocket = new JBSocket();

    this.jbsocket.onopen = function () {
      func(true);
    };

    var self = this;
    this.jbsocket.onerror = function (data) {
      if (data.errorid == JBSocket.ConnectError) func(false);else {
        // self.dispach('dispachMsg','onNetError',data.errorid);
        cc.log('error:');
        self.close();
      }
    };
    this.jbsocket.onmessage = function (data) {
      cc.log('data.msgid:' + data.msgid);
      self.dispachMsg(data.msgid, data.msg);
    };
    this.jbsocket.connect(ip, port);

    this.serverIP = ip;
    this.serverPort = port;
  },

  reconnect: function reconnect() {
    var self = this;
    cc.guimanager.wait('正在连接,请稍后...');
    this.connect(this.serverIP, this.serverPort, function (isConnect) {
      cc.guimanager.closeWait();
      if (!isConnect) {
        cc.guimanager.msgBox('连接失败,点击确定重试!', function () {
          cc.netmanager.reconnect();
        });
      } else {
        //连接成功 ,准备登陆
        self.login(self.loginType);
      }
    });
  },

  //登陆返回
  PublicProto_S_LoginRet: function PublicProto_S_LoginRet(msg) {
    if (msg.ret_code == 1 && !this.firstLogin) {
      cc.log('重连成功!');
    }
    this.firstLogin = false;
  },

  login: function login(type) {
    var msg = this.msg('PublicProto.C_Login');
    msg.login_type = type;
    msg.openid = cc.datamanager.getUserOpenId();
    cc.log("openid = " + msg.openid);
    msg.token = 'xxxxx';
    msg.nick_name = cc.datamanager.getNickName();
    cc.datamanager.mainPlayerData.nick_name = msg.nick_name;
    cc.datamanager.mainPlayerData.openid = msg.openid;
    cc.log("openid = " + msg.openid + ", nickname = " + msg.nick_name);
    this.send(msg);
    this.loginType = type;
  },

  onDisconnect: function onDisconnect() {
    //重连
    if (!this.firstLogin) {
      var self = this;
      cc.guimanager.msgBox('网络断开,点击确定尝试重连!', function () {
        cc.netmanager.reconnect();
      });
    }
  },

  //关闭网络
  close: function close() {
    if (this.jbsocket != null) {
      this.jbsocket.close();
      this.jbsocket = null;
      cc.log('onDisconnect');
      this.onDisconnect();
    }
  },

  //分发消息
  dispachMsg: function dispachMsg(msgid, msg) {
    var msgname = this.id_name_map[String(msgid)];
    var msgdata = this.messages[msgname].decode(msg);
    var msghandlername = msgname.replace('.', '_');

    cc.log('recv:' + msgname);
    if (typeof this[msghandlername] == 'function') {
      this[msghandlername](msgdata);
    }
    this.dispach("dispachMsg", msghandlername, msgdata);
  },

  dispach: function dispach(funcname, name, data) {
    for (var i = 0; i < this.handler.length; ++i) {
      this.handler[i][funcname](name, data);
    }
  },

  //申请一个 msg
  msg: function msg(msgname) {
    var message = this.messages[msgname];
    if (message) {
      var ret = new message();
      ret.__msgid = this.id_name_map[msgname];
      return ret;
    }
    return null;
  },

  //发送msg
  send: function send(msg) {
    if (this.jbsocket != null) {
      var id = msg.__msgid;
      this.jbsocket.send(id, new Uint8Array(msg.toBuffer()));
    }
  },

  registerHandler: function registerHandler(handler) {
    var self = this;
    if (handler != null && typeof handler.dispachMsg == 'function') {
      self.handler.push(handler);
    }
  }
});
cc.netmanager = new M();

cc._RF.pop();
},{"bytebuffer":"bytebuffer","long":"long","protobuf":"protobuf"}],"PokerFlop":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4aa02SHwA5J/YHD3/WAPCTa', 'PokerFlop');
// Scripts\Gui\PokerFlop.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        topNode: cc.Node,
        middleNode: cc.Node,
        bottomNode: cc.Node,

        _allPokerValues: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._allPokerValues = [52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40];
    },

    initPokerValues: function initPokerValues(values) {
        this._allPokerValues = values;
    },

    resetState: function resetState() {
        for (var i = 0; i < this.topNode.childrenCount; ++i) {
            var nd = this.topNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
        for (var i = 0; i < this.middleNode.childrenCount; ++i) {
            var nd = this.middleNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
        for (var i = 0; i < this.bottomNode.childrenCount; ++i) {
            var nd = this.bottomNode.children[i];
            cc.PokerUtil.replacePokerSprite("back", nd);
        }
    },

    //翻第一墩牌
    topFlopAction: function topFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.topNode.childrenCount; ++i) {
                var pokerVal = this._allPokerValues[i];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.topNode.children[i]);
            }
        }, this, param), cc.delayTime(0.3));
    },

    //翻第二墩牌
    middleFlopAction: function middleFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.middleNode.childrenCount; ++i) {
                var pokerVal = this._allPokerValues[i + 3];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.middleNode.children[i]);
            }
        }, this, param), cc.delayTime(0.3));
    },

    //翻第三墩牌
    bottomFlopAction: function bottomFlopAction(param) {
        return cc.sequence(cc.callFunc(function (target, param) {
            for (var i = 0; i < param.bottomNode.childrenCount; ++i) {
                var pokerVal = this._allPokerValues[i + 8];
                cc.PokerUtil.replacePokerSprite(pokerVal, param.bottomNode.children[i]);
            }
        }, this, param), cc.delayTime(0.3));
    }
});

cc._RF.pop();
},{}],"PokerList":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4b7307CmeVHsZbpKkNZL3la', 'PokerList');
// Scripts\Gui\PokerList.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    resetState: function resetState() {
        for (var i = 0; i < this.node.childrenCount; ++i) {
            var nd = this.node.children[i];
            nd.active = false;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PokerSelect":[function(require,module,exports){
"use strict";
cc._RF.push(module, '3b47a4kgtxMBrjGDVwvwKDi', 'PokerSelect');
// Scripts\Gui\PokerSelect.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isSelected: false,
        _pokerVal: 0,
        _pokerIndex: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.sys.os == cc.sys.OS_ANDROID || cc.sys.os == cc.sys.OS_IOS) {
            this.node.on(cc.Node.EventType.TOUCH_START, this._onSelect);
            //this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onSelect);
            //this.node.on(cc.Node.EventType.TOUCH_END, this._onSelect);
        } else {
            this.node.on(cc.Node.EventType.MOUSE_DOWN, this._onSelect);
        }
    },

    _onSelect: function _onSelect(event) {
        var component = event.currentTarget.getComponent("PokerSelect");
        if (!component._isSelected) {
            component.moveOut(event.currentTarget);
            cc.find("UIPokerGame/PokerSort").getComponent("PokerSort").selectCard(component._pokerVal);
        } else {
            component.moveBack(event.currentTarget);
            cc.find("UIPokerGame/PokerSort").getComponent("PokerSort").unselectCard(component._pokerVal);
        }
    },

    moveOut: function moveOut(node) {
        this._isSelected = true;
        node.runAction(cc.moveBy(0.06, cc.p(0, 20)));
    },

    moveBack: function moveBack(node) {
        this._isSelected = false;
        node.runAction(cc.moveBy(0.06, cc.p(0, -20)));
    },

    setPokerValue: function setPokerValue(val) {
        this._pokerVal = val;
        cc.PokerUtil.replacePokerSprite(val, this.node);
        /*
        var sprite = this.node.getComponent(cc.Sprite);
        var url = cc.PokerUtil.getPokerSpritePath(val);
        cc.log(url);
        cc.loader.loadRes(url, cc.SpriteFrame, function(err, spriteFrame){
            cc.log(url, spriteFrame, sprite)
            sprite.spriteFrame = spriteFrame;
        })
        */
    },

    setPokerIndex: function setPokerIndex(idx) {
        this._pokerIndex = idx;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PokerSort":[function(require,module,exports){
"use strict";
cc._RF.push(module, '60027OfYfZM9aft31kToOk+', 'PokerSort');
// Scripts\Gui\PokerSort.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        pokerSelectPrefab: cc.Prefab,
        sortTypeLabel: cc.Label,
        topBtnLabel: cc.Label,
        middleBtnLabel: cc.Label,
        bottomBtnLabel: cc.Label,
        cardList: cc.Node,
        confirmBtn: cc.Node,
        autoTypeContainer: cc.Node,

        _top: [],
        _middle: [],
        _bottom: [],
        _pokerList: null,
        _currentSortType: 2, //默认按大小排序

        _freePoker: null

    },

    // use this for initialization
    onLoad: function onLoad() {
        this.initPokers();
        this.initFreeSort();
    },

    initPokers: function initPokers() {
        this._pokerList = [];
        this._unselectPoker = cc.gamemanager.getCurMathPokers(); //未放入的13张牌
        this._selectedPoker = []; //选择准备放入的牌

        //var width = cc.configmanager.wndScale * 60
        var totalSize = (this._unselectPoker.length - 1) * 60 / 2;
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            var selectPoker = cc.instantiate(this.pokerSelectPrefab);
            var script = selectPoker.getComponent("PokerSelect");

            var pokerVal = this._unselectPoker[i];
            script.setPokerValue(pokerVal);
            //script.setPokerIndex(i);

            selectPoker.parent = this.cardList;
            selectPoker.position = cc.v2(-totalSize + i * 60, 0);
            this._pokerList.push(selectPoker);
        }
        //var scale = cc.configmanager.wndScale
        //this.cardList.setScale(scale, scale)
    },

    _resetPokers: function _resetPokers() {
        this._resetPokersState();

        var index = 0;
        cc.PokerUtil.sortPoker(this._currentSortType, this._unselectPoker);
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            var pokerVal = this._unselectPoker[i];
            if (pokerVal != 0) {
                var node = this._pokerList[index];
                index = index + 1;
                node.active = true;
                var script = node.getComponent("PokerSelect");
                script.setPokerValue(pokerVal);
            }
        }
        for (var i = index; i < this._pokerList.length; ++i) {
            this._pokerList[i].active = false;
        }
    },

    _resetPokersState: function _resetPokersState() {
        for (var i = 0; i < this._pokerList.length; ++i) {
            var node = this._pokerList[i];
            var script = node.getComponent("PokerSelect");
            if (script._isSelected == true) {
                script.moveBack(node);
            }
        }
    },

    _putdownPoker: function _putdownPoker(type) {
        var number = this._selectedPoker.length;
        if (type == 1 && number > 3 - this._top.length || type == 2 && number > 5 - this._middle.length || type == 3 && number > 5 - this._bottom.length) {
            cc.log("选择的牌数量太多!" + number);
            return;
        }

        for (var i = 0; i < number; ++i) {
            var pokerVal = this._selectedPoker[i];
            if (type == 1) {
                var path = "UIPokerGame/PokerSort/top/cards/card" + (this._top.length + 1);
                var node = cc.find(path);
                cc.PokerUtil.replacePokerSprite(pokerVal, node);
                this._top.push(pokerVal);
            } else if (type == 2) {
                var node = cc.find("UIPokerGame/PokerSort/middle/cards/card" + (this._middle.length + 1));
                cc.PokerUtil.replacePokerSprite(pokerVal, node);
                this._middle.push(pokerVal);
            } else if (type == 3) {
                var node = cc.find("UIPokerGame/PokerSort/bottom/cards/card" + (this._bottom.length + 1));
                cc.PokerUtil.replacePokerSprite(pokerVal, node);
                this._bottom.push(pokerVal);
            }
        }

        this.onPutdownCard();
        this._resetPokers();
    },

    _clearPokerHole: function _clearPokerHole(type) {
        var path = "";
        var number = 0;

        if (type == 1) {
            this.onFallbackCard(this._top);
            this._top = [];
            path = "UIPokerGame/PokerSort/top/cards/card";
            number = 3;
        } else if (type == 2) {
            this.onFallbackCard(this._middle);
            this._middle = [];
            path = "UIPokerGame/PokerSort/middle/cards/card";
            number = 5;
        } else {
            this.onFallbackCard(this._bottom);
            this._bottom = [];
            path = "UIPokerGame/PokerSort/bottom/cards/card";
            number = 5;
        }

        var url = "Textures/headBG";
        cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
            for (var i = 1; i <= number; ++i) {
                var node = cc.find(path + i);
                var sprite = node.getComponent(cc.Sprite);
                sprite.spriteFrame = spriteFrame;
            }
        });
        this._resetPokers();
    },

    _refreshState: function _refreshState() {
        var visible = this._top.length == 3 && this._middle.length == 5 && this._bottom.length == 5;
        this.confirmBtn.active = visible;
    },

    onClick_PutTop: function onClick_PutTop() {
        this.topBtnLabel.string = "放入";
        if (this._top.length < 3) {
            this._putdownPoker(1);
            if (this._top.length == 3) {
                this.topBtnLabel.string = "收回";
            }
        } else {
            this._clearPokerHole(1);
        }
        this._refreshState();
        this.initFreeSort();
    },

    onClick_PutMiddle: function onClick_PutMiddle() {
        this.middleBtnLabel.string = "放入";
        if (this._middle.length < 5) {
            this._putdownPoker(2);
            if (this._middle.length == 5) {
                this.middleBtnLabel.string = "收回";
            }
        } else {
            this._clearPokerHole(2);
        }
        this._refreshState();
        this.initFreeSort();
    },

    onClick_PutBottom: function onClick_PutBottom() {
        this.bottomBtnLabel.string = "放入";
        if (this._bottom.length < 5) {
            this._putdownPoker(3);
            if (this._bottom.length == 5) {
                this.bottomBtnLabel.string = "收回";
            }
        } else {
            this._clearPokerHole(3);
        }
        this._refreshState();
        this.initFreeSort();
    },

    onClick_Sort: function onClick_Sort() {
        if (this._currentSortType == 1) {
            this._currentSortType = 2;
            this.sortTypeLabel.string = "大小排序";
        } else {
            this._currentSortType = 1;
            this.sortTypeLabel.string = "花色排序";
        }
        this.clearSelectPoker();
        this._resetPokers();
    },

    //发送选择好的牌
    onClick_Confirm: function onClick_Confirm() {
        var msg = cc.netmanager.msg("PublicProto.C_G13_BringOut");
        var cards = [];
        for (var i = 0; i < this._top.length; ++i) {
            cards.push(this._top[i]);
        }
        for (var i = 0; i < this._middle.length; ++i) {
            cards.push(this._middle[i]);
        }
        for (var i = 0; i < this._bottom.length; ++i) {
            cards.push(this._bottom[i]);
        }
        msg.cards = cards;
        cc.netmanager.send(msg);

        this.node.destroy();
    },

    //初始化自由摆牌
    initFreeSort: function initFreeSort() {
        this._freePoker = [];
        var cArr = cc.PokerUtil.getGroupCards(this.getLeftCard());

        var szArr = [];
        if (cArr[4].length > 0) {
            szArr = [cArr[4][0].slice(0, 5)];
        }
        cc.log("shunzi", szArr.length);

        var cards = [cArr[6], szArr, cArr[3], cArr[2], cArr[1].reverse()];
        var names = ["五同", "顺子", "铁支", "三条", "对子"];
        var idx = 0;
        for (var i = 0; i < cards.length; ++i) {
            if (cards[i].length > 0) {
                var data = {};
                data.name = names[i];
                data.value = cards[i];
                this._freePoker.push(data);
                cc.log(this.autoTypeContainer.children[idx].name, this.autoTypeContainer.children[idx].children[0].name);
                this.autoTypeContainer.children[idx].active = true;
                this.autoTypeContainer.children[idx].children[0].getComponent(cc.Label).string = names[i];
                idx++;
            }
        }
        for (var i = idx; i < this.autoTypeContainer.childrenCount; ++i) {
            this.autoTypeContainer.children[i].children[0].getComponent(cc.Label).string = "";
            this.autoTypeContainer.children[i].active = false;
        }
    },

    //自由选牌按钮点击
    onClick_FreeSelectBtn: function onClick_FreeSelectBtn(event, index) {
        this.clearSelectPoker();
        this._resetPokersState();

        if (this._freePoker.length > index) {
            var freePk = this._freePoker[index].value[0];
            cc.log(freePk.length);
            for (var i = 0; i < freePk.length; ++i) {
                var pv = freePk[i];
                cc.log("pv.type", pv.type, "pv.value", pv.value);
                for (var j = 0; j < this._pokerList.length; ++j) {
                    var node = this._pokerList[j];
                    var script = node.getComponent("PokerSelect");
                    if (script._pokerVal == pv.type * 13 + pv.value) {
                        script.moveOut(node);
                        this.selectCard(script._pokerVal);
                        break;
                    }
                }
            }
        }
    },

    selectCard: function selectCard(val) {
        cc.log("select: " + val);
        this._selectedPoker.push(val);
    },

    unselectCard: function unselectCard(val) {
        for (var i = 0; i < this._selectedPoker.length; ++i) {
            if (this._selectedPoker[i] == val) {
                this._selectedPoker.splice(i, 1);
            }
        }
        cc.log("unselect: " + val + ", already unselect num: " + this._selectedPoker.length);
    },

    onPutdownCard: function onPutdownCard() {
        for (var i in this._unselectPoker) {
            var index = this._selectedPoker.indexOf(this._unselectPoker[i]);
            if (index != -1) {
                this._selectedPoker.splice(index, 1);
                this._unselectPoker[i] = 0;
            }
        }
        this._selectedPoker = [];
    },

    onFallbackCard: function onFallbackCard(cards) {
        for (var i = 0; i < cards.length; ++i) {
            for (var j = 0; j < this._unselectPoker.length; ++j) {
                if (this._unselectPoker[j] == 0) {
                    this._unselectPoker[j] = cards[i];
                    break;
                }
            }
        }
        this._selectedPoker = [];
    },

    getLeftCard: function getLeftCard() {
        var ret = [];
        for (var i = 0; i < this._unselectPoker.length; ++i) {
            if (this._unselectPoker[i] != 0) {
                ret.push(this._unselectPoker[i]);
            }
        }
        cc.log("getLeftCard size = ", ret.length);
        return ret;
    },

    clearSelectPoker: function clearSelectPoker() {
        this._selectedPoker = [];
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"PokerUtils":[function(require,module,exports){
"use strict";
cc._RF.push(module, '101ac+LJ2hPvIGflq7FJ34a', 'PokerUtils');
// Scripts\Manager\PokerUtils.js

"use strict";

var M = cc.Class({
	ctor: function ctor() {},

	/*
 扑克牌描述
     花色：  黑桃 3  、红桃 2 、 梅花 1 、方块 0
     牌点数： 2 ~ A == 1 ~ 13
     牌数值 = (花色 * 13 + 点数 - 1 )
 */

	_getPokerSpritePath: function _getPokerSpritePath(pokerVal) {
		return "Textures/Poker/" + pokerVal.toString();
	},

	//设置扑克牌图片
	replacePokerSprite: function replacePokerSprite(pokerVal, node) {
		var sprite = node.getComponent(cc.Sprite);
		var url = this._getPokerSpritePath(pokerVal);
		cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
			sprite.spriteFrame = spriteFrame;
		});
	},

	//返回牌花色和点数
	_getCardType: function _getCardType(x) {
		var ret = {};
		ret.x = (x - 1) / 13;
		ret.y = (x - 1) % 13;
		return ret;
	},

	//单张扑克解码
	singleCardsDecode: function singleCardsDecode(c) {
		var ret = {};
		ret.type = Math.floor((c - 1) / 13);
		ret.value = c - ret.type * 13;
		return ret;
	},

	//单张扑克编码
	singleCardsEncode: function singleCardsEncode(o) {
		return o.type * 13 + o.value;
	},

	//扑克解码
	cardsDecode: function cardsDecode(cArr) {
		var arr = [];
		for (var i = 0; i < cArr.length; ++i) {
			var c = {};
			c.type = Math.floor((cArr[i] - 1) / 13);
			c.value = cArr[i] - c.type * 13;
			arr.push(c);
		}
		return arr;
	},

	//扑克编码
	cardsEncode: function cardsEncode(cArr) {
		var arr = [];
		for (var i = 0; i < cArr.length; ++i) {
			var c = cArr[i];
			arr.push(c.type * 13 + c.value);
		}
		return arr;
	},

	_copyArray: function _copyArray(arr) {
		var ret = [];
		for (var i = 0; i < arr.length; ++i) {
			ret.push(arr[i]);
		}return ret;
	},

	//删除扑克: a, b中删除同样的元素
	_delCards: function _delCards(a, b) {},

	//获取普通组合牌型 cArr: 传入未解码的牌数值数组
	getGroupCards: function getGroupCards(cArr) {
		var tmpArr = this._copyArray(cArr);
		this.sortPoker(1, tmpArr);
		var decodeArr = this.cardsDecode(tmpArr);

		var wlArr = [],
		    dzArr = [],
		    stArr = [],
		    tzArr = [],
		    wtArr = [],
		    sArr = [],
		    szArr = [];
		var sz_n = 0;
		var num = decodeArr.length;

		var same = [];
		var notsame = [];

		var alldz = [];

		for (var i = num - 1; i >= 0;) {
			var last = decodeArr[i];

			--i;
			var find = false;
			while (i >= 0 && last.value == decodeArr[i].value) {
				find = true;
				same.push(last);
				last = decodeArr[i];
				--i;
			}
			if (find) {
				same.push(last);

				if (same.length > 1) {
					if (same.length == 2) dzArr.push([same[1], same[0]]);
					if (same.length == 3) stArr.push([same[2], same[1], same[0]]);
					if (same.length == 4) tzArr.push([same[3], same[2], same[1], same[0]]);
					if (same.length == 5) wtArr.push([same[4], same[3], same[2], same[1], same[0]]);
				}

				for (var idx = 0; idx < same.length; ++idx) {
					alldz.push(same[idx]);
				}

				same = [];
			}
			notsame.push(last);
		}

		if (notsame.length > 0) {
			for (var i = notsame.length - 1; i >= 0;) {
				var last = notsame[i];

				--i;
				var tmp = [];
				while (i >= 0 && last.value == notsame[i].value + 1) {
					tmp.push(last);
					last = notsame[i];
					--i;
				}
				tmp.push(last);
				if (tmp.length >= 5) {
					szArr.push(tmp);
				} else {
					for (var j = 0; j < tmp.length; ++j) {
						var ele = tmp[j];
						var fnd = false;
						for (var m = 0; m < alldz.length; ++m) {
							if (alldz[m].type == ele.type && alldz[m].value == ele.value) {
								fnd = true;
								break;
							}
						}
						if (fnd == false) {
							wlArr.push(tmp[j]);
						}
					}
				}
			}
		}

		//dzArr.reverse()
		//stArr.reverse()
		//tzArr.reverse()
		//wtArr.reverse()
		wlArr.reverse();

		var ret = [];
		ret.push(wlArr, dzArr, stArr, tzArr, szArr, decodeArr, wtArr);
		return ret;
	},

	//乌龙（三张）
	wulongThree: function wulongThree(cards) {
		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    cardsArr = [];
		for (var i = wlArr.length - 1; i >= 2; --i) {
			cardsArr.push([wlArr[i], wlArr[i - 1], wlArr[i - 2]]);
		}
		return cardsArr;
	},

	//一对（三张）
	yiduiThree: function yiduiThree(cards) {
		var cardsArr = [];
		if (cards.length < 3) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 0 && wlArr.length > 0) {
			for (var i = dzArr.length - 1; i >= 0; --i) {
				cardsArr.push([dzArr[i][0], dzArr[i][1], wlArr[0]]);
			}
		}
		return cardsArr;
	},

	//三条(三张)
	santiao: function santiao(cards) {
		var cardsArr = [];
		if (cards.length < 3) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var stArr = cArr[2];
		for (var i = stArr.length - 1; i >= 0; --i) {
			cardsArr.push(stArr[i]);
		}
		return cardsArr;
	},

	//乌龙(五张)
	wulongFive: function wulongFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0];
		if (wlArr.length > 4) {
			for (var i = wlArr.length - 1; i >= 4; --i) {
				var arr = [wlArr[i], wlArr[3], wlArr[2], wlArr[1], wlArr[0]];
				var cflag = false;
				for (var j = 1; j < arr.length; ++j) {
					if (arr[j].type != arr[j - 1].type) {
						//看乌龙花色是否一样,排除清一色
						cflag = true;
						break;
					}
				}
				if (cflag) {
					//不是同花色
					cflag = false;
					for (var j = 1; j < arr.length; ++j) {
						if (arr[j].value != arr[j - 1].value + 1) {
							cflag = true; //看是否是顺子
							break;
						}
					}
					//A2345
					if (cflag && arr[0].value == 13 && arr[1].value == 4 && arr[2].value == 3 && arr[3].value == 2 && arr[4].value == 1) cflag = false;

					if (cflag) {
						cardsArr.push(arr);
					}
				}
			}
		}
		return cardsArr;
	},

	//一对（五张）
	yiduiFive: function yiduiFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 0) {
			if (wlArr.length > 2) {
				for (var i = dzArr.length - 1; i >= 0; --i) {
					cardsArr.push([dzArr[i][0], dzArr[i][1], wlArr[2], wlArr[1], wlArr[0]]);
				}
			} else if (dzArr.length > 3) {
				//乌龙不够，拆对子
				for (var i = dzArr.length - 1; i >= 3; --i) {
					cardsArr.push([dzArr[i][1], dzArr[i][0], dzArr[2][1], dzArr[1][1], dzArr[0][1]]);
				}
			}
		}
		return cardsArr;
	},

	//两对（五张)
	liangdui: function liangdui(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1];
		if (dzArr.length > 1 && wlArr.length > 0 || dzArr.length > 2) {
			var i = dzArr.length;
			var condition = 1;
			if (wlArr.length == 0) {
				condition = 2; //没有乌龙要拆一对
			}
			for (var j = dzArr.length - 1; j >= condition; --j) {
				if (wlArr.length == 0) {
					cardsArr.push([dzArr[j][0], dzArr[j][1], dzArr[0][0], dzArr[0][1], dzArr[1][0]]);
				} else {
					cardsArr.push([dzArr[j][0], dzArr[j][1], dzArr[0][0], dzArr[0][1], wlArr[0]]);
				}
			}
		}
		return cardsArr;
	},

	//三条（五张）：三条+两单张
	santiaoFive: function santiaoFive(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1],
		    stArr = cArr[2];
		if (stArr.length > 0) {
			if (wlArr.length > 1) {
				for (var i = stArr.length - 1; i >= 0; --i) {
					//三条+乌龙
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], wlArr[1], wlArr[0]]);
				}
			} else if (dzArr.length > 1) {
				//三条+拆对子(三条+对子=葫芦  不属于三条)
				for (var i = stArr.length - 1; i >= 0; --i) {
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], dzArr[1][0], dzArr[0][0]]);
				}
			} else if (stArr.length > 2) {
				//只有三条，要拆两个三条当俩单张
				for (var i = stArr.length - 1; i >= 2; --i) {
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], stArr[1][0], stArr[0][0]]);
				}
			}
		}
		return cardsArr;
	},

	//顺子（五张）: 花色不同的顺子
	shunzi: function shunzi(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1],
		    szArr = cArr[4],
		    decodeArr = cArr[5];
		var szCards = [],
		    vCards = [];

		for (var i = decodeArr.length - 1; i >= 0; --i) {
			var o = decodeArr[i];
			if (i > 0 && o.value == decodeArr[i - 1].value || szCards.length > 0 && szCards[szCards.length - 1].value == decodeArr[i].value) {} else {
				szCards.push(o);
				vCards[o.value] = i;
			}
		}
		//A2345
		if (szArr.length > 0) {
			var i = szArr.length - 1;
			while (i >= 0) {
				var l = szArr[i].length - 1;
				while (l > 3) {
					var sArr = [szArr[i][l], szArr[i][l - 1], szArr[i][l - 2], szArr[i][l - 3], szArr[i][l - 4]];
					var cflag = false;
					for (var n = 1; n < sArr.length; ++n) {
						if (sArr[n].type != sArr[n - 1].type) {
							cflag = true;
							break;
						}
					}
					if (cflag) {
						sArr.reverse();
						cardsArr.push(sArr);
					}
					l--;
				}
				i--;
			}
		}
		cardsArr.reverse();
		return cardsArr;
	},

	//葫芦：三张相同+一对
	hulu: function hulu(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = this.getGroupCards(cards);
		var dzArr = cArr[1],
		    stArr = cArr[2];
		if (stArr.length > 0) {
			if (dzArr.length > 0) {
				for (var i = stArr.length - 1; i >= 0; --i) {
					cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], dzArr[0][0], dzArr[0][1]]);
				}
			} else {
				//没有对子  拆对子
				for (var i = stArr.length - 1; i >= 0; --i) {
					for (var l = 0; l < stArr.length; ++l) {
						if (l >= i) break;

						cardsArr.push([stArr[i][0], stArr[i][1], stArr[i][2], stArr[l][0], stArr[l][1]]);
					}
				}
			}
		}
		return cardsArr;
	},

	//铁支：四带一
	tiezhi: function tiezhi(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var wlArr = cArr[0],
		    dzArr = cArr[1],
		    stArr = cArr[2],
		    tzArr = cArr[3];
		if (tzArr.length > 0) {
			if (wlArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], wlArr[0]]);
				}
			} else if (dzArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], dzArr[0][0]]);
				}
			} else if (stArr.length > 0) {
				for (var i = tzArr.length - 1; i >= 0; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], stArr[0][0]]);
				}
			} else if (tzArr.length > 1) {
				for (var i = tzArr.length - 1; i >= 1; --i) {
					cardsArr.push([tzArr[i][0], tzArr[i][1], tzArr[i][2], tzArr[i][3], tzArr[0][0]]);
				}
			}
		}
		return cardsArr;
	},

	//五同
	wutong: function wutong(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;

		var cArr = this.getGroupCards(cards);
		var wtArr = cArr[6];
		if (wtArr.length > 0) {
			for (var i = wtArr.length - 1; i >= 0; --i) {
				cardsArr.push(wtArr[i]);
			}
		}
		return cardsArr;
	},

	//获取花色
	getSuit: function getSuit(cards) {
		var arr = [[], [], [], []];
		for (var i = 0; i < cards.length; ++i) {
			var suit = cards[i].type;
			arr[suit].push(cards[i]);
		}
		return arr;
	},

	//删除相同点数
	delSamePoint: function delSamePoint(cArr) {
		var arr = [],
		    cardsArr = [];
		for (var i = 0; i < cArr.length; ++i) {
			if (arr[cArr[i].value] == null) {
				arr[cArr[i].value] = true;
				cardsArr.push(cArr[i]);
			}
		}
		return cardsArr;
	},

	//同花顺
	tonghuashun: function tonghuashun(cards) {
		var cardsArr = [];
		if (cards.length < 5) return cardsArr;
		var cArr = this.getGroupCards(cards);
		var suitArr = this.getSuit(cArr[5]);

		for (var i = 3; i >= 0; --i) {
			var sArr = this.delSamePoint(suitArr[i]);
			if (sArr.length > 4) {
				//this.sortPoker(1, sArr)

				if (sArr[0].value == 13 && sArr[1].value == 12 && sArr[2].value == 11 && sArr[3].value == 10 && sArr[4].value == 9) {
					//A K Q J 10
					cardsArr.push([sArr[0], sArr[1], sArr[2], sArr[3], sArr[4]]);
				}
				var len = sArr.length;
				if (sArr[0].value == 13 && sArr[len - 4].value == 4 && sArr[len - 3].value == 3 && sArr[len - 2].value == 2 && sArr[len - 1].value == 1) {
					//A 2 3 4 5
					cardsArr.push([sArr[0], sArr[len - 1], sArr[len - 2], sArr[len - 3], sArr[len - 4]]);
				}
				for (var j = 0; j < sArr.length - 4; ++j) {
					if (sArr[j].value == sArr[j + 1].value + 1 && sArr[j + 1].value == sArr[j + 2].value + 1 && sArr[j + 2].value == sArr[j + 3].value + 1 && sArr[j + 3].value == sArr[j + 4].value + 1) {
						cardsArr.push([sArr[j], sArr[j + 1], sArr[j + 2], sArr[j + 3], sArr[j + 4]]);
					}
				}
			}
		}
		return cardsArr;
	},

	//给牌排序 sorttype: 1 大小排序 2 花色排序
	sortPoker: function sortPoker(sorttype, cardlist) {
		if (sorttype == 2) {
			cardlist.sort(function (x, y) {
				//数字越大在前
				if (x < y) return 1;
				if (x > y) return -1;
				return 0;
			});
		} else if (sorttype == 1) {
			cardlist.sort(function (x, y) {
				var xcard = [(x - 1) / 13, (x - 1) % 13];
				var ycard = [(y - 1) / 13, (y - 1) % 13];

				if (xcard[1] < ycard[1]) return 1;
				if (xcard[1] > ycard[1]) return -1;

				if (xcard[0] < ycard[0]) return 1;
				if (xcard[0] > ycard[0]) return -1;
				return 0;
			});
		}
	},

	//比较指定牌型i下：第二墩 和 第一墩 是否相公 : 是相公了 返回true
	//i: 第二墩牌型数字(0-10), a: 第二墩牌
	//b: 第一墩牌 
	//j: 表示第二墩牌的牌型(有可能第二墩有多种牌型，一般默认第一个牌型最大，所以j一般选0)

	isMessireThree: function isMessireThree(i, a, b, j) {

		//三条Five 和 三条three 比较
		if (i == 6) {
			if (a[j][2].value < b[2].value) {
				return true;
			}
		}

		//一对Five 和 一对three 比较
		if (i == 8) {
			if (a[j][0].value == b[0].value) {
				if (a[j][2].value < b[2].value) {
					return true;
				}
			}
		}

		//乌龙Five 和 乌龙three  比较
		if (i == 9) {
			if (a[j][0].value == b[0].value) {
				if (a[j][1].value == b[1].value) {
					if (a[j][2].value < b[2].value) {
						return true;
					}
				} else if (a[j][1].value < b[1].value) {
					return true;
				}
			} else if (a[j][0].value < b[0].value) {
				return true;
			}
		}
		return false;
	},

	//牌型一样情况下
	//比较指定牌型i下：第三墩 和 第二墩 是否相公  是相公返回true
	//i: 第三墩牌型(0-10)， 比较当前i牌型下a,b是否相公
	//a: 第三墩牌
	//b: 第二墩牌
	isMessireFive: function isMessireFive(i, a, b) {
		var v = [],
		    s = [];
		for (var i = 0; n < 5; ++i) {
			v.push(a[i].value);
			s.push(b[i].value);
		}
		v.sort(function (x, y) {
			return x < y;
		});
		s.sort(function (x, y) {
			return x < y;
		});

		if (i == 0 || i == 2) //五同或者四带一(铁支)
			{
				return v[2] < s[2];
			} else if (i == 3) //葫芦(三带二)
			{
				if (v[2] == s[2]) {
					if (v[0] == v[2] && s[0] == s[2]) {
						//三个都在前
						return v[3] < s[3];
					}
					if (v[0] == v[2] && s[2] == s[4]) {
						//三个在前段， 三个在后端
						return v[3] < s[0];
					}
					if (v[2] == v[4] && s[0] == s[2]) {
						return v[0] < s[3];
					}
					if (v[2] == v[4] && s[2] == s[4]) {
						return v[0] < s[0];
					}
				}
				return v[2] < s[2];
			} else if (i == 1 || i == 4 || i == 5 || i == 9) //同花顺、同花、顺子、乌龙
			{
				for (var j = 0; j < 5; ++j) {
					if (v[j] == s[j]) {
						continue;
					}
					return v[j] < s[j];
				}
			} else if (i == 6 || i == 7 || i == 8) //三条、两对、一对
			{}
	}

});

cc.PokerUtil = new M();

//第二墩、第三墩比较规则(5张牌)
cc.PokerUtil.t5Group = [];

cc.PokerUtil.t5Group[0] = cc.PokerUtil.wutong;
cc.PokerUtil.t5Group[1] = cc.PokerUtil.tonghuashun;
cc.PokerUtil.t5Group[2] = cc.PokerUtil.tiezhi;
cc.PokerUtil.t5Group[3] = cc.PokerUtil.hulu;
cc.PokerUtil.t5Group[4] = cc.PokerUtil.tonghua;
cc.PokerUtil.t5Group[5] = cc.PokerUtil.shunzi;
cc.PokerUtil.t5Group[6] = cc.PokerUtil.santiaoFive;
cc.PokerUtil.t5Group[7] = cc.PokerUtil.liangdui;
cc.PokerUtil.t5Group[8] = cc.PokerUtil.yiduiFive;
cc.PokerUtil.t5Group[9] = cc.PokerUtil.wulongFive;

//第一墩比较规则(3张牌)
cc.PokerUtil.t3Group = [];
cc.PokerUtil.t3Group[0] = cc.PokerUtil.santiao;
cc.PokerUtil.t3Group[1] = cc.PokerUtil.yiduiThree;
cc.PokerUtil.t3Group[2] = cc.PokerUtil.wulongThree;

cc._RF.pop();
},{}],"SceneManager":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5c8f0oxxLpE/6xiGrgxAiIh', 'SceneManager');
// Scripts\Manager\SceneManager.js

'use strict';

var M = cc.Class({
    loadScene: function loadScene(name, call) {
        cc.guimanager.closeAll();
        cc.director.loadScene(name, call);
    },
    loadMainScene: function loadMainScene() {
        this.loadScene('Main', function () {
            if (cc.scenemanager.room_info) {
                cc.gamemanager.gameStart();
            } else {
                cc.guimanager.open('UIMain');
            }
        });
    },

    loadLoginScene: function loadLoginScene() {
        cc.log('loadlogin');
        this.loadScene('Login', function () {
            cc.guimanager.open('UILogin');
        });
    },

    loadPokerGameScene: function loadPokerGameScene() {
        cc.log("LoadPokerGameScene");
        this.loadScene("PokerGame", function () {
            cc.guimanager.open("UIPokerGame");
        });
    }
});

cc.scenemanager = new M();

cc._RF.pop();
},{}],"ShopItem":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'c53e83gER1EiKyRDpugV92f', 'ShopItem');
// Scripts\Gui\Widget\ShopItem.js

'use strict';

cc.Class({
    extends: cc.Component,

    properties: {
        discount: cc.Node,
        discountText: cc.Label,
        img: cc.Sprite,
        moneyText: cc.Label,
        diamondText: cc.Label
    },

    //diamon discount price id image
    setData: function setData(data) {
        this.itemData = data;
        this.diamondText.string = String(data.diamond);
        if (data.discount > 0) {
            this.discount.active = true;
            this.discountText.string = '内赠{0}%'.format(data.discount);
        } else {
            data.discount.active = false;
        }
        this.moneyText.string = String(data.price);
        cc.loader.loadRes('Textures/' + data.image, cc.SpriteFrame, function (err, spriteFrame) {
            this.img.spriteFrame = spriteFrame;
        });
    },

    buy: function buy() {
        /// this.itemData.id
        //TODO:购买
    }
});

cc._RF.pop();
},{}],"UIChat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5b754Of9BtJELRQHB13mt6Z', 'UIChat');
// Scripts\Gui\UIChat.js

'use strict';

require('UIPanel');

cc.Class({
    extends: cc.uipanel,

    properties: {
        chatPage: cc.Node,
        facePage: cc.Node,
        chatBack: cc.Node,
        editBox: cc.EditBox,
        chatContent: cc.Node
    },

    onTouchBg: function onTouchBg() {
        this.setVisible(false);
    },

    onCreate: function onCreate() {
        var self = this;
        this.chatBack.on(cc.Node.EventType.TOUCH_START, function (event) {
            event.stopPropagationImmediate();
        });
        var self = this;
        cc.loader.loadRes('Gui/Widget/ChatSplit', function (err, splitPrefab) {
            self.splitPrefab = splitPrefab;
            cc.loader.loadRes('Gui/Widget/ChatItem', function (err, chatItemPrefab) {
                self.chatItemPrefab = chatItemPrefab;
            });
        });
        this._super();
    },

    onClose: function onClose() {
        if (this.splitPrefab) cc.loader.releaseAsset(this.splitPrefab);
        if (this.chatItemPrefab) cc.loader.releaseAsset(this.chatItemPrefab);
        this._super();
    },

    isReady: function isReady() {
        return this.splitPrefab && this.chatItemPrefab;
    },

    onChackChatpage: function onChackChatpage() {
        this.chatPage.active = true;
        this.facePage.active = false;
    },
    onCheckFacepage: function onCheckFacepage() {
        this.chatPage.active = false;
        this.facePage.active = true;
    },

    popBullet: function popBullet(msg) {
        var panel = cc.guimanager.getByName('UIPokerGame');
        if (panel) {
            cc.log('test');
            panel.showChat(cc.datamanager.mainPlayerData.cuid, msg);
        }
        this.setVisible(false);
    },
    sendChat: function sendChat() {
        var str = this.editBox.string;
        if (str.length > 0) {
            var msg = cc.netmanager.msg("PublicProto.C_SendChat");
            msg.type = 0;
            msg.data_text = str;
            cc.netmanager.send(msg);

            this.addChat(cc.gamemanager.mainPlayer(), str);
            this.editBox.string = "";
            this.popBullet(msg);
        }
    },

    addChat: function addChat(player, text) {
        if (player && this.isReady()) {
            //添加到聊天列表
            var split = cc.instantiate(this.splitPrefab);
            var item = cc.instantiate(this.chatItemPrefab);
            var str = '<color=#00ff00>'.concat(player.name, ':</c><color=#ffefbe>', text, '</c>');
            item.getComponent(cc.RichText).string = str;
            item.parent = this.chatContent;
            item.position = cc.p(11, 12);

            split.parent = this.chatContent;
            split.position = cc.p(219, 1);
        }
    },

    PublicProto_S_Chat: function PublicProto_S_Chat(msg) {
        if (msg.content.type == 0) {
            var player = cc.gamemanager.getPlayer(msg.cuid);
            if (player) {
                this.addChat(player, msg.content.data_text);
            }
        }
    },

    sendFace: function sendFace(event, id) {
        var msg = cc.netmanager.msg("PublicProto.C_SendChat");
        msg.type = 1;
        msg.data_int = parseInt(id);
        cc.netmanager.send(msg);

        this.popBullet(msg);
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UICreateRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bade1k88XdGG7qbS0HsDD/U', 'UICreateRoom');
// Scripts\Gui\UICreateRoom.js

"use strict";

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        createBtn: cc.Button,
        quanleidaToggle: cc.Toggle
    },

    onCreate: function onCreate() {
        this.init();
        this._super();
    },

    init: function init() {
        var setting = cc.datamanager.getRoomSetting();
        if (!setting) {
            //默认设置
            setting = {
                isQuanLeiDa: false,
                checks: [["0", "0", "56"], ["1", "0", "8"], ["2", "0", "10"], ["2", "0", "1"], ["3", "0", "1"], ["4", "0", "5"]]
            };
        }
        this.roomSetting = setting;
        var groups = this.node.getComponentsInChildren(cc.ToggleGroup);
        for (var i = 0; i < groups.length; ++i) {
            var items = groups[i].toggleItems;
            var index = parseInt(setting.checks[i][1]);
            for (var j = 0; j < items.length; ++j) {
                items[j].isChecked = j == index;
            }
        }
        this.quanleidaToggle.isChecked = setting.isQuanLeiDa;
    },

    onCheck: function onCheck(toggle, param) {
        var items = toggle.toggleGroup.toggleItems;
        for (var i = 0; i < items.length; ++i) {
            toggle = items[i];
            if (toggle.isChecked) {
                var strs = param.split(',');
                this.roomSetting.checks[parseInt(strs[0])] = strs;
            }
            var label = toggle.node.getChildByName('label').getComponent(cc.RichText);
            var str = label.string.replace(/\#[0-9A-Fa-f]*/, toggle.isChecked ? '#FFFFFF' : '#88A2C3');
            label.string = str;
        }
    },

    onCheckQuanLeiDa: function onCheckQuanLeiDa(toggle) {
        this.roomSetting.isQuanLeiDa = toggle.isChecked;
    },

    onCreateRoom: function onCreateRoom() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_CreateGame');
        msg.play_type = parseInt(this.roomSetting.checks[0][2]);
        msg.rounds = parseInt(this.roomSetting.checks[1][2]);
        msg.payor = parseInt(this.roomSetting.checks[2][2]);
        msg.da_qiang = parseInt(this.roomSetting.checks[3][2]);
        msg.yi_tiao_long = parseInt(this.roomSetting.checks[4][2]);
        msg.player_size = parseInt(this.roomSetting.checks[5][2]);
        msg.quan_lei_da = this.roomSetting.isQuanLeiDa;

        cc.log("msg.yi_tiao_long:" + msg.yi_tiao_long);
        cc.log("msg.quan_lei_da:" + msg.quan_lei_da);

        cc.netmanager.send(msg);
        cc.datamanager.saveRoomSetting(this.roomSetting);
        this.close();
    },

    PublicProto_S_G13_RoomAttr: function PublicProto_S_G13_RoomAttr(msg) {
        if (msg.room_code == 0) {
            //TODO:创建失败

        }
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIJoinRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, '973adVbE99DMqXsT6KyvjKG', 'UIJoinRoom');
// Scripts\Gui\UIJoinRoom.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        btnClose: cc.Button,
        btnComfire: cc.Button,
        spCursor: cc.Node,
        curIndex: 0
    },

    updateCursor: function updateCursor() {
        if (this.curIndex < 0) this.curIndex = 0;
        if (this.curIndex < 6) {
            var room = this.node.getChildByName('roomid');
            this.spCursor.parent = room.children[this.curIndex];
            this.spCursor.position = cc.p(0, 0);
        }

        this.btnClose.interactable = this.isfull();
    },

    getValue: function getValue(node) {
        return node.getChildByName('num').getComponent(cc.Label).string;
    },

    getRoomID: function getRoomID() {
        var room = this.node.getChildByName('roomid');
        var cs = room.children;
        var ids = [];
        for (var i = 0; i < room.childrenCount; ++i) {
            ids[i] = this.getValue(cs[i]);
        }
        return parseInt(ids.join(""));
    },

    setValue: function setValue(node, str) {
        node.getChildByName('num').getComponent(cc.Label).string = str;
    },

    setCurIndexValue: function setCurIndexValue(str) {
        if (!this.isfull()) {
            var room = this.node.getChildByName('roomid');
            this.setValue(room.children[this.curIndex], str);
        }
    },

    isfull: function isfull() {
        return this.curIndex == 6;
    },

    resetValue: function resetValue() {
        var room = this.node.getChildByName('roomid');
        var cs = room.children;
        for (var i = 0; i < this.curIndex; ++i) {
            this.setValue(cs[i], "");
        }
        this.curIndex = 0;
        this.updateCursor();
    },

    deleteValue: function deleteValue() {
        if (this.curIndex >= 0) {
            --this.curIndex;
            if (this.curIndex < 0) this.curIndex = 0;
            this.setCurIndexValue("");
            this.updateCursor();
        }
    },

    inputValue: function inputValue(num) {
        if (!this.isfull()) {
            this.setCurIndexValue(num);
            ++this.curIndex;
            this.updateCursor();
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var keyboard = this.node.getChildByName('keyboard');
        var cs = keyboard.children;
        for (var i = 0; i < keyboard.childrenCount; ++i) {
            var btn = cs[i].getComponent(cc.Button);
            var self = this;
            btn.node.on('click', function (event) {
                var node = event.target;
                if (node.name == "btn_reset") {
                    self.resetValue();
                } else if (node.name == "btn_delete") {
                    self.deleteValue();
                } else {
                    self.inputValue(node.getChildByName('num').getComponent(cc.Label).string);
                }
            });
        }
        this.btnClose.interactable = this.isfull();
    },

    onClick_btnClose: function onClick_btnClose() {
        this.close();
    },

    onclick_btnComfire: function onclick_btnComfire() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_JionGame');
        msg.room_id = this.getRoomID();
        cc.netmanager.send(msg);
        console.log('require join room:' + msg.room_id);
        this.close();
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UILogin":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fe480vPekNN7KUEzU8UAhgP', 'UILogin');
// Scripts\Gui\UILogin.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        btnWXLogin: cc.Button,
        btnGuestLogin: cc.Button
    },

    // use this for initialization
    onLoad: function onLoad() {},

    lockUI: function lockUI(bLock) {
        var interactable = !bLock;
        this.btnWXLogin.interactable = interactable;
        this.btnGuestLogin.interactable = interactable;

        //TO:转菊花 
    },

    login: function login(type) {
        this.lockUI(true);
        var self = this;
        cc.netmanager.connect(cc.configmanager.serverIP, cc.configmanager.serverPort, function (ok) {
            if (ok) {
                cc.log('connected!');
                cc.netmanager.login(type);
            } else {
                self.lockUI(false);
                cc.log('connect fail!');
            }
        });
    },

    //wechat login
    onClick_btnWXLogin: function onClick_btnWXLogin(event) {

        this.login(0);
    },

    //返回协议 
    PublicProto_S_LoginRet: function PublicProto_S_LoginRet(msg) {
        this.lockUI(false);
        if (msg.ret_code == 1) {
            cc.immanager.init();

            cc.datamanager.mainPlayerData.cuid = msg.cuid;
            cc.scenemanager.loadMainScene();
        } else {
            cc.log('login fail!');
        }
    },

    onMessageError: function onMessageError(errorid) {
        this.lockUI(false);
    },

    //guest login
    onClick_btnGuestLogin: function onClick_btnGuestLogin() {
        this.login(1);
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIMain":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bcb68jCR6NKyZZhF+bNoMrU', 'UIMain');
// Scripts\Gui\UIMain.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        funcNode: cc.Node,
        nameLabel: cc.Label
    },

    // use this for initialization
    onCreate: function onCreate() {
        cc.log("name = " + cc.datamanager.mainPlayerData.nick_name);
        this.nameLabel.string = cc.datamanager.mainPlayerData.nick_name;
        cc.audiomanager.playBGM('Hall_Bg');
        this._super();
        cc.gamemanager.gameStart();
    },

    update: function update() {
        this.funcNode.scaleY = this.funcNode.width / 840.0;
    },

    log: function log(str) {
        cc.log(str);
    },

    openLianxiRoom: function openLianxiRoom() {
        /*
        var action1 = cc.sequence(cc.delayTime(1), cc.callFunc(function(target,param){this.log("1秒后显示")}))
        var action2 = cc.sequence(cc.delayTime(2), cc.callFunc(function(target,param){this.log("2秒后显示")}))
        var action3 = cc.sequence(cc.delayTime(3), cc.callFunc(function(target,param){this.log("3秒后显示")}))
        */
        var act = cc.sequence(cc.delayTime(1), cc.callFunc(function (target, data) {
            cc.log(target.name, data.name);
        }, this.node, this.node.parent));
        this.node.runAction(act);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIMessageBox":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0b815ePDI1Gx46kTYrIvfWD', 'UIMessageBox');
// Scripts\Gui\UIMessageBox.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        msgText: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    setMessage: function setMessage(msg) {
        this.msgText.string = msg;
    },

    setCall: function setCall(call) {
        this.call = call;
    },

    onOkey: function onOkey() {
        if (this.call) {
            if (!this.call()) {
                this.close();
            }
        } else {
            this.close();
        }
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UINotice":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4ef4dTBL2VHV5Z7HFbNfVNc', 'UINotice');
// Scripts\Gui\UINotice.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        btnClose: cc.Button
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onBtnCloseClicked: function onBtnCloseClicked() {
        this.close();
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIPanel":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f6431fstrhNK5MN2iz1NYLe', 'UIPanel');
// Scripts\Gui\UIPanel.js

'use strict';

if (cc.uipanel == undefined) {
    cc.log('uipanel init');
    cc.uipanel = cc.Class({
        extends: cc.Component,
        properties: {
            bgOpaque: 200
        },
        ctor: function ctor() {
            this.isModel = true;
        },
        setVisible: function setVisible(bVisible) {
            this.node.active = bVisible;
            if (bVisible) {
                this.onShow();
            } else {
                this.onHide();
            }
        },

        onCreate: function onCreate() {
            if (this.isModel) {
                var self = this;
                cc.loader.loadRes('Gui/ModalBg', function (err, prefab) {
                    self.bg = cc.instantiate(prefab);
                    self.bg.parent = self.node;
                    self.bg.setSiblingIndex(0);
                    cc.log('self.bg.opacity:' + self.bg.opacity);
                    self.bg.opacity = self.bgOpaque;
                    cc.log('self.bg.opacity:' + self.bg.opacity);

                    self.bg.on(cc.Node.EventType.TOUCH_START, function (event) {
                        self.onTouchBg();
                        event.stopPropagationImmediate();
                    });
                });
            }
        },

        onTouchBg: function onTouchBg() {},

        onClose: function onClose() {
            if (this.bg) {
                this.bg.off(cc.Node.EventType.TOUCH_START);
            }
        },

        onShow: function onShow() {},

        onHide: function onHide() {},

        close: function close() {
            cc.log("close");
            cc.guimanager.close(this);
        },

        openUI: function openUI(event, name) {
            cc.guimanager.open(name);
        },
        showOrOpenUI: function showOrOpenUI(event, name) {
            cc.guimanager.showOrOpenUI(name);
        },
        select: function select(parentNode, index) {
            var count = parentNode.childrenCount;
            var cs = parentNode.children;
            for (var i = 0; i < count; ++i) {
                cs[i].active = i == index;
            }
        }
    });
}

cc._RF.pop();
},{}],"UIPokerGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '663f4GkXdFOZILOqkauFXod', 'UIPokerGame');
// Scripts\Gui\UIPokerGame.js

'use strict';

cc.Class({
    extends: cc.uipanel,

    properties: {
        originPoker: cc.Node,
        movePoker: cc.Node,
        prefabHeadIcon: cc.Prefab,
        prefabPokerSort: cc.Prefab,
        prefabPokerList: cc.Prefab,
        prefabPokerFlop: cc.Prefab,
        roomNum: cc.Label,
        myHeadIcon: cc.Node,
        startAnimation: cc.Node,
        recordBtn: cc.Node,
        recordPanel: cc.Node,

        _pokerList: null,
        _headIcons: null,
        _pokerFlops: null,
        _curShuffleIdx: 0,
        _playerHeads: null
    },

    // use this for initialization
    onCreate: function onCreate() {
        this._pokerList = [];

        var self = this;
        this.bubblePrefab = cc.loader.loadRes('Gui/Widget/ChatBubble', function (err, prefab) {
            self.bubblePrefab = prefab;
        });

        this.recordBtn.on(cc.Node.EventType.TOUCH_START, function (event) {
            self.onStartRecord();
        });
        this.recordBtn.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
            self.onCancelRecord();
        });
        this.recordBtn.on(cc.Node.EventType.TOUCH_END, function (event) {
            self.onStopRecord();
        });

        this.roomNum.string = cc.gamemanager.room_info.room_id;
        this.initRoom(cc.gamemanager.room_info.attr.player_size);
        this.onPlayerInRoom(cc.gamemanager._players);
        cc.audiomanager.playBGM('Game_Bg');
        this._super();
    },

    onClose: function onClose() {
        if (this.bubblePrefab) cc.loader.releaseAsset(this.bubblePrefab);
        cc.gamemanager.gameOver();
        this._super();
    },

    initRoom: function initRoom(playerNum) {
        if (playerNum == null) return;
        if (playerNum == 1) playerNum = 2;

        cc.log("init room, palyer number = " + playerNum);
        if (playerNum <= 1 || playerNum > 5) {
            return;
        }

        //玩家头像
        this._playerHeads = [];
        var pos = cc.configmanager.headIconPos[playerNum - 2];
        for (var i = 0; i < playerNum - 1; ++i) {
            var head = cc.instantiate(this.prefabHeadIcon);
            head.parent = this.node;
            head.position = pos[i];
            //head.active = false;
            this._playerHeads.push(head);
        }

        //发牌图片
        this._pokerList = [];
        var parentNode = cc.find("UIPokerGame/Pokers");
        this._pokerList.push(parentNode.children[0]);
        pos = cc.configmanager.headIconPos[playerNum - 2];
        for (var i = 0; i < playerNum - 1; ++i) {
            var pokerlist = cc.instantiate(this.prefabPokerList);
            pokerlist.parent = parentNode;
            pokerlist.position = pos[i];
            this._pokerList.push(pokerlist);
        }

        //比牌
        this._pokerFlops = []; //该数组包括自己
        var flopParent = cc.find("UIPokerGame/PokerFlops");
        this._pokerFlops.push(flopParent.children[0]); //自己的
        pos = cc.configmanager.headIconPos[playerNum - 2];
        for (var i = 0; i < playerNum - 1; ++i) {
            var pokerFlop = cc.instantiate(this.prefabPokerFlop);
            pokerFlop.parent = flopParent;
            pokerFlop.position = cc.v2(pos[i].x, pos[i].y + 200);
            this._pokerFlops.push(pokerFlop);
        }

        this.refreshNewMatchState();
    },

    //新的一局开始刷新数据
    refreshNewMatchState: function refreshNewMatchState() {
        for (var i = 0; i < this._pokerList.length; ++i) {
            var node = this._pokerList[i];
            node.getComponent("PokerList").resetState();
        }

        for (var i = 0; i < this._pokerFlops.length; ++i) {
            var node = this._pokerFlops[i];
            node.getComponent("PokerFlop").resetState();
        }
        cc.find("UIPokerGame/Pokers").active = false;
        cc.find("UIPokerGame/PokerFlops").active = false;
    },

    _refreshHeadInfo: function _refreshHeadInfo(node, data) {
        if (node == null) return;

        var icon = node.getChildByName("icon");
        var deficon = node.getChildByName("default");

        if (data == null || parseInt(data.cuid) == 0) {
            icon.active = false;
            deficon.active = true;
        } else {
            icon.active = true;
            deficon.active = false;

            node.cuid = data.cuid;

            var label = icon.getChildByName("name");
            if (label != null) {
                label.getComponent(cc.Label).string = data.name;
            }
            var coin = icon.getChildByName("coinnum");
            if (coin != null) {
                coin.getComponent(cc.Label).string = 0; //data.money.toString()
            }
            var prepare = icon.getChildByName("yizhunbei");
            if (prepare != null) {
                prepare.active = data.status == 2;
            }
            //玩家头像
            var icon = icon.getChildByName("headICON");
            if (icon != null) {}
        }
    },

    getHeader: function getHeader(cuid) {
        if (this.myHeadIcon.cuid && cuid.eq(this.myHeadIcon.cuid)) return this.myHeadIcon;
        for (var i = 0; i < this._playerHeads.length; ++i) {
            var header = this._playerHeads[i];
            if (header && header.cuid && cuid.eq(header.cuid)) {
                return header;
            }
        }
        return null;
    },

    getFlop: function getFlop(cuid) {
        for (var i = 0; i < this._pokerFlops.length; ++i) {
            var flop = this._pokerFlops[i];
            if (flop && flop.cuid && cuid.eq(flop.cuid)) {
                return flop;
            }
        }
        return null;
    },

    onPlayerInRoom: function onPlayerInRoom(playersdata) {

        //有时候会出现进入房间，initRoom还未调用
        if (this._playerHeads == null) {
            this.initRoom(cc.gamemanager.room_info.attr.player_size);
        }

        cc.log("onPlayerInRoom length = " + playersdata.length);
        if (playersdata.length == 0) {
            return;
        }

        var sortdata = [];
        var selfIdx = 0;
        var selfData = cc.datamanager.mainPlayerData;
        for (var i = 0; i < playersdata.length; ++i) {
            if (parseInt(playersdata[i].cuid) == parseInt(selfData.cuid)) {
                selfIdx = i;
                //cc.find("UIPokerGame/startBtn").active = (playersdata[i].status == 0);
                cc.log("我的状态： " + playersdata[i].status);
                var startBtn = cc.find("UIPokerGame/startBtn");
                startBtn.active = playersdata[i].status < 2;
                this._refreshHeadInfo(this.myHeadIcon, playersdata[i]);
                this._pokerFlops[0].cuid = playersdata[i].cuid;
                break;
            }
        }
        for (var i = selfIdx + 1; i < playersdata.length; ++i) {
            sortdata.push(playersdata[i]);
        }
        for (var i = 0; i < selfIdx; ++i) {
            sortdata.push(playersdata[i]);
        }

        var i = 0;
        for (; i < sortdata.length; ++i) {
            var node = this._playerHeads[i];
            this._refreshHeadInfo(node, sortdata[i]);
            this._pokerFlops[i + 1].cuid = sortdata[i].cuid;
        }

        for (; i < this._playerHeads.length; ++i) {
            var node = this._playerHeads[i];
            this._refreshHeadInfo(node, null);
            this._pokerFlops[i + 1].cuid = 0;
        }
    },

    showChat: function showChat(cuid, content) {
        cc.log(cuid);
        var header = this.getHeader(cuid);
        if (header) {
            cc.log("this.bubblePrefab:" + this.bubblePrefab);
            if (!header.bubble && this.bubblePrefab) {
                header.bubble = cc.instantiate(this.bubblePrefab);
                header.bubble.parent = cc.director.getScene();

                header.bubble.position = header.convertToWorldSpace(cc.p(0, 0));
            }
            if (header.bubble) {
                var buller = header.bubble.getComponent("ChatBubble");
                if (content.type == 0) {
                    buller.showText(content.data_text);
                } else if (content.type == 1) {
                    buller.showFace(content.data_int);
                }
                var scheduler = cc.director.getScheduler();
                scheduler.unscheduleAllForTarget(buller);
                scheduler.schedule(function () {
                    if (buller) {
                        buller.node.destroy();
                        header.bubble = null;
                    }
                }, buller, 0, 0, 3, false);
            }
        }
    },

    //聊天消息
    PublicProto_S_Chat: function PublicProto_S_Chat(msg) {
        this.showChat(msg.cuid, msg.content);
    },

    giveup: function giveup(event) {
        var msg = cc.netmanager.msg("PublicProto.C_G13_GiveUp");
        cc.netmanager.send(msg);
        event.target.getComponent(cc.Button).interactable = false;
    },

    clickSetBtn: function clickSetBtn() {},

    PublicProto_S_G13_PlayerQuited: function PublicProto_S_G13_PlayerQuited(msg) {
        cc.scenemanager.loadMainScene();
    },

    //开始新的一局
    newMatchStart: function newMatchStart() {

        this.refreshNewMatchState();

        var action = cc.sequence(cc.delayTime(3), cc.callFunc(function (target, param) {
            var self = target.getComponent("UIPokerGame");
            self.startAnimation.active = false;
            self.fapai();
        }, this));

        this.startAnimation.active = true;
        this.node.runAction(action);
    },

    clickStartBtn: function clickStartBtn() {
        //        this.newMatchStart()
        /*
                var actions = []
                for(var i = 0; i < this._pokerFlops.length; ++i)
                {
                    var node = this._pokerFlops[i]
                    var componet = node.getComponent("PokerFlop")
                    actions.push(componet.topFlopAction(componet))
                }
        
                for(var i = 0; i < this._pokerFlops.length; ++i)
                {
                    var node = this._pokerFlops[i]
                    var componet = node.getComponent("PokerFlop")
                    actions.push(componet.middleFlopAction(componet))
                }
        
                 for(var i = 0; i < this._pokerFlops.length; ++i)
                {
                    var node = this._pokerFlops[i]
                    var componet = node.getComponent("PokerFlop")
                    actions.push(componet.bottomFlopAction(componet))
                }
        
                this.node.runAction(cc.sequence(actions))
        */
        /*
        
                    //打开选牌界面
                    var pokerSort = cc.instantiate(this.prefabPokerSort);
                    pokerSort.parent = this.node;
                    pokerSort.position = cc.v2(0, 0); 
                    */

        //发送准备消息
        cc.find("UIPokerGame/startBtn").active = false;
        var msg = cc.netmanager.msg('PublicProto.C_G13_ReadyFlag');
        msg.ready = true;
        cc.netmanager.send(msg);
    },

    fapai: function fapai() {
        cc.find("UIPokerGame/Pokers").active = true;
        this.originPoker.active = true;
        this.movePoker.active = true;
        var aniName = "ac_cardmove" + cc.gamemanager.room_info.attr.player_size;
        cc.log("播放动画： ", aniName);
        this.movePoker.getComponent(cc.Animation).play(aniName);

        var cardlist = this._pokerList[0];
        var pokers = cc.gamemanager.getCurMathPokers();
        cc.log("cardlist.childrenCount = " + cardlist.childrenCount);
        for (var i = 0; i < cardlist.childrenCount; ++i) {
            var card = cardlist.children[i];
            var val = pokers[i];
            //cc.log("poker value  " + val)
            cc.PokerUtil.replacePokerSprite(val, card);
        }
    },

    //发牌event结束打开PokerSort选牌界面
    onAnimCompleted: function onAnimCompleted(index) {
        if (index < 1 || index > 5) {
            return;
        }
        //console.log([index, this._curShuffleIdx, this._pokerList[index-1].childrenCount ]);
        this._pokerList[index - 1].children[this._curShuffleIdx].active = true;

        if (index == cc.gamemanager.room_info.attr.player_size) {
            this._curShuffleIdx++;
            var aniName = "ac_cardmove" + cc.gamemanager.room_info.attr.player_size;
            this.movePoker.getComponent(cc.Animation).play(aniName);
        }
        if (this._curShuffleIdx >= 12) {
            this.movePoker.getComponent(cc.Animation).stop();
            this.movePoker.active = false;
            this.originPoker.active = false;

            //打开选牌界面
            var pokerSort = cc.instantiate(this.prefabPokerSort);
            //var pokerSort = cc.guimanager.open("PokerSort")
            pokerSort.parent = this.node;
            pokerSort.position = cc.v2(0, 0);

            this._pokerList[0].active = false;
            cc.find("UIPokerGame/Pokers").active = false;
            cc.find("UIPokerGame/PokerFlops").active = true;
        }
    },

    //收到结算牌消息，开始走比牌流程
    PublicProto_S_G13_AllHands: function PublicProto_S_G13_AllHands(msg) {
        if (msg.players.length != cc.gamemanager.room_info.attr.player_size) {
            cc.log("收到结算牌数据错误");
            return;
        }

        var action1 = [];
        var action2 = [];
        var action3 = [];

        for (var i = 0; i < msg.players.length; ++i) {
            var playerdata = msg.player[i];
            var node = this.getFlop(playerdata.cuid);
            if (node && node.getComponent("PokerFlop")) {
                var compoent = node.getComponent("PokerFlop");
                compoent.initPokerValues(playerdata.cards);
                action1.push(compoent.topFlopAction(compoent));
                action2.push(compoent.middleFlopAction(compoent));
                action3.push(compoent.bottomFlopAction(compoent));
            }
        }
        this.node.runAction(cc.sequence(action1));
    },

    stopRecord: function stopRecord() {
        cc.log('结束录音...');
        if (this.isStartRecord) {
            this.recordPanel.active = false;
            this.isStartRecord = false;
            cc.immanager.im.stopRecord();
        }
    },

    onStartRecord: function onStartRecord() {
        this.recordPanel.active = true;
        this.isStartRecord = true;

        cc.log('开始录音...');
        cc.immanager.im.startRecord();
        cc.immanager.setCall(function (data) {
            //长传成功

            var msg = cc.netmanager.msg("PublicProto.C_SendChat");
            msg.type = 2;
            cmd.data_text = data.url;
            cc.netmanager.send(msg);

            cc.netmanager.im.playFromUrl(data.url);
        }, function () {
            //停止录制
        });
    },

    onCancelRecord: function onCancelRecord() {
        this.stopRecord();
    },

    onStopRecord: function onStopRecord() {
        this.stopRecord();
    }
});

cc._RF.pop();
},{}],"UISetting":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f67d7lo/1dD4IGPp1qXvxwc', 'UISetting');
// Scripts\Gui\UISetting.js

"use strict";

cc.Class({
    extends: cc.uipanel,

    properties: {
        musicBar: cc.ProgressBar,
        effectBar: cc.ProgressBar,
        musicSlider: cc.Slider,
        effectSlider: cc.Slider,
        musicIcon: cc.Node,
        effectIcon: cc.Node
    },

    updateIcon: function updateIcon(iconNode, value) {
        this.select(iconNode, value);
    },

    onMusicChange: function onMusicChange(target) {
        var progress = target.progress;
        this.musicBar.progress = progress;
        if (progress == 0) {
            this.updateIcon(this.musicIcon, 0);
            //close sound
        } else {
            this.updateIcon(this.musicIcon, 1);
            //TODO:open sound
            //TODO:set sound volume
        }
    },

    onEffectChange: function onEffectChange(target) {
        var progress = target.progress;
        this.effectBar.progress = progress;
        if (progress == 0) {
            this.updateIcon(this.effectIcon, 0);
            //close sound
        } else {
            this.updateIcon(this.effectIcon, 1);
            //TODO:open sound
            //TODO:set sound volume
        }
    },

    onChangeUID: function onChangeUID() {
        this.close();
        //TODO:切换账号
    },

    setMusicPer: function setMusicPer(value) {
        this.musicSlider.progress = math.clamp(value, 0, 1);
    },

    setEffectPer: function setEffectPer(value) {
        this.effectSlider.progress = math.clamp(value, 0, 1);
    }

});

cc._RF.pop();
},{}],"UIShop":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'd175d8u1JVLZKSO/fFIu6nv', 'UIShop');
// Scripts\Gui\UIShop.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIVote":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6cccdKTYeNItrfjbosiV8kz', 'UIVote');
// Scripts\Gui\UIVote.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        tip: cc.RichText,
        btns: cc.Node,
        voteItems: cc.Node
    },

    onShow: function onShow() {
        var info = cc.gamemanager.voteInfo;
        this.remain_seconds = info.remain_seconds;
        var d = new Date();
        this.update_start_time = d.getTime() / 1000;
        this.voteSponsorName = cc.gamemanager.getPlayer(info.sponsor).name;
        if (!this.isSchedule) {
            this.updateTime();
            var s = cc.director.getScheduler();
            var self = this;
            s.schedule(function () {
                self.updateTime();
            }, this.node, 1, this.remain_seconds, 1, false);
            this.isSchedule = true;
        }

        this.updateVote(info);
    },

    onClose: function onClose() {
        this.stopUpdateTime();
        this._super();
    },

    updateTime: function updateTime() {
        var d = new Date();
        cc.log('this.remain_seconds:' + this.remain_seconds);
        var time = Math.max(0, Math.floor(this.remain_seconds - (d.getTime() / 1000 - this.update_start_time)));

        this.tip.string = '<color=#00ff00>玩家<color=#0fffff>'.concat(this.voteSponsorName, '</color>申请解散房间 (剩余<color=#0fffff>', String(time), '</color>秒,超时未同意默认同意)</c>');
        if (time == 0) {
            this.stopUpdateTime();
        }
    },

    stopUpdateTime: function stopUpdateTime() {
        if (this.isSchedule) {
            var s = cc.director.getScheduler();
            s.unscheduleAllForTarget(this.node);
            this.isSchedule = null;
        }
    },

    updateVote: function updateVote(info) {
        //更新投票
        var count = this.voteItems.childrenCount;
        var cs = this.voteItems.children;
        var myuid = cc.datamanager.mainPlayerData.cuid;
        for (var i = 0; i < count; ++i) {
            if (i < info.votes.length) {
                if (myuid.eq(info.votes[i].cuid)) {
                    this.btns.active = info.votes[i].vote == 0;
                }
                this.updateVoteItem(cs[i], info.votes[i]);
                cs[i].active = true;
            } else {
                cs[i].active = false;
            }
        }
    },

    voteToString: function voteToString(vote) {
        if (vote == 0) {
            return '<color=#598BD0>等待投票</c>';
        } else if (vote == 1) {
            return '<color=#6ED901>同意</c>';
        } else if (vate == 2) {
            return '<color=#ff0000>拒绝</c>';
        }
    },

    updateVoteItem: function updateVoteItem(item, info) {
        var nameNode = item.getChildByName('name');
        var stateNode = item.getChildByName('state');
        var stateLabel = stateNode.getComponent(cc.RichText);
        nameNode.getComponent(cc.Label).string = cc.gamemanager.getPlayer(info.cuid).name;
        stateLabel.string = this.voteToString(info.vote);
    },

    refuse: function refuse() {
        //拒绝
        var msg = cc.netmanager.msg('PublicProto.C_G13_VoteFoAbortGame');
        msg.vote = 2;
        cc.netmanager.send(msg);
        this.btns.active = false;
    },

    agree: function agree() {
        var msg = cc.netmanager.msg('PublicProto.C_G13_VoteFoAbortGame');
        msg.vote = 1;
        cc.netmanager.send(msg);
        this.btns.active = false;
    }

});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"UIWaiting":[function(require,module,exports){
"use strict";
cc._RF.push(module, '40765Z24V9DG58uVcxGqysf', 'UIWaiting');
// Scripts\Gui\UIWaiting.js

'use strict';

require('UIPanel');
cc.Class({
    extends: cc.uipanel,

    properties: {
        waitLabel: cc.Label
    },

    setMessage: function setMessage(msg) {
        this.waitLabel.string = msg;
    }
});

cc._RF.pop();
},{"UIPanel":"UIPanel"}],"bytebuffer":[function(require,module,exports){
"use strict";
cc._RF.push(module, '370a1Icrw1Ltpqrh3NzRfir', 'bytebuffer');
// Scripts\Lib\bytebuffer.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 Backing buffer: ArrayBuffer, Accessor: Uint8Array
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/bytebuffer.js for details
*/
(function (k, m) {
  if ("function" === typeof define && define.amd) define(["long"], m);else if ("function" === typeof require && "object" === (typeof module === "undefined" ? "undefined" : _typeof(module)) && module && module.exports) {
    var r = module,
        s;try {
      s = require("long");
    } catch (u) {}s = m(s);r.exports = s;
  } else (k.dcodeIO = k.dcodeIO || {}).ByteBuffer = m(k.dcodeIO.Long);
})(undefined, function (k) {
  function m(a) {
    var b = 0;return function () {
      return b < a.length ? a.charCodeAt(b++) : null;
    };
  }function r() {
    var a = [],
        b = [];return function () {
      if (0 === arguments.length) return b.join("") + w.apply(String, a);1024 < a.length + arguments.length && (b.push(w.apply(String, a)), a.length = 0);Array.prototype.push.apply(a, arguments);
    };
  }function s(a, b, c, d, f) {
    var l;l = 8 * f - d - 1;var g = (1 << l) - 1,
        e = g >> 1,
        h = -7;f = c ? f - 1 : 0;var k = c ? -1 : 1,
        p = a[b + f];f += k;c = p & (1 << -h) - 1;p >>= -h;for (h += l; 0 < h; c = 256 * c + a[b + f], f += k, h -= 8) {}l = c & (1 << -h) - 1;c >>= -h;for (h += d; 0 < h; l = 256 * l + a[b + f], f += k, h -= 8) {}if (0 === c) c = 1 - e;else {
      if (c === g) return l ? NaN : Infinity * (p ? -1 : 1);l += Math.pow(2, d);c -= e;
    }return (p ? -1 : 1) * l * Math.pow(2, c - d);
  }function u(a, b, c, d, f, l) {
    var g,
        e = 8 * l - f - 1,
        h = (1 << e) - 1,
        k = h >> 1,
        p = 23 === f ? Math.pow(2, -24) - Math.pow(2, -77) : 0;l = d ? 0 : l - 1;var m = d ? 1 : -1,
        n = 0 > b || 0 === b && 0 > 1 / b ? 1 : 0;b = Math.abs(b);isNaN(b) || Infinity === b ? (b = isNaN(b) ? 1 : 0, d = h) : (d = Math.floor(Math.log(b) / Math.LN2), 1 > b * (g = Math.pow(2, -d)) && (d--, g *= 2), b = 1 <= d + k ? b + p / g : b + p * Math.pow(2, 1 - k), 2 <= b * g && (d++, g /= 2), d + k >= h ? (b = 0, d = h) : 1 <= d + k ? (b = (b * g - 1) * Math.pow(2, f), d += k) : (b = b * Math.pow(2, k - 1) * Math.pow(2, f), d = 0));for (; 8 <= f; a[c + l] = b & 255, l += m, b /= 256, f -= 8) {}d = d << f | b;for (e += f; 0 < e; a[c + l] = d & 255, l += m, d /= 256, e -= 8) {}a[c + l - m] |= 128 * n;
  }var h = function h(a, b, c) {
    "undefined" === typeof a && (a = h.DEFAULT_CAPACITY);"undefined" === typeof b && (b = h.DEFAULT_ENDIAN);"undefined" === typeof c && (c = h.DEFAULT_NOASSERT);if (!c) {
      a |= 0;if (0 > a) throw RangeError("Illegal capacity");b = !!b;c = !!c;
    }this.buffer = 0 === a ? v : new ArrayBuffer(a);this.view = 0 === a ? null : new Uint8Array(this.buffer);this.offset = 0;this.markedOffset = -1;this.limit = a;this.littleEndian = b;this.noAssert = c;
  };h.VERSION = "5.0.1";h.LITTLE_ENDIAN = !0;h.BIG_ENDIAN = !1;h.DEFAULT_CAPACITY = 16;h.DEFAULT_ENDIAN = h.BIG_ENDIAN;h.DEFAULT_NOASSERT = !1;h.Long = k || null;var e = h.prototype;Object.defineProperty(e, "__isByteBuffer__", { value: !0, enumerable: !1, configurable: !1 });var v = new ArrayBuffer(0),
      w = String.fromCharCode;h.accessor = function () {
    return Uint8Array;
  };h.allocate = function (a, b, c) {
    return new h(a, b, c);
  };h.concat = function (a, b, c, d) {
    if ("boolean" === typeof b || "string" !== typeof b) d = c, c = b, b = void 0;for (var f = 0, l = 0, g = a.length, e; l < g; ++l) {
      h.isByteBuffer(a[l]) || (a[l] = h.wrap(a[l], b)), e = a[l].limit - a[l].offset, 0 < e && (f += e);
    }if (0 === f) return new h(0, c, d);b = new h(f, c, d);for (l = 0; l < g;) {
      c = a[l++], e = c.limit - c.offset, 0 >= e || (b.view.set(c.view.subarray(c.offset, c.limit), b.offset), b.offset += e);
    }b.limit = b.offset;b.offset = 0;return b;
  };h.isByteBuffer = function (a) {
    return !0 === (a && a.__isByteBuffer__);
  };h.type = function () {
    return ArrayBuffer;
  };h.wrap = function (a, b, c, d) {
    "string" !== typeof b && (d = c, c = b, b = void 0);if ("string" === typeof a) switch ("undefined" === typeof b && (b = "utf8"), b) {case "base64":
        return h.fromBase64(a, c);case "hex":
        return h.fromHex(a, c);case "binary":
        return h.fromBinary(a, c);case "utf8":
        return h.fromUTF8(a, c);case "debug":
        return h.fromDebug(a, c);default:
        throw Error("Unsupported encoding: " + b);}if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) throw TypeError("Illegal buffer");if (h.isByteBuffer(a)) return b = e.clone.call(a), b.markedOffset = -1, b;if (a instanceof Uint8Array) b = new h(0, c, d), 0 < a.length && (b.buffer = a.buffer, b.offset = a.byteOffset, b.limit = a.byteOffset + a.byteLength, b.view = new Uint8Array(a.buffer));else if (a instanceof ArrayBuffer) b = new h(0, c, d), 0 < a.byteLength && (b.buffer = a, b.offset = 0, b.limit = a.byteLength, b.view = 0 < a.byteLength ? new Uint8Array(a) : null);else if ("[object Array]" === Object.prototype.toString.call(a)) for (b = new h(a.length, c, d), b.limit = a.length, c = 0; c < a.length; ++c) {
      b.view[c] = a[c];
    } else throw TypeError("Illegal buffer");return b;
  };e.writeBitSet = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if (!(a instanceof Array)) throw TypeError("Illegal BitSet: Not an array");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f = a.length,
        e = f >> 3,
        g = 0,
        h;for (b += this.writeVarint32(f, b); e--;) {
      h = !!a[g++] & 1 | (!!a[g++] & 1) << 1 | (!!a[g++] & 1) << 2 | (!!a[g++] & 1) << 3 | (!!a[g++] & 1) << 4 | (!!a[g++] & 1) << 5 | (!!a[g++] & 1) << 6 | (!!a[g++] & 1) << 7, this.writeByte(h, b++);
    }if (g < f) {
      for (h = e = 0; g < f;) {
        h |= (!!a[g++] & 1) << e++;
      }this.writeByte(h, b++);
    }return c ? (this.offset = b, this) : b - d;
  };e.readBitSet = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);var c = this.readVarint32(a),
        d = c.value,
        f = d >> 3,
        e = 0,
        g = [];for (a += c.length; f--;) {
      c = this.readByte(a++), g[e++] = !!(c & 1), g[e++] = !!(c & 2), g[e++] = !!(c & 4), g[e++] = !!(c & 8), g[e++] = !!(c & 16), g[e++] = !!(c & 32), g[e++] = !!(c & 64), g[e++] = !!(c & 128);
    }if (e < d) for (f = 0, c = this.readByte(a++); e < d;) {
      g[e++] = !!(c >> f++ & 1);
    }b && (this.offset = a);return g;
  };e.readBytes = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + a > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+" + a + ") <= " + this.buffer.byteLength);
    }var d = this.slice(b, b + a);c && (this.offset += a);return d;
  };e.writeBytes = e.append;e.writeInt8 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 1;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);this.view[b - 1] = a;c && (this.offset += 1);return this;
  };e.writeByte = e.writeInt8;e.readInt8 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }a = this.view[a];128 === (a & 128) && (a = -(255 - a + 1));b && (this.offset += 1);return a;
  };e.readByte = e.readInt8;e.writeUint8 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 1;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);
    this.view[b - 1] = a;c && (this.offset += 1);return this;
  };e.writeUInt8 = e.writeUint8;e.readUint8 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }a = this.view[a];b && (this.offset += 1);return a;
  };e.readUInt8 = e.readUint8;e.writeInt16 = function (a, b) {
    var c = "undefined" === typeof b;
    c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 2;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 2;this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);c && (this.offset += 2);return this;
  };e.writeShort = e.writeInt16;e.readInt16 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);32768 === (c & 32768) && (c = -(65535 - c + 1));b && (this.offset += 2);return c;
  };e.readShort = e.readInt16;e.writeUint16 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 2;var d = this.buffer.byteLength;
    b > d && this.resize((d *= 2) > b ? d : b);b -= 2;this.littleEndian ? (this.view[b + 1] = (a & 65280) >>> 8, this.view[b] = a & 255) : (this.view[b] = (a & 65280) >>> 8, this.view[b + 1] = a & 255);c && (this.offset += 2);return this;
  };e.writeUInt16 = e.writeUint16;e.readUint16 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a], c |= this.view[a + 1] << 8) : (c = this.view[a] << 8, c |= this.view[a + 1]);b && (this.offset += 2);return c;
  };e.readUInt16 = e.readUint16;e.writeInt32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 4;this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);c && (this.offset += 4);return this;
  };e.writeInt = e.writeInt32;e.readInt32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);b && (this.offset += 4);return c | 0;
  };e.readInt = e.readInt32;e.writeUint32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 4;this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255, this.view[b + 2] = a >>> 16 & 255, this.view[b + 1] = a >>> 8 & 255, this.view[b] = a & 255) : (this.view[b] = a >>> 24 & 255, this.view[b + 1] = a >>> 16 & 255, this.view[b + 2] = a >>> 8 & 255, this.view[b + 3] = a & 255);c && (this.offset += 4);return this;
  };e.writeUInt32 = e.writeUint32;e.readUint32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);b && (this.offset += 4);return c;
  };e.readUInt32 = e.readUint32;k && (e.writeInt64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 8;var d = a.low,
        f = a.high;this.littleEndian ? (this.view[b + 3] = d >>> 24 & 255, this.view[b + 2] = d >>> 16 & 255, this.view[b + 1] = d >>> 8 & 255, this.view[b] = d & 255, b += 4, this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255, b += 4, this.view[b] = d >>> 24 & 255, this.view[b + 1] = d >>> 16 & 255, this.view[b + 2] = d >>> 8 & 255, this.view[b + 3] = d & 255);c && (this.offset += 8);return this;
  }, e.writeLong = e.writeInt64, e.readInt64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
      a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0, a += 4, d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0, a += 4, c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);
    a = new k(c, d, !1);b && (this.offset += 8);return a;
  }, e.readLong = e.readInt64, e.writeUint64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= 8;var d = a.low,
        f = a.high;this.littleEndian ? (this.view[b + 3] = d >>> 24 & 255, this.view[b + 2] = d >>> 16 & 255, this.view[b + 1] = d >>> 8 & 255, this.view[b] = d & 255, b += 4, this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255, b += 4, this.view[b] = d >>> 24 & 255, this.view[b + 1] = d >>> 16 & 255, this.view[b + 2] = d >>> 8 & 255, this.view[b + 3] = d & 255);c && (this.offset += 8);return this;
  }, e.writeUInt64 = e.writeUint64, e.readUint64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0;this.littleEndian ? (c = this.view[a + 2] << 16, c |= this.view[a + 1] << 8, c |= this.view[a], c += this.view[a + 3] << 24 >>> 0, a += 4, d = this.view[a + 2] << 16, d |= this.view[a + 1] << 8, d |= this.view[a], d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16, d |= this.view[a + 2] << 8, d |= this.view[a + 3], d += this.view[a] << 24 >>> 0, a += 4, c = this.view[a + 1] << 16, c |= this.view[a + 2] << 8, c |= this.view[a + 3], c += this.view[a] << 24 >>> 0);a = new k(c, d, !0);b && (this.offset += 8);return a;
  }, e.readUInt64 = e.readUint64);e.writeFloat32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 4;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);u(this.view, a, b - 4, this.littleEndian, 23, 4);c && (this.offset += 4);return this;
  };e.writeFloat = e.writeFloat32;e.readFloat32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }a = s(this.view, a, this.littleEndian, 23, 4);b && (this.offset += 4);return a;
  };e.readFloat = e.readFloat32;e.writeFloat64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }b += 8;var d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);u(this.view, a, b - 8, this.littleEndian, 52, 8);c && (this.offset += 8);return this;
  };e.writeDouble = e.writeFloat64;e.readFloat64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength);
    }a = s(this.view, a, this.littleEndian, 52, 8);b && (this.offset += 8);return a;
  };e.readDouble = e.readFloat64;h.MAX_VARINT32_BYTES = 5;h.calculateVarint32 = function (a) {
    a >>>= 0;return 128 > a ? 1 : 16384 > a ? 2 : 2097152 > a ? 3 : 268435456 > a ? 4 : 5;
  };h.zigZagEncode32 = function (a) {
    return ((a |= 0) << 1 ^ a >> 31) >>> 0;
  };h.zigZagDecode32 = function (a) {
    return a >>> 1 ^ -(a & 1) | 0;
  };e.writeVarint32 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = h.calculateVarint32(a),
        f;b += d;f = this.buffer.byteLength;b > f && this.resize((f *= 2) > b ? f : b);
    b -= d;for (a >>>= 0; 128 <= a;) {
      f = a & 127 | 128, this.view[b++] = f, a >>>= 7;
    }this.view[b++] = a;return c ? (this.offset = b, this) : d;
  };e.writeVarint32ZigZag = function (a, b) {
    return this.writeVarint32(h.zigZagEncode32(a), b);
  };e.readVarint32 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = 0,
        d = 0,
        f;do {
      if (!this.noAssert && a > this.limit) throw a = Error("Truncated"), a.truncated = !0, a;f = this.view[a++];5 > c && (d |= (f & 127) << 7 * c);++c;
    } while (0 !== (f & 128));d |= 0;return b ? (this.offset = a, d) : { value: d, length: c };
  };e.readVarint32ZigZag = function (a) {
    a = this.readVarint32(a);"object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) ? a.value = h.zigZagDecode32(a.value) : a = h.zigZagDecode32(a);return a;
  };k && (h.MAX_VARINT64_BYTES = 10, h.calculateVarint64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a) : "string" === typeof a && (a = k.fromString(a));var b = a.toInt() >>> 0,
        c = a.shiftRightUnsigned(28).toInt() >>> 0;a = a.shiftRightUnsigned(56).toInt() >>> 0;return 0 == a ? 0 == c ? 16384 > b ? 128 > b ? 1 : 2 : 2097152 > b ? 3 : 4 : 16384 > c ? 128 > c ? 5 : 6 : 2097152 > c ? 7 : 8 : 128 > a ? 9 : 10;
  }, h.zigZagEncode64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());return a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned();
  }, h.zigZagDecode64 = function (a) {
    "number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());return a.shiftRightUnsigned(1).xor(a.and(k.ONE).toSigned().negate()).toSigned();
  }, e.writeVarint64 = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" === typeof a) a = k.fromNumber(a);else if ("string" === typeof a) a = k.fromString(a);else if (!(a && a instanceof k)) throw TypeError("Illegal value: " + a + " (not an integer or Long)");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }"number" === typeof a ? a = k.fromNumber(a, !1) : "string" === typeof a ? a = k.fromString(a, !1) : !1 !== a.unsigned && (a = a.toSigned());var d = h.calculateVarint64(a),
        f = a.toInt() >>> 0,
        e = a.shiftRightUnsigned(28).toInt() >>> 0,
        g = a.shiftRightUnsigned(56).toInt() >>> 0;b += d;var t = this.buffer.byteLength;b > t && this.resize((t *= 2) > b ? t : b);b -= d;switch (d) {case 10:
        this.view[b + 9] = g >>> 7 & 1;case 9:
        this.view[b + 8] = 9 !== d ? g | 128 : g & 127;case 8:
        this.view[b + 7] = 8 !== d ? e >>> 21 | 128 : e >>> 21 & 127;case 7:
        this.view[b + 6] = 7 !== d ? e >>> 14 | 128 : e >>> 14 & 127;case 6:
        this.view[b + 5] = 6 !== d ? e >>> 7 | 128 : e >>> 7 & 127;case 5:
        this.view[b + 4] = 5 !== d ? e | 128 : e & 127;case 4:
        this.view[b + 3] = 4 !== d ? f >>> 21 | 128 : f >>> 21 & 127;case 3:
        this.view[b + 2] = 3 !== d ? f >>> 14 | 128 : f >>> 14 & 127;case 2:
        this.view[b + 1] = 2 !== d ? f >>> 7 | 128 : f >>> 7 & 127;case 1:
        this.view[b] = 1 !== d ? f | 128 : f & 127;}return c ? (this.offset += d, this) : d;
  }, e.writeVarint64ZigZag = function (a, b) {
    return this.writeVarint64(h.zigZagEncode64(a), b);
  }, e.readVarint64 = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d = 0,
        f = 0,
        e = 0,
        g = 0,
        g = this.view[a++],
        d = g & 127;if (g & 128 && (g = this.view[a++], d |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], d |= (g & 127) << 14, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], d |= (g & 127) << 21, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f = g & 127, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 14, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], f |= (g & 127) << 21, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], e = g & 127, g & 128 || this.noAssert && "undefined" === typeof g) && (g = this.view[a++], e |= (g & 127) << 7, g & 128 || this.noAssert && "undefined" === typeof g)) throw Error("Buffer overrun");d = k.fromBits(d | f << 28, f >>> 4 | e << 24, !1);return b ? (this.offset = a, d) : { value: d, length: a - c };
  }, e.readVarint64ZigZag = function (a) {
    (a = this.readVarint64(a)) && a.value instanceof k ? a.value = h.zigZagDecode64(a.value) : a = h.zigZagDecode64(a);return a;
  });e.writeCString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);var d,
        f = a.length;if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");for (d = 0; d < f; ++d) {
        if (0 === a.charCodeAt(d)) throw RangeError("Illegal str: Contains NULL-characters");
      }if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }f = n.calculateUTF16asUTF8(m(a))[1];b += f + 1;d = this.buffer.byteLength;b > d && this.resize((d *= 2) > b ? d : b);b -= f + 1;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));this.view[b++] = 0;return c ? (this.offset = b, this) : f;
  };e.readCString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d,
        f = -1;n.decodeUTF8toUTF16(function () {
      if (0 === f) return null;if (a >= this.limit) throw RangeError("Illegal range: Truncated data, " + a + " < " + this.limit);f = this.view[a++];return 0 === f ? null : f;
    }.bind(this), d = r(), !0);return b ? (this.offset = a, d()) : { string: d(), length: a - c };
  };e.writeIString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f;f = n.calculateUTF16asUTF8(m(a), this.noAssert)[1];b += 4 + f;var e = this.buffer.byteLength;b > e && this.resize((e *= 2) > b ? e : b);b -= 4 + f;this.littleEndian ? (this.view[b + 3] = f >>> 24 & 255, this.view[b + 2] = f >>> 16 & 255, this.view[b + 1] = f >>> 8 & 255, this.view[b] = f & 255) : (this.view[b] = f >>> 24 & 255, this.view[b + 1] = f >>> 16 & 255, this.view[b + 2] = f >>> 8 & 255, this.view[b + 3] = f & 255);b += 4;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));if (b !== d + 4 + f) throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + 4 + f));return c ? (this.offset = b, this) : b - d;
  };e.readIString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength);
    }var c = a,
        d = this.readUint32(a),
        d = this.readUTF8String(d, h.METRICS_BYTES, a += 4);a += d.length;return b ? (this.offset = a, d.string) : { string: d.string, length: a - c };
  };h.METRICS_CHARS = "c";h.METRICS_BYTES = "b";e.writeUTF8String = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d,
        f = b;d = n.calculateUTF16asUTF8(m(a))[1];b += d;var e = this.buffer.byteLength;b > e && this.resize((e *= 2) > b ? e : b);b -= d;n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));return c ? (this.offset = b, this) : b - f;
  };e.writeString = e.writeUTF8String;h.calculateUTF8Chars = function (a) {
    return n.calculateUTF16asUTF8(m(a))[0];
  };h.calculateUTF8Bytes = function (a) {
    return n.calculateUTF16asUTF8(m(a))[1];
  };
  h.calculateString = h.calculateUTF8Bytes;e.readUTF8String = function (a, b, c) {
    "number" === typeof b && (c = b, b = void 0);var d = "undefined" === typeof c;d && (c = this.offset);"undefined" === typeof b && (b = h.METRICS_CHARS);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");a |= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }var f = 0,
        e = c,
        g;if (b === h.METRICS_CHARS) {
      g = r();n.decodeUTF8(function () {
        return f < a && c < this.limit ? this.view[c++] : null;
      }.bind(this), function (a) {
        ++f;n.UTF8toUTF16(a, g);
      });if (f !== a) throw RangeError("Illegal range: Truncated data, " + f + " == " + a);return d ? (this.offset = c, g()) : { string: g(), length: c - e };
    }if (b === h.METRICS_BYTES) {
      if (!this.noAssert) {
        if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + a > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+" + a + ") <= " + this.buffer.byteLength);
      }var k = c + a;n.decodeUTF8toUTF16(function () {
        return c < k ? this.view[c++] : null;
      }.bind(this), g = r(), this.noAssert);if (c !== k) throw RangeError("Illegal range: Truncated data, " + c + " == " + k);return d ? (this.offset = c, g()) : { string: g(), length: c - e };
    }throw TypeError("Unsupported metrics: " + b);
  };e.readString = e.readUTF8String;e.writeVString = function (a, b) {
    var c = "undefined" === typeof b;c && (b = this.offset);if (!this.noAssert) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");b >>>= 0;if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength);
    }var d = b,
        f,
        e;f = n.calculateUTF16asUTF8(m(a), this.noAssert)[1];e = h.calculateVarint32(f);b += e + f;var g = this.buffer.byteLength;b > g && this.resize((g *= 2) > b ? g : b);b -= e + f;b += this.writeVarint32(f, b);n.encodeUTF16toUTF8(m(a), function (a) {
      this.view[b++] = a;
    }.bind(this));if (b !== d + f + e) throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + f + e));return c ? (this.offset = b, this) : b - d;
  };e.readVString = function (a) {
    var b = "undefined" === typeof a;b && (a = this.offset);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength);
    }var c = a,
        d = this.readVarint32(a),
        d = this.readUTF8String(d.value, h.METRICS_BYTES, a += d.length);a += d.length;return b ? (this.offset = a, d.string) : { string: d.string,
      length: a - c };
  };e.append = function (a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) c = b, b = void 0;var d = "undefined" === typeof c;d && (c = this.offset);if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }a instanceof h || (a = h.wrap(a, b));b = a.limit - a.offset;if (0 >= b) return this;c += b;var f = this.buffer.byteLength;c > f && this.resize((f *= 2) > c ? f : c);c -= b;this.view.set(a.view.subarray(a.offset, a.limit), c);a.offset += b;d && (this.offset += b);return this;
  };e.appendTo = function (a, b) {
    a.append(this, b);return this;
  };e.assert = function (a) {
    this.noAssert = !a;return this;
  };e.capacity = function () {
    return this.buffer.byteLength;
  };e.clear = function () {
    this.offset = 0;this.limit = this.buffer.byteLength;this.markedOffset = -1;return this;
  };e.clone = function (a) {
    var b = new h(0, this.littleEndian, this.noAssert);a ? (b.buffer = new ArrayBuffer(this.buffer.byteLength), b.view = new Uint8Array(b.buffer)) : (b.buffer = this.buffer, b.view = this.view);b.offset = this.offset;b.markedOffset = this.markedOffset;b.limit = this.limit;return b;
  };e.compact = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (0 === a && b === this.buffer.byteLength) return this;var c = b - a;if (0 === c) return this.buffer = v, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= a), this.limit = this.offset = 0, this;var d = new ArrayBuffer(c),
        f = new Uint8Array(d);f.set(this.view.subarray(a, b));this.buffer = d;this.view = f;0 <= this.markedOffset && (this.markedOffset -= a);this.offset = 0;this.limit = c;return this;
  };e.copy = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (a === b) return new h(0, this.littleEndian, this.noAssert);var c = b - a,
        d = new h(c, this.littleEndian, this.noAssert);d.offset = 0;d.limit = c;0 <= d.markedOffset && (d.markedOffset -= a);this.copyTo(d, 0, a, b);return d;
  };e.copyTo = function (a, b, c, d) {
    var f, e;if (!this.noAssert && !h.isByteBuffer(a)) throw TypeError("Illegal target: Not a ByteBuffer");b = (e = "undefined" === typeof b) ? a.offset : b | 0;c = (f = "undefined" === typeof c) ? this.offset : c | 0;d = "undefined" === typeof d ? this.limit : d | 0;if (0 > b || b > a.buffer.byteLength) throw RangeError("Illegal target range: 0 <= " + b + " <= " + a.buffer.byteLength);if (0 > c || d > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= " + c + " <= " + this.buffer.byteLength);var g = d - c;if (0 === g) return a;a.ensureCapacity(b + g);
    a.view.set(this.view.subarray(c, d), b);f && (this.offset += g);e && (a.offset += g);return this;
  };e.ensureCapacity = function (a) {
    var b = this.buffer.byteLength;return b < a ? this.resize((b *= 2) > a ? b : a) : this;
  };e.fill = function (a, b, c) {
    var d = "undefined" === typeof b;d && (b = this.offset);"string" === typeof a && 0 < a.length && (a = a.charCodeAt(0));"undefined" === typeof b && (b = this.offset);"undefined" === typeof c && (c = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");a |= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal begin: Not an integer");b >>>= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal end: Not an integer");c >>>= 0;if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
    }if (b >= c) return this;for (; b < c;) {
      this.view[b++] = a;
    }d && (this.offset = b);return this;
  };e.flip = function () {
    this.limit = this.offset;this.offset = 0;return this;
  };e.mark = function (a) {
    a = "undefined" === typeof a ? this.offset : a;
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");a >>>= 0;if (0 > a || a + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + a + " (+0) <= " + this.buffer.byteLength);
    }this.markedOffset = a;return this;
  };e.order = function (a) {
    if (!this.noAssert && "boolean" !== typeof a) throw TypeError("Illegal littleEndian: Not a boolean");this.littleEndian = !!a;return this;
  };e.LE = function (a) {
    this.littleEndian = "undefined" !== typeof a ? !!a : !0;return this;
  };e.BE = function (a) {
    this.littleEndian = "undefined" !== typeof a ? !a : !1;return this;
  };e.prepend = function (a, b, c) {
    if ("number" === typeof b || "string" !== typeof b) c = b, b = void 0;var d = "undefined" === typeof c;d && (c = this.offset);if (!this.noAssert) {
      if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");c >>>= 0;if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength);
    }a instanceof h || (a = h.wrap(a, b));b = a.limit - a.offset;if (0 >= b) return this;var f = b - c;if (0 < f) {
      var e = new ArrayBuffer(this.buffer.byteLength + f),
          g = new Uint8Array(e);g.set(this.view.subarray(c, this.buffer.byteLength), b);this.buffer = e;this.view = g;this.offset += f;0 <= this.markedOffset && (this.markedOffset += f);this.limit += f;c += f;
    } else new Uint8Array(this.buffer);this.view.set(a.view.subarray(a.offset, a.limit), c - b);a.offset = a.limit;d && (this.offset -= b);return this;
  };e.prependTo = function (a, b) {
    a.prepend(this, b);return this;
  };e.printDebug = function (a) {
    "function" !== typeof a && (a = console.log.bind(console));a(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0));
  };e.remaining = function () {
    return this.limit - this.offset;
  };e.reset = function () {
    0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0;return this;
  };e.resize = function (a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal capacity: " + a + " (not an integer)");a |= 0;if (0 > a) throw RangeError("Illegal capacity: 0 <= " + a);
    }if (this.buffer.byteLength < a) {
      a = new ArrayBuffer(a);var b = new Uint8Array(a);b.set(this.view);this.buffer = a;this.view = b;
    }return this;
  };
  e.reverse = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }if (a === b) return this;Array.prototype.reverse.call(this.view.subarray(a, b));return this;
  };
  e.skip = function (a) {
    if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");a |= 0;
    }var b = this.offset + a;if (!this.noAssert && (0 > b || b > this.buffer.byteLength)) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + a + " <= " + this.buffer.byteLength);this.offset = b;return this;
  };e.slice = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
      a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }var c = this.clone();c.offset = a;c.limit = b;return c;
  };e.toBuffer = function (a) {
    var b = this.offset,
        c = this.limit;if (!this.noAssert) {
      if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: Not an integer");b >>>= 0;if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal limit: Not an integer");
      c >>>= 0;if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength);
    }if (!a && 0 === b && c === this.buffer.byteLength) return this.buffer;if (b === c) return v;a = new ArrayBuffer(c - b);new Uint8Array(a).set(new Uint8Array(this.buffer).subarray(b, c), 0);return a;
  };e.toArrayBuffer = e.toBuffer;e.toString = function (a, b, c) {
    if ("undefined" === typeof a) return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";"number" === typeof a && (c = b = a = "utf8");switch (a) {case "utf8":
        return this.toUTF8(b, c);case "base64":
        return this.toBase64(b, c);case "hex":
        return this.toHex(b, c);case "binary":
        return this.toBinary(b, c);case "debug":
        return this.toDebug();case "columns":
        return this.toColumns();default:
        throw Error("Unsupported encoding: " + a);}
  };var x = function () {
    for (var a = {}, b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], c = [], d = 0, f = b.length; d < f; ++d) {
      c[b[d]] = d;
    }a.encode = function (a, c) {
      for (var d, f; null !== (d = a());) {
        c(b[d >> 2 & 63]), f = (d & 3) << 4, null !== (d = a()) ? (f |= d >> 4 & 15, c(b[(f | d >> 4 & 15) & 63]), f = (d & 15) << 2, null !== (d = a()) ? (c(b[(f | d >> 6 & 3) & 63]), c(b[d & 63])) : (c(b[f & 63]), c(61))) : (c(b[f & 63]), c(61), c(61));
      }
    };a.decode = function (a, b) {
      function d(a) {
        throw Error("Illegal character code: " + a);
      }for (var f, e, h; null !== (f = a());) {
        if (e = c[f], "undefined" === typeof e && d(f), null !== (f = a()) && (h = c[f], "undefined" === typeof h && d(f), b(e << 2 >>> 0 | (h & 48) >> 4), null !== (f = a()))) {
          e = c[f];if ("undefined" === typeof e) if (61 === f) break;else d(f);b((h & 15) << 4 >>> 0 | (e & 60) >> 2);if (null !== (f = a())) {
            h = c[f];if ("undefined" === typeof h) if (61 === f) break;else d(f);b((e & 3) << 6 >>> 0 | h);
          }
        }
      }
    };a.test = function (a) {
      return (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)
      );
    };return a;
  }();e.toBase64 = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);a |= 0;b |= 0;if (0 > a || b > this.capacity || a > b) throw RangeError("begin, end");var c;x.encode(function () {
      return a < b ? this.view[a++] : null;
    }.bind(this), c = r());return c();
  };h.fromBase64 = function (a, b) {
    if ("string" !== typeof a) throw TypeError("str");var c = new h(a.length / 4 * 3, b),
        d = 0;x.decode(m(a), function (a) {
      c.view[d++] = a;
    });c.limit = d;return c;
  };h.btoa = function (a) {
    return h.fromBinary(a).toBase64();
  };h.atob = function (a) {
    return h.fromBase64(a).toBinary();
  };e.toBinary = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);
    a |= 0;b |= 0;if (0 > a || b > this.capacity() || a > b) throw RangeError("begin, end");if (a === b) return "";for (var c = [], d = []; a < b;) {
      c.push(this.view[a++]), 1024 <= c.length && (d.push(String.fromCharCode.apply(String, c)), c = []);
    }return d.join("") + String.fromCharCode.apply(String, c);
  };h.fromBinary = function (a, b) {
    if ("string" !== typeof a) throw TypeError("str");for (var c = 0, d = a.length, f, e = new h(d, b); c < d;) {
      f = a.charCodeAt(c);if (255 < f) throw RangeError("illegal char code: " + f);e.view[c++] = f;
    }e.limit = d;return e;
  };e.toDebug = function (a) {
    for (var b = -1, c = this.buffer.byteLength, d, f = "", e = "", g = ""; b < c;) {
      -1 !== b && (d = this.view[b], f = 16 > d ? f + ("0" + d.toString(16).toUpperCase()) : f + d.toString(16).toUpperCase(), a && (e += 32 < d && 127 > d ? String.fromCharCode(d) : "."));++b;if (a && 0 < b && 0 === b % 16 && b !== c) {
        for (; 51 > f.length;) {
          f += " ";
        }g += f + e + "\n";f = e = "";
      }f = b === this.offset && b === this.limit ? f + (b === this.markedOffset ? "!" : "|") : b === this.offset ? f + (b === this.markedOffset ? "[" : "<") : b === this.limit ? f + (b === this.markedOffset ? "]" : ">") : f + (b === this.markedOffset ? "'" : a || 0 !== b && b !== c ? " " : "");
    }if (a && " " !== f) {
      for (; 51 > f.length;) {
        f += " ";
      }g += f + e + "\n";
    }return a ? g : f;
  };h.fromDebug = function (a, b, c) {
    var d = a.length;b = new h((d + 1) / 3 | 0, b, c);for (var f = 0, e = 0, g, k = !1, m = !1, n = !1, p = !1, q = !1; f < d;) {
      switch (g = a.charAt(f++)) {case "!":
          if (!c) {
            if (m || n || p) {
              q = !0;break;
            }m = n = p = !0;
          }b.offset = b.markedOffset = b.limit = e;k = !1;break;case "|":
          if (!c) {
            if (m || p) {
              q = !0;break;
            }m = p = !0;
          }b.offset = b.limit = e;k = !1;break;case "[":
          if (!c) {
            if (m || n) {
              q = !0;break;
            }m = n = !0;
          }b.offset = b.markedOffset = e;k = !1;break;case "<":
          if (!c) {
            if (m) {
              q = !0;break;
            }m = !0;
          }b.offset = e;k = !1;break;case "]":
          if (!c) {
            if (p || n) {
              q = !0;break;
            }p = n = !0;
          }b.limit = b.markedOffset = e;k = !1;break;case ">":
          if (!c) {
            if (p) {
              q = !0;break;
            }p = !0;
          }b.limit = e;k = !1;break;case "'":
          if (!c) {
            if (n) {
              q = !0;break;
            }n = !0;
          }b.markedOffset = e;k = !1;break;case " ":
          k = !1;break;default:
          if (!c && k) {
            q = !0;break;
          }g = parseInt(g + a.charAt(f++), 16);if (!c && (isNaN(g) || 0 > g || 255 < g)) throw TypeError("Illegal str: Not a debug encoded string");b.view[e++] = g;k = !0;}if (q) throw TypeError("Illegal str: Invalid symbol at " + f);
    }if (!c) {
      if (!m || !p) throw TypeError("Illegal str: Missing offset or limit");
      if (e < b.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + e + " < " + d);
    }return b;
  };e.toHex = function (a, b) {
    a = "undefined" === typeof a ? this.offset : a;b = "undefined" === typeof b ? this.limit : b;if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }for (var c = Array(b - a), d; a < b;) {
      d = this.view[a++], 16 > d ? c.push("0", d.toString(16)) : c.push(d.toString(16));
    }return c.join("");
  };h.fromHex = function (a, b, c) {
    if (!c) {
      if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");if (0 !== a.length % 2) throw TypeError("Illegal str: Length not a multiple of 2");
    }var d = a.length;b = new h(d / 2 | 0, b);for (var f, e = 0, g = 0; e < d; e += 2) {
      f = parseInt(a.substring(e, e + 2), 16);if (!c && (!isFinite(f) || 0 > f || 255 < f)) throw TypeError("Illegal str: Contains non-hex characters");
      b.view[g++] = f;
    }b.limit = g;return b;
  };var n = function () {
    var a = { MAX_CODEPOINT: 1114111, encodeUTF8: function encodeUTF8(a, c) {
        var d = null;"number" === typeof a && (d = a, a = function a() {
          return null;
        });for (; null !== d || null !== (d = a());) {
          128 > d ? c(d & 127) : (2048 > d ? c(d >> 6 & 31 | 192) : (65536 > d ? c(d >> 12 & 15 | 224) : (c(d >> 18 & 7 | 240), c(d >> 12 & 63 | 128)), c(d >> 6 & 63 | 128)), c(d & 63 | 128)), d = null;
        }
      }, decodeUTF8: function decodeUTF8(a, c) {
        for (var d, f, e, g, h = function h(a) {
          a = a.slice(0, a.indexOf(null));var b = Error(a.toString());b.name = "TruncatedError";b.bytes = a;throw b;
        }; null !== (d = a());) {
          if (0 === (d & 128)) c(d);else if (192 === (d & 224)) null === (f = a()) && h([d, f]), c((d & 31) << 6 | f & 63);else if (224 === (d & 240)) null !== (f = a()) && null !== (e = a()) || h([d, f, e]), c((d & 15) << 12 | (f & 63) << 6 | e & 63);else if (240 === (d & 248)) null !== (f = a()) && null !== (e = a()) && null !== (g = a()) || h([d, f, e, g]), c((d & 7) << 18 | (f & 63) << 12 | (e & 63) << 6 | g & 63);else throw RangeError("Illegal starting byte: " + d);
        }
      }, UTF16toUTF8: function UTF16toUTF8(a, c) {
        for (var d, e = null; null !== (d = null !== e ? e : a());) {
          55296 <= d && 57343 >= d && null !== (e = a()) && 56320 <= e && 57343 >= e ? (c(1024 * (d - 55296) + e - 56320 + 65536), e = null) : c(d);
        }null !== e && c(e);
      }, UTF8toUTF16: function UTF8toUTF16(a, c) {
        var d = null;"number" === typeof a && (d = a, a = function a() {
          return null;
        });for (; null !== d || null !== (d = a());) {
          65535 >= d ? c(d) : (d -= 65536, c((d >> 10) + 55296), c(d % 1024 + 56320)), d = null;
        }
      }, encodeUTF16toUTF8: function encodeUTF16toUTF8(b, c) {
        a.UTF16toUTF8(b, function (b) {
          a.encodeUTF8(b, c);
        });
      }, decodeUTF8toUTF16: function decodeUTF8toUTF16(b, c) {
        a.decodeUTF8(b, function (b) {
          a.UTF8toUTF16(b, c);
        });
      }, calculateCodePoint: function calculateCodePoint(a) {
        return 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
      }, calculateUTF8: function calculateUTF8(a) {
        for (var c, d = 0; null !== (c = a());) {
          d += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4;
        }return d;
      }, calculateUTF16asUTF8: function calculateUTF16asUTF8(b) {
        var c = 0,
            d = 0;a.UTF16toUTF8(b, function (a) {
          ++c;d += 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4;
        });return [c, d];
      } };return a;
  }();e.toUTF8 = function (a, b) {
    "undefined" === typeof a && (a = this.offset);"undefined" === typeof b && (b = this.limit);if (!this.noAssert) {
      if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");a >>>= 0;if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");b >>>= 0;if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength);
    }var c;try {
      n.decodeUTF8toUTF16(function () {
        return a < b ? this.view[a++] : null;
      }.bind(this), c = r());
    } catch (d) {
      if (a !== b) throw RangeError("Illegal range: Truncated data, " + a + " != " + b);
    }return c();
  };h.fromUTF8 = function (a, b, c) {
    if (!c && "string" !== typeof a) throw TypeError("Illegal str: Not a string");var d = new h(n.calculateUTF16asUTF8(m(a), !0)[1], b, c),
        e = 0;n.encodeUTF16toUTF8(m(a), function (a) {
      d.view[e++] = a;
    });d.limit = e;return d;
  };return h;
});

cc._RF.pop();
},{"long":"long"}],"init":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b5713OFGZhA+Jt7gBxhwNe/', 'init');
// Scripts\init.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        cc.log("onload begin");

        cc.netmanager.init();
        cc.netmanager.registerHandler(cc.datamanager);
        cc.netmanager.registerHandler(cc.gamemanager);
        cc.netmanager.registerHandler(cc.guimanager);

        cc.audiomanager.init();

        cc.scenemanager.loadLoginScene();
        cc.log('onload');
    }

});

cc._RF.pop();
},{}],"long":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2c847wd+iJEZZInKRIzLwWs', 'long');
// Scripts\Lib\long.js

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define([], factory);
    /* CommonJS */else if (typeof require === 'function' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory();
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
})(undefined, function () {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */

    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned, unsigned = false;
        } else {
            unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long) return val;
        if (typeof val === 'number') return fromNumber(val);
        if (typeof val === 'string') return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');
        if (this.isZero()) return '0';
        if (this.isNegative()) {
            // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) {
            if ((val & 1 << bit) != 0) break;
        }return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq( /* validates */other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp( /* validates */other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp( /* validates */other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp( /* validates */other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp( /* validates */other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        // At this point the sign bits are the same
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return ZERO;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (multiplier.isZero()) return ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error('division by zero');
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE)) return ONE;else {
                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                        var halfThis = this.shr(1);
                        approx = halfThis.div(divisor).shl(1);
                        if (approx.eq(ZERO)) {
                            return divisor.isNegative() ? ONE : NEG_ONE;
                        } else {
                            rem = this.sub(divisor.mul(approx));
                            res = approx.add(rem.div(divisor));
                            return res;
                        }
                    }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),


            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0) return this;else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
    };

    return Long;
});

cc._RF.pop();
},{}],"protobuf":[function(require,module,exports){
(function (process){
"use strict";
cc._RF.push(module, 'e6691hW/mRNZZdi3yfy4y8r', 'protobuf');
// Scripts\Lib\protobuf.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/protobuf.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define(["bytebuffer"], factory);
    /* CommonJS */else if (typeof require === "function" && (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory(require("bytebuffer"), true);
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
})(undefined, function (ByteBuffer, isCommonJS) {
    "use strict";

    /**
     * The ProtoBuf namespace.
     * @exports ProtoBuf
     * @namespace
     * @expose
     */

    var ProtoBuf = {};

    /**
     * @type {!function(new: ByteBuffer, ...[*])}
     * @expose
     */
    ProtoBuf.ByteBuffer = ByteBuffer;

    /**
     * @type {?function(new: Long, ...[*])}
     * @expose
     */
    ProtoBuf.Long = ByteBuffer.Long || null;

    /**
     * ProtoBuf.js version.
     * @type {string}
     * @const
     * @expose
     */
    ProtoBuf.VERSION = "5.0.1";

    /**
     * Wire types.
     * @type {Object.<string,number>}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES = {};

    /**
     * Varint wire type.
     * @type {number}
     * @expose
     */
    ProtoBuf.WIRE_TYPES.VARINT = 0;

    /**
     * Fixed 64 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS64 = 1;

    /**
     * Length delimited wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.LDELIM = 2;

    /**
     * Start group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

    /**
     * End group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

    /**
     * Fixed 32 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS32 = 5;

    /**
     * Packable wire types.
     * @type {!Array.<number>}
     * @const
     * @expose
     */
    ProtoBuf.PACKABLE_WIRE_TYPES = [ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32];

    /**
     * Types.
     * @dict
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
     * @const
     * @expose
     */
    ProtoBuf.TYPES = {
        // According to the protobuf spec.
        "int32": {
            name: "int32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "uint32": {
            name: "uint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "sint32": {
            name: "sint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "int64": {
            name: "int64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "uint64": {
            name: "uint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sint64": {
            name: "sint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "bool": {
            name: "bool",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: false
        },
        "double": {
            name: "double",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: 0
        },
        "string": {
            name: "string",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: ""
        },
        "bytes": {
            name: "bytes",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null // overridden in the code, must be a unique instance
        },
        "fixed32": {
            name: "fixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "sfixed32": {
            name: "sfixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "fixed64": {
            name: "fixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sfixed64": {
            name: "sfixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "float": {
            name: "float",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "enum": {
            name: "enum",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "message": {
            name: "message",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null
        },
        "group": {
            name: "group",
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
            defaultValue: null
        }
    };

    /**
     * Valid map key types.
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
     * @const
     * @expose
     */
    ProtoBuf.MAP_KEY_TYPES = [ProtoBuf.TYPES["int32"], ProtoBuf.TYPES["sint32"], ProtoBuf.TYPES["sfixed32"], ProtoBuf.TYPES["uint32"], ProtoBuf.TYPES["fixed32"], ProtoBuf.TYPES["int64"], ProtoBuf.TYPES["sint64"], ProtoBuf.TYPES["sfixed64"], ProtoBuf.TYPES["uint64"], ProtoBuf.TYPES["fixed64"], ProtoBuf.TYPES["bool"], ProtoBuf.TYPES["string"], ProtoBuf.TYPES["bytes"]];

    /**
     * Minimum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MIN = 1;

    /**
     * Maximum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MAX = 0x1FFFFFFF;

    /**
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
     *  Must be set prior to parsing.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.convertFieldsToCamelCase = false;

    /**
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
     *  setting this to `false` prior to building messages.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateAccessors = true;

    /**
     * By default, messages are populated with default values if a field is not present on the wire. To disable
     *  this behavior, set this setting to `false`.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateDefaults = true;

    /**
     * @alias ProtoBuf.Util
     * @expose
     */
    ProtoBuf.Util = function () {
        "use strict";

        /**
         * ProtoBuf utilities.
         * @exports ProtoBuf.Util
         * @namespace
         */

        var Util = {};

        /**
         * Flag if running in node or not.
         * @type {boolean}
         * @const
         * @expose
         */
        Util.IS_NODE = !!((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process + '' === '[object process]' && !process['browser']);

        /**
         * Constructs a XMLHttpRequest object.
         * @return {XMLHttpRequest}
         * @throws {Error} If XMLHttpRequest is not supported
         * @expose
         */
        Util.XHR = function () {
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
            var XMLHttpFactories = [function () {
                return new XMLHttpRequest();
            }, function () {
                return new ActiveXObject("Msxml2.XMLHTTP");
            }, function () {
                return new ActiveXObject("Msxml3.XMLHTTP");
            }, function () {
                return new ActiveXObject("Microsoft.XMLHTTP");
            }];
            /** @type {?XMLHttpRequest} */
            var xhr = null;
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xhr = XMLHttpFactories[i]();
                } catch (e) {
                    continue;
                }
                break;
            }
            if (!xhr) throw Error("XMLHttpRequest is not supported");
            return xhr;
        };

        /**
         * Fetches a resource.
         * @param {string} path Resource path
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose
         */
        Util.fetch = function (path, callback) {
            if (callback && typeof callback != 'function') callback = null;
            if (Util.IS_NODE) {
                var fs = require("fs");
                if (callback) {
                    fs.readFile(path, function (err, data) {
                        if (err) callback(null);else callback("" + data);
                    });
                } else try {
                    return fs.readFileSync(path);
                } catch (e) {
                    return null;
                }
            } else {
                var xhr = Util.XHR();
                xhr.open('GET', path, callback ? true : false);
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                xhr.setRequestHeader('Accept', 'text/plain');
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                if (callback) {
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState != 4) return;
                        if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') callback(xhr.responseText);else callback(null);
                    };
                    if (xhr.readyState == 4) return;
                    xhr.send(null);
                } else {
                    xhr.send(null);
                    if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') return xhr.responseText;
                    return null;
                }
            }
        };

        /**
         * Converts a string to camel case.
         * @param {string} str
         * @returns {string}
         * @expose
         */
        Util.toCamelCase = function (str) {
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                return $1.toUpperCase();
            });
        };

        return Util;
    }();

    /**
     * Language expressions.
     * @type {!Object.<string,!RegExp>}
     * @expose
     */
    ProtoBuf.Lang = {

        // Characters always ending a statement
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,

        // Field rules
        RULE: /^(?:required|optional|repeated|map)$/,

        // Field types
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,

        // Names
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,

        // Type definitions
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,

        // Type references
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,

        // Fully qualified type references
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,

        // All numbers
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,

        // Decimal numbers
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,

        // Hexadecimal numbers
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,

        // Octal numbers
        NUMBER_OCT: /^0[0-7]+$/,

        // Floating point numbers
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,

        // Booleans
        BOOL: /^(?:true|false)$/i,

        // Id numbers
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Negative id numbers (enum values)
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Whitespaces
        WHITESPACE: /\s/,

        // All strings
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,

        // Double quoted strings
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,

        // Single quoted strings
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
    };

    /**
     * @alias ProtoBuf.DotProto
     * @expose
     */
    ProtoBuf.DotProto = function (ProtoBuf, Lang) {
        "use strict";

        /**
         * Utilities to parse .proto files.
         * @exports ProtoBuf.DotProto
         * @namespace
         */

        var DotProto = {};

        /**
         * Constructs a new Tokenizer.
         * @exports ProtoBuf.DotProto.Tokenizer
         * @class prototype tokenizer
         * @param {string} proto Proto to tokenize
         * @constructor
         */
        var Tokenizer = function Tokenizer(proto) {

            /**
             * Source to parse.
             * @type {string}
             * @expose
             */
            this.source = proto + "";

            /**
             * Current index.
             * @type {number}
             * @expose
             */
            this.index = 0;

            /**
             * Current line.
             * @type {number}
             * @expose
             */
            this.line = 1;

            /**
             * Token stack.
             * @type {!Array.<string>}
             * @expose
             */
            this.stack = [];

            /**
             * Opening character of the current string read, if any.
             * @type {?string}
             * @private
             */
            this._stringOpen = null;
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer.prototype
         * @inner
         */
        var TokenizerPrototype = Tokenizer.prototype;

        /**
         * Reads a string beginning at the current index.
         * @return {string}
         * @private
         */
        TokenizerPrototype._readString = function () {
            var re = this._stringOpen === '"' ? Lang.STRING_DQ : Lang.STRING_SQ;
            re.lastIndex = this.index - 1; // Include the open quote
            var match = re.exec(this.source);
            if (!match) throw Error("unterminated string");
            this.index = re.lastIndex;
            this.stack.push(this._stringOpen);
            this._stringOpen = null;
            return match[1];
        };

        /**
         * Gets the next token and advances by one.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.next = function () {
            if (this.stack.length > 0) return this.stack.shift();
            if (this.index >= this.source.length) return null;
            if (this._stringOpen !== null) return this._readString();

            var repeat, prev, next;
            do {
                repeat = false;

                // Strip white spaces
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
                    if (next === '\n') ++this.line;
                    if (++this.index === this.source.length) return null;
                }

                // Strip comments
                if (this.source.charAt(this.index) === '/') {
                    ++this.index;
                    if (this.source.charAt(this.index) === '/') {
                        // Line
                        while (this.source.charAt(++this.index) !== '\n') {
                            if (this.index == this.source.length) return null;
                        }++this.index;
                        ++this.line;
                        repeat = true;
                    } else if ((next = this.source.charAt(this.index)) === '*') {
                        /* Block */
                        do {
                            if (next === '\n') ++this.line;
                            if (++this.index === this.source.length) return null;
                            prev = next;
                            next = this.source.charAt(this.index);
                        } while (prev !== '*' || next !== '/');
                        ++this.index;
                        repeat = true;
                    } else return '/';
                }
            } while (repeat);

            if (this.index === this.source.length) return null;

            // Read the next token
            var end = this.index;
            Lang.DELIM.lastIndex = 0;
            var delim = Lang.DELIM.test(this.source.charAt(end++));
            if (!delim) while (end < this.source.length && !Lang.DELIM.test(this.source.charAt(end))) {
                ++end;
            }var token = this.source.substring(this.index, this.index = end);
            if (token === '"' || token === "'") this._stringOpen = token;
            return token;
        };

        /**
         * Peeks for the next token.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.peek = function () {
            if (this.stack.length === 0) {
                var token = this.next();
                if (token === null) return null;
                this.stack.push(token);
            }
            return this.stack[0];
        };

        /**
         * Skips a specific token and throws if it differs.
         * @param {string} expected Expected token
         * @throws {Error} If the actual token differs
         */
        TokenizerPrototype.skip = function (expected) {
            var actual = this.next();
            if (actual !== expected) throw Error("illegal '" + actual + "', '" + expected + "' expected");
        };

        /**
         * Omits an optional token.
         * @param {string} expected Expected optional token
         * @returns {boolean} `true` if the token exists
         */
        TokenizerPrototype.omit = function (expected) {
            if (this.peek() === expected) {
                this.next();
                return true;
            }
            return false;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Tokenizer(index/length)"
         * @expose
         */
        TokenizerPrototype.toString = function () {
            return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")";
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer
         * @expose
         */
        DotProto.Tokenizer = Tokenizer;

        /**
         * Constructs a new Parser.
         * @exports ProtoBuf.DotProto.Parser
         * @class prototype parser
         * @param {string} source Source
         * @constructor
         */
        var Parser = function Parser(source) {

            /**
             * Tokenizer.
             * @type {!ProtoBuf.DotProto.Tokenizer}
             * @expose
             */
            this.tn = new Tokenizer(source);

            /**
             * Whether parsing proto3 or not.
             * @type {boolean}
             */
            this.proto3 = false;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser.prototype
         * @inner
         */
        var ParserPrototype = Parser.prototype;

        /**
         * Parses the source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        ParserPrototype.parse = function () {
            var topLevel = {
                "name": "[ROOT]", // temporary
                "package": null,
                "messages": [],
                "enums": [],
                "imports": [],
                "options": {},
                "services": []
                // "syntax": undefined
            };
            var token,
                head = true,
                weak;
            try {
                while (token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!head || topLevel["package"] !== null) throw Error("unexpected 'package'");
                            token = this.tn.next();
                            if (!Lang.TYPEREF.test(token)) throw Error("illegal package name: " + token);
                            this.tn.skip(";");
                            topLevel["package"] = token;
                            break;
                        case 'import':
                            if (!head) throw Error("unexpected 'import'");
                            token = this.tn.peek();
                            if (token === "public" || (weak = token === "weak")) // token ignored
                                this.tn.next();
                            token = this._readString();
                            this.tn.skip(";");
                            if (!weak) // import ignored
                                topLevel["imports"].push(token);
                            break;
                        case 'syntax':
                            if (!head) throw Error("unexpected 'syntax'");
                            this.tn.skip("=");
                            if ((topLevel["syntax"] = this._readString()) === "proto3") this.proto3 = true;
                            this.tn.skip(";");
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null);
                            head = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel);
                            head = false;
                            break;
                        case 'option':
                            this._parseOption(topLevel);
                            break;
                        case 'service':
                            this._parseService(topLevel);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel);
                            break;
                        default:
                            throw Error("unexpected '" + token + "'");
                    }
                }
            } catch (e) {
                e.message = "Parse error at line " + this.tn.line + ": " + e.message;
                throw e;
            }
            delete topLevel["name"];
            return topLevel;
        };

        /**
         * Parses the specified source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        Parser.parse = function (source) {
            return new Parser(source).parse();
        };

        // ----- Conversion ------

        /**
         * Converts a numerical string to an id.
         * @param {string} value
         * @param {boolean=} mayBeNegative
         * @returns {number}
         * @inner
         */
        function mkId(value, mayBeNegative) {
            var id = -1,
                sign = 1;
            if (value.charAt(0) == '-') {
                sign = -1;
                value = value.substring(1);
            }
            if (Lang.NUMBER_DEC.test(value)) id = parseInt(value);else if (Lang.NUMBER_HEX.test(value)) id = parseInt(value.substring(2), 16);else if (Lang.NUMBER_OCT.test(value)) id = parseInt(value.substring(1), 8);else throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            id = sign * id | 0; // Force to 32bit
            if (!mayBeNegative && id < 0) throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            return id;
        }

        /**
         * Converts a numerical string to a number.
         * @param {string} val
         * @returns {number}
         * @inner
         */
        function mkNumber(val) {
            var sign = 1;
            if (val.charAt(0) == '-') {
                sign = -1;
                val = val.substring(1);
            }
            if (Lang.NUMBER_DEC.test(val)) return sign * parseInt(val, 10);else if (Lang.NUMBER_HEX.test(val)) return sign * parseInt(val.substring(2), 16);else if (Lang.NUMBER_OCT.test(val)) return sign * parseInt(val.substring(1), 8);else if (val === 'inf') return sign * Infinity;else if (val === 'nan') return NaN;else if (Lang.NUMBER_FLT.test(val)) return sign * parseFloat(val);
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
        }

        // ----- Reading ------

        /**
         * Reads a string.
         * @returns {string}
         * @private
         */
        ParserPrototype._readString = function () {
            var value = "",
                token,
                delim;
            do {
                delim = this.tn.next();
                if (delim !== "'" && delim !== '"') throw Error("illegal string delimiter: " + delim);
                value += this.tn.next();
                this.tn.skip(delim);
                token = this.tn.peek();
            } while (token === '"' || token === '"'); // multi line?
            return value;
        };

        /**
         * Reads a value.
         * @param {boolean=} mayBeTypeRef
         * @returns {number|boolean|string}
         * @private
         */
        ParserPrototype._readValue = function (mayBeTypeRef) {
            var token = this.tn.peek(),
                value;
            if (token === '"' || token === "'") return this._readString();
            this.tn.next();
            if (Lang.NUMBER.test(token)) return mkNumber(token);
            if (Lang.BOOL.test(token)) return token.toLowerCase() === 'true';
            if (mayBeTypeRef && Lang.TYPEREF.test(token)) return token;
            throw Error("illegal value: " + token);
        };

        // ----- Parsing constructs -----

        /**
         * Parses a namespace option.
         * @param {!Object} parent Parent definition
         * @param {boolean=} isList
         * @private
         */
        ParserPrototype._parseOption = function (parent, isList) {
            var token = this.tn.next(),
                custom = false;
            if (token === '(') {
                custom = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
                throw Error("illegal option name: " + token);
            var name = token;
            if (custom) {
                // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                this.tn.skip(')');
                name = '(' + name + ')';
                token = this.tn.peek();
                if (Lang.FQTYPEREF.test(token)) {
                    name += token;
                    this.tn.next();
                }
            }
            this.tn.skip('=');
            this._parseOptionValue(parent, name);
            if (!isList) this.tn.skip(";");
        };

        /**
         * Sets an option on the specified options object.
         * @param {!Object.<string,*>} options
         * @param {string} name
         * @param {string|number|boolean} value
         * @inner
         */
        function setOption(options, name, value) {
            if (typeof options[name] === 'undefined') options[name] = value;else {
                if (!Array.isArray(options[name])) options[name] = [options[name]];
                options[name].push(value);
            }
        }

        /**
         * Parses an option value.
         * @param {!Object} parent
         * @param {string} name
         * @private
         */
        ParserPrototype._parseOptionValue = function (parent, name) {
            var token = this.tn.peek();
            if (token !== '{') {
                // Plain value
                setOption(parent["options"], name, this._readValue(true));
            } else {
                // Aggregate options
                this.tn.skip("{");
                while ((token = this.tn.next()) !== '}') {
                    if (!Lang.NAME.test(token)) throw Error("illegal option name: " + name + "." + token);
                    if (this.tn.omit(":")) setOption(parent["options"], name + "." + token, this._readValue(true));else this._parseOptionValue(parent, name + "." + token);
                }
            }
        };

        /**
         * Parses a service definition.
         * @param {!Object} parent Parent definition
         * @private
         */
        ParserPrototype._parseService = function (parent) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal service name at line " + this.tn.line + ": " + token);
            var name = token;
            var svc = {
                "name": name,
                "rpc": {},
                "options": {}
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(svc);else if (token === 'rpc') this._parseServiceRPC(svc);else throw Error("illegal service token: " + token);
            }
            this.tn.omit(";");
            parent["services"].push(svc);
        };

        /**
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
         * @param {!Object} svc Service definition
         * @private
         */
        ParserPrototype._parseServiceRPC = function (svc) {
            var type = "rpc",
                token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal rpc service method name: " + token);
            var name = token;
            var method = {
                "request": null,
                "response": null,
                "request_stream": false,
                "response_stream": false,
                "options": {}
            };
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["request_stream"] = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token)) throw Error("illegal rpc service request type: " + token);
            method["request"] = token;
            this.tn.skip(")");
            token = this.tn.next();
            if (token.toLowerCase() !== "returns") throw Error("illegal rpc service request type delimiter: " + token);
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["response_stream"] = true;
                token = this.tn.next();
            }
            method["response"] = token;
            this.tn.skip(")");
            token = this.tn.peek();
            if (token === '{') {
                this.tn.next();
                while ((token = this.tn.next()) !== '}') {
                    if (token === 'option') this._parseOption(method);else throw Error("illegal rpc service token: " + token);
                }
                this.tn.omit(";");
            } else this.tn.skip(";");
            if (typeof svc[type] === 'undefined') svc[type] = {};
            svc[type][name] = method;
        };

        /**
         * Parses a message definition.
         * @param {!Object} parent Parent definition
         * @param {!Object=} fld Field definition if this is a group
         * @returns {!Object}
         * @private
         */
        ParserPrototype._parseMessage = function (parent, fld) {
            var isGroup = !!fld,
                token = this.tn.next();
            var msg = {
                "name": "",
                "fields": [],
                "enums": [],
                "messages": [],
                "options": {},
                "services": [],
                "oneofs": {}
                // "extensions": undefined
            };
            if (!Lang.NAME.test(token)) throw Error("illegal " + (isGroup ? "group" : "message") + " name: " + token);
            msg["name"] = token;
            if (isGroup) {
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                msg["isGroup"] = true;
            }
            token = this.tn.peek();
            if (token === '[' && fld) this._parseFieldOptions(fld);
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(msg, token);else if (token === "oneof") this._parseMessageOneOf(msg);else if (token === "enum") this._parseEnum(msg);else if (token === "message") this._parseMessage(msg);else if (token === "option") this._parseOption(msg);else if (token === "service") this._parseService(msg);else if (token === "extensions") {
                    if (msg.hasOwnProperty("extensions")) {
                        msg["extensions"] = msg["extensions"].concat(this._parseExtensionRanges());
                    } else {
                        msg["extensions"] = this._parseExtensionRanges();
                    }
                } else if (token === "reserved") this._parseIgnored(); // TODO
                else if (token === "extend") this._parseExtend(msg);else if (Lang.TYPEREF.test(token)) {
                        if (!this.proto3) throw Error("illegal field rule: " + token);
                        this._parseMessageField(msg, "optional", token);
                    } else throw Error("illegal message token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(msg);
            return msg;
        };

        /**
         * Parses an ignored statement.
         * @private
         */
        ParserPrototype._parseIgnored = function () {
            while (this.tn.peek() !== ';') {
                this.tn.next();
            }this.tn.skip(";");
        };

        /**
         * Parses a message field.
         * @param {!Object} msg Message definition
         * @param {string} rule Field rule
         * @param {string=} type Field type if already known (never known for maps)
         * @returns {!Object} Field descriptor
         * @private
         */
        ParserPrototype._parseMessageField = function (msg, rule, type) {
            if (!Lang.RULE.test(rule)) throw Error("illegal message field rule: " + rule);
            var fld = {
                "rule": rule,
                "type": "",
                "name": "",
                "options": {},
                "id": 0
            };
            var token;
            if (rule === "map") {

                if (type) throw Error("illegal type: " + type);
                this.tn.skip('<');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field type: " + token);
                fld["keytype"] = token;
                this.tn.skip(',');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field: " + token);
                fld["type"] = token;
                this.tn.skip('>');
                token = this.tn.next();
                if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                fld["name"] = token;
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                token = this.tn.peek();
                if (token === '[') this._parseFieldOptions(fld);
                this.tn.skip(";");
            } else {

                type = typeof type !== 'undefined' ? type : this.tn.next();

                if (type === "group") {

                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    var grp = this._parseMessage(msg, fld);
                    if (!/^[A-Z]/.test(grp["name"])) throw Error('illegal group name: ' + grp["name"]);
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    this.tn.omit(";");
                } else {

                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type)) throw Error("illegal message field type: " + type);
                    fld["type"] = type;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                    fld["name"] = token;
                    this.tn.skip("=");
                    fld["id"] = mkId(this.tn.next());
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions(fld);
                    this.tn.skip(";");
                }
            }
            msg["fields"].push(fld);
            return fld;
        };

        /**
         * Parses a message oneof.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseMessageOneOf = function (msg) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal oneof name: " + token);
            var name = token,
                fld;
            var fields = [];
            this.tn.skip("{");
            while ((token = this.tn.next()) !== "}") {
                fld = this._parseMessageField(msg, "optional", token);
                fld["oneof"] = name;
                fields.push(fld["id"]);
            }
            this.tn.omit(";");
            msg["oneofs"][name] = fields;
        };

        /**
         * Parses a set of field option definitions.
         * @param {!Object} fld Field definition
         * @private
         */
        ParserPrototype._parseFieldOptions = function (fld) {
            this.tn.skip("[");
            var token,
                first = true;
            while ((token = this.tn.peek()) !== ']') {
                if (!first) this.tn.skip(",");
                this._parseOption(fld, true);
                first = false;
            }
            this.tn.next();
        };

        /**
         * Parses an enum.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseEnum = function (msg) {
            var enm = {
                "name": "",
                "values": [],
                "options": {}
            };
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
            enm["name"] = token;
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(enm);else {
                    if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
                    this.tn.skip("=");
                    var val = {
                        "name": token,
                        "id": mkId(this.tn.next(), true)
                    };
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions({ "options": {} });
                    this.tn.skip(";");
                    enm["values"].push(val);
                }
            }
            this.tn.omit(";");
            msg["enums"].push(enm);
        };

        /**
         * Parses extension / reserved ranges.
         * @returns {!Array.<!Array.<number>>}
         * @private
         */
        ParserPrototype._parseExtensionRanges = function () {
            var ranges = [];
            var token, range, value;
            do {
                range = [];
                while (true) {
                    token = this.tn.next();
                    switch (token) {
                        case "min":
                            value = ProtoBuf.ID_MIN;
                            break;
                        case "max":
                            value = ProtoBuf.ID_MAX;
                            break;
                        default:
                            value = mkNumber(token);
                            break;
                    }
                    range.push(value);
                    if (range.length === 2) break;
                    if (this.tn.peek() !== "to") {
                        range.push(value);
                        break;
                    }
                    this.tn.next();
                }
                ranges.push(range);
            } while (this.tn.omit(","));
            this.tn.skip(";");
            return ranges;
        };

        /**
         * Parses an extend block.
         * @param {!Object} parent Parent object
         * @private
         */
        ParserPrototype._parseExtend = function (parent) {
            var token = this.tn.next();
            if (!Lang.TYPEREF.test(token)) throw Error("illegal extend reference: " + token);
            var ext = {
                "ref": token,
                "fields": []
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(ext, token);else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3) throw Error("illegal field rule: " + token);
                    this._parseMessageField(ext, "optional", token);
                } else throw Error("illegal extend token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(ext);
            return ext;
        };

        // ----- General -----

        /**
         * Returns a string representation of this parser.
         * @returns {string}
         */
        ParserPrototype.toString = function () {
            return "Parser at line " + this.tn.line;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser
         * @expose
         */
        DotProto.Parser = Parser;

        return DotProto;
    }(ProtoBuf, ProtoBuf.Lang);

    /**
     * @alias ProtoBuf.Reflect
     * @expose
     */
    ProtoBuf.Reflect = function (ProtoBuf) {
        "use strict";

        /**
         * Reflection types.
         * @exports ProtoBuf.Reflect
         * @namespace
         */

        var Reflect = {};

        /**
         * Constructs a Reflect base class.
         * @exports ProtoBuf.Reflect.T
         * @constructor
         * @abstract
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         */
        var T = function T(builder, parent, name) {

            /**
             * Builder reference.
             * @type {!ProtoBuf.Builder}
             * @expose
             */
            this.builder = builder;

            /**
             * Parent object.
             * @type {?ProtoBuf.Reflect.T}
             * @expose
             */
            this.parent = parent;

            /**
             * Object name in namespace.
             * @type {string}
             * @expose
             */
            this.name = name;

            /**
             * Fully qualified class name
             * @type {string}
             * @expose
             */
            this.className;
        };

        /**
         * @alias ProtoBuf.Reflect.T.prototype
         * @inner
         */
        var TPrototype = T.prototype;

        /**
         * Returns the fully qualified name of this object.
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
         * @expose
         */
        TPrototype.fqn = function () {
            var name = this.name,
                ptr = this;
            do {
                ptr = ptr.parent;
                if (ptr == null) break;
                name = ptr.name + "." + name;
            } while (true);
            return name;
        };

        /**
         * Returns a string representation of this Reflect object (its fully qualified name).
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
         * @return String representation
         * @expose
         */
        TPrototype.toString = function (includeClass) {
            return (includeClass ? this.className + " " : "") + this.fqn();
        };

        /**
         * Builds this type.
         * @throws {Error} If this type cannot be built directly
         * @expose
         */
        TPrototype.build = function () {
            throw Error(this.toString(true) + " cannot be built directly");
        };

        /**
         * @alias ProtoBuf.Reflect.T
         * @expose
         */
        Reflect.T = T;

        /**
         * Constructs a new Namespace.
         * @exports ProtoBuf.Reflect.Namespace
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
         * @param {string} name Namespace name
         * @param {Object.<string,*>=} options Namespace options
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Namespace = function Namespace(builder, parent, name, options, syntax) {
            T.call(this, builder, parent, name);

            /**
             * @override
             */
            this.className = "Namespace";

            /**
             * Children inside the namespace.
             * @type {!Array.<ProtoBuf.Reflect.T>}
             */
            this.children = [];

            /**
             * Options.
             * @type {!Object.<string, *>}
             */
            this.options = options || {};

            /**
             * Syntax level (e.g., proto2 or proto3).
             * @type {!string}
             */
            this.syntax = syntax || "proto2";
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace.prototype
         * @inner
         */
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

        /**
         * Returns an array of the namespace's children.
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}
         * @expose
         */
        NamespacePrototype.getChildren = function (type) {
            type = type || null;
            if (type == null) return this.children.slice();
            var children = [];
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i] instanceof type) children.push(this.children[i]);
            }return children;
        };

        /**
         * Adds a child to the namespace.
         * @param {ProtoBuf.Reflect.T} child Child
         * @throws {Error} If the child cannot be added (duplicate)
         * @expose
         */
        NamespacePrototype.addChild = function (child) {
            var other;
            if (other = this.getChild(child.name)) {
                // Try to revert camelcase transformation on collision
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null) other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null) child.name = child.originalName;else throw Error("Duplicate name in namespace " + this.toString(true) + ": " + child.name);
            }
            this.children.push(child);
        };

        /**
         * Gets a child by its name or id.
         * @param {string|number} nameOrId Child name or id
         * @return {?ProtoBuf.Reflect.T} The child or null if not found
         * @expose
         */
        NamespacePrototype.getChild = function (nameOrId) {
            var key = typeof nameOrId === 'number' ? 'id' : 'name';
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i][key] === nameOrId) return this.children[i];
            }return null;
        };

        /**
         * Resolves a reflect object inside of this namespace.
         * @param {string|!Array.<string>} qn Qualified name to resolve
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
         * @expose
         */
        NamespacePrototype.resolve = function (qn, excludeNonNamespace) {
            var part = typeof qn === 'string' ? qn.split(".") : qn,
                ptr = this,
                i = 0;
            if (part[i] === "") {
                // Fully qualified name, e.g. ".My.Message'
                while (ptr.parent !== null) {
                    ptr = ptr.parent;
                }i++;
            }
            var child;
            do {
                do {
                    if (!(ptr instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    child = ptr.getChild(part[i]);
                    if (!child || !(child instanceof Reflect.T) || excludeNonNamespace && !(child instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    ptr = child;i++;
                } while (i < part.length);
                if (ptr != null) break; // Found
                // Else search the parent
                if (this.parent !== null) return this.parent.resolve(qn, excludeNonNamespace);
            } while (ptr != null);
            return ptr;
        };

        /**
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
         * @param {!ProtoBuf.Reflect.T} t Reflection type
         * @returns {string} The shortest qualified name or, if there is none, the fqn
         * @expose
         */
        NamespacePrototype.qn = function (t) {
            var part = [],
                ptr = t;
            do {
                part.unshift(ptr.name);
                ptr = ptr.parent;
            } while (ptr !== null);
            for (var len = 1; len <= part.length; len++) {
                var qn = part.slice(part.length - len);
                if (t === this.resolve(qn, t instanceof Reflect.Namespace)) return qn.join(".");
            }
            return t.fqn();
        };

        /**
         * Builds the namespace and returns the runtime counterpart.
         * @return {Object.<string,Function|Object>} Runtime namespace
         * @expose
         */
        NamespacePrototype.build = function () {
            /** @dict */
            var ns = {};
            var children = this.children;
            for (var i = 0, k = children.length, child; i < k; ++i) {
                child = children[i];
                if (child instanceof Namespace) ns[child.name] = child.build();
            }
            if (Object.defineProperty) Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
            return ns;
        };

        /**
         * Builds the namespace's '$options' property.
         * @return {Object.<string,*>}
         */
        NamespacePrototype.buildOpt = function () {
            var opt = {},
                keys = Object.keys(this.options);
            for (var i = 0, k = keys.length; i < k; ++i) {
                var key = keys[i],
                    val = this.options[keys[i]];
                // TODO: Options are not resolved, yet.
                // if (val instanceof Namespace) {
                //     opt[key] = val.build();
                // } else {
                opt[key] = val;
                // }
            }
            return opt;
        };

        /**
         * Gets the value assigned to the option with the specified name.
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
         */
        NamespacePrototype.getOption = function (name) {
            if (typeof name === 'undefined') return this.options;
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace
         * @expose
         */
        Reflect.Namespace = Namespace;

        /**
         * Constructs a new Element implementation that checks and converts values for a
         * particular field type, as appropriate.
         *
         * An Element represents a single value: either the value of a singular field,
         * or a value contained in one entry of a repeated field or map field. This
         * class does not implement these higher-level concepts; it only encapsulates
         * the low-level typechecking and conversion.
         *
         * @exports ProtoBuf.Reflect.Element
         * @param {{name: string, wireType: number}} type Resolved data type
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
         * (e.g. submessage field).
         * @param {boolean} isMapKey Is this element a Map key? The value will be
         * converted to string form if so.
         * @param {string} syntax Syntax level of defining message type, e.g.,
         * proto2 or proto3.
         * @param {string} name Name of the field containing this element (for error
         * messages)
         * @constructor
         */
        var Element = function Element(type, resolvedType, isMapKey, syntax, name) {

            /**
             * Element type, as a string (e.g., int32).
             * @type {{name: string, wireType: number}}
             */
            this.type = type;

            /**
             * Element type reference to submessage or enum definition, if needed.
             * @type {ProtoBuf.Reflect.T|null}
             */
            this.resolvedType = resolvedType;

            /**
             * Element is a map key.
             * @type {boolean}
             */
            this.isMapKey = isMapKey;

            /**
             * Syntax level of defining message type, e.g., proto2 or proto3.
             * @type {string}
             */
            this.syntax = syntax;

            /**
             * Name of the field containing this element (for error messages)
             * @type {string}
             */
            this.name = name;

            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0) throw Error("Invalid map key type: " + type.name);
        };

        var ElementPrototype = Element.prototype;

        /**
         * Obtains a (new) default value for the specified type.
         * @param type {string|{name: string, wireType: number}} Field type
         * @returns {*} Default value
         * @inner
         */
        function mkDefault(type) {
            if (typeof type === 'string') type = ProtoBuf.TYPES[type];
            if (typeof type.defaultValue === 'undefined') throw Error("default value for type " + type.name + " is not supported");
            if (type == ProtoBuf.TYPES["bytes"]) return new ByteBuffer(0);
            return type.defaultValue;
        }

        /**
         * Returns the default value for this field in proto3.
         * @function
         * @param type {string|{name: string, wireType: number}} the field type
         * @returns {*} Default value
         */
        Element.defaultFieldValue = mkDefault;

        /**
         * Makes a Long from a value.
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers
         * @returns {!Long}
         * @throws {Error} If the value cannot be converted to a Long
         * @inner
         */
        function mkLong(value, unsigned) {
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean' && value.low === value.low && value.high === value.high) return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string') return ProtoBuf.Long.fromString(value, unsigned || false, 10);
            if (typeof value === 'number') return ProtoBuf.Long.fromNumber(value, unsigned || false);
            throw Error("not convertible to Long");
        }

        ElementPrototype.toString = function () {
            return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';
        };

        /**
         * Checks if the given value can be set for an element of this type (singular
         * field or one element of a repeated field or map).
         * @param {*} value Value to check
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be verified for this element slot
         * @expose
         */
        ElementPrototype.verifyValue = function (value) {
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            switch (this.type) {
                // Signed 32bit
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                    // Account for !NaN: value === value
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value > 4294967295 ? value | 0 : value;

                // Unsigned 32bit
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value < 0 ? value >>> 0 : value;

                // Signed 64bit
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, false);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Unsigned 64bit
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, true);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value !== 'boolean') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a boolean");
                    return value;

                // Float
                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    if (typeof value !== 'number') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a number");
                    return value;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    if (typeof value !== 'string' && !(value && value instanceof String)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a string");
                    return "" + value; // Convert String object to string

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (ByteBuffer.isByteBuffer(value)) return value;
                    return ByteBuffer.wrap(value, "base64");

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    {
                        var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
                        for (i = 0; i < values.length; i++) {
                            if (values[i].name == value) return values[i].id;else if (values[i].id == value) return values[i].id;
                        }if (this.syntax === 'proto3') {
                            // proto3: just make sure it's an integer.
                            if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                            if (value > 4294967295 || value < 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not in range for uint32");
                            return value;
                        } else {
                            // proto2 requires enum values to be valid.
                            fail(value, "not a valid enum value");
                        }
                    }
                // Embedded message
                case ProtoBuf.TYPES["group"]:
                case ProtoBuf.TYPES["message"]:
                    {
                        if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== 'object') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "object expected");
                        if (value instanceof this.resolvedType.clazz) return value;
                        if (value instanceof ProtoBuf.Builder.Message) {
                            // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                            var obj = {};
                            for (var i in value) {
                                if (value.hasOwnProperty(i)) obj[i] = value[i];
                            }value = obj;
                        }
                        // Else let's try to construct one from a key-value object
                        return new this.resolvedType.clazz(value); // May throw for a hundred of reasons
                    }
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal value for " + this.toString(true) + ": " + value + " (undefined type " + this.type + ")");
        };

        /**
         * Calculates the byte length of an element on the wire.
         * @param {number} id Field number
         * @param {*} value Field value
         * @returns {number} Byte length
         * @throws {Error} If the value cannot be calculated
         * @expose
         */
        ElementPrototype.calculateLength = function (id, value) {
            if (value === null) return 0; // Nothing to encode
            // Tag has already been written
            var n;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["uint32"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["sint32"]:
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                case ProtoBuf.TYPES["fixed32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["float"]:
                    return 4;
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    return ByteBuffer.calculateVarint64(value);
                case ProtoBuf.TYPES["sint64"]:
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                case ProtoBuf.TYPES["fixed64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    return 8;
                case ProtoBuf.TYPES["bool"]:
                    return 1;
                case ProtoBuf.TYPES["enum"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["double"]:
                    return 8;
                case ProtoBuf.TYPES["string"]:
                    n = ByteBuffer.calculateUTF8Bytes(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                case ProtoBuf.TYPES["message"]:
                    n = this.resolvedType.calculate(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["group"]:
                    n = this.resolvedType.calculate(value);
                    return n + ByteBuffer.calculateVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
            }
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
        };

        /**
         * Encodes a value to the specified buffer. Does not encode the key.
         * @param {number} id Field number
         * @param {*} value Field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the value cannot be encoded
         * @expose
         */
        ElementPrototype.encodeValue = function (id, value, buffer) {
            if (value === null) return buffer; // Nothing to encode
            // Tag has already been written

            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long – it is, effectively, treated like a very large unsigned integer." (see #122)
                    if (value < 0) buffer.writeVarint64(value);else buffer.writeVarint32(value);
                    break;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    buffer.writeVarint32ZigZag(value);
                    break;

                // Fixed unsigned 32bit
                case ProtoBuf.TYPES["fixed32"]:
                    buffer.writeUint32(value);
                    break;

                // Fixed signed 32bit
                case ProtoBuf.TYPES["sfixed32"]:
                    buffer.writeInt32(value);
                    break;

                // 64bit varint as-is
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    buffer.writeVarint64(value); // throws
                    break;

                // 64bit varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    buffer.writeVarint64ZigZag(value); // throws
                    break;

                // Fixed unsigned 64bit
                case ProtoBuf.TYPES["fixed64"]:
                    buffer.writeUint64(value); // throws
                    break;

                // Fixed signed 64bit
                case ProtoBuf.TYPES["sfixed64"]:
                    buffer.writeInt64(value); // throws
                    break;

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value === 'string') buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);else buffer.writeVarint32(value ? 1 : 0);
                    break;

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    buffer.writeFloat32(value);
                    break;

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    buffer.writeFloat64(value);
                    break;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    buffer.writeVString(value);
                    break;

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    var prevOffset = value.offset;
                    buffer.writeVarint32(value.remaining());
                    buffer.append(value);
                    value.offset = prevOffset;
                    break;

                // Embedded message
                case ProtoBuf.TYPES["message"]:
                    var bb = new ByteBuffer().LE();
                    this.resolvedType.encode(value, bb);
                    buffer.writeVarint32(bb.offset);
                    buffer.append(bb.flip());
                    break;

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    this.resolvedType.encode(value, buffer);
                    buffer.writeVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
                    break;

                default:
                    // We should never end here
                    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
            }
            return buffer;
        };

        /**
         * Decode one element value from the specified buffer.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number} wireType The field wire type
         * @param {number} id The field number
         * @return {*} Decoded value
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        ElementPrototype.decode = function (buffer, wireType, id) {
            if (wireType != this.type.wireType) throw Error("Unexpected wire type for element");

            var value, nBytes;
            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    return buffer.readVarint32() | 0;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    return buffer.readVarint32() >>> 0;

                // 32bit signed varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    return buffer.readVarint32ZigZag() | 0;

                // Fixed 32bit unsigned
                case ProtoBuf.TYPES["fixed32"]:
                    return buffer.readUint32() >>> 0;

                case ProtoBuf.TYPES["sfixed32"]:
                    return buffer.readInt32() | 0;

                // 64bit signed varint
                case ProtoBuf.TYPES["int64"]:
                    return buffer.readVarint64();

                // 64bit unsigned varint
                case ProtoBuf.TYPES["uint64"]:
                    return buffer.readVarint64().toUnsigned();

                // 64bit signed varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    return buffer.readVarint64ZigZag();

                // Fixed 64bit unsigned
                case ProtoBuf.TYPES["fixed64"]:
                    return buffer.readUint64();

                // Fixed 64bit signed
                case ProtoBuf.TYPES["sfixed64"]:
                    return buffer.readInt64();

                // Bool varint
                case ProtoBuf.TYPES["bool"]:
                    return !!buffer.readVarint32();

                // Constant enum value (varint)
                case ProtoBuf.TYPES["enum"]:
                    // The following Builder.Message#set will already throw
                    return buffer.readVarint32();

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    return buffer.readFloat();

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    return buffer.readDouble();

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    return buffer.readVString();

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset + nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                // Length-delimited embedded message
                case ProtoBuf.TYPES["message"]:
                    {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    return this.resolvedType.decode(buffer, -1, id);
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal decode type");
        };

        /**
         * Converts a value from a string to the canonical element type.
         *
         * Legal only when isMapKey is true.
         *
         * @param {string} str The string value
         * @returns {*} The value
         */
        ElementPrototype.valueFromString = function (str) {
            if (!this.isMapKey) {
                throw Error("valueFromString() called on non-map-key element");
            }

            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return this.verifyValue(parseInt(str));

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    // Long-based fields support conversions from string already.
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bool"]:
                    return str === "true";

                case ProtoBuf.TYPES["string"]:
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bytes"]:
                    return ByteBuffer.fromBinary(str);
            }
        };

        /**
         * Converts a value from the canonical element type to a string.
         *
         * It should be the case that `valueFromString(valueToString(val))` returns
         * a value equivalent to `verifyValue(val)` for every legal value of `val`
         * according to this element type.
         *
         * This may be used when the element must be stored or used as a string,
         * e.g., as a map key on an Object.
         *
         * Legal only when isMapKey is true.
         *
         * @param {*} val The value
         * @returns {string} The string form of the value.
         */
        ElementPrototype.valueToString = function (value) {
            if (!this.isMapKey) {
                throw Error("valueToString() called on non-map-key element");
            }

            if (this.type === ProtoBuf.TYPES["bytes"]) {
                return value.toString("binary");
            } else {
                return value.toString();
            }
        };

        /**
         * @alias ProtoBuf.Reflect.Element
         * @expose
         */
        Reflect.Element = Element;

        /**
         * Constructs a new Message.
         * @exports ProtoBuf.Reflect.Message
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
         * @param {string} name Message name
         * @param {Object.<string,*>=} options Message options
         * @param {boolean=} isGroup `true` if this is a legacy group
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Message = function Message(builder, parent, name, options, isGroup, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Message";

            /**
             * Extensions range.
             * @type {!Array.<number>|undefined}
             * @expose
             */
            this.extensions = undefined;

            /**
             * Runtime message class.
             * @type {?function(new:ProtoBuf.Builder.Message)}
             * @expose
             */
            this.clazz = null;

            /**
             * Whether this is a legacy group or not.
             * @type {boolean}
             * @expose
             */
            this.isGroup = !!isGroup;

            // The following cached collections are used to efficiently iterate over or look up fields when decoding.

            /**
             * Cached fields.
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fields = null;

            /**
             * Cached fields by id.
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsById = null;

            /**
             * Cached fields by name.
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsByName = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Message.prototype
         * @inner
         */
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the message and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Message
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
         * @return {ProtoBuf.Reflect.Message} Message class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        MessagePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Message class in its own scope
            var clazz = function (ProtoBuf, T) {

                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

                /**
                 * Constructs a new runtime Message.
                 * @name ProtoBuf.Builder.Message
                 * @class Barebone of all runtime messages.
                 * @param {!Object.<string,*>|string} values Preset values
                 * @param {...string} var_args
                 * @constructor
                 * @throws {Error} If the message cannot be created
                 */
                var Message = function Message(values, var_args) {
                    ProtoBuf.Builder.Message.call(this);

                    // Create virtual oneof properties
                    for (var i = 0, k = oneofs.length; i < k; ++i) {
                        this[oneofs[i].name] = null;
                    } // Create fields and set default values
                    for (i = 0, k = fields.length; i < k; ++i) {
                        var field = fields[i];
                        this[field.name] = field.repeated ? [] : field.map ? new ProtoBuf.Map(field) : null;
                        if ((field.required || T.syntax === 'proto3') && field.defaultValue !== null) this[field.name] = field.defaultValue;
                    }

                    if (arguments.length > 0) {
                        var value;
                        // Set field values from a values object
                        if (arguments.length === 1 && values !== null && (typeof values === "undefined" ? "undefined" : _typeof(values)) === 'object' && (
                        /* not _another_ Message */typeof values.encode !== 'function' || values instanceof Message) &&
                        /* not a repeated field */!Array.isArray(values) &&
                        /* not a Map */!(values instanceof ProtoBuf.Map) &&
                        /* not a ByteBuffer */!ByteBuffer.isByteBuffer(values) &&
                        /* not an ArrayBuffer */!(values instanceof ArrayBuffer) &&
                        /* not a Long */!(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            this.$set(values);
                        } else // Set field values from arguments, in declaration order
                            for (i = 0, k = arguments.length; i < k; ++i) {
                                if (typeof (value = arguments[i]) !== 'undefined') this.$set(fields[i].name, value);
                            } // May throw
                    }
                };

                /**
                 * @alias ProtoBuf.Builder.Message.prototype
                 * @inner
                 */
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                /**
                 * Adds a value to a repeated field.
                 * @name ProtoBuf.Builder.Message#add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.add = function (key, value, noAssert) {
                    var field = T._fieldsByName[key];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + key + " is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated) throw Error(this + "#" + key + " is not a repeated field");
                        value = field.verifyValue(value, true);
                    }
                    if (this[key] === null) this[key] = [];
                    this[key].push(value);
                    return this;
                };

                /**
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                 * @name ProtoBuf.Builder.Message#$add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.$add = MessagePrototype.add;

                /**
                 * Sets a field's value.
                 * @name ProtoBuf.Builder.Message#set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.set = function (keyOrObj, value, noAssert) {
                    if (keyOrObj && (typeof keyOrObj === "undefined" ? "undefined" : _typeof(keyOrObj)) === 'object') {
                        noAssert = value;
                        for (var ikey in keyOrObj) {
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined') this.$set(ikey, value, noAssert);
                        }return this;
                    }
                    var field = T._fieldsByName[keyOrObj];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + keyOrObj + " is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + keyOrObj + " is not a field: " + field.toString(true));
                        this[field.name] = value = field.verifyValue(value); // May throw
                    } else this[keyOrObj] = value;
                    if (field && field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
                        if (value !== null) {
                            if (currentField !== null && currentField !== field.name) this[currentField] = null; // Clear currently set field
                            this[field.oneof.name] = field.name; // Point virtual field at this field
                        } else if ( /* value === null && */currentField === keyOrObj) this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
                    }
                    return this;
                };

                /**
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                 * @name ProtoBuf.Builder.Message#$set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.$set = MessagePrototype.set;

                /**
                 * Gets a field's value.
                 * @name ProtoBuf.Builder.Message#get
                 * @function
                 * @param {string} key Key
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.get = function (key, noAssert) {
                    if (noAssert) return this[key];
                    var field = T._fieldsByName[key];
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: undefined");
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true));
                    return this[field.name];
                };

                /**
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                 * @name ProtoBuf.Builder.Message#$get
                 * @function
                 * @param {string} key Key
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.$get = MessagePrototype.get;

                // Getters and setters

                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    // no setters for extension fields as these are named by their fqn
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField) continue;

                    if (T.builder.options['populateAccessors']) (function (field) {
                        // set/get[SomeValue]
                        var Name = field.originalName.replace(/(_[a-zA-Z])/g, function (match) {
                            return match.toUpperCase().replace('_', '');
                        });
                        Name = Name.substring(0, 1).toUpperCase() + Name.substring(1);

                        // set/get_[some_value] FIXME: Do we really need these?
                        var name = field.originalName.replace(/([A-Z])/g, function (match) {
                            return "_" + match;
                        });

                        /**
                         * The current field's unbound setter function.
                         * @function
                         * @param {*} value
                         * @param {boolean=} noAssert
                         * @returns {!ProtoBuf.Builder.Message}
                         * @inner
                         */
                        var setter = function setter(value, noAssert) {
                            this[field.name] = noAssert ? value : field.verifyValue(value);
                            return this;
                        };

                        /**
                         * The current field's unbound getter function.
                         * @function
                         * @returns {*}
                         * @inner
                         */
                        var getter = function getter() {
                            return this[field.name];
                        };

                        if (T.getChild("set" + Name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set" + Name] = setter;

                        if (T.getChild("set_" + name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set_" + name] = setter;

                        if (T.getChild("get" + Name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            MessagePrototype["get" + Name] = getter;

                        if (T.getChild("get_" + name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            MessagePrototype["get_" + name] = getter;
                    })(field);
                }

                // En-/decoding

                /**
                 * Encodes the message.
                 * @name ProtoBuf.Builder.Message#$encode
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message#encode64
                 * @see ProtoBuf.Builder.Message#encodeHex
                 * @see ProtoBuf.Builder.Message#encodeAB
                 */
                MessagePrototype.encode = function (buffer, noVerify) {
                    if (typeof buffer === 'boolean') noVerify = buffer, buffer = undefined;
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var le = buffer.littleEndian;
                    try {
                        T.encode(this, buffer.LE(), noVerify);
                        return (isNew ? buffer.flip() : buffer).LE(le);
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Encodes a message using the specified data payload.
                 * @param {!Object.<string,*>} data Data payload
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @expose
                 */
                Message.encode = function (data, buffer, noVerify) {
                    return new Message(data).encode(buffer, noVerify);
                };

                /**
                 * Calculates the byte length of the message.
                 * @name ProtoBuf.Builder.Message#calculate
                 * @function
                 * @returns {number} Byte length
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
                 * @expose
                 */
                MessagePrototype.calculate = function () {
                    return T.calculate(this);
                };

                /**
                 * Encodes the varint32 length-delimited message.
                 * @name ProtoBuf.Builder.Message#encodeDelimited
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeDelimited = function (buffer, noVerify) {
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var enc = new ByteBuffer().LE();
                    T.encode(this, enc, noVerify).flip();
                    buffer.writeVarint32(enc.remaining());
                    buffer.append(enc);
                    return isNew ? buffer.flip() : buffer;
                };

                /**
                 * Directly encodes the message to an ArrayBuffer.
                 * @name ProtoBuf.Builder.Message#encodeAB
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeAB = function () {
                    try {
                        return this.encode().toArrayBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

                /**
                 * Directly encodes the message to a node Buffer.
                 * @name ProtoBuf.Builder.Message#encodeNB
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeNB = function () {
                    try {
                        return this.encode().toBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;

                /**
                 * Directly encodes the message to a base64 encoded string.
                 * @name ProtoBuf.Builder.Message#encode64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encode64 = function () {
                    try {
                        return this.encode().toBase64();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBase64 = MessagePrototype.encode64;

                /**
                 * Directly encodes the message to a hex encoded string.
                 * @name ProtoBuf.Builder.Message#encodeHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeHex = function () {
                    try {
                        return this.encode().toHex();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toHex = MessagePrototype.encodeHex;

                /**
                 * Clones a message object or field value to a raw object.
                 * @param {*} obj Object to clone
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
                 * @returns {*} Cloned object
                 * @inner
                 */
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
                    if (obj === null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== 'object') {
                        // Convert enum values to their respective names
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
                            if (name !== null) return name;
                        }
                        // Pass-through string, number, boolean, null...
                        return obj;
                    }
                    // Convert ByteBuffers to raw buffer or strings
                    if (ByteBuffer.isByteBuffer(obj)) return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
                    // Convert Longs to proper objects or strings
                    if (ProtoBuf.Long.isLong(obj)) return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
                    var clone;
                    // Clone arrays
                    if (Array.isArray(obj)) {
                        clone = [];
                        obj.forEach(function (v, k) {
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                        });
                        return clone;
                    }
                    clone = {};
                    // Convert maps to objects
                    if (obj instanceof ProtoBuf.Map) {
                        var it = obj.entries();
                        for (var e = it.next(); !e.done; e = it.next()) {
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        }return clone;
                    }
                    // Everything else is a non-null object
                    var type = obj.$type,
                        field = undefined;
                    for (var i in obj) {
                        if (obj.hasOwnProperty(i)) {
                            if (type && (field = type.getChild(i))) clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);else clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
                        }
                    }return clone;
                }

                /**
                 * Returns the message's raw payload.
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @returns {Object.<string,*>} Raw payload
                 * @expose
                 */
                MessagePrototype.toRaw = function (binaryAsBase64, longsAsStrings) {
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                };

                /**
                 * Encodes a message to JSON.
                 * @returns {string} JSON string
                 * @expose
                 */
                MessagePrototype.encodeJSON = function () {
                    return JSON.stringify(cloneRaw(this,
                    /* binary-as-base64 */true,
                    /* longs-as-strings */true, this.$type));
                };

                /**
                 * Decodes a message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decode
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message.decode64
                 * @see ProtoBuf.Builder.Message.decodeHex
                 */
                Message.decode = function (buffer, length, enc) {
                    if (typeof length === 'string') enc = length, length = -1;
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    var le = buffer.littleEndian;
                    try {
                        var msg = T.decode(buffer.LE(), length);
                        buffer.LE(le);
                        return msg;
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Decodes a varint32 length-delimited message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decodeDelimited
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeDelimited = function (buffer, enc) {
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    if (buffer.remaining() < 1) return null;
                    var off = buffer.offset,
                        len = buffer.readVarint32();
                    if (buffer.remaining() < len) {
                        buffer.offset = off;
                        return null;
                    }
                    try {
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    } catch (err) {
                        buffer.offset += len;
                        throw err;
                    }
                };

                /**
                 * Decodes the message from the specified base64 encoded string.
                 * @name ProtoBuf.Builder.Message.decode64
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decode64 = function (str) {
                    return Message.decode(str, "base64");
                };

                /**
                 * Decodes the message from the specified hex encoded string.
                 * @name ProtoBuf.Builder.Message.decodeHex
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeHex = function (str) {
                    return Message.decode(str, "hex");
                };

                /**
                 * Decodes the message from a JSON string.
                 * @name ProtoBuf.Builder.Message.decodeJSON
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are
                 * missing.
                 * @expose
                 */
                Message.decodeJSON = function (str) {
                    return new Message(JSON.parse(str));
                };

                // Utility

                /**
                 * Returns a string representation of this Message.
                 * @name ProtoBuf.Builder.Message#toString
                 * @function
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
                 * @expose
                 */
                MessagePrototype.toString = function () {
                    return T.toString();
                };

                // Properties

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message.$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message#$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Message, '$options', { "value": T.buildOpt() }), Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }), Object.defineProperty(Message, "$type", { "value": T }), Object.defineProperty(MessagePrototype, "$type", { "value": T });

                return Message;
            }(ProtoBuf, this);

            // Static enums and prototyped sub-messages / cached collections
            this._fields = [];
            this._fieldsById = {};
            this._fieldsByName = {};
            for (var i = 0, k = this.children.length, child; i < k; i++) {
                child = this.children[i];
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                    if (clazz.hasOwnProperty(child.name)) throw Error("Illegal reflect child of " + this.toString(true) + ": " + child.toString(true) + " cannot override static property '" + child.name + "'");
                    clazz[child.name] = child.build();
                } else if (child instanceof Message.Field) child.build(), this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child;else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
                    throw Error("Illegal reflect child of " + this.toString(true) + ": " + this.children[i].toString(true));
            }

            return this.clazz = clazz;
        };

        /**
         * Encodes a runtime message's contents to the specified buffer.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @param {ByteBuffer} buffer ByteBuffer to write to
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
         * @expose
         */
        MessagePrototype.encode = function (message, buffer, noVerify) {
            var fieldMissing = null,
                field;
            for (var i = 0, k = this._fields.length, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) {
                    if (fieldMissing === null) fieldMissing = field;
                } else field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
            }
            if (fieldMissing !== null) {
                var err = Error("Missing at least one required field for " + this.toString(true) + ": " + fieldMissing);
                err["encoded"] = buffer; // Still expose what we got
                throw err;
            }
            return buffer;
        };

        /**
         * Calculates a runtime message's byte length.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @returns {number} Byte length
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
         * @expose
         */
        MessagePrototype.calculate = function (message) {
            for (var n = 0, i = 0, k = this._fields.length, field, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) throw Error("Missing at least one required field for " + this.toString(true) + ": " + field);else n += field.calculate(val, message);
            }
            return n;
        };

        /**
         * Skips all data until the end of the specified group has been reached.
         * @param {number} expectedId Expected GROUPEND id
         * @param {!ByteBuffer} buf ByteBuffer
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
         * @inner
         */
        function skipTillGroupEnd(expectedId, buf) {
            var tag = buf.readVarint32(),
                // Throws on OOB
            wireType = tag & 0x07,
                id = tag >>> 3;
            switch (wireType) {
                case ProtoBuf.WIRE_TYPES.VARINT:
                    do {
                        tag = buf.readUint8();
                    } while ((tag & 0x80) === 0x80);
                    break;
                case ProtoBuf.WIRE_TYPES.BITS64:
                    buf.offset += 8;
                    break;
                case ProtoBuf.WIRE_TYPES.LDELIM:
                    tag = buf.readVarint32(); // reads the varint
                    buf.offset += tag; // skips n bytes
                    break;
                case ProtoBuf.WIRE_TYPES.STARTGROUP:
                    skipTillGroupEnd(id, buf);
                    break;
                case ProtoBuf.WIRE_TYPES.ENDGROUP:
                    if (id === expectedId) return false;else throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");
                case ProtoBuf.WIRE_TYPES.BITS32:
                    buf.offset += 4;
                    break;
                default:
                    throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
            }
            return true;
        }

        /**
         * Decodes an encoded message and returns the decoded message.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number=} length Message length. Defaults to decode all remaining data.
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
         * @return {ProtoBuf.Builder.Message} Decoded message
         * @throws {Error} If the message cannot be decoded
         * @expose
         */
        MessagePrototype.decode = function (buffer, length, expectedGroupEndId) {
            if (typeof length !== 'number') length = -1;
            var start = buffer.offset,
                msg = new this.clazz(),
                tag,
                wireType,
                id,
                field;
            while (buffer.offset < start + length || length === -1 && buffer.remaining() > 0) {
                tag = buffer.readVarint32();
                wireType = tag & 0x07;
                id = tag >>> 3;
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                    if (id !== expectedGroupEndId) throw Error("Illegal group end indicator for " + this.toString(true) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
                    break;
                }
                if (!(field = this._fieldsById[id])) {
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {
                        case ProtoBuf.WIRE_TYPES.VARINT:
                            buffer.readVarint32();
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS32:
                            buffer.offset += 4;
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS64:
                            buffer.offset += 8;
                            break;
                        case ProtoBuf.WIRE_TYPES.LDELIM:
                            var len = buffer.readVarint32();
                            buffer.offset += len;
                            break;
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            while (skipTillGroupEnd(id, buffer)) {}
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(true) + "#decode: " + wireType);
                    }
                    continue;
                }
                if (field.repeated && !field.options["packed"]) {
                    msg[field.name].push(field.decode(wireType, buffer));
                } else if (field.map) {
                    var keyval = field.decode(wireType, buffer);
                    msg[field.name].set(keyval[0], keyval[1]);
                } else {
                    msg[field.name] = field.decode(wireType, buffer);
                    if (field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
                        if (currentField !== null && currentField !== field.name) msg[currentField] = null; // Clear currently set field
                        msg[field.oneof.name] = field.name; // Point virtual field at this field
                    }
                }
            }

            // Check if all required fields are present and set default values for optional fields that are not
            for (var i = 0, k = this._fields.length; i < k; ++i) {
                field = this._fields[i];
                if (msg[field.name] === null) {
                    if (this.syntax === "proto3") {
                        // Proto3 sets default values by specification
                        msg[field.name] = field.defaultValue;
                    } else if (field.required) {
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got
                        throw err;
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null) msg[field.name] = field.defaultValue;
                }
            }
            return msg;
        };

        /**
         * @alias ProtoBuf.Reflect.Message
         * @expose
         */
        Reflect.Message = Message;

        /**
         * Constructs a new Message Field.
         * @exports ProtoBuf.Reflect.Message.Field
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string?} keytype Key data type, if any.
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {Object.<string,*>=} options Options
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Field = function Field(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
            T.call(this, builder, message, name);

            /**
             * @override
             */
            this.className = "Message.Field";

            /**
             * Message field required flag.
             * @type {boolean}
             * @expose
             */
            this.required = rule === "required";

            /**
             * Message field repeated flag.
             * @type {boolean}
             * @expose
             */
            this.repeated = rule === "repeated";

            /**
             * Message field map flag.
             * @type {boolean}
             * @expose
             */
            this.map = rule === "map";

            /**
             * Message field key type. Type reference string if unresolved, protobuf
             * type if resolved. Valid only if this.map === true, null otherwise.
             * @type {string|{name: string, wireType: number}|null}
             * @expose
             */
            this.keyType = keytype || null;

            /**
             * Message field type. Type reference string if unresolved, protobuf type if
             * resolved. In a map field, this is the value type.
             * @type {string|{name: string, wireType: number}}
             * @expose
             */
            this.type = type;

            /**
             * Resolved type reference inside the global namespace.
             * @type {ProtoBuf.Reflect.T|null}
             * @expose
             */
            this.resolvedType = null;

            /**
             * Unique message field id.
             * @type {number}
             * @expose
             */
            this.id = id;

            /**
             * Message field options.
             * @type {!Object.<string,*>}
             * @dict
             * @expose
             */
            this.options = options || {};

            /**
             * Default value.
             * @type {*}
             * @expose
             */
            this.defaultValue = null;

            /**
             * Enclosing OneOf.
             * @type {?ProtoBuf.Reflect.Message.OneOf}
             * @expose
             */
            this.oneof = oneof || null;

            /**
             * Syntax level of this definition (e.g., proto3).
             * @type {string}
             * @expose
             */
            this.syntax = syntax || 'proto2';

            /**
             * Original field name.
             * @type {string}
             * @expose
             */
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

            /**
             * Element implementation. Created in build() after types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.element = null;

            /**
             * Key element implementation, for map fields. Created in build() after
             * types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.keyElement = null;

            // Convert field names to camel case notation if the override is set
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField)) this.name = ProtoBuf.Util.toCamelCase(this.name);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field.prototype
         * @inner
         */
        var FieldPrototype = Field.prototype = Object.create(T.prototype);

        /**
         * Builds the field.
         * @override
         * @expose
         */
        FieldPrototype.build = function () {
            this.element = new Element(this.type, this.resolvedType, false, this.syntax, this.name);
            if (this.map) this.keyElement = new Element(this.keyType, undefined, true, this.syntax, this.name);

            // In proto3, fields do not have field presence, and every field is set to
            // its type's default value ("", 0, 0.0, or false).
            if (this.syntax === 'proto3' && !this.repeated && !this.map) this.defaultValue = Element.defaultFieldValue(this.type);

            // Otherwise, default values are present when explicitly specified
            else if (typeof this.options['default'] !== 'undefined') this.defaultValue = this.verifyValue(this.options['default']);
        };

        /**
         * Checks if the given value can be set for this field.
         * @param {*} value Value to check
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be set for this field
         * @expose
         */
        FieldPrototype.verifyValue = function (value, skipRepeated) {
            skipRepeated = skipRepeated || false;
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            if (value === null) {
                // NULL values for optional fields
                if (this.required) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "required");
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"]) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "proto3 field without field presence cannot be null");
                return null;
            }
            var i;
            if (this.repeated && !skipRepeated) {
                // Repeated values as arrays
                if (!Array.isArray(value)) value = [value];
                var res = [];
                for (i = 0; i < value.length; i++) {
                    res.push(this.element.verifyValue(value[i]));
                }return res;
            }
            if (this.map && !skipRepeated) {
                // Map values as objects
                if (!(value instanceof ProtoBuf.Map)) {
                    // If not already a Map, attempt to convert.
                    if (!(value instanceof Object)) {
                        fail(typeof value === "undefined" ? "undefined" : _typeof(value), "expected ProtoBuf.Map or raw object for map field");
                    }
                    return new ProtoBuf.Map(this, value);
                } else {
                    return value;
                }
            }
            // All non-repeated fields expect no array
            if (!this.repeated && Array.isArray(value)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "no array expected");

            return this.element.verifyValue(value);
        };

        /**
         * Determines whether the field will have a presence on the wire given its
         * value.
         * @param {*} value Verified field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {boolean} Whether the field will be present on the wire
         */
        FieldPrototype.hasWirePresence = function (value, message) {
            if (this.syntax !== 'proto3') return value !== null;
            if (this.oneof && message[this.oneof.name] === this.name) return true;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return value !== 0;

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    return value.low !== 0 || value.high !== 0;

                case ProtoBuf.TYPES["bool"]:
                    return value;

                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    return value !== 0.0;

                case ProtoBuf.TYPES["string"]:
                    return value.length > 0;

                case ProtoBuf.TYPES["bytes"]:
                    return value.remaining() > 0;

                case ProtoBuf.TYPES["enum"]:
                    return value !== 0;

                case ProtoBuf.TYPES["message"]:
                    return value !== null;
                default:
                    return true;
            }
        };

        /**
         * Encodes the specified field value to the specified buffer.
         * @param {*} value Verified field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the field cannot be encoded
         * @expose
         */
        FieldPrototype.encode = function (value, buffer, message) {
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return buffer; // Optional omitted
            try {
                if (this.repeated) {
                    var i;
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin
                        for (i = 0; i < value.length; i++) {
                            this.element.encodeValue(this.id, value[i], buffer);
                        }var len = buffer.offset - start,
                            varintLen = ByteBuffer.calculateVarint32(len);
                        if (varintLen > 1) {
                            // We need to move the contents
                            var contents = buffer.slice(start, buffer.offset);
                            start += varintLen - 1;
                            buffer.offset = start;
                            buffer.append(contents);
                        }
                        buffer.writeVarint32(len, start - varintLen);
                    } else {
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"
                        for (i = 0; i < value.length; i++) {
                            buffer.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, value[i], buffer);
                        }
                    }
                } else if (this.map) {
                    // Write out each map entry as a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        // Submessage with wire type of length-delimited.
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.writeVarint32(length);

                        // Write out the key and val.
                        buffer.writeVarint32(1 << 3 | this.keyType.wireType);
                        this.keyElement.encodeValue(1, key, buffer);
                        buffer.writeVarint32(2 << 3 | this.type.wireType);
                        this.element.encodeValue(2, val, buffer);
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        buffer.writeVarint32(this.id << 3 | this.type.wireType);
                        this.element.encodeValue(this.id, value, buffer);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return buffer;
        };

        /**
         * Calculates the length of this field's value on the network level.
         * @param {*} value Field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @returns {number} Byte length
         * @expose
         */
        FieldPrototype.calculate = function (value, message) {
            value = this.verifyValue(value); // May throw
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return 0; // Optional omitted
            var n = 0;
            try {
                if (this.repeated) {
                    var i, ni;
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        ni = 0;
                        for (i = 0; i < value.length; i++) {
                            ni += this.element.calculateLength(this.id, value[i]);
                        }n += ByteBuffer.calculateVarint32(ni);
                        n += ni;
                    } else {
                        for (i = 0; i < value.length; i++) {
                            n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), n += this.element.calculateLength(this.id, value[i]);
                        }
                    }
                } else if (this.map) {
                    // Each map entry becomes a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        n += ByteBuffer.calculateVarint32(length);
                        n += length;
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType);
                        n += this.element.calculateLength(this.id, value);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return n;
        };

        /**
         * Decode the field value from the specified buffer.
         * @param {number} wireType Leading wire type
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
         *             map fields, or an individual value otherwise.
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        FieldPrototype.decode = function (wireType, buffer, skipRepeated) {
            var value, nBytes;

            // We expect wireType to match the underlying type's wireType unless we see
            // a packed repeated field, or unless this is a map field.
            var wireTypeOK = !this.map && wireType == this.type.wireType || !skipRepeated && this.repeated && this.options["packed"] && wireType == ProtoBuf.WIRE_TYPES.LDELIM || this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM;
            if (!wireTypeOK) throw Error("Illegal wire type for field " + this.toString(true) + ": " + wireType + " (" + this.type.wireType + " expected)");

            // Handle packed repeated fields.
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {
                    nBytes = buffer.readVarint32();
                    nBytes = buffer.offset + nBytes; // Limit
                    var values = [];
                    while (buffer.offset < nBytes) {
                        values.push(this.decode(this.type.wireType, buffer, true));
                    }return values;
                }
                // Read the next value otherwise...
            }

            // Handle maps.
            if (this.map) {
                // Read one (key, value) submessage, and return [key, value]
                var key = Element.defaultFieldValue(this.keyType);
                value = Element.defaultFieldValue(this.type);

                // Read the length
                nBytes = buffer.readVarint32();
                if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());

                // Get a sub-buffer of this key/value submessage
                var msgbuf = buffer.clone();
                msgbuf.limit = msgbuf.offset + nBytes;
                buffer.offset += nBytes;

                while (msgbuf.remaining() > 0) {
                    var tag = msgbuf.readVarint32();
                    wireType = tag & 0x07;
                    var id = tag >>> 3;
                    if (id === 1) {
                        key = this.keyElement.decode(msgbuf, wireType, id);
                    } else if (id === 2) {
                        value = this.element.decode(msgbuf, wireType, id);
                    } else {
                        throw Error("Unexpected tag in map field key/value submessage");
                    }
                }

                return [key, value];
            }

            // Handle singular and non-packed repeated field values.
            return this.element.decode(buffer, wireType, this.id);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field
         * @expose
         */
        Reflect.Message.Field = Field;

        /**
         * Constructs a new Message ExtensionField.
         * @exports ProtoBuf.Reflect.Message.ExtensionField
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {!Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Message.Field
         */
        var ExtensionField = function ExtensionField(builder, message, rule, type, name, id, options) {
            Field.call(this, builder, message, rule, /* keytype = */null, type, name, id, options);

            /**
             * Extension reference.
             * @type {!ProtoBuf.Reflect.Extension}
             * @expose
             */
            this.extension;
        };

        // Extends Field
        ExtensionField.prototype = Object.create(Field.prototype);

        /**
         * @alias ProtoBuf.Reflect.Message.ExtensionField
         * @expose
         */
        Reflect.Message.ExtensionField = ExtensionField;

        /**
         * Constructs a new Message OneOf.
         * @exports ProtoBuf.Reflect.Message.OneOf
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} name OneOf name
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var OneOf = function OneOf(builder, message, name) {
            T.call(this, builder, message, name);

            /**
             * Enclosed fields.
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
             * @expose
             */
            this.fields = [];
        };

        /**
         * @alias ProtoBuf.Reflect.Message.OneOf
         * @expose
         */
        Reflect.Message.OneOf = OneOf;

        /**
         * Constructs a new Enum.
         * @exports ProtoBuf.Reflect.Enum
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
         * @param {string} name Enum name
         * @param {Object.<string,*>=} options Enum options
         * @param {string?} syntax The syntax level (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Enum = function Enum(builder, parent, name, options, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Enum";

            /**
             * Runtime enum object.
             * @type {Object.<string,number>|null}
             * @expose
             */
            this.object = null;
        };

        /**
         * Gets the string name of an enum value.
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
         * @param {number} value Enum value
         * @returns {?string} Name or `null` if not present
         * @expose
         */
        Enum.getName = function (enm, value) {
            var keys = Object.keys(enm);
            for (var i = 0, key; i < keys.length; ++i) {
                if (enm[key = keys[i]] === value) return key;
            }return null;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum.prototype
         * @inner
         */
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);

        /**
         * Builds this enum and returns the runtime counterpart.
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
         * @returns {!Object.<string,number>}
         * @expose
         */
        EnumPrototype.build = function (rebuild) {
            if (this.object && !rebuild) return this.object;
            var enm = new ProtoBuf.Builder.Enum(),
                values = this.getChildren(Enum.Value);
            for (var i = 0, k = values.length; i < k; ++i) {
                enm[values[i]['name']] = values[i]['id'];
            }if (Object.defineProperty) Object.defineProperty(enm, '$options', {
                "value": this.buildOpt(),
                "enumerable": false
            });
            return this.object = enm;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum
         * @expose
         */
        Reflect.Enum = Enum;

        /**
         * Constructs a new Enum Value.
         * @exports ProtoBuf.Reflect.Enum.Value
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Value = function Value(builder, enm, name, id) {
            T.call(this, builder, enm, name);

            /**
             * @override
             */
            this.className = "Enum.Value";

            /**
             * Unique enum value id.
             * @type {number}
             * @expose
             */
            this.id = id;
        };

        // Extends T
        Value.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Enum.Value
         * @expose
         */
        Reflect.Enum.Value = Value;

        /**
         * An extension (field).
         * @exports ProtoBuf.Reflect.Extension
         * @constructor
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
         */
        var Extension = function Extension(builder, parent, name, field) {
            T.call(this, builder, parent, name);

            /**
             * Extended message field.
             * @type {!ProtoBuf.Reflect.Message.Field}
             * @expose
             */
            this.field = field;
        };

        // Extends T
        Extension.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Extension
         * @expose
         */
        Reflect.Extension = Extension;

        /**
         * Constructs a new Service.
         * @exports ProtoBuf.Reflect.Service
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} root Root
         * @param {string} name Service name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Service = function Service(builder, root, name, options) {
            Namespace.call(this, builder, root, name, options);

            /**
             * @override
             */
            this.className = "Service";

            /**
             * Built runtime service class.
             * @type {?function(new:ProtoBuf.Builder.Service)}
             */
            this.clazz = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Service.prototype
         * @inner
         */
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the service and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Service
         * @param {boolean=} rebuild Whether to rebuild or not
         * @return {Function} Service class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        ServicePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Service class in its own scope
            return this.clazz = function (ProtoBuf, T) {

                /**
                 * Constructs a new runtime Service.
                 * @name ProtoBuf.Builder.Service
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.
                 * @constructor
                 * @throws {Error} If the service cannot be created
                 */
                var Service = function Service(rpcImpl) {
                    ProtoBuf.Builder.Service.call(this);

                    /**
                     * Service implementation.
                     * @name ProtoBuf.Builder.Service#rpcImpl
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose
                     */
                    this.rpcImpl = rpcImpl || function (name, msg, callback) {
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first
                        // argument or null and the actual response message.
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };
                };

                /**
                 * @alias ProtoBuf.Builder.Service.prototype
                 * @inner
                 */
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                /**
                 * Asynchronously performs an RPC call using the given RPC implementation.
                 * @name ProtoBuf.Builder.Service.[Method]
                 * @function
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                /**
                 * Asynchronously performs an RPC call using the instance's RPC implementation.
                 * @name ProtoBuf.Builder.Service#[Method]
                 * @function
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                for (var i = 0; i < rpc.length; i++) {
                    (function (method) {

                        // service#Method(message, callback)
                        ServicePrototype[method.name] = function (req, callback) {
                            try {
                                try {
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                                } catch (err) {
                                    if (!(err instanceof TypeError)) throw err;
                                }
                                if (req === null || (typeof req === "undefined" ? "undefined" : _typeof(req)) !== 'object') throw Error("Illegal arguments");
                                if (!(req instanceof method.resolvedRequestType.clazz)) req = new method.resolvedRequestType.clazz(req);
                                this.rpcImpl(method.fqn(), req, function (err, res) {
                                    // Assumes that this is properly async
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    // Coalesce to empty string when service response has empty content
                                    if (res === null) res = '';
                                    try {
                                        res = method.resolvedResponseType.clazz.decode(res);
                                    } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                        callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                                        return;
                                    }
                                    callback(null, res);
                                });
                            } catch (err) {
                                setTimeout(callback.bind(this, err), 0);
                            }
                        };

                        // Service.Method(rpcImpl, message, callback)
                        Service[method.name] = function (rpcImpl, req, callback) {
                            new Service(rpcImpl)[method.name](req, callback);
                        };

                        if (Object.defineProperty) Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }), Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);
                }

                // Properties

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service.$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service#$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Service, "$options", { "value": T.buildOpt() }), Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }), Object.defineProperty(Service, "$type", { "value": T }), Object.defineProperty(ServicePrototype, "$type", { "value": T });

                return Service;
            }(ProtoBuf, this);
        };

        /**
         * @alias ProtoBuf.Reflect.Service
         * @expose
         */
        Reflect.Service = Service;

        /**
         * Abstract service method.
         * @exports ProtoBuf.Reflect.Service.Method
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Method = function Method(builder, svc, name, options) {
            T.call(this, builder, svc, name);

            /**
             * @override
             */
            this.className = "Service.Method";

            /**
             * Options.
             * @type {Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Reflect.Service.Method.prototype
         * @inner
         */
        var MethodPrototype = Method.prototype = Object.create(T.prototype);

        /**
         * Builds the method's '$options' property.
         * @name ProtoBuf.Reflect.Service.Method#buildOpt
         * @function
         * @return {Object.<string,*>}
         */
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;

        /**
         * @alias ProtoBuf.Reflect.Service.Method
         * @expose
         */
        Reflect.Service.Method = Method;

        /**
         * RPC service method.
         * @exports ProtoBuf.Reflect.Service.RPCMethod
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {string} request Request message name
         * @param {string} response Response message name
         * @param {boolean} request_stream Whether requests are streamed
         * @param {boolean} response_stream Whether responses are streamed
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Service.Method
         */
        var RPCMethod = function RPCMethod(builder, svc, name, request, response, request_stream, response_stream, options) {
            Method.call(this, builder, svc, name, options);

            /**
             * @override
             */
            this.className = "Service.RPCMethod";

            /**
             * Request message name.
             * @type {string}
             * @expose
             */
            this.requestName = request;

            /**
             * Response message name.
             * @type {string}
             * @expose
             */
            this.responseName = response;

            /**
             * Whether requests are streamed
             * @type {bool}
             * @expose
             */
            this.requestStream = request_stream;

            /**
             * Whether responses are streamed
             * @type {bool}
             * @expose
             */
            this.responseStream = response_stream;

            /**
             * Resolved request message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedRequestType = null;

            /**
             * Resolved response message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedResponseType = null;
        };

        // Extends Method
        RPCMethod.prototype = Object.create(Method.prototype);

        /**
         * @alias ProtoBuf.Reflect.Service.RPCMethod
         * @expose
         */
        Reflect.Service.RPCMethod = RPCMethod;

        return Reflect;
    }(ProtoBuf);

    /**
     * @alias ProtoBuf.Builder
     * @expose
     */
    ProtoBuf.Builder = function (ProtoBuf, Lang, Reflect) {
        "use strict";

        /**
         * Constructs a new Builder.
         * @exports ProtoBuf.Builder
         * @class Provides the functionality to build protocol messages.
         * @param {Object.<string,*>=} options Options
         * @constructor
         */

        var Builder = function Builder(options) {

            /**
             * Namespace.
             * @type {ProtoBuf.Reflect.Namespace}
             * @expose
             */
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

            /**
             * Namespace pointer.
             * @type {ProtoBuf.Reflect.T}
             * @expose
             */
            this.ptr = this.ns;

            /**
             * Resolved flag.
             * @type {boolean}
             * @expose
             */
            this.resolved = false;

            /**
             * The current building result.
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
             * @expose
             */
            this.result = null;

            /**
             * Imported files.
             * @type {Array.<string>}
             * @expose
             */
            this.files = {};

            /**
             * Import root override.
             * @type {?string}
             * @expose
             */
            this.importRoot = null;

            /**
             * Options.
             * @type {!Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Builder.prototype
         * @inner
         */
        var BuilderPrototype = Builder.prototype;

        // ----- Definition tests -----

        /**
         * Tests if a definition most likely describes a message.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessage = function (def) {
            // Messages require a string name
            if (typeof def["name"] !== 'string') return false;
            // Messages do not contain values (enum) or rpc methods (service)
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a message field.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessageField = function (def) {
            // Message fields require a string rule, name and type and an id
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an enum.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isEnum = function (def) {
            // Enums require a string name
            if (typeof def["name"] !== 'string') return false;
            // Enums require at least one value
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a service.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isService = function (def) {
            // Services require a string name and an rpc object
            if (typeof def["name"] !== 'string' || _typeof(def["rpc"]) !== 'object' || !def["rpc"]) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an extended message
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isExtend = function (def) {
            // Extends rquire a string ref
            if (typeof def["ref"] !== 'string') return false;
            return true;
        };

        // ----- Building -----

        /**
         * Resets the pointer to the root namespace.
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.reset = function () {
            this.ptr = this.ns;
            return this;
        };

        /**
         * Defines a namespace on top of the current pointer position and places the pointer on it.
         * @param {string} namespace
         * @return {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.define = function (namespace) {
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace)) throw Error("illegal namespace: " + namespace);
            namespace.split(".").forEach(function (part) {
                var ns = this.ptr.getChild(part);
                if (ns === null) // Keep existing
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
                this.ptr = ns;
            }, this);
            return this;
        };

        /**
         * Creates the specified definitions at the current pointer position.
         * @param {!Array.<!Object>} defs Messages, enums or services to create
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If a message definition is invalid
         * @expose
         */
        BuilderPrototype.create = function (defs) {
            if (!defs) return this; // Nothing to create
            if (!Array.isArray(defs)) defs = [defs];else {
                if (defs.length === 0) return this;
                defs = defs.slice();
            }

            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
            var stack = [defs];
            while (stack.length > 0) {
                defs = stack.pop();

                if (!Array.isArray(defs)) // Stack always contains entire namespaces
                    throw Error("not a valid namespace: " + JSON.stringify(defs));

                while (defs.length > 0) {
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

                    if (Builder.isMessage(def)) {
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);

                        // Create OneOfs
                        var oneofs = {};
                        if (def["oneofs"]) Object.keys(def["oneofs"]).forEach(function (name) {
                            obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                        }, this);

                        // Create fields
                        if (def["fields"]) def["fields"].forEach(function (fld) {
                            if (obj.getChild(fld["id"] | 0) !== null) throw Error("duplicate or invalid field id in " + obj.name + ": " + fld['id']);
                            if (fld["options"] && _typeof(fld["options"]) !== 'object') throw Error("illegal field options in " + obj.name + "#" + fld["name"]);
                            var oneof = null;
                            if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]])) throw Error("illegal oneof in " + obj.name + "#" + fld["name"] + ": " + fld["oneof"]);
                            fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                            if (oneof) oneof.fields.push(fld);
                            obj.addChild(fld);
                        }, this);

                        // Push children to stack
                        var subObj = [];
                        if (def["enums"]) def["enums"].forEach(function (enm) {
                            subObj.push(enm);
                        });
                        if (def["messages"]) def["messages"].forEach(function (msg) {
                            subObj.push(msg);
                        });
                        if (def["services"]) def["services"].forEach(function (svc) {
                            subObj.push(svc);
                        });

                        // Set extension ranges
                        if (def["extensions"]) {
                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
                                obj.extensions = [def["extensions"]];else obj.extensions = def["extensions"];
                        }

                        // Create on top of current namespace
                        this.ptr.addChild(obj);
                        if (subObj.length > 0) {
                            stack.push(defs); // Push the current level back
                            defs = subObj; // Continue processing sub level
                            subObj = null;
                            this.ptr = obj; // And move the pointer to this namespace
                            obj = null;
                            continue;
                        }
                        subObj = null;
                    } else if (Builder.isEnum(def)) {

                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
                        def["values"].forEach(function (val) {
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isService(def)) {

                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
                        Object.keys(def["rpc"]).forEach(function (name) {
                            var mtd = def["rpc"][name];
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isExtend(def)) {

                        obj = this.ptr.resolve(def["ref"], true);
                        if (obj) {
                            def["fields"].forEach(function (fld) {
                                if (obj.getChild(fld['id'] | 0) !== null) throw Error("duplicate extended field id in " + obj.name + ": " + fld['id']);
                                // Check if field id is allowed to be extended
                                if (obj.extensions) {
                                    var valid = false;
                                    obj.extensions.forEach(function (range) {
                                        if (fld["id"] >= range[0] && fld["id"] <= range[1]) valid = true;
                                    });
                                    if (!valid) throw Error("illegal extended field id in " + obj.name + ": " + fld['id'] + " (not within valid ranges)");
                                }
                                // Convert extension field names to camel case notation if the override is set
                                var name = fld["name"];
                                if (this.options['convertFieldsToCamelCase']) name = ProtoBuf.Util.toCamelCase(name);
                                // see #161: Extensions use their fully qualified name as their runtime key and...
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn() + '.' + name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for
                                // resolving their type later on (the extension always keeps the original name to
                                // prevent naming collisions)
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
                                field.extension = ext;
                                this.ptr.addChild(ext);
                                obj.addChild(field);
                            }, this);
                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                            throw Error("extended message " + def["ref"] + " is not defined");
                    } else throw Error("not a valid definition: " + JSON.stringify(def));

                    def = null;
                    obj = null;
                }
                // Break goes here
                defs = null;
                this.ptr = this.ptr.parent; // Namespace done, continue at parent
            }
            this.resolved = false; // Require re-resolve
            this.result = null; // Require re-build
            return this;
        };

        /**
         * Propagates syntax to all children.
         * @param {!Object} parent
         * @inner
         */
        function propagateSyntax(parent) {
            if (parent['messages']) {
                parent['messages'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                    propagateSyntax(child);
                });
            }
            if (parent['enums']) {
                parent['enums'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                });
            }
        }

        /**
         * Imports another definition into this builder.
         * @param {Object.<string,*>} json Parsed import
         * @param {(string|{root: string, file: string})=} filename Imported file name
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If the definition or file cannot be imported
         * @expose
         */
        BuilderPrototype["import"] = function (json, filename) {
            var delim = '/';

            // Make sure to skip duplicate imports

            if (typeof filename === 'string') {

                if (ProtoBuf.Util.IS_NODE) filename = require("path")['resolve'](filename);
                if (this.files[filename] === true) return this.reset();
                this.files[filename] = true;
            } else if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                // Object with root, file.

                var root = filename.root;
                if (ProtoBuf.Util.IS_NODE) root = require("path")['resolve'](root);
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0) delim = '\\';
                var fname = root + delim + filename.file;
                if (this.files[fname] === true) return this.reset();
                this.files[fname] = true;
            }

            // Import imports

            if (json['imports'] && json['imports'].length > 0) {
                var importRoot,
                    resetRoot = false;

                if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                    // If an import root is specified, override

                    this.importRoot = filename["root"];resetRoot = true; // ... and reset afterwards
                    importRoot = this.importRoot;
                    filename = filename["file"];
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                } else if (typeof filename === 'string') {

                    if (this.importRoot) // If import root is overridden, use it
                        importRoot = this.importRoot;else {
                        // Otherwise compute from filename
                        if (filename.indexOf("/") >= 0) {
                            // Unix
                            importRoot = filename.replace(/\/[^\/]*$/, "");
                            if ( /* /file.proto */importRoot === "") importRoot = "/";
                        } else if (filename.indexOf("\\") >= 0) {
                            // Windows
                            importRoot = filename.replace(/\\[^\\]*$/, "");
                            delim = '\\';
                        } else importRoot = ".";
                    }
                } else importRoot = null;

                for (var i = 0; i < json['imports'].length; i++) {
                    if (typeof json['imports'][i] === 'string') {
                        // Import file
                        if (!importRoot) throw Error("cannot determine import root");
                        var importFilename = json['imports'][i];
                        if (importFilename === "google/protobuf/descriptor.proto") continue; // Not needed and therefore not used
                        importFilename = importRoot + delim + importFilename;
                        if (this.files[importFilename] === true) continue; // Already imported
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto) // If this is a light build
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);
                        if (contents === null) throw Error("failed to import '" + importFilename + "' in '" + filename + "': file not found");
                        if (/\.json$/i.test(importFilename)) // Always possible
                            this["import"](JSON.parse(contents + ""), importFilename); // May throw
                        else this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                    } else // Import structure
                        if (!filename) this["import"](json['imports'][i]);else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function ($0, $1, $2) {
                                return $1 + "_import" + i + "." + $2;
                            }));else // Without extension: Append _importN to make it unique
                            this["import"](json['imports'][i], filename + "_import" + i);
                }
                if (resetRoot) // Reset import root override when all imports are done
                    this.importRoot = null;
            }

            // Import structures

            if (json['package']) this.define(json['package']);
            if (json['syntax']) propagateSyntax(json);
            var base = this.ptr;
            if (json['options']) Object.keys(json['options']).forEach(function (key) {
                base.options[key] = json['options'][key];
            });
            if (json['messages']) this.create(json['messages']), this.ptr = base;
            if (json['enums']) this.create(json['enums']), this.ptr = base;
            if (json['services']) this.create(json['services']), this.ptr = base;
            if (json['extends']) this.create(json['extends']);

            return this.reset();
        };

        /**
         * Resolves all namespace objects.
         * @throws {Error} If a type cannot be resolved
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.resolveAll = function () {
            // Resolve all reflected objects
            var res;
            if (this.ptr == null || _typeof(this.ptr.type) === 'object') return this; // Done (already resolved)

            if (this.ptr instanceof Reflect.Namespace) {
                // Resolve children

                this.ptr.children.forEach(function (child) {
                    this.ptr = child;
                    this.resolveAll();
                }, this);
            } else if (this.ptr instanceof Reflect.Message.Field) {
                // Resolve type

                if (!Lang.TYPE.test(this.ptr.type)) {
                    if (!Lang.TYPEREF.test(this.ptr.type)) throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res) throw Error("unresolvable type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    this.ptr.resolvedType = res;
                    if (res instanceof Reflect.Enum) {
                        this.ptr.type = ProtoBuf.TYPES["enum"];
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3') throw Error("proto3 message cannot reference proto2 enum");
                    } else if (res instanceof Reflect.Message) this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];else throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                } else this.ptr.type = ProtoBuf.TYPES[this.ptr.type];

                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                if (this.ptr.map) {
                    if (!Lang.TYPE.test(this.ptr.keyType)) throw Error("illegal key type for map field in " + this.ptr.toString(true) + ": " + this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                }
            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {

                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.requestName);
                    this.ptr.resolvedRequestType = res;
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.responseName);
                    this.ptr.resolvedResponseType = res;
                } else // Should not happen as nothing else is implemented
                    throw Error("illegal service type in " + this.ptr.toString(true));
            } else if (!(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
            ) throw Error("illegal object in namespace: " + _typeof(this.ptr) + ": " + this.ptr);

            return this.reset();
        };

        /**
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
         * return the built package.
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
         * @throws {Error} If a type could not be resolved
         * @expose
         */
        BuilderPrototype.build = function (path) {
            this.reset();
            if (!this.resolved) this.resolveAll(), this.resolved = true, this.result = null; // Require re-build
            if (this.result === null) // (Re-)Build
                this.result = this.ns.build();
            if (!path) return this.result;
            var part = typeof path === 'string' ? path.split(".") : path,
                ptr = this.result; // Build namespace pointer (no hasChild etc.)
            for (var i = 0; i < part.length; i++) {
                if (ptr[part[i]]) ptr = ptr[part[i]];else {
                    ptr = null;
                    break;
                }
            }return ptr;
        };

        /**
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
         */
        BuilderPrototype.lookup = function (path, excludeNonNamespace) {
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Builder"
         * @expose
         */
        BuilderPrototype.toString = function () {
            return "Builder";
        };

        // ----- Base classes -----
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Message = function () {};

        /**
         * @alias ProtoBuf.Builder.Enum
         */
        Builder.Enum = function () {};

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Service = function () {};

        return Builder;
    }(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);

    /**
     * @alias ProtoBuf.Map
     * @expose
     */
    ProtoBuf.Map = function (ProtoBuf, Reflect) {
        "use strict";

        /**
         * Constructs a new Map. A Map is a container that is used to implement map
         * fields on message objects. It closely follows the ES6 Map API; however,
         * it is distinct because we do not want to depend on external polyfills or
         * on ES6 itself.
         *
         * @exports ProtoBuf.Map
         * @param {!ProtoBuf.Reflect.Field} field Map field
         * @param {Object.<string,*>=} contents Initial contents
         * @constructor
         */

        var Map = function Map(field, contents) {
            if (!field.map) throw Error("field is not a map");

            /**
             * The field corresponding to this map.
             * @type {!ProtoBuf.Reflect.Field}
             */
            this.field = field;

            /**
             * Element instance corresponding to key type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

            /**
             * Element instance corresponding to value type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

            /**
             * Internal map: stores mapping of (string form of key) -> (key, value)
             * pair.
             *
             * We provide map semantics for arbitrary key types, but we build on top
             * of an Object, which has only string keys. In order to avoid the need
             * to convert a string key back to its native type in many situations,
             * we store the native key value alongside the value. Thus, we only need
             * a one-way mapping from a key type to its string form that guarantees
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
             * === K2).
             *
             * @type {!Object<string, {key: *, value: *}>}
             */
            this.map = {};

            /**
             * Returns the number of elements in the map.
             */
            Object.defineProperty(this, "size", {
                get: function get() {
                    return Object.keys(this.map).length;
                }
            });

            // Fill initial contents from a raw object.
            if (contents) {
                var keys = Object.keys(contents);
                for (var i = 0; i < keys.length; i++) {
                    var key = this.keyElem.valueFromString(keys[i]);
                    var val = this.valueElem.verifyValue(contents[keys[i]]);
                    this.map[this.keyElem.valueToString(key)] = { key: key, value: val };
                }
            }
        };

        var MapPrototype = Map.prototype;

        /**
         * Helper: return an iterator over an array.
         * @param {!Array<*>} arr the array
         * @returns {!Object} an iterator
         * @inner
         */
        function arrayIterator(arr) {
            var idx = 0;
            return {
                next: function next() {
                    if (idx < arr.length) return { done: false, value: arr[idx++] };
                    return { done: true };
                }
            };
        }

        /**
         * Clears the map.
         */
        MapPrototype.clear = function () {
            this.map = {};
        };

        /**
         * Deletes a particular key from the map.
         * @returns {boolean} Whether any entry with this key was deleted.
         */
        MapPrototype["delete"] = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            var hadKey = keyValue in this.map;
            delete this.map[keyValue];
            return hadKey;
        };

        /**
         * Returns an iterator over [key, value] pairs in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.entries = function () {
            var entries = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                entries.push([(entry = this.map[strKeys[i]]).key, entry.value]);
            }return arrayIterator(entries);
        };

        /**
         * Returns an iterator over keys in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.keys = function () {
            var keys = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                keys.push(this.map[strKeys[i]].key);
            }return arrayIterator(keys);
        };

        /**
         * Returns an iterator over values in the map.
         * @returns {!Object} The iterator
         */
        MapPrototype.values = function () {
            var values = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                values.push(this.map[strKeys[i]].value);
            }return arrayIterator(values);
        };

        /**
         * Iterates over entries in the map, calling a function on each.
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
         * @param {Object=} thisArg The `this` value for the callback
         */
        MapPrototype.forEach = function (cb, thisArg) {
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                cb.call(thisArg, (entry = this.map[strKeys[i]]).value, entry.key, this);
            }
        };

        /**
         * Sets a key in the map to the given value.
         * @param {*} key The key
         * @param {*} value The value
         * @returns {!ProtoBuf.Map} The map instance
         */
        MapPrototype.set = function (key, value) {
            var keyValue = this.keyElem.verifyValue(key);
            var valValue = this.valueElem.verifyValue(value);
            this.map[this.keyElem.valueToString(keyValue)] = { key: keyValue, value: valValue };
            return this;
        };

        /**
         * Gets the value corresponding to a key in the map.
         * @param {*} key The key
         * @returns {*|undefined} The value, or `undefined` if key not present
         */
        MapPrototype.get = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            if (!(keyValue in this.map)) return undefined;
            return this.map[keyValue].value;
        };

        /**
         * Determines whether the given key is present in the map.
         * @param {*} key The key
         * @returns {boolean} `true` if the key is present
         */
        MapPrototype.has = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            return keyValue in this.map;
        };

        return Map;
    }(ProtoBuf, ProtoBuf.Reflect);

    /**
     * Loads a .proto string and returns the Builder.
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadProto = function (proto, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = undefined;
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
    };

    /**
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
     * @function
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

    /**
     * Loads a .proto file and returns the Builder.
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadProtoFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadProto(contents, builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
    };

    /**
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
     * @function
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


    /**
     * Constructs a new empty Builder.
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
     * @return {!ProtoBuf.Builder} Builder
     * @expose
     */
    ProtoBuf.newBuilder = function (options) {
        options = options || {};
        if (typeof options['convertFieldsToCamelCase'] === 'undefined') options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
        if (typeof options['populateAccessors'] === 'undefined') options['populateAccessors'] = ProtoBuf.populateAccessors;
        return new ProtoBuf.Builder(options);
    };

    /**
     * Loads a .json definition and returns the Builder.
     * @param {!*|string} json JSON definition
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadJson = function (json, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = null;
        if (!builder || (typeof builder === "undefined" ? "undefined" : _typeof(builder)) !== 'object') builder = ProtoBuf.newBuilder();
        if (typeof json === 'string') json = JSON.parse(json);
        builder["import"](json, filename);
        builder.resolveAll();
        return builder;
    };

    /**
     * Loads a .json file and returns the Builder.
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadJsonFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
    };

    return ProtoBuf;
});

cc._RF.pop();
}).call(this,require('_process'))

},{"_process":2,"bytebuffer":"bytebuffer","fs":undefined,"path":1}]},{},["CardMoveEvent","MainGame","PokerFlop","PokerList","PokerSelect","PokerSort","UIChat","UICreateRoom","UIJoinRoom","UILogin","UIMain","UIMessageBox","UINotice","UIPanel","UIPokerGame","UISetting","UIShop","UIVote","UIWaiting","ChatBubble","ShopItem","bytebuffer","long","protobuf","AudioMgr","ConfigManager","DataManager","GameManager","GuiManager","IMManager","NetManager","PokerUtils","SceneManager","init"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvQXVkaW9NZ3IuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvQ2FyZE1vdmVFdmVudC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvQ2hhdEJ1YmJsZS5qcyIsImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvQ29uZmlnTWFuYWdlci5qcyIsImFzc2V0cy9TY3JpcHRzL01hbmFnZXIvRGF0YU1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL0dhbWVNYW5hZ2VyLmpzIiwiYXNzZXRzL1NjcmlwdHMvTWFuYWdlci9HdWlNYW5hZ2VyLmpzIiwiYXNzZXRzL1NjcmlwdHMvTWFuYWdlci9JTU1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvTWFpbkdhbWUuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL05ldE1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvUG9rZXJGbG9wLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1Bva2VyTGlzdC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9Qb2tlclNlbGVjdC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9Qb2tlclNvcnQuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL1Bva2VyVXRpbHMuanMiLCJhc3NldHMvU2NyaXB0cy9NYW5hZ2VyL1NjZW5lTWFuYWdlci5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9XaWRnZXQvU2hvcEl0ZW0uanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlDaGF0LmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJQ3JlYXRlUm9vbS5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSUpvaW5Sb29tLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJTG9naW4uanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlNYWluLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJTWVzc2FnZUJveC5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSU5vdGljZS5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSVBhbmVsLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJUG9rZXJHYW1lLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJU2V0dGluZy5qcyIsImFzc2V0cy9TY3JpcHRzL0d1aS9VSVNob3AuanMiLCJhc3NldHMvU2NyaXB0cy9HdWkvVUlWb3RlLmpzIiwiYXNzZXRzL1NjcmlwdHMvR3VpL1VJV2FpdGluZy5qcyIsImFzc2V0cy9TY3JpcHRzL0xpYi9ieXRlYnVmZmVyLmpzIiwiYXNzZXRzL1NjcmlwdHMvaW5pdC5qcyIsImFzc2V0cy9TY3JpcHRzL0xpYi9sb25nLmpzIiwiYXNzZXRzL1NjcmlwdHMvTGliL3Byb3RvYnVmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVJO0FBQ0k7QUFDQTtBQUNBO0FBSFE7O0FBTVo7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNIO0FBQ0Q7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBR0E7O0FBS0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUF0RVk7O0FBOEVqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBWlE7O0FBZVo7QUFDQTs7QUFJQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQTlCSzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBRlE7O0FBS1o7QUFDQTs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQXpCSTs7Ozs7Ozs7OztBQ0NUOztBQUVBOztBQUVJO0FBQ0k7QUFDQTs7QUFFQTs7QUFPQTs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUplOztBQU9uQjtBQUNIO0FBakNZOztBQW9DakI7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTs7QUFFSTtBQUNJOztBQU9BOztBQUtBO0FBQ0E7QUFDQTtBQUdIOztBQUVEO0FBQ0k7QUFFSTtBQUNIO0FBQ0o7O0FBR0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUE3RFk7O0FBaUVqQjs7Ozs7Ozs7OztBQ2xFQTtBQUNBOztBQUVJO0FBQ0k7O0FBRUE7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUVJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUVJO0FBRUk7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFFSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFBb0M7QUFDaEM7QUFDSDtBQUNHOztBQUVIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNHO0FBQ0E7QUFDRjs7QUFFRDtBQUNBO0FBQ0c7QUFDQTtBQUNBO0FBQ0Y7O0FBeEpZOztBQTRKakI7Ozs7Ozs7Ozs7QUM1SkE7O0FBRUk7QUFDSTtBQUVIOztBQUVGO0FBQ0s7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUVJO0FBQ0g7QUFDSjtBQUNKO0FBQ0w7O0FBRUQ7QUFDQztBQUNBO0FBQ0k7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFJSTtBQUNIOztBQUVEO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDSjtBQUNEOztBQUVEO0FBQ0s7QUFDQTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0w7O0FBRUQ7QUFDSztBQUNJO0FBQ0E7QUFDSDtBQUNMOztBQUVEO0FBQ0M7QUFDQTtBQUNJO0FBQ0g7QUFDRDs7QUFFRDtBQUNDO0FBQ0E7O0FBRUQ7QUFDSztBQUVJO0FBQ0E7QUFDSDtBQUNKOztBQUVGO0FBQ0M7QUFDSTtBQUNBO0FBRUk7QUFDSTtBQUVJO0FBQ0E7QUFDQTtBQUNIO0FBTkw7QUFPQztBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFFSTtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVGO0FBQ0s7QUFDQTtBQUNBO0FBRUk7QUFFSTtBQUNIO0FBQ0Q7QUFDSDtBQUNMOztBQUVEO0FBQ0M7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0E7QUFySmE7QUF1SmpCOzs7Ozs7Ozs7O0FDeEpBOztBQUVJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBRUk7QUFBK0I7QUFDL0I7QUFDSTtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBYko7QUFlSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQWxEWTs7QUFxRGpCOzs7Ozs7Ozs7O0FDckRBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZROztBQWFaO0FBQ0E7O0FBakJLOzs7Ozs7Ozs7O0FDQ1Q7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7QUFFRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNJO0FBQ0Q7QUFDRztBQUNBO0FBQ0Y7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDRTtBQUNBO0FBQ0U7QUFDRDtBQUNGOztBQUVEO0FBQ0U7QUFDRDs7QUFFRDtBQUNJOztBQUdBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7QUFJQztBQUNBO0FBQ0E7QUFDRDtBQUNGO0FBQ0E7QUFDSTtBQUNGO0FBQ0Q7QUFDRDs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDRTtBQUNFO0FBRUU7QUFDRTtBQUNEO0FBQ0Y7QUFHQztBQUNBO0FBQ0Q7QUFDSjtBQUNGOztBQUVEO0FBQ0E7QUFDRTtBQUVFO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUVFO0FBQ0E7QUFDSTtBQUNIO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0k7QUFFRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0o7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBRUk7QUFDSDtBQUNIO0FBQ0Q7O0FBRUQ7QUFDRTtBQUVFO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0U7QUFDQTtBQUVFO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7QUFFRTtBQUNBO0FBQ0Q7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFFSTtBQUNIO0FBQ0Y7QUF6TVk7QUEyTWpCOzs7Ozs7Ozs7O0FDNU1BO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFMUTs7QUFRWjtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSztBQUNHO0FBQ0E7QUFDSDtBQUNBO0FBQ0c7QUFDQTtBQUNIO0FBQ0E7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBRUk7QUFDSTtBQUVJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUVJO0FBQ0k7QUFFSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFFSTtBQUNJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQXJFSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7O0FBR0E7QUFDQTs7QUFJQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQXJCSzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJROztBQWdCWjtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUF4RUs7Ozs7Ozs7Ozs7QUNBVDtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUExQlE7O0FBOEJaO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBSUk7QUFDQTtBQUNIOztBQUVGO0FBRUk7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNGOztBQUVEO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNDO0FBQ0k7QUFDRztBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Y7QUFDRjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFBMkM7QUFBMEI7QUFDckU7QUFBOEM7QUFBNkI7QUFDM0U7QUFBOEM7QUFBNkI7QUFDM0U7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFFSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNHO0FBQ0s7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNMO0FBQ0Q7QUFDRjs7QUFFRDtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQWpWSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBSUo7Ozs7Ozs7QUFRSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFSjtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQztBQUREO0FBR0E7O0FBRUQ7QUFDQTs7QUFHQTtBQUNBO0FBQ0M7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0M7O0FBRUE7QUFDQTtBQUNBO0FBRUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0M7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNDO0FBQ0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0Q7QUFDQTtBQUNDO0FBQ0E7QUFBQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUFrQztBQUNqQztBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQVc7QUFDVjtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBR0E7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFBMkI7QUFDM0I7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQztBQUNDO0FBQTJDO0FBQzFDO0FBQ0E7QUFDRDtBQUE4QjtBQUM5QjtBQUNDO0FBQ0E7QUFDRDtBQUE0QjtBQUM1QjtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUVBO0FBQ0M7QUFDQTtBQUlJO0FBQ0E7QUFDQTtBQUNKO0FBQ0Q7QUFDQTtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUVBO0FBQ0E7QUFDQztBQUNDOztBQUdBO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBOztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNDO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUVBO0FBQ0Q7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFRDtBQUNBO0FBQ0M7QUFBQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNFOztBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDQTs7QUFFRTtBQUNBO0FBQ0k7QUFDSTtBQUFnQztBQUM1QjtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBRUc7QUFDSTtBQUNBOztBQUVaO0FBRUE7O0FBR0E7QUFFQTtBQUVBO0FBQ1M7QUFDSjtBQUNKOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVDO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0M7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQztBQUNDO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDO0FBQUE7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQXNCO0FBQWM7QUFDcEM7QUFBc0I7QUFBYzs7QUFFcEM7QUFDQTtBQUNDO0FBQ0E7QUFFRDtBQUNDO0FBQ0M7QUFBOEI7QUFDN0I7QUFDQTtBQUNEO0FBQThCO0FBQzdCO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFFRDtBQUNDO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBRUQ7QUFFQTs7QUFsbUJlOztBQWd1QmpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3J2QkE7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUVJO0FBQ0g7QUFHRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBOUJZOztBQWlDakI7Ozs7Ozs7Ozs7QUNqQ0E7QUFDSTs7QUFFQTtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMUzs7QUFRWjtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBRUk7QUFDQTtBQUNIO0FBR0c7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFqQ0k7Ozs7Ozs7Ozs7QUNDVDs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxROztBQVNaO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUVJO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNOOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBRUk7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNIO0FBOUdJOzs7Ozs7Ozs7O0FDSFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUZROztBQUtaO0FBQ0c7QUFDQTtBQUNGOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFDSTtBQUNBO0FBRk07QUFJYjtBQUNEO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUVJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUVJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFFSTs7QUFFSDtBQUNKOztBQWpGSTs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBSlM7O0FBT1o7QUFDSTtBQUNBO0FBRUk7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUVJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBRUk7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDRztBQUNBO0FBQ0E7QUFFSztBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBRU07QUFDTDtBQUdHO0FBQ0g7QUFHRztBQUNIO0FBRUY7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQS9ISzs7Ozs7Ozs7OztBQ0RUO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFGUTs7QUFLWjtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSztBQUNBO0FBQ0Q7QUFDRztBQUVJO0FBQ0E7QUFDSDtBQUdHO0FBQ0E7QUFDSDtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBRUk7O0FBRUE7QUFDQTtBQUVIO0FBR0M7QUFDRDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFwRUk7Ozs7Ozs7Ozs7QUNEVDtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBRlE7O0FBS1o7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7Ozs7O0FBS0E7QUFFSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBekNLOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFEUTs7QUFJWjtBQUNBOztBQUlBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUVJO0FBRUk7QUFDSDtBQUNKO0FBR0c7QUFDSDtBQUNKO0FBaENJOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFEUTs7QUFJWjtBQUNBOztBQUlBO0FBQ1E7QUFDSDs7QUFFTDtBQUNBOztBQUVBO0FBbkJLOzs7Ozs7Ozs7O0FDRFQ7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRE87QUFHWDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEOztBQUlBO0FBQ0k7QUFFSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBSUE7O0FBSUE7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUEvRWlCO0FBaUZ6Qjs7Ozs7Ozs7OztBQ3BGRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJROztBQW9CWjtBQUNBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFFQTs7QUFHQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTs7QUFHQTtBQUNBOztBQUVBO0FBRUk7QUFDQTtBQUNIO0FBR0c7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFHSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUVJO0FBQ0E7QUFFSTtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDs7QUFFSTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBRUk7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFFSTtBQUNBOztBQUVBO0FBQ0g7QUFDRDtBQUVJO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBRUk7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7QUFHQTtBQUNRO0FBQ1A7O0FBRUQ7QUFDQTs7QUFFSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSDs7QUFFRDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7O0FBU1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUF2Y0k7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTlM7O0FBU2I7QUFDQztBQUNBOztBQUVEO0FBQ0M7QUFDRztBQUNBO0FBRUM7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDSjs7QUFFRDtBQUNDO0FBQ0c7QUFDQTtBQUVDO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBOztBQUVEO0FBQ0M7QUFDQTs7QUEzREk7Ozs7Ozs7Ozs7QUNBVDtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZROztBQWFaO0FBQ0E7O0FBakJLOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNJOztBQUVBO0FBQ0c7QUFDQTtBQUNBO0FBSFM7O0FBTVo7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0M7QUFDTDtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUVJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBRUk7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSTtBQUVJO0FBRUk7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUdHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFFSTtBQUNIO0FBR0c7QUFDSDtBQUdHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBcEhJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNJOztBQUVBO0FBQ0c7QUFEUzs7QUFJWjtBQUNJO0FBQ0g7QUFUSTs7Ozs7Ozs7Ozs7O0FDRlQ7Ozs7OztBQU1BO0FBQWU7QUFBb0o7QUFBQTtBQUFtQjtBQUFrQjtBQUE2QjtBQUEyRDtBQUFtQjtBQUFjO0FBQTBCO0FBQXlDO0FBQUM7QUFBYTtBQUFBO0FBQWdDO0FBQ2pWO0FBQUM7QUFBc0I7QUFBZ0I7QUFBQTtBQUFxQztBQUF1SztBQUE4RDtBQUFpQztBQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQy9aO0FBQTBhO0FBQXNCO0FBQ3hXO0FBQTZEO0FBQTRLO0FBQ2pRO0FBQXFFO0FBQWtCO0FBQTRCO0FBQW9CO0FBQTRCO0FBQW1HO0FBQXJDO0FBQ3RVO0FBRHdlO0FBQzVWO0FBQTRCO0FBQW1DO0FBQW1CO0FBQW1CO0FBQTBCO0FBQTBIO0FBQW9DO0FBQW9DO0FBQXFDO0FBQ3plO0FBQWdDO0FBQ2dIO0FBQTlEO0FBQTZIO0FBQTZCO0FBQW1FO0FBQ3hOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0U7QUFBcEM7QUFBK0w7QUFBZTtBQUFmO0FBQTBEO0FBQWtDO0FBQTBCO0FBQWdEO0FBQUE7QUFBQTtBQUFBO0FBQzdiO0FBQXJCO0FBQWdOO0FBQWxDO0FBQWtGO0FBQTJCO0FBQW1FO0FBQzdVO0FBQXFEO0FBQWlEO0FBQW1FO0FBQ25OO0FBQWtIO0FBQWdEO0FBQW1FO0FBQW9OO0FBQzlhO0FBQWtEO0FBQW1FO0FBQW9UO0FBQ3JiO0FBQWlEO0FBQW1EO0FBQW1FO0FBQW9OO0FBQTRDO0FBQW9EO0FBQzNkO0FBQXNDO0FBQWtUO0FBQ2hTO0FBQW1EO0FBQW1FO0FBQW9OO0FBQ3BWO0FBQXFEO0FBQW1FO0FBQW9UO0FBQzFkO0FBQTBMO0FBQXNEO0FBQW1FO0FBQ2xUO0FBQW1JO0FBQXNEO0FBQW1FO0FBQ3ROO0FBQTRUO0FBQWlEO0FBQW1FO0FBQ2pTO0FBQXFPO0FBQW1EO0FBQzljO0FBQW1CO0FBQW9UO0FBQzlMO0FBQXNEO0FBQW1FO0FBQW9OO0FBQzVSO0FBQTBEO0FBQW1FO0FBQ2pIO0FBQXFKO0FBQ2xDO0FBQWtEO0FBQW1FO0FBQzlhO0FBQTBIO0FBQUE7QUFDMUg7QUFBNkM7QUFBb0Q7QUFBbUU7QUFDN0g7QUFBcUo7QUFDakM7QUFBc0Q7QUFBbUU7QUFBb047QUFBQTtBQUM3RjtBQUF5RDtBQUFtRTtBQUNuUDtBQUEySTtBQUF1RDtBQUNuYjtBQUFvTjtBQUFxRTtBQUF3RDtBQUFtRTtBQUN2YjtBQUFvTjtBQUEySTtBQUF3RDtBQUFtRTtBQUNsUztBQUFxRTtBQUFtRjtBQUE0RDtBQUE4QjtBQUE0QjtBQUE4QjtBQUMvZDtBQUErQjtBQUFtRTtBQUFrVDtBQUFBO0FBQ3paO0FBQXdCO0FBQW5CO0FBQXdHO0FBQXFDO0FBQWlEO0FBQTRCO0FBQW1FO0FBQ2pTO0FBQUE7QUFBQTtBQUFpQjtBQUF3SDtBQUFzRTtBQUFrQztBQUE0RztBQUE2RDtBQUErRTtBQUM5VDtBQUE4QjtBQUE2SztBQUE4QjtBQUNwVDtBQUErQjtBQUFtRTtBQUM1SjtBQUFvSDtBQUFBO0FBQUE7QUFBbU47QUFBOEI7QUFBd0M7QUFBa0Q7QUFDbmM7QUFBZ0Q7QUFBd0M7QUFBa0Q7QUFBa0Q7QUFBZ0Q7QUFBZ0U7QUFBcUM7QUFBaUQ7QUFBNEI7QUFBbUU7QUFDOVQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNUk7QUFBa0M7QUFBZ0g7QUFBK0I7QUFBZ0Q7QUFBb0M7QUFBb0Y7QUFBaEI7QUFDdk07QUFBNkk7QUFBaUI7QUFBOEQ7QUFBMkI7QUFBbUU7QUFDaFQ7QUFBQTtBQUFBO0FBQThDO0FBQWtKO0FBQTJFO0FBQThCO0FBQ2xiO0FBQXdSO0FBQUE7QUFDcEg7QUFBaUI7QUFBaUk7QUFBMkI7QUFBbUU7QUFDaFU7QUFBQTtBQUFBO0FBQXNKO0FBQXlFO0FBQW1FO0FBQ2xTO0FBQUE7QUFBdUo7QUFBaUI7QUFBK0M7QUFBa0U7QUFBdUM7QUFBa0M7QUFBdUM7QUFDMWhCO0FBQXdFO0FBQW1KO0FBQ2xNO0FBQUE7QUFBQTtBQUFzQztBQUE4QjtBQUE2QztBQUF3QjtBQUF1QjtBQUErSDtBQUF3QjtBQUFtQjtBQUN4VDtBQUF5QztBQUErQjtBQUE4SjtBQUE0QztBQUE0RDtBQUFtRTtBQUM1YjtBQUFvTjtBQUFBO0FBQUE7QUFBK047QUFBaUI7QUFDaFo7QUFBMkI7QUFBbUU7QUFBb047QUFBQTtBQUFBO0FBQ3RXO0FBQVk7QUFBMEI7QUFBNEg7QUFBb047QUFDM1E7QUFBMEI7QUFBNkI7QUFBc0I7QUFBNkI7QUFBdUI7QUFBOEI7QUFBb0I7QUFBaUY7QUFBcUI7QUFDMVE7QUFBeUI7QUFBa0c7QUFDbk47QUFBbUw7QUFBMEw7QUFBc0I7QUFBa0c7QUFDOU87QUFBeUQ7QUFBK0k7QUFDMWQ7QUFDUDtBQUF1RjtBQUE4QjtBQUF1RTtBQUF3QjtBQUF1TTtBQUNsSDtBQUE4QjtBQUFWO0FBQTBEO0FBQW1CO0FBQWlEO0FBQW9CO0FBQy9jO0FBQW1CO0FBQW9OO0FBQWdDO0FBQXFCO0FBQWlJO0FBQWtCO0FBQTREO0FBQWtCO0FBQ3BkO0FBQTJCO0FBQTRIO0FBQW9OO0FBQXlGO0FBQUE7QUFDdlQ7QUFBdUk7QUFBMkI7QUFBOEI7QUFBMEI7QUFDOVg7QUFBd0I7QUFBOEI7QUFBb0I7QUFBb0c7QUFBc0I7QUFBbUI7QUFBdUo7QUFBNkI7QUFBd0Y7QUFBWTtBQUNqZ0I7QUFBd0I7QUFBa0c7QUFBdVM7QUFBdUY7QUFDeGY7QUFBbUI7QUFBbUI7QUFBK0Y7QUFBNkw7QUFBdUI7QUFBa0c7QUFDM2I7QUFBc047QUFBaUQ7QUFBd0I7QUFBQTtBQUFrRDtBQUNqVjtBQUFnSTtBQUFxTDtBQUF1RDtBQUM5UztBQUFzQztBQUFxQztBQUFxQztBQUF1QztBQUFxQztBQUFnQztBQUEwQztBQUFrQjtBQUNqUDtBQURpUDtBQUNoTjtBQUE0QjtBQUE1QjtBQUE4TTtBQUF3QjtBQUFjO0FBQTJDO0FBQThCO0FBQ3ZYO0FBQXlHO0FBQTZFO0FBQUM7QUFEa0s7QUFDaks7QUFBb0I7QUFBQTtBQUFpRjtBQUFVO0FBQTRCO0FBQ2xWO0FBQStCO0FBQThCO0FBQTRCO0FBQThDO0FBQTBEO0FBQWM7QUFBcUI7QUFBb0I7QUFBa0M7QUFBb0I7QUFBa0M7QUFBMEI7QUFDdmE7QUFBaUg7QUFBdkI7QUFBdUs7QUFBNEI7QUFBMEY7QUFBbUY7QUFBbUI7QUFBdUI7QUFDamM7QUFBbUw7QUFBa0I7QUFBbEI7QUFBNEM7QUFBNE47QUFDM2U7QUFBa0I7QUFBbEI7QUFBcUM7QUFBYTtBQUE2QjtBQUF1RjtBQUFpQztBQUFPO0FBQVk7QUFBVztBQUFTO0FBQXNEO0FBQU87QUFBUztBQUFXO0FBQU87QUFBdUM7QUFBTztBQUFTO0FBQVc7QUFBTztBQUE4QztBQUFPO0FBQU07QUFBVztBQUFLO0FBQStCO0FBQU87QUFDaGdCO0FBQVc7QUFBTztBQUE2QztBQUFPO0FBQU07QUFBVztBQUFLO0FBQThCO0FBQU87QUFBTTtBQUFXO0FBQUs7QUFBcUM7QUFBbUI7QUFBVTtBQUFXO0FBQXNNO0FBQU87QUFDcGI7QUFBNkc7QUFBUztBQUF1QjtBQUFnRztBQUNwTjtBQUE0QjtBQUE1QjtBQUFzSDtBQUEyQjtBQUFPO0FBQWtKO0FBQTREO0FBQy9YO0FBQWM7QUFBbUI7QUFBa0I7QUFBc0Q7QUFBa0Q7QUFBWTtBQUFpQztBQUEvQjtBQUFtSztBQUEwQjtBQUE4QjtBQUFrRztBQUFpQjtBQUFqSjtBQUNaO0FBQTJCO0FBQTRDO0FBQTVDO0FBQ3pWO0FBQTJCO0FBQWtEO0FBQVk7QUFBaUM7QUFBL0I7QUFBZ0c7QUFBaUM7QUFBNEI7QUFBa0I7QUFBRTtBQUFpQztBQUEyQjtBQUFtQjtBQUFFO0FBQWdDO0FBQW9DO0FBQTJCO0FBQThCO0FBQTlCO0FBQ2xiO0FBQWtDO0FBQUE7QUFBd0M7QUFBb0M7QUFBYztBQUFXO0FBQTBCO0FBQWtHO0FBQzlQO0FBQVU7QUFBK0I7QUFBK0I7QUFBbUI7QUFBUztBQUF5RTtBQUFXO0FBQTRCO0FBQXdFO0FBQTZGO0FBQWM7QUFBcUI7QUFBVTs7Ozs7Ozs7OztBQzVGamQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDSDs7QUE3Qkk7Ozs7Ozs7Ozs7OztBQ0FUOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7QUFLQTs7QUFFSTtBQUVBO0FBRUE7QUFHSDtBQUNHOztBQUVBOzs7Ozs7Ozs7OztBQVVBOztBQUVJOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUhnRDs7QUFNcEQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0g7QUFDRztBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0k7QUFFQTtBQUVIO0FBQ0c7QUFFQTtBQUVIO0FBQ0Q7QUFFQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFFQTtBQUVBO0FBQ0k7QUFDQTtBQUVIO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7O0FBR0E7QUFDQTtBQUdJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBRUE7QUFFQTtBQUF5QjtBQUNyQjtBQUNJO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNIO0FBRUo7O0FBRUQ7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0k7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUdJO0FBQ0k7QUFESjtBQUdIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNJO0FBQ0o7QUFDQTtBQUNJO0FBREo7QUFJSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFFQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUVBOztBQUdBO0FBQ0k7QUFJSDs7QUFHRDtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFBQTtBQUtJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUVEO0FBQ0k7QUFFQTtBQUNIO0FBRUQ7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDSTtBQUNKO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFDSTtBQUxKO0FBT0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBTUg7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBTUg7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0E7QUFHSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBSUo7QUFDSjs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUNIOztBQUVEO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUM3c0NEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7OztBQUtBOztBQUVJO0FBRUE7QUFFQTtBQUdIO0FBQ0c7O0FBRUE7Ozs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFNQTs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhJO0FBS1I7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNJO0FBQ0E7QUFDQTtBQUhLO0FBS1Q7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0k7QUFDQTtBQUNBO0FBSFE7QUFLWjtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDSTtBQUNBO0FBQ0E7QUFIUTtBQUtaO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUFLVDtBQUNJO0FBQ0E7QUFDQTtBQUhJO0FBS1I7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUF2Rkk7O0FBOEZqQjs7Ozs7O0FBTUE7O0FBZ0JBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7QUFJQTtBQUNJOztBQUVBOzs7Ozs7QUFLQTs7QUFFQTs7Ozs7O0FBTUE7O0FBSUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNpQjtBQUE0QjtBQUM1QjtBQUEyQztBQUMzQztBQUEyQztBQUMzQztBQUE4QztBQUUvRDtBQUNBO0FBQ0E7QUFDSTtBQUFNO0FBQThCO0FBQ3hCO0FBQVc7QUFDdkI7QUFDSDtBQUNEO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUlIO0FBQ0o7QUFFTztBQUNIO0FBQ0c7QUFDSDtBQUNSO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBSUg7QUFDRDtBQUVBO0FBQ0g7QUFDRztBQUNBO0FBRUE7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSDs7QUFFRDs7Ozs7QUFLQTs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBekRZOztBQTREaEI7Ozs7QUFJQTtBQUNJOztBQUVBOzs7Ozs7QUFLQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVJOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFFQTs7QUFHQTtBQUdBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBRUE7QUFFSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUE4QztBQUMxQztBQUNJO0FBREo7QUFJQTtBQUNBO0FBQ0g7QUFBNkQ7QUFDMUQ7QUFDSTtBQUVBO0FBRUE7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBRUo7QUFDSjs7QUFFRDs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRVE7QUFESjtBQUdKO0FBRUE7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUVIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUlc7QUFVZjtBQUFBO0FBQUE7QUFHQTtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFFQTtBQUNBO0FBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDSTtBQUNKO0FBQ0o7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUEvQ1I7QUFpREg7QUFDSjtBQUNHO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQVFBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQVlBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBQUE7QUFHQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVIOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ1I7QUFDQTtBQUFjO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDQTtBQUVIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUdJO0FBRUE7QUFDSDtBQUNKOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFBcUI7QUFDakI7QUFDSDtBQUFRO0FBQ0w7QUFDQTtBQUNJO0FBRUE7QUFJSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDQTtBQUNJO0FBTUg7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxTO0FBT2I7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBSUg7QUFDRDtBQUNIO0FBRUQ7QUFFQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUk07QUFVVjtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFhSTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBTEE7QUFNQTtBQUtEO0FBRUE7QUFDSDtBQUVKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0k7QUFESjtBQUdIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMTTtBQU9WO0FBQ0E7O0FBRUk7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUg7O0FBRUc7O0FBRUE7O0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVIOztBQUVHO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUg7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQUE7QUFFQTtBQUNJO0FBRUE7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFHSTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBRk07QUFJVjtBQUNBO0FBRUE7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBR0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQVRSO0FBV0E7QUFDQTtBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUE7QUFDSTtBQUNBO0FBRk07QUFJVjtBQUNBO0FBQ0k7QUFHSTtBQUVBO0FBQ0g7QUFFSjtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVBOzs7O0FBSUE7QUFDSTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7QUFFSDs7QUFFRDs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7OztBQUtBOztBQUVBOzs7Ozs7Ozs7QUFTQTs7QUFFSTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBRUE7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFDSTtBQURKO0FBSUg7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFBQTtBQU1IO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUlIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUFBO0FBQUE7QUFHQTtBQUFzQjtBQUNsQjtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0E7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUVBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOztBQUVJOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUVIOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBR0E7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUVBOztBQUVKO0FBQ0E7QUFDQTtBQUNJO0FBRUE7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFBaUM7QUFDN0I7QUFFUTtBQUNIO0FBQ0c7QUFDSDtBQUdSOztBQUVEO0FBQ0E7QUFDQTtBQUFnQztBQUM1QjtBQUVRO0FBQ0g7QUFDRztBQUNIO0FBR1I7O0FBRUQ7QUFDQTtBQUNJO0FBRUE7O0FBRUo7QUFDQTtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQTZCO0FBQ3pCO0FBQ0E7QUFDSTtBQURKO0FBT0k7QUFDQTtBQUVBO0FBRUE7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQWdDO0FBQzVCO0FBRUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFJSDtBQUNEO0FBQ0E7QUFDSDtBQTNHTDs7QUE4R0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDSTtBQUNKO0FBQ0E7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNBO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBRUE7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFyQ1I7QUF1Q0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBSUE7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFJQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDSTtBQUNBO0FBMUdSO0FBNEdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7O0FBR0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFBOEI7QUFDMUI7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUFnQztBQUM1QjtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBaEZSOztBQW1GQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNO0FBQ0E7O0FBRU47QUFDTTs7QUFFTjtBQUNNOztBQUVOO0FBQ007QUF2QlY7QUF5Qkg7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDSTs7QUFHQTtBQUNBOztBQUVJO0FBQUE7O0FBR0E7Ozs7Ozs7OztBQVNBO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBREo7QUFHQTtBQUNJO0FBQ0E7QUFHQTtBQUdIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0k7QUFESjtBQUdQO0FBQ0o7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0E7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQURKO0FBSUg7QUFDRDtBQUNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0g7QUFFRDtBQUE0QjtBQUN4QjtBQUNBO0FBQ0k7QUFFQTtBQUNIO0FBRUo7QUFDRDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7O0FBR0E7QUFFUTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFSjtBQUNJOzs7Ozs7Ozs7OztBQVdBOztBQUVKO0FBQ0k7Ozs7Ozs7O0FBUUE7O0FBRUo7QUFDSTs7Ozs7Ozs7QUFRQTtBQUVQO0FBQ1I7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNJO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0E7QUFBQTtBQUVBO0FBQ0k7QUFDSTtBQUlIO0FBTkw7QUFRSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRVM7QUFDQTtBQUlaOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0k7QUFHQTtBQUlBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7QUFJQTtBQUVBO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7O0FBTUE7QUFFSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRUE7QUFDSDtBQU1HO0FBQ1A7O0FBRUQ7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVIO0FBRUo7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFJSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUFBO0FBQ0k7QUFESjtBQUdBO0FBQ0k7QUFDSTtBQUFHO0FBQUg7QUFFQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUlKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUF4QlI7QUEwQkE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFsQlI7QUFvQkE7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFBbUI7QUFDZjtBQUNBO0FBRUE7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUFnQztBQUM1QjtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7QUFFSjtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBRUg7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBSEE7QUFNSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUFzQjtBQUNsQjtBQUVBO0FBRUE7QUFDSDtBQUNEO0FBQ0E7QUFBc0M7QUFDbEM7QUFFQTtBQUNBO0FBQ0k7QUFESjtBQUdIO0FBQ0Q7QUFBaUM7QUFDN0I7QUFDSTtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDRDtBQUNBOztBQUdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBRUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0k7O0FBRUo7QUFDSTtBQUNKO0FBQ0k7QUFsQ1I7QUFvQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUVBO0FBRUE7QUFBcUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0g7QUFDSjtBQUNHO0FBQ0E7QUFDSTtBQUNBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNHO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdBO0FBQ0g7QUFDRztBQUNJO0FBREo7QUFHSDtBQUNKO0FBQ0c7QUFDQTtBQUNJO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNHO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7QUFHQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNJOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUlIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUFBO0FBRUE7QUFDSTtBQURKO0FBSVE7QUFDQTtBQUZtQztBQUkzQztBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0k7O0FBR0E7QUFDQTs7QUFFSTs7Ozs7Ozs7QUFRQTtBQUNJOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNJOztBQUVJO0FBQ0E7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFFSDtBQUNEO0FBRUE7QUFFQTtBQUFxRDtBQUNqRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFFQTtBQUFNO0FBQXNEO0FBQzVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNKO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBR0g7QUFDSjs7QUFFRDs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7O0FBTUE7QUFFSDtBQUNKOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFFSDs7QUFFRDs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7Ozs7O0FBT0E7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNKO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBR0k7QUFFQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJOztBQUVBO0FBQ0k7O0FBRUo7QUFDSTs7QUFFQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUVRO0FBQ0g7O0FBRUw7QUFDQTtBQUVRO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0g7O0FBRUw7QUFDQTtBQUNBO0FBRVE7QUFDSDtBQUNMO0FBRVE7QUFDSDtBQUNMO0FBRVE7QUFDSDs7QUFFTDtBQUNBO0FBQ0k7QUFDSTtBQUdQOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFFSDs7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBRUg7O0FBRUc7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBRUg7O0FBRUc7QUFDQTtBQUNJO0FBQ0k7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBRUg7QUFDRDtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFSjtBQUNHO0FBRVA7O0FBR0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJOztBQUVBOztBQUVBOztBQUVJO0FBRUE7QUFFQTtBQUVIO0FBQTBDOztBQUV2QztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7QUFFQTtBQUNJO0FBQUE7O0FBR0E7QUFBb0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBR0g7O0FBRUc7QUFDSTtBQUNHO0FBQ0g7QUFBa0M7QUFDOUI7QUFDQTtBQUVIO0FBQXlDO0FBQ3RDO0FBQ0E7QUFDSDtBQUVKO0FBRUo7O0FBR0Q7QUFDSTtBQUE4QztBQUMxQztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSTtBQUNKO0FBQ0E7QUFFQTtBQUNJO0FBREo7QUFJSDtBQUNHO0FBR0k7QUFBNEY7QUFBK0I7QUFFM0g7QUFDWDtBQUNEO0FBQ0k7QUFDUDs7QUFFRDs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVRO0FBQ0g7QUFDTDtBQUdBO0FBR0E7QUFHQTs7QUFHQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTs7QUFHQTtBQUE2Qzs7QUFFekM7QUFDSTtBQUNBO0FBQ0g7QUFFSjtBQUF1RDs7QUFFcEQ7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBS0o7O0FBR0Q7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNIO0FBRUo7O0FBRUc7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDSDtBQUNHO0FBRVA7QUFFRztBQUNBO0FBSEc7O0FBT1A7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFJQTtBQUNJO0FBQ0o7QUFFQTtBQUFBO0FBRUE7QUFDSTtBQUdJO0FBQ0E7QUFDSDtBQU5MO0FBUUg7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUVIOztBQUVEOzs7O0FBSUE7QUFDSTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTs7QUFHQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7QUFFQTs7O0FBR0E7QUFDSTtBQUFrQjtBQUFzQztBQUR4Qjs7QUFJcEM7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFFSDtBQUNKO0FBQ0o7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFFQTtBQUNIO0FBTEU7QUFPVjs7QUFFRDs7O0FBR0E7QUFDSTtBQUNIOztBQUVEOzs7O0FBSUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7O0FBSUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDs7QUFFRDs7OztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUNJO0FBREo7QUFFSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFHRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUdBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDSTtBQUtBO0FBRVE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQTs7O0FBR0E7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUE7QUFDSTtBQUtBO0FBRVE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDTDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8v6Z+z5LmQ566h55CG5ZmoXHJcbnZhciBNID0gY2MuQ2xhc3Moe1xyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBiZ21Wb2x1bWU6MS4wLFxyXG4gICAgICAgIHNmeFZvbHVtZToxLjAsXHJcbiAgICAgICAgYmdtQXVkaW9JRDotMSxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJnYm1Wb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSBwYXJzZUZsb2F0KHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzZnhWb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSBwYXJzZUZsb2F0KHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MuZ2FtZS5vbihjYy5nYW1lLkVWRU5UX0hJREUsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2MuYXVkaW9FbmdpbmUucGF1c2VBbGxcIik7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnBhdXNlQWxsKCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY2MuZ2FtZS5vbihjYy5nYW1lLkVWRU5UX1NIT1csIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsXCIpO1xyXG4gICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5yZXN1bWVBbGwoKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5zZXRNdXNpY1ZvbHVtZSh0aGlzLmJnbVZvbHVtZSlcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5zZXRNdXNpY1ZvbHVtZSh0aGlzLnNmeFZvbHVtZSlcclxuICAgIH0sXHJcblxyXG4gICAgcGxheUJHTSA6IGZ1bmN0aW9uKHVybCl7XHJcbiAgICAgICAgaWYgKHRoaXMuYmdfY2xpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5yZWxlYXNlQXNzZXQodGhpcy5iZ19jbGlwKVxyXG4gICAgICAgICAgICB0aGlzLmJnX2NsaXAgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5iZ19jbGlwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKCdTb3VuZC8nICsgdXJsLGNjLkF1ZGlvQ2xpcCxmdW5jdGlvbihlcnIsY2xpcCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmJnX2NsaXAgPSBjbGlwXHJcbiAgICAgICAgICAgICAgICBzZWxmLmJnbUF1ZGlvSUQgPSBjYy5hdWRpb0VuZ2luZS5wbGF5TXVzaWMoc2VsZi5iZ19jbGlwLCB0cnVlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYXlTRlggOiBmdW5jdGlvbih1cmwpe1xyXG4gICAgICAgIGlmKHRoaXMuc2Z4Vm9sdW1lID4gMCl7XHJcbiAgICAgICAgICAgIHZhciBhdWRpb0lkID0gY2MuYXVkaW9FbmdpbmUucGxheShhdWRpb1VybCwgZmFsc2UsIHRoaXMuc2Z4Vm9sdW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJHTVZvbHVtZTpmdW5jdGlvbih2YWx1ZSkge1xyXG5cclxuICAgIH0sXHJcbiAgICBzZXRTRlhWb2x1bWU6ZnVuY3Rpb24odmFsdWUpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBwYXVzZUFsbCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzdW1lQWxsIDogZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5yZXN1bWVBbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcblxyXG5jYy5hdWRpb21hbmFnZXIgPSBuZXcgTSgpOyIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuXHJcbiAgICAgICAgcGFyZW50Tm9kZTogY2MuTm9kZVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgb25BbmltQ29tcGxldGVkOiBmdW5jdGlvbihudW0pe1xyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5nZXRDb21wb25lbnQoXCJVSVBva2VyR2FtZVwiKS5vbkFuaW1Db21wbGV0ZWQobnVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICB0ZXh0OmNjLkxhYmVsLFxyXG4gICAgICAgIGZhY2U6Y2MuQW5pbWF0aW9uLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dUZXh0OmZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIHRoaXMudGV4dC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLmZhY2Uubm9kZS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMudGV4dC5zdHJpbmcgPSBtc2dcclxuICAgICAgICBjYy5sb2coJ3Rlc3Q6JyArIG1zZylcclxuICAgIH0sXHJcbiAgICBzaG93RmFjZSA6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0Lm5vZGUuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICB0aGlzLmZhY2Uubm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5mYWNlLnBsYXkoXCJmYWNlX1wiICsgaWQpXHJcbiAgICAgICAgLy8gdGhpcy5mYWNlLnNwcml0ZUZyYW1lID0gY2MuZ2FtZW1hbmFnZXIuY3JlYXRlRmFjZShpZClcclxuICAgICAgICAvLyBjYy5sb2coJ3RoaXMuZmFjZS5zcHJpdGVGcmFtZTonICsgdGhpcy5mYWNlLnNwcml0ZUZyYW1lKVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcbi8v5L+d5a2Y5LiA5Lqb5a6i5oi356uv6YWN572uXHJcblxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuXHJcbiAgICBjdG9yOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuc2VydmVySVAgPSBcIjEwLjE3My4zMi41MlwiIC8vXCIxMTkuMjMuNzEuMjM3XCIgXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJQb3J0ID0gNzAwMFxyXG5cclxuICAgICAgICB0aGlzLm5pY2tOYW1lMSA9IFtcclxuICAgICAgICAgICAgXCLkuIrlrphcIiwgXCLmrKfpmLNcIiwgXCLkuJzmlrlcIiwgXCLnq6/mnKhcIiwgXCLni6zlraRcIixcclxuICAgICAgICAgICAgXCLlj7jpqaxcIiwgXCLljZflrqtcIiwgXCLlpI/kvq9cIiwgXCLor7jokZtcIiwgXCLnmofnlKtcIixcclxuICAgICAgICAgICAgXCLplb/lrZlcIiwgXCLlrofmlodcIiwgXCLovanovpVcIiwgXCLkuJzpg61cIiwgXCLlrZDovaZcIixcclxuICAgICAgICAgICAgXCLkuJzpmLNcIiwgXCLlrZDoqIBcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubmlja05hbWUyID0gW1xyXG4gICAgICAgICAgICBcIumbgOWco1wiLCBcIui1jOS+oFwiLCBcIui1jOWco1wiLCBcIueos+i1olwiLCBcIuS4jei+k1wiLFxyXG4gICAgICAgICAgICBcIuWlvei/kFwiLCBcIuiHquaRuFwiLCBcIuaciemSsVwiLCBcIuWcn+ixqlwiLFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMud25kU2NhbGUgPSBjYy52aWV3LmdldEZyYW1lU2l6ZSgpLmhlaWdodCAvIDcyMDtcclxuXHJcbiAgICAgICAgY2MubG9nKFwiZ2V0RnJhbWVTaXplOiBcIiwgY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aCwgY2Mudmlldy5nZXRGcmFtZVNpemUoKS5oZWlnaHQpXHJcblxyXG4gICAgICAgIC8v5oi/6Ze05aS05YOP5L2N572uKOS7juiHquW3seW8gOWni+mAhuaXtumSiOaWueWQke+8jOmZpOiHquW3seWkluacgOWkmuS6lOWQjeeOqeWutilcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnduZFNjYWxlXHJcbiAgICAgICAgdmFyIHN4ID0gY2Mudmlldy5nZXRGcmFtZVNpemUoKS53aWR0aC8yXHJcbiAgICAgICAgdGhpcy5oZWFkSWNvblBvcyA9IFtcclxuICAgICAgICAgICAgW2NjLnYyKDAsIDE4OCldLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMuS6ulxyXG4gICAgICAgICAgICBbY2MudjIoMzAwL3NjYWxlLCAxNjApLCBjYy52MigtMzAwL3NjYWxlLCAxNjApXSwgICAgLy8z5Lq6XHJcbiAgICAgICAgICAgIFtjYy52Migoc3gtNTApL3NjYWxlLCAtNDApLCBjYy52MigwLCAxODgpLCBjYy52MigoLXN4KzUwKS9zY2FsZSwgLTQwKV0sIC8vNOS6ulxyXG4gICAgICAgICAgICBbY2MudjIoKHN4LTUwKS9zY2FsZSwgLTQwKSwgY2MudjIoMzAwL3NjYWxlLCAxNTApLCBjYy52MigtMzAwL3NjYWxlLCAxNTApLCBjYy52MigoLXN4KzUwKS9zY2FsZSwgLTQwKV0gIC8vNeS6ulxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMueXVueWluX3Nka19pZCA9IDEwMDE2NjRcclxuICAgIH0sXHJcbn0pO1xyXG5cclxuY2MuY29uZmlnbWFuYWdlciA9IG5ldyBNKCk7IiwiLy/mlbDmja7nrqHnkIblmajvvIzlrZjlgqjlhajlsYDmlbDmja5cclxudmFyIE0gPSBjYy5DbGFzcyh7XHJcbiAgICBcclxuICAgIGN0b3I6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm5pY2tOYW1lMSA9IFtcclxuICAgICAgICAgICAgXCLkuIrlrphcIiwgXCLmrKfpmLNcIiwgXCLkuJzmlrlcIiwgXCLnq6/mnKhcIiwgXCLni6zlraRcIixcclxuICAgICAgICAgICAgXCLlj7jpqaxcIiwgXCLljZflrqtcIiwgXCLlpI/kvq9cIiwgXCLor7jokZtcIiwgXCLnmofnlKtcIixcclxuICAgICAgICAgICAgXCLplb/lrZlcIiwgXCLlrofmlodcIiwgXCLovanovpVcIiwgXCLkuJzpg61cIiwgXCLlrZDovaZcIixcclxuICAgICAgICAgICAgXCLkuJzpmLNcIiwgXCLlrZDoqIBcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubmlja05hbWUyID0gW1xyXG4gICAgICAgICAgICBcIumbgOWco1wiLCBcIui1jOS+oFwiLCBcIui1jOWco1wiLCBcIueos+i1olwiLCBcIuS4jei+k1wiLFxyXG4gICAgICAgICAgICBcIuWlvei/kFwiLCBcIuiHquaRuFwiLCBcIuaciemSsVwiLCBcIuWcn+ixqlwiLFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8v5Li75Lq654mp5Z+65pys5pWw5o2uXHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YSA9IHt9XHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YS5jdWlkID0gMCxcclxuICAgICAgICB0aGlzLm1haW5QbGF5ZXJEYXRhLm5pY2tfbmFtZSA9IFwiXCIsXHJcbiAgICAgICAgdGhpcy5tYWluUGxheWVyRGF0YS5wZW5pZCA9IFwiXCJcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGFjaE1zZzpmdW5jdGlvbihuYW1lLGRhdGEpe1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXSA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpc1tuYW1lXShkYXRhKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG5cclxuICAgIFB1YmxpY1Byb3RvX1NfTm90aWNlIDogZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgY2MuZ3VpbWFuYWdlci5tc2dCb3goZGF0YS50ZXh0KVxyXG4gICAgfSxcclxuXHJcbiAgICBzYXZlUm9vbVNldHRpbmc6ZnVuY3Rpb24oc2V0dGluZyl7XHJcbiAgICAgICAgdGhpcy5yb29tU2V0dGluZyA9IHNldHRpbmdcclxuICAgIH0sXHJcbiAgICBnZXRSb29tU2V0dGluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb21TZXR0aW5nXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVzZXJPcGVuSWQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGlkID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlck9wZW5JZFwiKTtcclxuICAgICAgICAvLyBpZihpZCA9PSBudWxsKXtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwKTtcclxuICAgICAgICAgICAgaWQgPSBudW0udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlck9wZW5JZFwiLCBpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tmlja05hbWU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG5pY2tuYW1lID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlck5pY2tOYW1lXCIpO1xyXG4gICAgICAgIGlmKG5pY2tuYW1lID09IG51bGwpe1xyXG4gICAgICAgICAgICB2YXIgbmlja05hbWUxID0gY2MuY29uZmlnbWFuYWdlci5uaWNrTmFtZTFcclxuICAgICAgICAgICAgdmFyIG5pY2tOYW1lMiA9IGNjLmNvbmZpZ21hbmFnZXIubmlja05hbWUyXHJcbiAgICAgICAgICAgIG5pY2tuYW1lID0gbmlja05hbWUxW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxNSldICsgbmlja05hbWUyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5KV07XHJcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJOaWNrTmFtZVwiLCBuaWNrbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuaWNrbmFtZTtcclxuICAgIH0sXHJcblxyXG59KTtcclxuXHJcbmNjLmRhdGFtYW5hZ2VyID0gbmV3IE0oKVxyXG4iLCIvL+a4uOaIj+euoeeQhuWZqO+8jOi/m+WFpeaIv+mXtOWQjueahOaVsOaNruWSjOmAu+i+keeuoeeQhlxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuXHJcbiAgICBjdG9yOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX3BsYXllcnMgPSBbXTsgICAgIC8v5oi/6Ze0546p5a625L+h5oGv77yM5YyF5ous6Ieq5bexXHJcblxyXG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHRQb2tlcnMoKVxyXG5cclxuICAgICAgICB0aGlzLl9jdXJyZW50TWF0Y2hJZHggPSAwOyAgICAgIC8v5b2T5YmN5piv56ys5Yeg5bGA77yMMOS7o+ihqOa1i+ivleaVsOaNrlxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0RGVmYXVsdFBva2VyczogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9teVBva2VyVmFsdWVzID0gW11cclxuICAgICAgICB0aGlzLl9teVBva2VyVmFsdWVzLnB1c2goWzE4LDQyLDgsNyw2LDUsMzgsMjYsMTcsMjUsMzcsMjEsMTldKTsgICAvL+aIkeaJi+S4iueahOWNgeS4ieW8oOeJjCwg56ysMOWxgOa1i+ivleaVsOaNrlxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG5hbWUsZGF0YSl7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdKGRhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy/liJvlu7rmiJbliqDlhaXmiL/pl7Tov5Tlm57miJDlip9cclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX1Jvb21BdHRyOmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgaWYgKG1zZy5yb29tX2NvZGUgIT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbV9pbmZvID0gbXNnXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXJ0KClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yi35paw5oi/6Ze0546p5a625pWw5o2uXHJcbiAgICBQdWJsaWNQcm90b19TX0cxM19QbGF5ZXJzSW5Sb29tOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGNjLmxvZyhcIuaUtuWIsOWKoOWFpeaIv+mXtOa2iOaBryBzaXplID1cIiArIG1zZy5wbGF5ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fcGxheWVycyA9IFtdXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5wbGF5ZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fVxyXG4gICAgICAgICAgICBkYXRhLmN1aWQgPSBtc2cucGxheWVyc1tpXS5jdWlkO1xyXG4gICAgICAgICAgICBkYXRhLnN0YXR1cyA9IG1zZy5wbGF5ZXJzW2ldLnN0YXR1cztcclxuICAgICAgICAgICAgZGF0YS5uYW1lID0gbXNnLnBsYXllcnNbaV0ubmFtZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLmRpc3BhY2hNc2coXCJvblBsYXllckluUm9vbVwiLCB0aGlzLl9wbGF5ZXJzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGxheWVyIDogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBjYy5sb2coXCJ0aGlzLl9wbGF5ZXJzLmxlbmd0aDpcIiArIHRoaXMuX3BsYXllcnMubGVuZ3RoKVxyXG4gICAgICAgIGlmICh0aGlzLl9wbGF5ZXJzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wbGF5ZXJzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxheWVyc1tpXS5jdWlkLmVxKGlkKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWVyc1tpXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIG1haW5QbGF5ZXIgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQbGF5ZXIoY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEuY3VpZClcclxuICAgIH0sXHJcblxyXG4gICAgLy/muLjmiI/lvIDlp4vosIPnlKhcclxuICAgIGdhbWVTdGFydCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmKHRoaXMucm9vbV9pbmZvICYmIGNjLmRpcmVjdG9yLmdldFNjZW5lKCkubmFtZSA9PSBcIk1haW5cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLnNjZW5lbWFuYWdlci5sb2FkUG9rZXJHYW1lU2NlbmUoKVxyXG5cclxuICAgICAgICAgICAgLy8gdGhpcy5fZmFjZXMgPSBbXVxyXG4gICAgICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDE7IGkgPD0gMTU7ICsraSlcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgaW5kZXggPSBpXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcyA9IHNlbGZcclxuICAgICAgICAgICAgLy8gICAgIHZhciBmdW5jID0gZnVuY3Rpb24oZXJyLHNmKXtcclxuICAgICAgICAgICAgLy8gICAgICAgICBzLl9mYWNlc1tpbmRleCAtIDFdID0gc2ZcclxuICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgLy8gICAgIGNjLmxvYWRlci5sb2FkUmVzKCdUZXh0dXJlcy9leHByZXNzaW9uJyArIGluZGV4LGNjLlNwcml0ZUZyYW1lLGZ1bmMpXHJcbiAgICAgICAgICAgIC8vICAgICB9KSgpXHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5ri45oiP57uT5p2f6LCD55SoXHJcbiAgICBnYW1lT3ZlciA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucm9vbV9pbmZvID0gbnVsbFxyXG4gICAgICAgIHRoaXMuX3BsYXllcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmluaXREZWZhdWx0UG9rZXJzKClcclxuICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZhY2VzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgaWYgKHRoaXMuX2ZhY2VzW2ldKVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBjYy5sb2FkZXIucmVsZWFzZUFzc2V0KHRoaXMuX2ZhY2VzW2ldKVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHRoaXMuX2ZhY2VzID0gbnVsbFxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gY3JlYXRlRmFjZTpmdW5jdGlvbihmYWNlaWQpe1xyXG4gICAgLy8gICAgIGlmICh0aGlzLl9mYWNlcyAmJiBmYWNlaWQgPD0gdGhpcy5fZmFjZXMubGVuZ3RoKVxyXG4gICAgLy8gICAgIHtcclxuICAgIC8vICAgICAgICAgdmFyIHByZWZhYiA9IHRoaXMuX2ZhY2VzW2ZhY2VpZCAtIDFdXHJcbiAgICAvLyAgICAgICAgIGNjLmxvZygncHJlZmFiOicgKyBwcmVmYWIpXHJcbiAgICAvLyAgICAgICAgIHJldHVybiBjYy5pbnN0YW50aWF0ZShwcmVmYWIpXHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHJldHVybiBudWxsXHJcbiAgICAvLyB9LFxyXG5cclxuICAgIC8v6I635Y+W5b2T5YmN5bGA55qEMTPlvKDniYxcclxuICAgIGdldEN1ck1hdGhQb2tlcnM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5fbXlQb2tlclZhbHVlcy5sZW5ndGggPiB0aGlzLl9jdXJyZW50TWF0Y2hJZHgpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXlQb2tlclZhbHVlc1t0aGlzLl9jdXJyZW50TWF0Y2hJZHhdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aUtuWIsOWPkeeJjOa2iOaBr1xyXG4gICAgUHVibGljUHJvdG9fU19HMTNfSGFuZE9mTWluZTogZnVuY3Rpb24obXNnKXtcclxuICAgICAgICBjYy5sb2coXCLmlLbliLDlj5HniYzmtojmga8sIOeJjOaVsOmHjyA9IFwiICsgbXNnLmNhcmRzLmxlbmd0aClcclxuXHJcbiAgICAgICAgaWYobXNnLmNhcmRzLmxlbmd0aCAhPSAxMyl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIueJjOaVsOaNruS4jeWvue+8gVwiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX215UG9rZXJWYWx1ZXMucHVzaChtc2cuY2FyZHMpXHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1hdGNoSWR4KytcclxuXHJcbiAgICAgICAgaWYodGhpcy5fY3VycmVudE1hdGNoSWR4ID09IDEpeyAgICAgLy/lvIDlp4vnrKzkuIDmiopcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5kaXNwYWNoTXNnKFwibmV3TWF0Y2hTdGFydFwiKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgLy/nrKzkuozmiormlbDmja7lt7Lnu4/ov4fmnaXvvIzlhYjlrZjlgqjnrYnlvoXnrKzkuIDmiorlrqLmiLfnq6/liqjnlLvnu5PmnZ9cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aKleelqOWNj+iurlxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfQWJvcnRHYW1lT3JOb3Q6IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgdGhpcy52b3RlSW5mbyA9IG1zZyBcclxuICAgICAgIGNjLmd1aW1hbmFnZXIuc2hvd09yT3BlblVJKCdVSVZvdGUnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+aKleelqOWksei0pVxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfVm90ZUZhaWxlZDogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICBjYy5ndWltYW5hZ2VyLmNsb3NlQnlOYW1lKCdVSVZvdGUnKVxyXG4gICAgICAgdmFyIG5hbWUgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIobXNnLm9wcG9uZW50KS5uYW1lXHJcbiAgICAgICBjYy5ndWltYW5hZ2VyLm1zZ0JveCgn546p5a62OicuY29uY2F0KG5hbWUsJyzkuI3lkIzmhI8s5oqV56Wo5pyq6YCa6L+HLOa4uOaIj+e7p+e7reOAgicpKVxyXG4gICAgfSxcclxuICAgIFxyXG59KTtcclxuXHJcbmNjLmdhbWVtYW5hZ2VyID0gbmV3IE0oKVxyXG4iLCJcclxudmFyIE0gPSBjYy5DbGFzcyh7XHJcblxyXG4gICAgY3RvciA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB7fVxyXG4gICAgICAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG5hbWUsbXNnZGF0YSl7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucGFuZWxzKXtcclxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhbmVsc1trZXldXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDxsaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGxpc3RbaV1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcFtuYW1lXSA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBbbmFtZV0obXNnZGF0YSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgfSxcclxuXHJcbiAgIG9wZW46ZnVuY3Rpb24obmFtZSxjYWxsLGJ2aXNpYmxlKXtcclxuICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgY2MubG9hZGVyLmxvYWRSZXMoJ0d1aS8nICsgbmFtZSxmdW5jdGlvbihlcnIscHJlZmFiKSB7XHJcbiAgICAgICAgaWYgKHByZWZhYiAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHByZWZhYilcclxuICAgICAgICAgICAgb2JqLnBhcmVudCA9IGNjLmRpcmVjdG9yLmdldFNjZW5lKClcclxuICAgICAgICAgICAgdmFyIHBhbmVsID0gb2JqLmdldENvbXBvbmVudChjYy51aXBhbmVsKTtcclxuICAgICAgICAgICAgaWYgKGNhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGNhbGwocGFuZWwpXHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gc2VsZi5wYW5lbHNbbmFtZV1cclxuICAgICAgICAgICAgaWYgKCFsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5sb2coJ2FkZCBsaXN0OicgKyBuYW1lKVxyXG4gICAgICAgICAgICAgICAgbGlzdCA9IFtdXHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsc1tuYW1lXSA9IGxpc3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYW5lbC5vbkNyZWF0ZSgpXHJcbiAgICAgICAgICAgIGlmIChidmlzaWJsZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBwYW5lbC5zZXRWaXNpYmxlKHRydWUpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc2V0VmlzaWJsZShidmlzaWJsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGlzdC5wdXNoKHBhbmVsKVxyXG4gICAgICAgICAgICByZXR1cm4gcGFuZWxcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MubG9nKCdvcGVuIHBhbmVsIGZhaWw6JyArIG5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgfSxcclxuXHJcbiAgIHNob3dPck9wZW5VSTpmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgdmFyIHBhbmVsID0gdGhpcy5nZXRCeU5hbWUobmFtZSlcclxuICAgICAgICBpZiAocGFuZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYW5lbC5zZXRWaXNpYmxlKHRydWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbihuYW1lLG51bGwsdHJ1ZSlcclxuICAgICAgICB9XHJcbiAgIH0sXHJcblxyXG4gICBtc2dCb3ggOiBmdW5jdGlvbihtc2csZnVuYykge1xyXG4gICAgICAgIHRoaXMub3BlbignVUlNZXNzYWdlQm94JyxmdW5jdGlvbihwYW5lbCl7XHJcbiAgICAgICAgICAgIHBhbmVsLnNldE1lc3NhZ2UobXNnKVxyXG4gICAgICAgICAgICBwYW5lbC5zZXRDYWxsKGZ1bmMpXHJcbiAgICAgICAgfSlcclxuICAgfSxcclxuXHJcbiAgIHdhaXQgOiBmdW5jdGlvbihtc2cpIHtcclxuICAgIGNjLmxvZyhtc2cpXHJcbiAgICB0aGlzLm9wZW4oJ1VJV2FpdGluZycsZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgICAgIHBhbmVsLnNldE1lc3NhZ2UobXNnKVxyXG4gICAgfSk7XHJcbiAgIH0sXHJcblxyXG4gICBjbG9zZVdhaXQgOiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5jbG9zZUJ5TmFtZSgnVUlXYWl0aW5nJylcclxuICAgfSxcclxuXHJcbiAgIGRlc3Ryb3lQYW5lbDpmdW5jdGlvbihwYW5lbCl7XHJcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLm5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwYW5lbC5vbkNsb3NlKClcclxuICAgICAgICAgICAgcGFuZWwubm9kZS5kZXN0cm95KClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgY2xvc2U6ZnVuY3Rpb24ocGFuZWwpe1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucGFuZWxzKXtcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucGFuZWxzW2tleV1cclxuICAgICAgICBpZiAobGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7aSA+PSAwOyAtLWkpXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXSA9PSBwYW5lbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lQYW5lbChwYW5lbClcclxuICAgICAgICAgICAgICAgICAgICBsaXN0LnNsaWNlKGksMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QnlOYW1lOmZ1bmN0aW9uKHBhbmVsTmFtZSkge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5wYW5lbHNbcGFuZWxOYW1lXVxyXG4gICAgICAgIGlmIChsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbMF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgIGNsb3NlQnlOYW1lOmZ1bmN0aW9uKHBhbmVsTmFtZSl7XHJcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhbmVsc1twYW5lbE5hbWVdXHJcbiAgICAgICAgY2MubG9nKCdiZWdpbiBjbG9zZUJ5bmFtZTonICsgcGFuZWxOYW1lKVxyXG4gICAgICAgIGlmIChsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxpc3QubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVBhbmVsKGxpc3RbaV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYW5lbHNbcGFuZWxOYW1lXSA9IFtdXHJcbiAgICAgICAgfVxyXG4gICB9LFxyXG5cclxuICAgY2xvc2VBbGw6ZnVuY3Rpb24oKXtcclxuICAgIGNjLmxvZygnY2xvc2UgQWxsOicgKyB0aGlzLnBhbmVscy5sZW5ndGgpXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wYW5lbHMpe1xyXG4gICAgICAgIGNjLmxvZygna2V5OicgKyBrZXkpXHJcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhbmVsc1trZXldXHJcbiAgICAgICAgaWYgKGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGlzdC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MubG9nKCdkZXN0cm95UGFuZWw6JyArIGxpc3QubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95UGFuZWwobGlzdFtpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucGFuZWxzID0ge31cclxuICAgfVxyXG59KTtcclxuY2MuZ3VpbWFuYWdlciA9IG5ldyBNKCk7XHJcblxyXG5cclxuIiwidmFyIE0gPSBjYy5DbGFzcyh7XHJcbiAgIFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQgOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1lID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGFcclxuICAgICAgICBjYy5sb2coJ3l1bnZhc2RrOicgKyB5dW52YXNkay5JTURpc3BhdGNoTXNnTm9kZSlcclxuICAgICAgICBjYy5sb2coJ3RoaXMuaW0wOicgKyB0aGlzLmltKVxyXG4gICAgICAgIHRoaXMuaW0gPSB5dW52YXNkay5JTURpc3BhdGNoTXNnTm9kZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNjLmxvZygndGhpcy5pbTE6JyArIHRoaXMuaW0pXHJcbiAgICAgICAgdGhpcy5pbS5pbml0U0RLKGNjLmNvbmZpZ21hbmFnZXIueXVueWluX3Nka19pZClcclxuICAgICAgICB0aGlzLmltLmNwTG9naW4obWUubmlja19uYW1lLG1lLmN1aWQpIFxyXG4gICAgICAgIHRoaXMuaW0uc2V0TGlzdGVuZXIodGhpcyx0aGlzLm9uTWVzc2FnZSlcclxuICAgIH0sXHJcblxyXG4gICAgb25NZXNzYWdlIDogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIGNjLmluZm8oJ+aUtuWIsOivremfs+a2iOaBrzonICsgZGF0YSlcclxuICAgICAgICB2YXIgcnNwID0gSlNPTi5wYXJzZShkYXRhKVxyXG4gICAgICAgIHN3aXRjaChyc3AubmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJZVlNES19VUExPQURfQ09NUExFVEVEXCI6IC8v5LiK5Lyg5oiQ5YqfXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9vblVwbG9hZClcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vblVwbG9hZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiWVZTREtfU1RPUF9SRUNPUkRcIjpcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5fb25TdG9wUmVjb3JkKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29uU3RvcFJlY29yZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q2FsbCA6IGZ1bmN0aW9uKG9uVXBsb2FkLG9uU3RvcFJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuX29uVXBsb2FkID0gb25VcGxvYWRcclxuICAgICAgICB0aGlzLl9vblN0b3BSZWNvcmQgPSBvblN0b3BSZWNvcmRcclxuICAgIH1cclxufSk7XHJcblxyXG5jYy5pbW1hbmFnZXIgPSBuZXcgTSgpIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsIlxyXG52YXIgTSA9IGNjLkNsYXNzKHtcclxuICAgIGN0b3I6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXF1aXJlKCdsb25nJylcclxuICAgICAgICByZXF1aXJlKCdieXRlYnVmZmVyJylcclxuICAgICAgICB0aGlzLlByb3RvQnVmID0gcmVxdWlyZSgncHJvdG9idWYnKVxyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IFtdXHJcbiAgICAgICAgdGhpcy5maXJzdExvZ2luID0gdHJ1ZVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdDpmdW5jdGlvbigpe1xyXG5cclxuICAgICAgdGhpcy5tZXNzYWdlcyA9IHt9O1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHRoaXMubG9hZFByb3RvKCdQcm90by9jbGllbnQnLGZ1bmN0aW9uKGJ1aWxkZXIpe1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLkNfTG9naW4nKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5TX0xvZ2luUmV0Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19Ob3RpY2UnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX1NlbmRDaGF0Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19DaGF0Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfSmlvbkdhbWUnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19DcmVhdGVHYW1lJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfUGxheWVyc0luUm9vbScpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX1Jvb21BdHRyJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfR2l2ZVVwJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfVm90ZUZhaWxlZCcpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX0Fib3J0R2FtZU9yTm90Jyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfVm90ZUZvQWJvcnRHYW1lJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfUGxheWVyUXVpdGVkJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uQ19HMTNfUmVhZHlGbGFnJyk7XHJcbiAgICAgICAgc2VsZi5idWlsZE1lc3NhZ2UoYnVpbGRlciwnUHVibGljUHJvdG8uU19HMTNfUGxheWVyc0luUm9vbScpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX0hhbmRPZk1pbmUnKTtcclxuICAgICAgICBzZWxmLmJ1aWxkTWVzc2FnZShidWlsZGVyLCdQdWJsaWNQcm90by5DX0cxM19CcmluZ091dCcpO1xyXG4gICAgICAgIHNlbGYuYnVpbGRNZXNzYWdlKGJ1aWxkZXIsJ1B1YmxpY1Byb3RvLlNfRzEzX0FsbEhhbmRzJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmxvYWRQcm90b0lEKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBsb2FkUHJvdG86ZnVuY3Rpb24ocGF0aCxjYWxsKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHBhdGgsZnVuY3Rpb24oZXJyLHByb3RvKXtcclxuICAgICAgICAgIHZhciBidWlsZGVyID0gc2VsZi5Qcm90b0J1Zi5wcm90b0Zyb21TdHJpbmcocHJvdG8pO1xyXG4gICAgICAgICAgY2FsbChidWlsZGVyKVxyXG4gICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJ1aWxkTWVzc2FnZTpmdW5jdGlvbihidWlsZGVyLG5hbWUpe1xyXG4gICAgICAgIHRoaXMubWVzc2FnZXNbbmFtZV0gPSBidWlsZGVyLmJ1aWxkKG5hbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkUHJvdG9JRDpmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgY2MubG9hZGVyLmxvYWRSZXMoJ1Byb3RvL3Byb3RvaWQnLGZ1bmN0aW9uKGVycixwcm90b2lkKXtcclxuICAgICAgICBzZWxmLmlkX25hbWVfbWFwID0gSlNPTi5wYXJzZShwcm90b2lkKVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgaWRfbmFtZV9jb252ZXJ0OmZ1bmN0aW9uKGlkX29yX25hbWUpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm90b19pZF9uYW1lX21hcFtpZF9vcl9uYW1lXVxyXG4gICAgfSxcclxuXHJcbiAgICBjb25uZWN0OmZ1bmN0aW9uKGlwLHBvcnQsZnVuYyl7XHJcbiAgICAgICAgaWYgKHRoaXMuamJzb2NrZXQgPT0gbnVsbClcclxuICAgICAgICAgIHRoaXMuamJzb2NrZXQgPSBuZXcgSkJTb2NrZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmpic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICBmdW5jKHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuamJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3JpZCA9PSBKQlNvY2tldC5Db25uZWN0RXJyb3IpXHJcbiAgICAgICAgICAgIGZ1bmMoZmFsc2UpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgIC8vIHNlbGYuZGlzcGFjaCgnZGlzcGFjaE1zZycsJ29uTmV0RXJyb3InLGRhdGEuZXJyb3JpZCk7XHJcbiAgICAgICAgICAgY2MubG9nKCdlcnJvcjonKVxyXG4gICAgICAgICAgIHNlbGYuY2xvc2UoKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgfVxyXG4gICAgICAgIHRoaXMuamJzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNjLmxvZygnZGF0YS5tc2dpZDonICsgZGF0YS5tc2dpZClcclxuICAgICAgICAgIHNlbGYuZGlzcGFjaE1zZyhkYXRhLm1zZ2lkLGRhdGEubXNnKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmpic29ja2V0LmNvbm5lY3QoaXAscG9ydCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVySVAgPSBpcFxyXG4gICAgICAgIHRoaXMuc2VydmVyUG9ydCA9IHBvcnRcclxuICAgIH0sXHJcblxyXG4gICAgcmVjb25uZWN0OmZ1bmN0aW9uKCl7XHJcbiAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgIGNjLmd1aW1hbmFnZXIud2FpdCgn5q2j5Zyo6L+e5o6lLOivt+eojeWQji4uLicpXHJcbiAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnNlcnZlcklQLHRoaXMuc2VydmVyUG9ydCxmdW5jdGlvbihpc0Nvbm5lY3Qpe1xyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIuY2xvc2VXYWl0KClcclxuICAgICAgICAgIGlmICghaXNDb25uZWN0KVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLm1zZ0JveCgn6L+e5o6l5aSx6LSlLOeCueWHu+ehruWumumHjeivlSEnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgY2MubmV0bWFuYWdlci5yZWNvbm5lY3QoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAvL+i/nuaOpeaIkOWKnyAs5YeG5aSH55m76ZmGXHJcbiAgICAgICAgICAgIHNlbGYubG9naW4oc2VsZi5sb2dpblR5cGUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIC8v55m76ZmG6L+U5ZueXHJcbiAgICBQdWJsaWNQcm90b19TX0xvZ2luUmV0OmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgIGlmIChtc2cucmV0X2NvZGUgPT0gMSAmJiAhdGhpcy5maXJzdExvZ2luKVxyXG4gICAgICB7XHJcbiAgICAgICAgY2MubG9nKCfph43ov57miJDlip8hJylcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZpcnN0TG9naW4gPSBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBsb2dpbjpmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICB2YXIgbXNnID0gdGhpcy5tc2coJ1B1YmxpY1Byb3RvLkNfTG9naW4nKTtcclxuICAgICAgIG1zZy5sb2dpbl90eXBlID0gdHlwZVxyXG4gICAgICAgbXNnLm9wZW5pZCA9IGNjLmRhdGFtYW5hZ2VyLmdldFVzZXJPcGVuSWQoKVxyXG4gICAgICAgY2MubG9nKFwib3BlbmlkID0gXCIgKyBtc2cub3BlbmlkKVxyXG4gICAgICAgbXNnLnRva2VuID0gJ3h4eHh4J1xyXG4gICAgICAgbXNnLm5pY2tfbmFtZSA9IGNjLmRhdGFtYW5hZ2VyLmdldE5pY2tOYW1lKCk7XHJcbiAgICAgICBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5uaWNrX25hbWUgPSBtc2cubmlja19uYW1lO1xyXG4gICAgICAgY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEub3BlbmlkID0gbXNnLm9wZW5pZDtcclxuICAgICAgIGNjLmxvZyhcIm9wZW5pZCA9IFwiICsgbXNnLm9wZW5pZCArIFwiLCBuaWNrbmFtZSA9IFwiICsgbXNnLm5pY2tfbmFtZSk7XHJcbiAgICAgICB0aGlzLnNlbmQobXNnKTtcclxuICAgICAgIHRoaXMubG9naW5UeXBlID0gdHlwZTtcclxuICAgIH0sXHJcblxyXG4gICAgb25EaXNjb25uZWN0OmZ1bmN0aW9uKCkge1xyXG4gICAgICAvL+mHjei/nlxyXG4gICAgICBpZiAoIXRoaXMuZmlyc3RMb2dpbilcclxuICAgICAge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIGNjLmd1aW1hbmFnZXIubXNnQm94KCfnvZHnu5zmlq3lvIAs54K55Ye756Gu5a6a5bCd6K+V6YeN6L+eIScsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5yZWNvbm5lY3QoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/lhbPpl63nvZHnu5xcclxuICAgIGNsb3NlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKHRoaXMuamJzb2NrZXQgIT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aGlzLmpic29ja2V0LmNsb3NlKCk7XHJcbiAgICAgICAgICB0aGlzLmpic29ja2V0ID0gbnVsbDtcclxuICAgICAgICAgIGNjLmxvZygnb25EaXNjb25uZWN0JylcclxuICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5YiG5Y+R5raI5oGvXHJcbiAgICBkaXNwYWNoTXNnOmZ1bmN0aW9uKG1zZ2lkLG1zZykge1xyXG4gICAgICB2YXIgbXNnbmFtZSA9IHRoaXMuaWRfbmFtZV9tYXBbU3RyaW5nKG1zZ2lkKV1cclxuICAgICAgdmFyIG1zZ2RhdGEgPSB0aGlzLm1lc3NhZ2VzW21zZ25hbWVdLmRlY29kZShtc2cpXHJcbiAgICAgIHZhciBtc2doYW5kbGVybmFtZSA9IG1zZ25hbWUucmVwbGFjZSgnLicsJ18nKVxyXG5cclxuICAgICAgY2MubG9nKCdyZWN2OicgKyBtc2duYW1lKVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2doYW5kbGVybmFtZV0gPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXNbbXNnaGFuZGxlcm5hbWVdKG1zZ2RhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICB0aGlzLmRpc3BhY2goXCJkaXNwYWNoTXNnXCIsbXNnaGFuZGxlcm5hbWUsbXNnZGF0YSlcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGFjaDpmdW5jdGlvbihmdW5jbmFtZSxuYW1lLGRhdGEpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXIubGVuZ3RoOysraSlcclxuICAgICAge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcltpXVtmdW5jbmFtZV0obmFtZSxkYXRhKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v55Sz6K+35LiA5LiqIG1zZ1xyXG4gICAgbXNnOmZ1bmN0aW9uKG1zZ25hbWUpe1xyXG4gICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbbXNnbmFtZV07XHJcbiAgICAgIGlmIChtZXNzYWdlKVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIHJldCA9IG5ldyBtZXNzYWdlKCk7XHJcbiAgICAgICAgcmV0Ll9fbXNnaWQgPSB0aGlzLmlkX25hbWVfbWFwW21zZ25hbWVdXHJcbiAgICAgICAgcmV0dXJuIHJldFxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Y+R6YCBbXNnXHJcbiAgICBzZW5kOmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgIGlmICh0aGlzLmpic29ja2V0ICE9IG51bGwpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgaWQgPSBtc2cuX19tc2dpZFxyXG4gICAgICAgIHRoaXMuamJzb2NrZXQuc2VuZChpZCxuZXcgVWludDhBcnJheShtc2cudG9CdWZmZXIoKSkpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVnaXN0ZXJIYW5kbGVyOmZ1bmN0aW9uKGhhbmRsZXIpe1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgaWYgKGhhbmRsZXIgIT0gbnVsbCAmJiB0eXBlb2YgaGFuZGxlci5kaXNwYWNoTXNnID09ICdmdW5jdGlvbicpXHJcbiAgICAgIHtcclxuICAgICAgICAgIHNlbGYuaGFuZGxlci5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5jYy5uZXRtYW5hZ2VyID0gbmV3IE0oKTtcclxuXHJcblxyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHRvcE5vZGU6IGNjLk5vZGUsXHJcbiAgICAgICAgbWlkZGxlTm9kZTogY2MuTm9kZSxcclxuICAgICAgICBib3R0b21Ob2RlOiBjYy5Ob2RlLFxyXG5cclxuICAgICAgICBfYWxsUG9rZXJWYWx1ZXM6bnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2FsbFBva2VyVmFsdWVzID0gWzUyLDUxLDUwLDQ5LDQ4LDQ3LDQ2LDQ1LDQ0LDQzLDQyLDQxLDQwXVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0UG9rZXJWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcyl7XHJcbiAgICAgICAgdGhpcy5fYWxsUG9rZXJWYWx1ZXMgPSB2YWx1ZXNcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudG9wTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmQgPSB0aGlzLnRvcE5vZGUuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShcImJhY2tcIiwgbmQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5taWRkbGVOb2RlLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuZCA9IHRoaXMubWlkZGxlTm9kZS5jaGlsZHJlbltpXVxyXG4gICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKFwiYmFja1wiLCBuZClcclxuICAgICAgICB9XHJcbiAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmJvdHRvbU5vZGUuY2hpbGRyZW5Db3VudDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5kID0gdGhpcy5ib3R0b21Ob2RlLmNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUoXCJiYWNrXCIsIG5kKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/nv7vnrKzkuIDloqnniYxcclxuICAgIHRvcEZsb3BBY3Rpb246IGZ1bmN0aW9uKHBhcmFtKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjYy5zZXF1ZW5jZShjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQscGFyYW0pe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW0udG9wTm9kZS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2tlclZhbCA9IHRoaXMuX2FsbFBva2VyVmFsdWVzW2ldXHJcbiAgICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKHBva2VyVmFsLCBwYXJhbS50b3BOb2RlLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMsIHBhcmFtKSwgY2MuZGVsYXlUaW1lKDAuMykpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v57+756ys5LqM5aKp54mMXHJcbiAgICBtaWRkbGVGbG9wQWN0aW9uOiBmdW5jdGlvbihwYXJhbSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY2Muc2VxdWVuY2UoY2MuY2FsbEZ1bmMoZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJhbS5taWRkbGVOb2RlLmNoaWxkcmVuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gdGhpcy5fYWxsUG9rZXJWYWx1ZXNbaSszXVxyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShwb2tlclZhbCwgcGFyYW0ubWlkZGxlTm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLHBhcmFtKSwgY2MuZGVsYXlUaW1lKDAuMykpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v57+756ys5LiJ5aKp54mMXHJcbiAgICBib3R0b21GbG9wQWN0aW9uOiBmdW5jdGlvbihwYXJhbSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY2Muc2VxdWVuY2UoY2MuY2FsbEZ1bmMoZnVuY3Rpb24odGFyZ2V0LCBwYXJhbSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJhbS5ib3R0b21Ob2RlLmNoaWxkcmVuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gdGhpcy5fYWxsUG9rZXJWYWx1ZXNbaSs4XVxyXG4gICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShwb2tlclZhbCwgcGFyYW0uYm90dG9tTm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLCBwYXJhbSksIGNjLmRlbGF5VGltZSgwLjMpKVxyXG4gICAgfVxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0U3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmQgPSB0aGlzLm5vZGUuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgbmQuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfaXNTZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgX3Bva2VyVmFsOiAwLFxyXG4gICAgICAgIF9wb2tlckluZGV4OiAtMSxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQgfHwgY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsIHRoaXMuX29uU2VsZWN0KTtcclxuICAgICAgICAgICAgLy90aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfTU9WRSwgdGhpcy5fb25TZWxlY3QpO1xyXG4gICAgICAgICAgICAvL3RoaXMubm9kZS5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9FTkQsIHRoaXMuX29uU2VsZWN0KTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLk1PVVNFX0RPV04sIHRoaXMuX29uU2VsZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9vblNlbGVjdDogZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG4gICAgICAgIGlmKCFjb21wb25lbnQuX2lzU2VsZWN0ZWQpe1xyXG4gICAgICAgICAgICBjb21wb25lbnQubW92ZU91dChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyU29ydFwiKS5nZXRDb21wb25lbnQoXCJQb2tlclNvcnRcIikuc2VsZWN0Q2FyZChjb21wb25lbnQuX3Bva2VyVmFsKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29tcG9uZW50Lm1vdmVCYWNrKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICBjYy5maW5kKFwiVUlQb2tlckdhbWUvUG9rZXJTb3J0XCIpLmdldENvbXBvbmVudChcIlBva2VyU29ydFwiKS51bnNlbGVjdENhcmQoY29tcG9uZW50Ll9wb2tlclZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtb3ZlT3V0OiBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICBub2RlLnJ1bkFjdGlvbihjYy5tb3ZlQnkoMC4wNiwgY2MucCgwLCAyMCkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUJhY2s6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICBub2RlLnJ1bkFjdGlvbihjYy5tb3ZlQnkoMC4wNiwgY2MucCgwLCAtMjApKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBva2VyVmFsdWU6IGZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgdGhpcy5fcG9rZXJWYWwgPSB2YWw7XHJcbiAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZSh2YWwsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgIHZhciB1cmwgPSBjYy5Qb2tlclV0aWwuZ2V0UG9rZXJTcHJpdGVQYXRoKHZhbCk7XHJcbiAgICAgICAgY2MubG9nKHVybCk7XHJcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXModXJsLCBjYy5TcHJpdGVGcmFtZSwgZnVuY3Rpb24oZXJyLCBzcHJpdGVGcmFtZSl7XHJcbiAgICAgICAgICAgIGNjLmxvZyh1cmwsIHNwcml0ZUZyYW1lLCBzcHJpdGUpXHJcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgKi9cclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9rZXJJbmRleDogZnVuY3Rpb24oaWR4KXtcclxuICAgICAgICB0aGlzLl9wb2tlckluZGV4ID0gaWR4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBwb2tlclNlbGVjdFByZWZhYjogY2MuUHJlZmFiLFxyXG4gICAgICAgIHNvcnRUeXBlTGFiZWw6IGNjLkxhYmVsLFxyXG4gICAgICAgIHRvcEJ0bkxhYmVsOiBjYy5MYWJlbCxcclxuICAgICAgICBtaWRkbGVCdG5MYWJlbDogY2MuTGFiZWwsXHJcbiAgICAgICAgYm90dG9tQnRuTGFiZWw6IGNjLkxhYmVsLFxyXG4gICAgICAgIGNhcmRMaXN0OmNjLk5vZGUsXHJcbiAgICAgICAgY29uZmlybUJ0bjogY2MuTm9kZSxcclxuICAgICAgICBhdXRvVHlwZUNvbnRhaW5lcjogY2MuTm9kZSxcclxuXHJcbiAgICAgICAgX3RvcDpbXSxcclxuICAgICAgICBfbWlkZGxlOltdLFxyXG4gICAgICAgIF9ib3R0b206W10sXHJcbiAgICAgICAgX3Bva2VyTGlzdDogbnVsbCxcclxuICAgICAgICBfY3VycmVudFNvcnRUeXBlOiAyLCAgLy/pu5jorqTmjInlpKflsI/mjpLluo9cclxuXHJcbiAgICAgICAgX2ZyZWVQb2tlcjogbnVsbFxyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5pdFBva2VycygpO1xyXG4gICAgICAgIHRoaXMuaW5pdEZyZWVTb3J0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRQb2tlcnM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5fcG9rZXJMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5fdW5zZWxlY3RQb2tlciA9IGNjLmdhbWVtYW5hZ2VyLmdldEN1ck1hdGhQb2tlcnMoKSAgICAgICAgIC8v5pyq5pS+5YWl55qEMTPlvKDniYxcclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/pgInmi6nlh4blpIfmlL7lhaXnmoTniYxcclxuXHJcbiAgICAgICAgLy92YXIgd2lkdGggPSBjYy5jb25maWdtYW5hZ2VyLnduZFNjYWxlICogNjBcclxuICAgICAgICB2YXIgdG90YWxTaXplID0gKHRoaXMuX3Vuc2VsZWN0UG9rZXIubGVuZ3RoIC0gMSkgKiA2MCAvIDI7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Vuc2VsZWN0UG9rZXIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0UG9rZXIgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnBva2VyU2VsZWN0UHJlZmFiKTtcclxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IHNlbGVjdFBva2VyLmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gdGhpcy5fdW5zZWxlY3RQb2tlcltpXTtcclxuICAgICAgICAgICAgc2NyaXB0LnNldFBva2VyVmFsdWUocG9rZXJWYWwpO1xyXG4gICAgICAgICAgICAvL3NjcmlwdC5zZXRQb2tlckluZGV4KGkpO1xyXG5cclxuICAgICAgICAgICAgc2VsZWN0UG9rZXIucGFyZW50ID0gdGhpcy5jYXJkTGlzdDtcclxuICAgICAgICAgICAgc2VsZWN0UG9rZXIucG9zaXRpb24gPSBjYy52MigtdG90YWxTaXplK2kqNjAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckxpc3QucHVzaChzZWxlY3RQb2tlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdmFyIHNjYWxlID0gY2MuY29uZmlnbWFuYWdlci53bmRTY2FsZVxyXG4gICAgICAgIC8vdGhpcy5jYXJkTGlzdC5zZXRTY2FsZShzY2FsZSwgc2NhbGUpXHJcbiAgICB9LFxyXG5cclxuICAgIF9yZXNldFBva2VyczogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9yZXNldFBva2Vyc1N0YXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgY2MuUG9rZXJVdGlsLnNvcnRQb2tlcih0aGlzLl9jdXJyZW50U29ydFR5cGUsIHRoaXMuX3Vuc2VsZWN0UG9rZXIpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl91bnNlbGVjdFBva2VyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHBva2VyVmFsID0gdGhpcy5fdW5zZWxlY3RQb2tlcltpXTtcclxuICAgICAgICAgICAgaWYocG9rZXJWYWwgIT0gMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Bva2VyTGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIG5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBub2RlLmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0LnNldFBva2VyVmFsdWUocG9rZXJWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaSA9IGluZGV4OyBpIDwgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5fcG9rZXJMaXN0W2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3Jlc2V0UG9rZXJzU3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bva2VyTGlzdC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcG9rZXJMaXN0W2ldO1xyXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlclNlbGVjdFwiKTtcclxuICAgICAgICAgICAgaWYoc2NyaXB0Ll9pc1NlbGVjdGVkID09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0Lm1vdmVCYWNrKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHV0ZG93blBva2VyOiBmdW5jdGlvbih0eXBlKXtcclxuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5fc2VsZWN0ZWRQb2tlci5sZW5ndGg7XHJcbiAgICAgICAgaWYoKHR5cGUgPT0gMSAmJiBudW1iZXIgPiAzIC0gdGhpcy5fdG9wLmxlbmd0aCkgXHJcbiAgICAgICAgfHwgKHR5cGUgPT0gMiAmJiBudW1iZXIgPiA1IC0gdGhpcy5fbWlkZGxlLmxlbmd0aClcclxuICAgICAgICB8fCAodHlwZSA9PSAzICYmIG51bWJlciA+IDUgLSB0aGlzLl9ib3R0b20ubGVuZ3RoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIumAieaLqeeahOeJjOaVsOmHj+WkquWkmiFcIiArIG51bWJlcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG51bWJlcjsgKytpKVxyXG4gICAgICAge1xyXG4gICAgICAgICAgIHZhciBwb2tlclZhbCA9IHRoaXMuX3NlbGVjdGVkUG9rZXJbaV07XHJcbiAgICAgICAgICAgaWYodHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcIlVJUG9rZXJHYW1lL1Bva2VyU29ydC90b3AvY2FyZHMvY2FyZFwiICsgKHRoaXMuX3RvcC5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKHBhdGgpO1xyXG4gICAgICAgICAgICAgICBjYy5Qb2tlclV0aWwucmVwbGFjZVBva2VyU3ByaXRlKHBva2VyVmFsLCBub2RlKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fdG9wLnB1c2gocG9rZXJWYWwpO1xyXG4gICAgICAgICAgIH1lbHNlIGlmKHR5cGUgPT0gMil7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyU29ydC9taWRkbGUvY2FyZHMvY2FyZFwiICsgKHRoaXMuX21pZGRsZS5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgICAgICAgIGNjLlBva2VyVXRpbC5yZXBsYWNlUG9rZXJTcHJpdGUocG9rZXJWYWwsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl9taWRkbGUucHVzaChwb2tlclZhbCk7XHJcbiAgICAgICAgICAgfWVsc2UgaWYodHlwZSA9PSAzKXtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiVUlQb2tlckdhbWUvUG9rZXJTb3J0L2JvdHRvbS9jYXJkcy9jYXJkXCIgKyAodGhpcy5fYm90dG9tLmxlbmd0aCArIDEpKTtcclxuICAgICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZShwb2tlclZhbCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX2JvdHRvbS5wdXNoKHBva2VyVmFsKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgdGhpcy5vblB1dGRvd25DYXJkKCk7XHJcbiAgICAgICB0aGlzLl9yZXNldFBva2VycygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2xlYXJQb2tlckhvbGU6IGZ1bmN0aW9uKHR5cGUpe1xyXG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcclxuICAgICAgICB2YXIgbnVtYmVyID0gMDtcclxuXHJcbiAgICAgICAgaWYodHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgdGhpcy5vbkZhbGxiYWNrQ2FyZCh0aGlzLl90b3ApO1xyXG4gICAgICAgICAgICB0aGlzLl90b3AgPSBbXTtcclxuICAgICAgICAgICAgcGF0aCA9IFwiVUlQb2tlckdhbWUvUG9rZXJTb3J0L3RvcC9jYXJkcy9jYXJkXCI7XHJcbiAgICAgICAgICAgIG51bWJlciA9IDM7XHJcbiAgICAgICAgfWVsc2UgaWYodHlwZSA9PSAyKXtcclxuICAgICAgICAgICAgdGhpcy5vbkZhbGxiYWNrQ2FyZCh0aGlzLl9taWRkbGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9taWRkbGUgPSBbXTtcclxuICAgICAgICAgICAgcGF0aCA9IFwiVUlQb2tlckdhbWUvUG9rZXJTb3J0L21pZGRsZS9jYXJkcy9jYXJkXCI7XHJcbiAgICAgICAgICAgIG51bWJlciA9IDU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMub25GYWxsYmFja0NhcmQodGhpcy5fYm90dG9tKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tID0gW107XHJcbiAgICAgICAgICAgIHBhdGggPSBcIlVJUG9rZXJHYW1lL1Bva2VyU29ydC9ib3R0b20vY2FyZHMvY2FyZFwiO1xyXG4gICAgICAgICAgICBudW1iZXIgPSA1O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVybCA9IFwiVGV4dHVyZXMvaGVhZEJHXCI7XHJcbiAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHVybCwgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSBudW1iZXI7ICsraSApe1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKHBhdGgraSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gbm9kZS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgIHRoaXMuX3Jlc2V0UG9rZXJzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9yZWZyZXNoU3RhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSAodGhpcy5fdG9wLmxlbmd0aCA9PSAzICYmIHRoaXMuX21pZGRsZS5sZW5ndGggPT0gNSAmJiB0aGlzLl9ib3R0b20ubGVuZ3RoID09IDUpO1xyXG4gICAgICAgIHRoaXMuY29uZmlybUJ0bi5hY3RpdmUgPSB2aXNpYmxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsaWNrX1B1dFRvcDogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnRvcEJ0bkxhYmVsLnN0cmluZyA9IFwi5pS+5YWlXCI7ICBcclxuICAgICAgICBpZih0aGlzLl90b3AubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHRoaXMuX3B1dGRvd25Qb2tlcigxKTtcclxuICAgICAgICAgICAgaWYodGhpcy5fdG9wLmxlbmd0aCA9PSAzKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9wQnRuTGFiZWwuc3RyaW5nID0gXCLmlLblm55cIjsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQb2tlckhvbGUoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdEZyZWVTb3J0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xpY2tfUHV0TWlkZGxlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubWlkZGxlQnRuTGFiZWwuc3RyaW5nID0gXCLmlL7lhaVcIjsgIFxyXG4gICAgICAgIGlmKHRoaXMuX21pZGRsZS5sZW5ndGggPCA1KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcHV0ZG93blBva2VyKDIpO1xyXG4gICAgICAgICAgICBpZih0aGlzLl9taWRkbGUubGVuZ3RoID09IDUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taWRkbGVCdG5MYWJlbC5zdHJpbmcgPSBcIuaUtuWbnlwiOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhclBva2VySG9sZSgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaFN0YXRlKCk7XHJcbiAgICAgICAgdGhpcy5pbml0RnJlZVNvcnQoKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQ2xpY2tfUHV0Qm90dG9tOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuYm90dG9tQnRuTGFiZWwuc3RyaW5nID0gXCLmlL7lhaVcIjsgIFxyXG4gICAgICAgIGlmKHRoaXMuX2JvdHRvbS5sZW5ndGggPCA1KXtcclxuICAgICAgICAgICAgdGhpcy5fcHV0ZG93blBva2VyKDMpO1xyXG4gICAgICAgICAgICBpZih0aGlzLl9ib3R0b20ubGVuZ3RoID09IDUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3R0b21CdG5MYWJlbC5zdHJpbmcgPSBcIuaUtuWbnlwiOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhclBva2VySG9sZSgzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaFN0YXRlKCk7XHJcbiAgICAgICAgdGhpcy5pbml0RnJlZVNvcnQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25DbGlja19Tb3J0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRTb3J0VHlwZSA9PSAxKXtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNvcnRUeXBlID0gMjtcclxuICAgICAgICAgICAgdGhpcy5zb3J0VHlwZUxhYmVsLnN0cmluZyA9IFwi5aSn5bCP5o6S5bqPXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTb3J0VHlwZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydFR5cGVMYWJlbC5zdHJpbmcgPSBcIuiKseiJsuaOkuW6j1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0UG9rZXIoKTtcclxuICAgICAgICB0aGlzLl9yZXNldFBva2VycygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkemAgemAieaLqeWlveeahOeJjFxyXG4gICAgb25DbGlja19Db25maXJtOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZyhcIlB1YmxpY1Byb3RvLkNfRzEzX0JyaW5nT3V0XCIpXHJcbiAgICAgICAgdmFyIGNhcmRzID0gW11cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fdG9wLmxlbmd0aDsgKytpKXsgY2FyZHMucHVzaCh0aGlzLl90b3BbaV0pO31cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkZGxlLmxlbmd0aDsgKytpKXsgY2FyZHMucHVzaCh0aGlzLl9taWRkbGVbaV0pO31cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fYm90dG9tLmxlbmd0aDsgKytpKXsgY2FyZHMucHVzaCh0aGlzLl9ib3R0b21baV0pO31cclxuICAgICAgICBtc2cuY2FyZHMgPSBjYXJkc1xyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIuc2VuZChtc2cpXHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5kZXN0cm95KClcclxuICAgIH0sXHJcblxyXG4gICAgLy/liJ3lp4vljJboh6rnlLHmkYbniYxcclxuICAgIGluaXRGcmVlU29ydDogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9mcmVlUG9rZXIgPSBbXVxyXG4gICAgICAgIHZhciBjQXJyID0gY2MuUG9rZXJVdGlsLmdldEdyb3VwQ2FyZHModGhpcy5nZXRMZWZ0Q2FyZCgpKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzekFyciA9IFtdXHJcbiAgICAgICAgaWYoY0Fycls0XS5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgc3pBcnIgPSBbY0Fycls0XVswXS5zbGljZSgwLCA1KV1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2MubG9nKFwic2h1bnppXCIsIHN6QXJyLmxlbmd0aClcclxuXHJcbiAgICAgICAgdmFyIGNhcmRzID0gW2NBcnJbNl0sIHN6QXJyLCBjQXJyWzNdLCBjQXJyWzJdLCBjQXJyWzFdLnJldmVyc2UoKV1cclxuICAgICAgICB2YXIgbmFtZXMgPSBbXCLkupTlkIxcIiwgXCLpobrlrZBcIiwgXCLpk4HmlK9cIiwgXCLkuInmnaFcIiwgXCLlr7nlrZBcIl1cclxuICAgICAgICB2YXIgaWR4ID0gMFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYXJkcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKGNhcmRzW2ldLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fVxyXG4gICAgICAgICAgICAgICAgZGF0YS5uYW1lID0gbmFtZXNbaV1cclxuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBjYXJkc1tpXVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZVBva2VyLnB1c2goZGF0YSlcclxuICAgICAgICAgICAgICAgIGNjLmxvZyh0aGlzLmF1dG9UeXBlQ29udGFpbmVyLmNoaWxkcmVuW2lkeF0ubmFtZSwgdGhpcy5hdXRvVHlwZUNvbnRhaW5lci5jaGlsZHJlbltpZHhdLmNoaWxkcmVuWzBdLm5hbWUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9UeXBlQ29udGFpbmVyLmNoaWxkcmVuW2lkeF0uYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvVHlwZUNvbnRhaW5lci5jaGlsZHJlbltpZHhdLmNoaWxkcmVuWzBdLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gbmFtZXNbaV1cclxuICAgICAgICAgICAgICAgIGlkeCsrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBpID0gaWR4OyBpIDwgdGhpcy5hdXRvVHlwZUNvbnRhaW5lci5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9UeXBlQ29udGFpbmVyLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCJcIlxyXG4gICAgICAgICAgICB0aGlzLmF1dG9UeXBlQ29udGFpbmVyLmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iHqueUsemAieeJjOaMiemSrueCueWHu1xyXG4gICAgb25DbGlja19GcmVlU2VsZWN0QnRuOiBmdW5jdGlvbihldmVudCwgaW5kZXgpe1xyXG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3RQb2tlcigpO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0UG9rZXJzU3RhdGUoKVxyXG5cclxuICAgICAgICBpZih0aGlzLl9mcmVlUG9rZXIubGVuZ3RoID4gaW5kZXgpe1xyXG4gICAgICAgICAgICB2YXIgZnJlZVBrID0gdGhpcy5fZnJlZVBva2VyW2luZGV4XS52YWx1ZVswXVxyXG4gICAgICAgICAgICBjYy5sb2coZnJlZVBrLmxlbmd0aClcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZyZWVQay5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHYgPSBmcmVlUGtbaV1cclxuICAgICAgICAgICAgICAgIGNjLmxvZyhcInB2LnR5cGVcIiwgcHYudHlwZSwgXCJwdi52YWx1ZVwiLCBwdi52YWx1ZSlcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB0aGlzLl9wb2tlckxpc3QubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcG9rZXJMaXN0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBub2RlLmdldENvbXBvbmVudChcIlBva2VyU2VsZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNjcmlwdC5fcG9rZXJWYWwgPT0gKHB2LnR5cGUqMTMrcHYudmFsdWUpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm1vdmVPdXQobm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RDYXJkKHNjcmlwdC5fcG9rZXJWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2VsZWN0Q2FyZDogZnVuY3Rpb24odmFsKXtcclxuICAgICAgICBjYy5sb2coXCJzZWxlY3Q6IFwiICsgdmFsKTtcclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyLnB1c2godmFsKTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5zZWxlY3RDYXJkOiBmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWxlY3RlZFBva2VyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5fc2VsZWN0ZWRQb2tlcltpXSA9PSB2YWwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQb2tlci5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2MubG9nKFwidW5zZWxlY3Q6IFwiICsgdmFsICsgXCIsIGFscmVhZHkgdW5zZWxlY3QgbnVtOiBcIiArIHRoaXMuX3NlbGVjdGVkUG9rZXIubGVuZ3RoKVxyXG4gICAgfSxcclxuXHJcbiAgICBvblB1dGRvd25DYXJkOiBmdW5jdGlvbigpe1xyXG4gICAgICAgZm9yKHZhciBpIGluIHRoaXMuX3Vuc2VsZWN0UG9rZXIpe1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWxlY3RlZFBva2VyLmluZGV4T2YodGhpcy5fdW5zZWxlY3RQb2tlcltpXSlcclxuICAgICAgICAgICAgaWYoIGluZGV4ICE9IC0xKXtcclxuICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdW5zZWxlY3RQb2tlcltpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIHRoaXMuX3NlbGVjdGVkUG9rZXIgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgb25GYWxsYmFja0NhcmQ6IGZ1bmN0aW9uKGNhcmRzKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FyZHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5fdW5zZWxlY3RQb2tlci5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl91bnNlbGVjdFBva2VyW2pdID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0UG9rZXJbal0gPSBjYXJkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW107XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExlZnRDYXJkOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciByZXQgPSBbXVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl91bnNlbGVjdFBva2VyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5fdW5zZWxlY3RQb2tlcltpXSAhPSAwKXtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHRoaXMuX3Vuc2VsZWN0UG9rZXJbaV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2MubG9nKFwiZ2V0TGVmdENhcmQgc2l6ZSA9IFwiLCByZXQubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiByZXRcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJTZWxlY3RQb2tlcjogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFBva2VyID0gW107XHJcbiAgICB9LFxyXG59KTtcclxuIiwiXHJcbnZhciBNID0gY2MuQ2xhc3Moe1xyXG4gICAgY3RvcjogZnVuY3Rpb24oKXtcclxuXHJcbiAgICB9LFxyXG5cclxuLypcclxu5omR5YWL54mM5o+P6L+wXHJcbiAgICDoirHoibLvvJogIOm7keahgyAzICDjgIHnuqLmoYMgMiDjgIEg5qKF6IqxIDEg44CB5pa55Z2XIDBcclxuICAgIOeJjOeCueaVsO+8miAyIH4gQSA9PSAxIH4gMTNcclxuICAgIOeJjOaVsOWAvCA9ICjoirHoibIgKiAxMyArIOeCueaVsCAtIDEgKVxyXG4qL1xyXG5cclxuXHJcbiAgICBfZ2V0UG9rZXJTcHJpdGVQYXRoOmZ1bmN0aW9uKHBva2VyVmFsKXtcclxuICAgICAgICByZXR1cm4gXCJUZXh0dXJlcy9Qb2tlci9cIiArIHBva2VyVmFsLnRvU3RyaW5nKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6K6+572u5omR5YWL54mM5Zu+54mHXHJcbiAgICByZXBsYWNlUG9rZXJTcHJpdGU6ZnVuY3Rpb24ocG9rZXJWYWwsIG5vZGUpe1xyXG4gICAgICAgIHZhciBzcHJpdGUgPSBub2RlLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLl9nZXRQb2tlclNwcml0ZVBhdGgocG9rZXJWYWwpO1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHVybCwgY2MuU3ByaXRlRnJhbWUsIGZ1bmN0aW9uKGVyciwgc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZTtcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+i/lOWbnueJjOiKseiJsuWSjOeCueaVsFxyXG4gICAgX2dldENhcmRUeXBlOiBmdW5jdGlvbih4KXtcclxuICAgICAgICB2YXIgcmV0ID0ge307XHJcbiAgICAgICAgcmV0LnggPSAoeC0xKS8xMztcclxuICAgICAgICByZXQueSA9ICh4LTEpJTEzO1xyXG4gICAgICAgIHJldHVybiByZXRcclxuICAgIH0sXHJcblxyXG5cdC8v5Y2V5byg5omR5YWL6Kej56CBXHJcblx0c2luZ2xlQ2FyZHNEZWNvZGU6IGZ1bmN0aW9uKGMpe1xyXG5cdFx0dmFyIHJldCA9IHt9XHJcblx0XHRyZXQudHlwZSA9IE1hdGguZmxvb3IoKGMgLSAxKSAvIDEzKTtcclxuXHRcdHJldC52YWx1ZSA9IGMgLSByZXQudHlwZSAqIDEzO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9LFxyXG5cclxuXHQvL+WNleW8oOaJkeWFi+e8lueggVxyXG5cdHNpbmdsZUNhcmRzRW5jb2RlOiBmdW5jdGlvbihvKXtcclxuXHRcdHJldHVybiBvLnR5cGUgKiAxMyArIG8udmFsdWU7XHJcblx0fSxcclxuXHJcblx0Ly/miZHlhYvop6PnoIFcclxuXHRjYXJkc0RlY29kZTogZnVuY3Rpb24oY0Fycil7XHJcblx0XHR2YXIgYXJyID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY0Fyci5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciBjID0ge31cclxuXHRcdFx0Yy50eXBlID0gTWF0aC5mbG9vcigoY0FycltpXS0xKS8xMyk7XHJcblx0XHRcdGMudmFsdWUgPSBjQXJyW2ldIC0gYy50eXBlKjEzO1xyXG5cdFx0XHRhcnIucHVzaChjKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhcnI7XHJcblx0fSxcclxuXHJcblx0Ly/miZHlhYvnvJbnoIFcclxuXHRjYXJkc0VuY29kZTogZnVuY3Rpb24oY0Fycil7XHJcblx0XHR2YXIgYXJyID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY0Fyci5sZW5ndGg7ICsraSl7XHJcblx0XHRcdHZhciBjID0gY0FycltpXTtcclxuXHRcdFx0YXJyLnB1c2goYy50eXBlKjEzK2MudmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9LFxyXG5cclxuXHRfY29weUFycmF5OiBmdW5jdGlvbihhcnIpe1xyXG5cdFx0dmFyIHJldCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSlcclxuXHRcdFx0cmV0LnB1c2goYXJyW2ldKTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fSxcclxuXHJcblx0Ly/liKDpmaTmiZHlhYs6IGEsIGLkuK3liKDpmaTlkIzmoLfnmoTlhYPntKBcclxuXHRfZGVsQ2FyZHM6IGZ1bmN0aW9uKGEsIGIpeyBcclxuXHR9LFxyXG5cclxuXHQvL+iOt+WPluaZrumAmue7hOWQiOeJjOWeiyBjQXJyOiDkvKDlhaXmnKrop6PnoIHnmoTniYzmlbDlgLzmlbDnu4RcclxuXHRnZXRHcm91cENhcmRzOiBmdW5jdGlvbihjQXJyKXtcclxuXHRcdHZhciB0bXBBcnIgPSB0aGlzLl9jb3B5QXJyYXkoY0Fycik7XHJcblx0XHR0aGlzLnNvcnRQb2tlcigxLCB0bXBBcnIpO1xyXG5cdFx0dmFyIGRlY29kZUFyciA9IHRoaXMuY2FyZHNEZWNvZGUodG1wQXJyKTtcclxuXHJcblx0XHR2YXIgd2xBcnI9W10sIGR6QXJyPVtdLCBzdEFycj1bXSwgdHpBcnI9W10sIHd0QXJyPVtdLCBzQXJyPVtdLCBzekFycj1bXTtcclxuXHRcdHZhciBzel9uID0gMDtcclxuXHRcdHZhciBudW0gPSBkZWNvZGVBcnIubGVuZ3RoO1xyXG5cdFx0XHJcblx0XHR2YXIgc2FtZSA9IFtdXHJcblx0XHR2YXIgbm90c2FtZSA9IFtdXHJcblx0XHRcclxuXHRcdHZhciBhbGxkeiA9IFtdXHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IG51bS0xOyBpID49IDA7KXtcclxuXHRcdFx0dmFyIGxhc3QgPSBkZWNvZGVBcnJbaV1cclxuXHRcdFx0XHJcblx0XHRcdC0taVxyXG5cdFx0XHR2YXIgZmluZCA9IGZhbHNlXHJcblx0XHRcdHdoaWxlKGkgPj0gMCAmJmxhc3QudmFsdWUgPT0gZGVjb2RlQXJyW2ldLnZhbHVlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0ZmluZCA9IHRydWVcclxuXHRcdFx0XHRzYW1lLnB1c2gobGFzdClcclxuXHRcdFx0XHRsYXN0ID0gZGVjb2RlQXJyW2ldXHJcblx0XHRcdFx0LS1pXHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZmluZCl7XHJcblx0XHRcdFx0c2FtZS5wdXNoKGxhc3QpXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoc2FtZS5sZW5ndGggPiAxKXtcclxuXHRcdFx0XHRcdGlmKHNhbWUubGVuZ3RoID09IDIpXHRkekFyci5wdXNoKFtzYW1lWzFdLCBzYW1lWzBdXSlcclxuXHRcdFx0XHRcdGlmKHNhbWUubGVuZ3RoID09IDMpIFx0c3RBcnIucHVzaChbc2FtZVsyXSxzYW1lWzFdLHNhbWVbMF1dKVxyXG5cdFx0XHRcdFx0aWYoc2FtZS5sZW5ndGggPT0gNCkgXHR0ekFyci5wdXNoKFtzYW1lWzNdLHNhbWVbMl0sc2FtZVsxXSxzYW1lWzBdXSlcclxuXHRcdFx0XHRcdGlmKHNhbWUubGVuZ3RoID09IDUpIFx0d3RBcnIucHVzaChbc2FtZVs0XSwgc2FtZVszXSxzYW1lWzJdLHNhbWVbMV0sc2FtZVswXV0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHRmb3IodmFyIGlkeCA9IDA7IGlkeCA8IHNhbWUubGVuZ3RoOyArK2lkeCl7XHJcblx0XHRcdFx0XHRhbGxkei5wdXNoKHNhbWVbaWR4XSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRcdHNhbWUgPSBbXVxyXG5cdFx0XHR9XHJcblx0XHRcdG5vdHNhbWUucHVzaChsYXN0KVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZihub3RzYW1lLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRmb3IodmFyIGkgPSBub3RzYW1lLmxlbmd0aC0xOyBpID49IDA7KXtcclxuXHRcdFx0XHR2YXIgbGFzdCA9IG5vdHNhbWVbaV1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQtLWlcclxuXHRcdFx0XHR2YXIgdG1wID0gW11cclxuXHRcdFx0XHR3aGlsZShpID49IDAgJiYgbGFzdC52YWx1ZSA9PSBub3RzYW1lW2ldLnZhbHVlKzEpe1xyXG5cdFx0XHRcdFx0dG1wLnB1c2gobGFzdClcclxuXHRcdFx0XHRcdGxhc3QgPSBub3RzYW1lW2ldXHJcblx0XHRcdFx0XHQtLWlcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG1wLnB1c2gobGFzdClcclxuXHRcdFx0XHRpZih0bXAubGVuZ3RoID49IDUpe1xyXG5cdFx0XHRcdFx0c3pBcnIucHVzaCh0bXApXHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgdG1wLmxlbmd0aDsgKytqKXtcclxuXHRcdFx0XHRcdFx0dmFyIGVsZSA9IHRtcFtqXVxyXG5cdFx0XHRcdFx0XHR2YXIgZm5kID0gZmFsc2VcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBtID0gMDsgbSA8IGFsbGR6Lmxlbmd0aDsgKyttKXtcclxuXHRcdFx0XHRcdFx0XHRpZihhbGxkelttXS50eXBlID09IGVsZS50eXBlICYmIGFsbGR6W21dLnZhbHVlID09IGVsZS52YWx1ZSl7XHJcblx0XHRcdFx0XHRcdFx0XHRmbmQgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihmbmQgPT0gZmFsc2Upe1xyXG5cdFx0XHRcdFx0XHRcdHdsQXJyLnB1c2godG1wW2pdKVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vZHpBcnIucmV2ZXJzZSgpXHJcblx0XHQvL3N0QXJyLnJldmVyc2UoKVxyXG5cdFx0Ly90ekFyci5yZXZlcnNlKClcclxuXHRcdC8vd3RBcnIucmV2ZXJzZSgpXHJcblx0XHR3bEFyci5yZXZlcnNlKClcclxuXHRcdFxyXG5cdFx0dmFyIHJldCA9IFtdO1xyXG5cdFx0cmV0LnB1c2god2xBcnIsZHpBcnIsc3RBcnIsdHpBcnIsc3pBcnIsZGVjb2RlQXJyLHd0QXJyKTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fSxcclxuXHJcblxyXG5cdC8v5LmM6b6Z77yI5LiJ5byg77yJXHJcblx0d3Vsb25nVGhyZWU6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjQXJyID0gdGhpcy5nZXRHcm91cENhcmRzKGNhcmRzKVxyXG5cdFx0dmFyIHdsQXJyID0gY0FyclswXSwgY2FyZHNBcnI9W107XHJcblx0XHRmb3IodmFyIGkgPSB3bEFyci5sZW5ndGgtMTsgaSA+PSAyOyAtLWkpe1xyXG5cdFx0XHRjYXJkc0Fyci5wdXNoKFt3bEFycltpXSx3bEFycltpLTFdLHdsQXJyW2ktMl1dKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiA5a+577yI5LiJ5byg77yJXHJcblx0eWlkdWlUaHJlZTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCAzKVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHRcclxuXHRcdHZhciBjQXJyID0gdGhpcy5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdO1xyXG5cdFx0aWYoZHpBcnIubGVuZ3RoID4gMCAmJiB3bEFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0Zm9yKHZhciBpID0gZHpBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtkekFycltpXVswXSwgZHpBcnJbaV1bMV0sIHdsQXJyWzBdXSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiJ5p2hKOS4ieW8oClcclxuXHRzYW50aWFvOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDMpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHRcdFxyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHN0QXJyID0gY0FyclsyXTtcclxuXHRcdGZvcih2YXIgaSA9IHN0QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7XHJcblx0XHRcdGNhcmRzQXJyLnB1c2goc3RBcnJbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LmM6b6ZKOS6lOW8oClcclxuXHR3dWxvbmdGaXZlOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHRcdFxyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHdsQXJyID0gY0FyclswXTtcclxuXHRcdGlmKHdsQXJyLmxlbmd0aCA+IDQgKXtcclxuXHRcdFx0Zm9yKCB2YXIgaSA9IHdsQXJyLmxlbmd0aC0xOyBpID49IDQ7IC0taSl7XHJcblx0XHRcdFx0dmFyIGFyciA9IFt3bEFycltpXSx3bEFyclszXSx3bEFyclsyXSx3bEFyclsxXSx3bEFyclswXV07XHJcblx0XHRcdFx0dmFyIGNmbGFnID0gZmFsc2U7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMTsgaiA8IGFyci5sZW5ndGg7ICsrail7XHJcblx0XHRcdFx0XHRpZihhcnJbal0udHlwZSAhPSBhcnJbai0xXS50eXBlKXtcdC8v55yL5LmM6b6Z6Iqx6Imy5piv5ZCm5LiA5qC3LOaOkumZpOa4heS4gOiJslxyXG5cdFx0XHRcdFx0XHRjZmxhZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihjZmxhZyl7XHQvL+S4jeaYr+WQjOiKseiJslxyXG5cdFx0XHRcdFx0Y2ZsYWcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDE7IGogPCBhcnIubGVuZ3RoOyArK2ope1xyXG5cdFx0XHRcdFx0XHRpZihhcnJbal0udmFsdWUgIT0gYXJyW2otMV0udmFsdWUrMSl7XHJcblx0XHRcdFx0XHRcdFx0Y2ZsYWcgPSB0cnVlO1x0Ly/nnIvmmK/lkKbmmK/pobrlrZBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly9BMjM0NVxyXG5cdFx0XHRcdFx0aWYoY2ZsYWcgJiYgYXJyWzBdLnZhbHVlID09IDEzICYmIGFyclsxXS52YWx1ZSA9PSA0ICYmIGFyclsyXS52YWx1ZSA9PSAzICYmIGFyclszXS52YWx1ZSA9PSAyICYmIGFycls0XS52YWx1ZSA9PSAxKVxyXG5cdFx0XHRcdFx0XHRjZmxhZyA9IGZhbHNlXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmKGNmbGFnKXtcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChhcnIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiA5a+577yI5LqU5byg77yJXHJcblx0eWlkdWlGaXZlOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHJcblx0XHR2YXIgY0FyciA9IHRoaXMuZ2V0R3JvdXBDYXJkcyhjYXJkcyk7XHJcblx0XHR2YXIgd2xBcnI9Y0FyclswXSwgZHpBcnI9Y0FyclsxXTtcclxuXHRcdGlmKGR6QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRpZih3bEFyci5sZW5ndGggPiAyKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSBkekFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbZHpBcnJbaV1bMF0sIGR6QXJyW2ldWzFdLHdsQXJyWzJdLHdsQXJyWzFdLHdsQXJyWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihkekFyci5sZW5ndGggPiAzKXsgLy/kuYzpvpnkuI3lpJ/vvIzmi4blr7nlrZBcclxuXHRcdFx0XHRmb3IodmFyIGkgPSBkekFyci5sZW5ndGgtMTsgaSA+PSAzOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbZHpBcnJbaV1bMV0sIGR6QXJyW2ldWzBdLGR6QXJyWzJdWzFdLGR6QXJyWzFdWzFdLGR6QXJyWzBdWzFdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/kuKTlr7nvvIjkupTlvKApXHJcblx0bGlhbmdkdWk6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBjYXJkc0FyciA9IFtdO1xyXG5cdFx0aWYoY2FyZHMubGVuZ3RoIDwgNSlcclxuXHRcdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHdsQXJyPWNBcnJbMF0sIGR6QXJyPWNBcnJbMV07XHJcblx0XHRpZigoZHpBcnIubGVuZ3RoPjEgJiYgd2xBcnIubGVuZ3RoPjApIHx8IGR6QXJyLmxlbmd0aCA+IDIpe1xyXG5cdFx0XHR2YXIgaSA9IGR6QXJyLmxlbmd0aDtcclxuXHRcdFx0dmFyIGNvbmRpdGlvbiA9IDE7XHJcblx0XHRcdGlmKHdsQXJyLmxlbmd0aCA9PSAwKXtcclxuXHRcdFx0XHRjb25kaXRpb24gPSAyOyAgIC8v5rKh5pyJ5LmM6b6Z6KaB5ouG5LiA5a+5XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKHZhciBqID0gZHpBcnIubGVuZ3RoLTE7IGogPj0gY29uZGl0aW9uOyAtLWope1xyXG5cdFx0XHRcdGlmKHdsQXJyLmxlbmd0aCA9PSAwKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW2R6QXJyW2pdWzBdLGR6QXJyW2pdWzFdLGR6QXJyWzBdWzBdLGR6QXJyWzBdWzFdLGR6QXJyWzFdWzBdXSk7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtkekFycltqXVswXSxkekFycltqXVsxXSxkekFyclswXVswXSxkekFyclswXVsxXSx3bEFyclswXV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LiJ5p2h77yI5LqU5byg77yJ77ya5LiJ5p2hK+S4pOWNleW8oFxyXG5cdHNhbnRpYW9GaXZlOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHRcdHZhciBjQXJyID0gdGhpcy5nZXRHcm91cENhcmRzKGNhcmRzKTtcclxuXHRcdHZhciB3bEFycj1jQXJyWzBdLCBkekFycj1jQXJyWzFdLCBzdEFycj1jQXJyWzJdO1xyXG5cdFx0aWYoc3RBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdGlmKHdsQXJyLmxlbmd0aCA+IDEpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IHN0QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7ICAvL+S4ieadoSvkuYzpvplcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLHdsQXJyWzFdLHdsQXJyWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihkekFyci5sZW5ndGggPiAxKXsgICAgLy/kuInmnaEr5ouG5a+55a2QKOS4ieadoSvlr7nlrZA96JGr6IqmICDkuI3lsZ7kuo7kuInmnaEpXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLGR6QXJyWzFdWzBdLGR6QXJyWzBdWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihzdEFyci5sZW5ndGggPiAyKXsgIC8v5Y+q5pyJ5LiJ5p2h77yM6KaB5ouG5Lik5Liq5LiJ5p2h5b2T5L+p5Y2V5bygXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMjsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3N0QXJyW2ldWzBdLHN0QXJyW2ldWzFdLHN0QXJyW2ldWzJdLHN0QXJyWzFdWzBdLHN0QXJyWzBdWzBdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/pobrlrZDvvIjkupTlvKDvvIk6IOiKseiJsuS4jeWQjOeahOmhuuWtkFxyXG5cdHNodW56aTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHR2YXIgY0FyciA9IHRoaXMuZ2V0R3JvdXBDYXJkcyhjYXJkcyk7XHJcblx0XHR2YXIgd2xBcnI9Y0FyclswXSwgZHpBcnI9Y0FyclsxXSwgc3pBcnI9Y0Fycls0XSwgZGVjb2RlQXJyPWNBcnJbNV07XHJcblx0XHR2YXIgc3pDYXJkcz1bXSwgdkNhcmRzPVtdO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IGRlY29kZUFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHR2YXIgbyA9IGRlY29kZUFycltpXTtcclxuXHRcdFx0aWYoKGkgPiAwICYmIG8udmFsdWUgPT0gZGVjb2RlQXJyW2ktMV0udmFsdWUpIFxyXG5cdFx0XHQgICB8fCAoc3pDYXJkcy5sZW5ndGggPiAwICYmIHN6Q2FyZHNbc3pDYXJkcy5sZW5ndGgtMV0udmFsdWUgPT0gZGVjb2RlQXJyW2ldLnZhbHVlKSl7XHJcblxyXG5cdFx0XHQgICB9ZWxzZXtcclxuXHRcdFx0XHQgICBzekNhcmRzLnB1c2gobyk7XHJcblx0XHRcdFx0ICAgdkNhcmRzW28udmFsdWVdID0gaTtcclxuXHRcdFx0ICAgfVxyXG5cdFx0fVxyXG5cdFx0Ly9BMjM0NVxyXG5cdFx0aWYoc3pBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdHZhciBpID0gc3pBcnIubGVuZ3RoLTFcclxuXHRcdFx0d2hpbGUoaSA+PSAwKXtcclxuXHRcdFx0XHR2YXIgbCA9IHN6QXJyW2ldLmxlbmd0aC0xO1xyXG5cdFx0XHRcdHdoaWxlKGwgPiAzKXtcclxuXHRcdFx0XHRcdHZhciBzQXJyID0gW3N6QXJyW2ldW2xdLHN6QXJyW2ldW2wtMV0sc3pBcnJbaV1bbC0yXSxzekFycltpXVtsLTNdLHN6QXJyW2ldW2wtNF1dO1xyXG5cdFx0XHRcdFx0dmFyIGNmbGFnID0gZmFsc2U7XHJcblx0XHRcdFx0XHRmb3IodmFyIG4gPSAxOyBuIDwgc0Fyci5sZW5ndGg7ICsrbil7XHJcblx0XHRcdFx0XHRcdGlmKHNBcnJbbl0udHlwZSAhPSBzQXJyW24tMV0udHlwZSl7XHJcblx0XHRcdFx0XHRcdFx0Y2ZsYWcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihjZmxhZyl7XHJcblx0XHRcdFx0XHRcdHNBcnIucmV2ZXJzZSgpXHJcblx0XHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goc0Fycik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsLS07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGktLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y2FyZHNBcnIucmV2ZXJzZSgpXHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0Ly/okavoiqbvvJrkuInlvKDnm7jlkIwr5LiA5a+5XHJcblx0aHVsdTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0XHR2YXIgY0FyciA9IHRoaXMuZ2V0R3JvdXBDYXJkcyhjYXJkcyk7XHJcblx0XHR2YXIgZHpBcnI9Y0FyclsxXSwgc3RBcnI9Y0FyclsyXTtcclxuXHRcdGlmKHN0QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRpZihkekFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSBzdEFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbc3RBcnJbaV1bMF0sc3RBcnJbaV1bMV0sc3RBcnJbaV1bMl0sZHpBcnJbMF1bMF0sZHpBcnJbMF1bMV1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHQvL+ayoeacieWvueWtkCAg5ouG5a+55a2QXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gc3RBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGZvcih2YXIgbCA9IDA7IGwgPCBzdEFyci5sZW5ndGg7ICsrbCl7XHJcblx0XHRcdFx0XHRcdGlmKGwgPj0gaSlcclxuXHRcdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbc3RBcnJbaV1bMF0sc3RBcnJbaV1bMV0sc3RBcnJbaV1bMl0sc3RBcnJbbF1bMF0sc3RBcnJbbF1bMV1dKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjYXJkc0FycjtcclxuXHR9LFxyXG5cclxuXHQvL+mTgeaUr++8muWbm+W4puS4gFxyXG5cdHRpZXpoaTogZnVuY3Rpb24oY2FyZHMpe1xyXG5cdFx0dmFyIGNhcmRzQXJyID0gW107XHJcblx0XHRpZihjYXJkcy5sZW5ndGggPCA1KVxyXG5cdFx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblxyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHdsQXJyPWNBcnJbMF0sIGR6QXJyPWNBcnJbMV0sIHN0QXJyPWNBcnJbMl0sIHR6QXJyPWNBcnJbM11cclxuXHRcdGlmKHR6QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRpZih3bEFyci5sZW5ndGggPiAwKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSB0ekFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbdHpBcnJbaV1bMF0sdHpBcnJbaV1bMV0sdHpBcnJbaV1bMl0sdHpBcnJbaV1bM10sd2xBcnJbMF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2UgaWYoZHpBcnIubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gdHpBcnIubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKXtcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3R6QXJyW2ldWzBdLHR6QXJyW2ldWzFdLHR6QXJyW2ldWzJdLHR6QXJyW2ldWzNdLGR6QXJyWzBdWzBdXSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHN0QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IHR6QXJyLmxlbmd0aC0xOyBpID49IDA7IC0taSl7XHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFt0ekFycltpXVswXSx0ekFycltpXVsxXSx0ekFycltpXVsyXSx0ekFycltpXVszXSxzdEFyclswXVswXV0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZih0ekFyci5sZW5ndGggPiAxKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSB0ekFyci5sZW5ndGgtMTsgaSA+PSAxOyAtLWkpe1xyXG5cdFx0XHRcdFx0Y2FyZHNBcnIucHVzaChbdHpBcnJbaV1bMF0sdHpBcnJbaV1bMV0sdHpBcnJbaV1bMl0sdHpBcnJbaV1bM10sdHpBcnJbMF1bMF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNhcmRzQXJyO1xyXG5cdH0sXHJcblxyXG5cdC8v5LqU5ZCMXHJcblx0d3V0b25nOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FycjtcclxuXHRcdFxyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpO1xyXG5cdFx0dmFyIHd0QXJyID0gY0Fycls2XTtcclxuXHRcdGlmKHd0QXJyLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRmb3IodmFyIGkgPSB3dEFyci5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpe1xyXG5cdFx0XHRcdGNhcmRzQXJyLnB1c2god3RBcnJbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnI7XHJcblx0fSxcclxuXHJcblx0XHQvL+iOt+WPluiKseiJslxyXG5cdGdldFN1aXQ6IGZ1bmN0aW9uKGNhcmRzKXtcclxuXHRcdHZhciBhcnIgPSBbW10sW10sW10sW11dXHJcblx0XHRmb3IodmFyIGk9MDsgaSA8IGNhcmRzLmxlbmd0aDsgKytpKXtcclxuXHRcdFx0dmFyIHN1aXQgPSBjYXJkc1tpXS50eXBlXHJcblx0XHRcdGFycltzdWl0XS5wdXNoKGNhcmRzW2ldKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFyclxyXG5cdH0sXHJcblx0XHJcblx0Ly/liKDpmaTnm7jlkIzngrnmlbBcclxuXHRkZWxTYW1lUG9pbnQ6IGZ1bmN0aW9uIChjQXJyKXtcclxuXHRcdHZhciBhcnI9W10sIGNhcmRzQXJyPVtdXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY0Fyci5sZW5ndGg7ICsraSl7XHJcblx0XHRcdGlmKGFycltjQXJyW2ldLnZhbHVlXSA9PSBudWxsKXtcclxuXHRcdFx0XHRhcnJbY0FycltpXS52YWx1ZV0gPSB0cnVlXHJcblx0XHRcdFx0Y2FyZHNBcnIucHVzaChjQXJyW2ldKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnJcclxuXHR9LFxyXG5cclxuXHQvL+WQjOiKsemhulxyXG5cdHRvbmdodWFzaHVuOiBmdW5jdGlvbihjYXJkcyl7XHJcblx0XHR2YXIgY2FyZHNBcnIgPSBbXTtcclxuXHRcdGlmKGNhcmRzLmxlbmd0aCA8IDUpXHJcblx0XHRcdHJldHVybiBjYXJkc0FyclxyXG5cdFx0dmFyIGNBcnIgPSB0aGlzLmdldEdyb3VwQ2FyZHMoY2FyZHMpXHJcblx0XHR2YXIgc3VpdEFyciA9IHRoaXMuZ2V0U3VpdChjQXJyWzVdKVxyXG5cdFx0XHJcblx0XHRmb3IodmFyIGkgPSAzOyBpID49IDA7IC0taSl7XHJcblx0XHRcdHZhciBzQXJyID0gdGhpcy5kZWxTYW1lUG9pbnQoc3VpdEFycltpXSlcclxuXHRcdFx0aWYoc0Fyci5sZW5ndGggPiA0KXtcclxuXHRcdFx0XHQgLy90aGlzLnNvcnRQb2tlcigxLCBzQXJyKVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKHNBcnJbMF0udmFsdWU9PTEzICYmIHNBcnJbMV0udmFsdWU9PTEyICYmIHNBcnJbMl0udmFsdWU9PTExICYmIHNBcnJbM10udmFsdWU9PTEwICYmIHNBcnJbNF0udmFsdWU9PTkpe1xyXG5cdFx0XHRcdFx0Ly9BIEsgUSBKIDEwXHJcblx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtzQXJyWzBdLHNBcnJbMV0sc0FyclsyXSxzQXJyWzNdLHNBcnJbNF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgbGVuID0gc0Fyci5sZW5ndGhcclxuXHRcdFx0XHRpZihzQXJyWzBdLnZhbHVlPT0xMyAmJiBzQXJyW2xlbi00XS52YWx1ZT09NCAmJiBzQXJyW2xlbi0zXS52YWx1ZT09MyYmIHNBcnJbbGVuLTJdLnZhbHVlPT0yJiYgc0FycltsZW4tMV0udmFsdWU9PTEpe1xyXG5cdFx0XHRcdFx0Ly9BIDIgMyA0IDVcclxuXHRcdFx0XHRcdGNhcmRzQXJyLnB1c2goW3NBcnJbMF0sc0FycltsZW4tMV0sc0FycltsZW4tMl0sc0FycltsZW4tM10sc0FycltsZW4tNF1dKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgc0Fyci5sZW5ndGgtNDsgKytqKXtcclxuXHRcdFx0XHRcdGlmKHNBcnJbal0udmFsdWU9PShzQXJyW2orMV0udmFsdWUrMSkgJiYgc0FycltqKzFdLnZhbHVlPT0oc0FycltqKzJdLnZhbHVlKzEpICYmIHNBcnJbaisyXS52YWx1ZT09KHNBcnJbaiszXS52YWx1ZSsxKSAmJiBzQXJyW2orM10udmFsdWU9PShzQXJyW2orNF0udmFsdWUrMSkpe1xyXG5cdFx0XHRcdFx0XHRjYXJkc0Fyci5wdXNoKFtzQXJyW2pdLHNBcnJbaisxXSxzQXJyW2orMl0sc0FycltqKzNdLHNBcnJbais0XV0pXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FyZHNBcnJcclxuXHR9LFxyXG5cclxuICAgIC8v57uZ54mM5o6S5bqPIHNvcnR0eXBlOiAxIOWkp+Wwj+aOkuW6jyAyIOiKseiJsuaOkuW6j1xyXG4gICAgc29ydFBva2VyOiBmdW5jdGlvbihzb3J0dHlwZSwgY2FyZGxpc3Qpe1xyXG4gICAgICAgIGlmKHNvcnR0eXBlID09IDIpe1xyXG4gICAgICAgICAgICBjYXJkbGlzdC5zb3J0KGZ1bmN0aW9uKHgsIHkpeyAgIC8v5pWw5a2X6LaK5aSn5Zyo5YmNXHJcbiAgICAgICAgICAgICAgICBpZih4IDwgeSkgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIGlmKHggPiB5KSAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNvcnR0eXBlID09IDEpe1xyXG4gICAgICAgICAgICBjYXJkbGlzdC5zb3J0KGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHhjYXJkID0gWyAoeC0xKS8xMywgKHgtMSklMTMgXTtcclxuICAgICAgICAgICAgICAgIHZhciB5Y2FyZCA9IFsgKHktMSkvMTMsICh5LTEpJTEzIF07XHJcblxyXG5cdFx0XHRcdGlmKHhjYXJkWzFdIDwgeWNhcmRbMV0pXHJcblx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHRpZih4Y2FyZFsxXSA+IHljYXJkWzFdKVxyXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmKHhjYXJkWzBdIDwgeWNhcmRbMF0pXHJcblx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHRpZih4Y2FyZFswXSA+IHljYXJkWzBdKVxyXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHRcdHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG5cdC8v5q+U6L6D5oyH5a6a54mM5Z6LaeS4i++8muesrOS6jOWiqSDlkowg56ys5LiA5aKpIOaYr+WQpuebuOWFrCA6IOaYr+ebuOWFrOS6hiDov5Tlm550cnVlXHJcblx0Ly9pOiDnrKzkuozloqnniYzlnovmlbDlrZcoMC0xMCksIGE6IOesrOS6jOWiqeeJjFxyXG5cdC8vYjog56ys5LiA5aKp54mMIFxyXG5cdC8vajog6KGo56S656ys5LqM5aKp54mM55qE54mM5Z6LKOacieWPr+iDveesrOS6jOWiqeacieWkmuenjeeJjOWei++8jOS4gOiIrOm7mOiupOesrOS4gOS4queJjOWei+acgOWkp++8jOaJgOS7pWrkuIDoiKzpgIkwKVxyXG5cdFxyXG5cdGlzTWVzc2lyZVRocmVlOiBmdW5jdGlvbihpLCBhLCBiLCBqKXtcclxuXHRcdFxyXG5cdFx0Ly/kuInmnaFGaXZlIOWSjCDkuInmnaF0aHJlZSDmr5TovoNcclxuXHRcdGlmKCBpID09IDYpe1x0XHJcblx0XHRcdGlmKCBhW2pdWzJdLnZhbHVlIDwgYlsyXS52YWx1ZSl7XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL+S4gOWvuUZpdmUg5ZKMIOS4gOWvuXRocmVlIOavlOi+g1xyXG5cdFx0aWYoIGkgPT0gOCApe1x0XHJcblx0XHRcdGlmKGFbal1bMF0udmFsdWUgPT0gYlswXS52YWx1ZSl7XHJcblx0XHRcdFx0aWYoYVtqXVsyXS52YWx1ZSA8IGJbMl0udmFsdWUpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly/kuYzpvplGaXZlIOWSjCDkuYzpvpl0aHJlZSAg5q+U6L6DXHJcblx0XHRpZihpID09IDkpe1xyXG5cdFx0XHRpZihhW2pdWzBdLnZhbHVlICA9PSBiWzBdLnZhbHVlKXtcclxuXHRcdFx0XHRpZihhW2pdWzFdLnZhbHVlID09IGJbMV0udmFsdWUpe1xyXG5cdFx0XHRcdFx0aWYoYVtqXVsyXS52YWx1ZSA8IGJbMl0udmFsdWUpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1lbHNlIGlmKGFbal1bMV0udmFsdWUgPCBiWzFdLnZhbHVlKXtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZiggYVtqXVswXS52YWx1ZSA8IGJbMF0udmFsdWUpe1xyXG5cdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZVxyXG5cdH0sXHJcblx0XHJcblx0Ly/niYzlnovkuIDmoLfmg4XlhrXkuItcclxuXHQvL+avlOi+g+aMh+WumueJjOWei2nkuIvvvJrnrKzkuInloqkg5ZKMIOesrOS6jOWiqSDmmK/lkKbnm7jlhawgIOaYr+ebuOWFrOi/lOWbnnRydWVcclxuXHQvL2k6IOesrOS4ieWiqeeJjOWeiygwLTEwKe+8jCDmr5TovoPlvZPliY1p54mM5Z6L5LiLYSxi5piv5ZCm55u45YWsXHJcblx0Ly9hOiDnrKzkuInloqnniYxcclxuXHQvL2I6IOesrOS6jOWiqeeJjFxyXG5cdGlzTWVzc2lyZUZpdmU6IGZ1bmN0aW9uKGksIGEsIGIpe1xyXG5cdFx0dmFyIHYgPSBbXSwgcyA9IFtdXHJcblx0XHRmb3IodmFyIGkgPSAwOyBuIDwgNTsgKytpKXtcclxuXHRcdFx0di5wdXNoKGFbaV0udmFsdWUpXHJcblx0XHRcdHMucHVzaChiW2ldLnZhbHVlKVxyXG5cdFx0fVxyXG5cdFx0di5zb3J0KGZ1bmN0aW9uKHgseSl7IHJldHVybiB4IDwgeSB9KVxyXG5cdFx0cy5zb3J0KGZ1bmN0aW9uKHgseSl7IHJldHVybiB4IDwgeSB9KVxyXG5cdFx0XHJcblx0XHRpZihpPT0wIHx8IGkgPT0gMilcdC8v5LqU5ZCM5oiW6ICF5Zub5bim5LiAKOmTgeaUrylcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIHZbMl0gPCBzWzJdXHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKCBpID09IDMpXHQvL+iRq+iKpijkuInluKbkuowpXHJcblx0XHR7XHRcclxuXHRcdFx0aWYodlsyXSA9PSBzWzJdKXtcclxuXHRcdFx0XHRpZih2WzBdPT12WzJdICYmIHNbMF09PXNbMl0pe1x0Ly/kuInkuKrpg73lnKjliY1cclxuXHRcdFx0XHRcdHJldHVybiB2WzNdIDwgc1szXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih2WzBdPT12WzJdICYmIHNbMl09PXNbNF0peyAvL+S4ieS4quWcqOWJjeaute+8jCDkuInkuKrlnKjlkI7nq69cclxuXHRcdFx0XHRcdHJldHVybiB2WzNdIDwgc1swXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih2WzJdPT12WzRdICYmIHNbMF09PXNbMl0pe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZbMF0gPCBzWzNdXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZbMl09PXZbNF0gJiYgc1syXT09c1s0XSl7XHJcblx0XHRcdFx0XHRyZXR1cm4gdlswXSA8IHNbMF1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZbMl0gPCBzWzJdXHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKGk9PTEgfHwgaT09NCB8fCBpPT01IHx8IGk9PTkpXHQvL+WQjOiKsemhuuOAgeWQjOiKseOAgemhuuWtkOOAgeS5jOm+mVxyXG5cdFx0e1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgNTsgKytqKXtcclxuXHRcdFx0XHRpZih2W2pdID09IHNbal0pe1xyXG5cdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHZbal0gPCBzW2pdXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoIGk9PSA2IHx8IGk9PTcgfHwgaT09OCkgIC8v5LiJ5p2h44CB5Lik5a+544CB5LiA5a+5XHJcblx0XHR7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcbi8qXHJcbiAgICBfZ2V0Q2FyZFN0eWxlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBDYXJkU3R5bGUgPSB7fVxyXG4gICAgICAgIENhcmRTdHlsZS53dXRvbmcgICAgICAgID0gW10gICAgICAgIC8v5LqU5ZCMXHJcbiAgICAgICAgQ2FyZFN0eWxlLnRvbmdodWFzaHVuICAgPSBbXSAgICAgICAgLy/lkIzoirHpobpcclxuICAgICAgICBDYXJkU3R5bGUudGllemhpICAgICAgICA9IFtdICAgICAgICAvL+mTgeaUr1xyXG4gICAgICAgIENhcmRTdHlsZS5odWx1ICAgICAgICAgID0gW10gICAgICAgIC8v6JGr6IqmXHJcbiAgICAgICAgQ2FyZFN0eWxlLnRvbmdodWEgICAgICAgPSBbXSAgICAgICAgLy/lkIzoirFcclxuICAgICAgICBDYXJkU3R5bGUuc2h1bnppICAgICAgICA9IFtdICAgICAgICAvL+mhuuWtkFxyXG4gICAgICAgIENhcmRTdHlsZS5zYW50aWFvICAgICAgID0gW10gICAgICAgIC8v5LiJ5p2hXHJcblx0XHRDYXJkU3R5bGUubGlhbmdkdWkgICAgICA9IFtdICAgICAgICAvL+S4pOWvueWtkFxyXG4gICAgICAgIENhcmRTdHlsZS5kdWl6aSAgICAgICAgID0gW10gICAgICAgIC8v5a+55a2QXHJcbiAgICAgICAgcmV0dXJuIENhcmRTdHlsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/orqHnrpfniYzlnoss6L+U5Zue5ZCE56eN54mM55qE5pWw6YePXHJcbiAgICBjYWN1bGF0ZVNlbGZDYXJkOiBmdW5jdGlvbihjYXJkbGlzdCl7XHJcblxyXG5cdFx0dmFyIENhcmRTdHlsZSA9IHRoaXMuX2dldENhcmRTdHlsZSgpO1xyXG5cclxuXHRcdC8vc2h1bnppXHJcblx0XHR2YXIgZmYgPSAwOyB0dCA9IDA7XHJcblx0XHRmb3IodmFyIGkgPSAxOyBpIDw9NTI7ICsraSl7XHJcblx0XHRcdGlmKGNhcmRsaXN0LmluZGV4T2YoaSkgPT0gLTEgfHwgaSA9PSA1Mil7XHJcblx0XHRcdFx0aWYodHQgLSBmZiA+PSA0KXtcclxuXHRcdFx0XHRcdHZhciBsZW4gPSBDYXJkU3R5bGUuc2h1bnppLmxlbmd0aDtcclxuXHRcdFx0XHRcdENhcmRTdHlsZS5zaHVuemlbbGVuXSA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBtID0gdHQ7IG0gPj0gKHR0LTQpOyAtLW0pe1xyXG5cdFx0XHRcdFx0XHRDYXJkU3R5bGUuc2h1bnppW2xlbl0ucHVzaChtKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZmYgPSB0dCA9IDA7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdGlmKGZmID09IDApIGZmID0gaTtcclxuXHRcdFx0XHR0dCA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgLy/mjInnhafmlbDlrZflpKflsI/vvIzkuI3nnIvoirHoibLmjpLluo9cclxuICAgICAgICB2YXIgYWxsY2FyZCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDU7ICsraSl7XHJcblx0XHRcdGFsbGNhcmRbaV0gPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IDEzOyArK2ope1xyXG5cdFx0XHRcdGFsbGNhcmRbaV1bal0gPSAwO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDw9IGNhcmRsaXN0Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNhcmQgPSB0aGlzLl9nZXRDYXJkVHlwZShjYXJkbGlzdFtpXSk7XHJcblx0XHRcdGlmKGFsbGNhcmRbY2FyZC54XVtjYXJkLnldID09IDApeyBcclxuXHRcdFx0XHRhbGxjYXJkW2NhcmQueF1bY2FyZC55XSA9IGNhcmRsaXN0W2ldO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvLzTph4zpnaLlrZjmlL7ph43lpI3pu5HmoYNcclxuXHRcdFx0XHRhbGxjYXJkWzRdW2NhcmQueV0gPSBjYXJkbGlzdFtpXTtcclxuXHRcdFx0fVxyXG4gICAgICAgIH1cclxuXHRcdFxyXG5cdFx0Ly/mn6Xmib7miYDmnInlj6/og73nmoTniYzlnotcclxuXHRcdFxyXG5cdFx0Ly/lhYjmn6Xlr7nlrZBcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCAxMzsgKytpKXtcclxuXHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgNTsgKytqKXtcclxuXHRcdFx0XHRpZihhbGxjYXJkW2ldW2pdICE9IDApe1xyXG5cdFx0XHRcdFx0YXJyLnB1c2goYWxsY2FyZFtpXVtqXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGFyci5sZW5ndGggPCAyKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYoYXJyLmxlbmd0aCA9PSA1KXtcclxuXHRcdFx0XHR2YXIgbGVuID0gQ2FyZFN0eWxlLnd1dG9uZy5sZW5ndGg7XHJcblx0XHRcdFx0Q2FyZFN0eWxlLnd1dG9uZ1tsZW5dID0gYXJyO1xyXG5cdFx0XHR9ZWxzZSBpZihhcnIubGVuZ3RoID09IDQpe1xyXG5cdFx0XHRcdHZhciBsZW4gPSBDYXJkU3R5bGUudGllemhpLmxlbmd0aDtcclxuXHRcdFx0XHRDYXJkU3R5bGUudGllemhpW2xlbl0gPSBhcnI7XHJcblx0XHRcdH1lbHNlIGlmKGFyci5sZW5ndGggPT0gMyl7XHJcblx0XHRcdFx0dmFyIGxlbiA9IENhcmRTdHlsZS5zYW50aWFvLmxlbmd0aDtcclxuXHRcdFx0XHRDYXJkU3R5bGUuc2FudGlhb1tsZW5dID0gYXJyO1xyXG5cdFx0XHR9ZWxzZSBpZihhcnIubGVuZ3RoID09IDIpe1xyXG5cdFx0XHRcdHZhciBsZW4gPSBDYXJkU3R5bGUuZHVpemkubGVuZ3RoO1xyXG5cdFx0XHRcdENhcmRTdHlsZS5kdWl6aVtsZW5dID0gYXJyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8v5YaN5p+l6Iqx6ImyXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgNTsgKytpKXtcclxuXHRcdFx0dmFyIGYgPSAwLCB0ID0gMDtcclxuXHRcdFx0dmFyIGZpbmQgPSBmYWxzZTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IDEzOyArK2ope1xyXG5cdFx0XHRcdGlmKGFsbGNhcmRbaV1bal0gPT0gMCB8fCBqID09IDEyKXtcclxuXHRcdFx0XHRcdGlmKHQgLSBmID49IDQpe1xyXG5cdFx0XHRcdFx0XHR2YXIgbGVuID0gQ2FyZFN0eWxlLnRvbmdodWFzaHVuLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0Q2FyZFN0eWxlLnRvbmdodWFzaHVuW2xlbl0gPSBbXTtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBtID0gdDsgbSA+PSAodC00KTsgLS1tKXtcclxuXHRcdFx0XHRcdFx0XHRDYXJkU3R5bGUudG9uZ2h1YXNodW5bbGVuXS5wdXNoKGFsbGNhcmRbaV1bbV0pO1xyXG5cdFx0XHRcdFx0XHRcdGZpbmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGYgPSB0ID0gMDtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdGlmKGYgPT0gMCkgZiA9IGo7XHJcblx0XHRcdFx0XHR0ID0gajtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoIWZpbmQgJiYgYWxsY2FyZFtpXS5sZW5ndGggPj0gNSApe1xyXG5cdFx0XHRcdFx0dmFyIGxlbiA9IENhcmRTdHlsZS50b25naHVhLmxlbmd0aDtcclxuXHRcdFx0XHRcdENhcmRTdHlsZS50b25naHVhW2xlbl0gPSBbXTtcclxuXHRcdFx0XHRcdGZvcih2YXIgbiA9IDEyOyBuID49IDA7IC0tbil7XHJcblx0XHRcdFx0XHRcdGlmKGFsbGNhcmRbaV1bbl0gIT0gMCl7XHJcblx0XHRcdFx0XHRcdFx0Q2FyZFN0eWxlLnRvbmdodWFbbGVuXS5wdXNoKGFsbGNhcmRbaV1bbl0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcbiAgICAgICAgcmV0dXJuIENhcmRTdHlsZTtcclxuICAgIH0sXHJcbiovXHJcbn0pO1xyXG5cclxuY2MuUG9rZXJVdGlsID0gbmV3IE0oKTtcclxuXHJcbi8v56ys5LqM5aKp44CB56ys5LiJ5aKp5q+U6L6D6KeE5YiZKDXlvKDniYwpXHJcbmNjLlBva2VyVXRpbC50NUdyb3VwID0gW107XHJcblxyXG5jYy5Qb2tlclV0aWwudDVHcm91cFswXSA9IGNjLlBva2VyVXRpbC53dXRvbmc7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzFdID0gY2MuUG9rZXJVdGlsLnRvbmdodWFzaHVuO1xyXG5jYy5Qb2tlclV0aWwudDVHcm91cFsyXSA9IGNjLlBva2VyVXRpbC50aWV6aGk7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzNdID0gY2MuUG9rZXJVdGlsLmh1bHU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzRdID0gY2MuUG9rZXJVdGlsLnRvbmdodWE7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzVdID0gY2MuUG9rZXJVdGlsLnNodW56aTtcclxuY2MuUG9rZXJVdGlsLnQ1R3JvdXBbNl0gPSBjYy5Qb2tlclV0aWwuc2FudGlhb0ZpdmU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzddID0gY2MuUG9rZXJVdGlsLmxpYW5nZHVpO1xyXG5jYy5Qb2tlclV0aWwudDVHcm91cFs4XSA9IGNjLlBva2VyVXRpbC55aWR1aUZpdmU7XHJcbmNjLlBva2VyVXRpbC50NUdyb3VwWzldID0gY2MuUG9rZXJVdGlsLnd1bG9uZ0ZpdmU7XHJcblxyXG4vL+esrOS4gOWiqeavlOi+g+inhOWImSgz5byg54mMKVxyXG5jYy5Qb2tlclV0aWwudDNHcm91cCA9IFtdO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFswXSA9IGNjLlBva2VyVXRpbC5zYW50aWFvO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFsxXSA9IGNjLlBva2VyVXRpbC55aWR1aVRocmVlO1xyXG5jYy5Qb2tlclV0aWwudDNHcm91cFsyXSA9IGNjLlBva2VyVXRpbC53dWxvbmdUaHJlZTtcclxuIiwidmFyIE0gPSBjYy5DbGFzcyh7XHJcbiAgICBsb2FkU2NlbmU6ZnVuY3Rpb24obmFtZSxjYWxsKXtcclxuICAgICAgICBjYy5ndWltYW5hZ2VyLmNsb3NlQWxsKClcclxuICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUobmFtZSxjYWxsKTtcclxuICAgIH0sXHJcbiAgICBsb2FkTWFpblNjZW5lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5sb2FkU2NlbmUoJ01haW4nLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmIChjYy5zY2VuZW1hbmFnZXIucm9vbV9pbmZvKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5nYW1lbWFuYWdlci5nYW1lU3RhcnQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5vcGVuKCdVSU1haW4nKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGxvYWRMb2dpblNjZW5lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MubG9nKCdsb2FkbG9naW4nKTtcclxuICAgICAgICB0aGlzLmxvYWRTY2VuZSgnTG9naW4nLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbignVUlMb2dpbicpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZFBva2VyR2FtZVNjZW5lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MubG9nKFwiTG9hZFBva2VyR2FtZVNjZW5lXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZFNjZW5lKFwiUG9rZXJHYW1lXCIsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNjLmd1aW1hbmFnZXIub3BlbihcIlVJUG9rZXJHYW1lXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxufSk7XHJcblxyXG5jYy5zY2VuZW1hbmFnZXIgPSBuZXcgTSgpIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIGRpc2NvdW50OmNjLk5vZGUsXHJcbiAgICAgICBkaXNjb3VudFRleHQ6Y2MuTGFiZWwsXHJcbiAgICAgICBpbWc6Y2MuU3ByaXRlLFxyXG4gICAgICAgbW9uZXlUZXh0OmNjLkxhYmVsLFxyXG4gICAgICAgZGlhbW9uZFRleHQ6Y2MuTGFiZWxcclxuICAgIH0sXHJcblxyXG4gICAgLy9kaWFtb24gZGlzY291bnQgcHJpY2UgaWQgaW1hZ2VcclxuICAgIHNldERhdGE6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgdGhpcy5pdGVtRGF0YSA9IGRhdGFcclxuICAgICAgICB0aGlzLmRpYW1vbmRUZXh0LnN0cmluZyA9IFN0cmluZyhkYXRhLmRpYW1vbmQpXHJcbiAgICAgICAgaWYgKGRhdGEuZGlzY291bnQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb3VudC5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgICAgIHRoaXMuZGlzY291bnRUZXh0LnN0cmluZyA9ICflhoXotaB7MH0lJy5mb3JtYXQoZGF0YS5kaXNjb3VudClcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGF0YS5kaXNjb3VudC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb25leVRleHQuc3RyaW5nID0gU3RyaW5nKGRhdGEucHJpY2UpXHJcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoJ1RleHR1cmVzLycgKyBkYXRhLmltYWdlLGNjLlNwcml0ZUZyYW1lLGZ1bmN0aW9uKGVycixzcHJpdGVGcmFtZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW1nLnNwcml0ZUZyYW1lID0gc3ByaXRlRnJhbWVcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcbiAgICBidXk6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvLy8gdGhpcy5pdGVtRGF0YS5pZFxyXG4gICAgICAgIC8vVE9ETzrotK3kubBcclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5yZXF1aXJlKCdVSVBhbmVsJylcclxuXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGNoYXRQYWdlOmNjLk5vZGUsXHJcbiAgICAgICAgZmFjZVBhZ2U6Y2MuTm9kZSxcclxuICAgICAgICBjaGF0QmFjazpjYy5Ob2RlLFxyXG4gICAgICAgIGVkaXRCb3g6Y2MuRWRpdEJveCxcclxuICAgICAgICBjaGF0Q29udGVudDpjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIFxyXG4gICAgb25Ub3VjaEJnOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKGZhbHNlKVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNyZWF0ZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgIHRoaXMuY2hhdEJhY2sub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uSW1tZWRpYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoJ0d1aS9XaWRnZXQvQ2hhdFNwbGl0JyxmdW5jdGlvbihlcnIsc3BsaXRQcmVmYWIpe1xyXG4gICAgICAgICAgICBzZWxmLnNwbGl0UHJlZmFiICA9IHNwbGl0UHJlZmFiXHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKCdHdWkvV2lkZ2V0L0NoYXRJdGVtJyxmdW5jdGlvbihlcnIsY2hhdEl0ZW1QcmVmYWIpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jaGF0SXRlbVByZWZhYiA9IGNoYXRJdGVtUHJlZmFiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLl9zdXBlcigpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xvc2U6ZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3BsaXRQcmVmYWIpXHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5yZWxlYXNlQXNzZXQodGhpcy5zcGxpdFByZWZhYilcclxuICAgICAgICBpZiAodGhpcy5jaGF0SXRlbVByZWZhYilcclxuICAgICAgICAgICAgY2MubG9hZGVyLnJlbGVhc2VBc3NldCh0aGlzLmNoYXRJdGVtUHJlZmFiKVxyXG4gICAgICAgIHRoaXMuX3N1cGVyKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzUmVhZHkgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdFByZWZhYiAmJiB0aGlzLmNoYXRJdGVtUHJlZmFiXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2hhY2tDaGF0cGFnZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuY2hhdFBhZ2UuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuZmFjZVBhZ2UuYWN0aXZlID0gZmFsc2VcclxuICAgIH0sXHJcbiAgICBvbkNoZWNrRmFjZXBhZ2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNoYXRQYWdlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5mYWNlUGFnZS5hY3RpdmUgPSB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgIHBvcEJ1bGxldCA6IGZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgdmFyIHBhbmVsID0gY2MuZ3VpbWFuYWdlci5nZXRCeU5hbWUoJ1VJUG9rZXJHYW1lJylcclxuICAgICAgICBpZiAocGFuZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5sb2coJ3Rlc3QnKVxyXG4gICAgICAgICAgICBwYW5lbC5zaG93Q2hhdChjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5jdWlkLG1zZylcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKGZhbHNlKVxyXG4gICAgfSxcclxuICAgIHNlbmRDaGF0OmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmVkaXRCb3guc3RyaW5nXHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19TZW5kQ2hhdFwiKVxyXG4gICAgICAgICAgICBtc2cudHlwZSAgPSAwXHJcbiAgICAgICAgICAgIG1zZy5kYXRhX3RleHQgPSBzdHJcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hhdChjYy5nYW1lbWFuYWdlci5tYWluUGxheWVyKCksc3RyKVxyXG4gICAgICAgICAgICB0aGlzLmVkaXRCb3guc3RyaW5nID0gXCJcIlxyXG4gICAgICAgICAgICB0aGlzLnBvcEJ1bGxldChtc2cpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDaGF0OmZ1bmN0aW9uKHBsYXllcix0ZXh0KXtcclxuICAgICAgICBpZiAocGxheWVyICYmIHRoaXMuaXNSZWFkeSgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy/mt7vliqDliLDogYrlpKnliJfooahcclxuICAgICAgICAgICB2YXIgc3BsaXQgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnNwbGl0UHJlZmFiKTsgXHJcbiAgICAgICAgICAgdmFyIGl0ZW0gID0gY2MuaW5zdGFudGlhdGUodGhpcy5jaGF0SXRlbVByZWZhYik7XHJcbiAgICAgICAgICAgdmFyIHN0ciA9ICc8Y29sb3I9IzAwZmYwMD4nLmNvbmNhdChwbGF5ZXIubmFtZSAsICc6PC9jPjxjb2xvcj0jZmZlZmJlPicgLCB0ZXh0ICwgJzwvYz4nKVxyXG4gICAgICAgICAgIGl0ZW0uZ2V0Q29tcG9uZW50KGNjLlJpY2hUZXh0KS5zdHJpbmcgPSBzdHJcclxuICAgICAgICAgICBpdGVtLnBhcmVudCA9IHRoaXMuY2hhdENvbnRlbnRcclxuICAgICAgICAgICBpdGVtLnBvc2l0aW9uID0gY2MucCgxMSwxMilcclxuICAgICAgICAgICBcclxuICAgICAgICAgICBzcGxpdC5wYXJlbnQgPSB0aGlzLmNoYXRDb250ZW50XHJcbiAgICAgICAgICAgc3BsaXQucG9zaXRpb24gPSBjYy5wKDIxOSwxKVxyXG4gICAgICAgICAgfSBcclxuICAgIH0sXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19DaGF0IDogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgaWYgKG1zZy5jb250ZW50LnR5cGUgPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwbGF5ZXIgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIobXNnLmN1aWQpICBcclxuICAgICAgICAgICAgaWYgKHBsYXllcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGF0KHBsYXllcixtc2cuY29udGVudC5kYXRhX3RleHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbmRGYWNlOmZ1bmN0aW9uKGV2ZW50LGlkKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKFwiUHVibGljUHJvdG8uQ19TZW5kQ2hhdFwiKVxyXG4gICAgICAgIG1zZy50eXBlICA9IDFcclxuICAgICAgICBtc2cuZGF0YV9pbnQgPSBwYXJzZUludChpZClcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG5cclxuICAgICAgICB0aGlzLnBvcEJ1bGxldChtc2cpXHJcbiAgICB9LFxyXG59KTtcclxuIiwicmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGNyZWF0ZUJ0biA6Y2MuQnV0dG9uLFxyXG4gICAgICAgIHF1YW5sZWlkYVRvZ2dsZSA6IGNjLlRvZ2dsZVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNyZWF0ZTpmdW5jdGlvbigpIHtcclxuICAgICAgIHRoaXMuaW5pdCgpOyBcclxuICAgICAgIHRoaXMuX3N1cGVyKClcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDpmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGNjLmRhdGFtYW5hZ2VyLmdldFJvb21TZXR0aW5nKClcclxuICAgICAgICBpZiAoIXNldHRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL+m7mOiupOiuvue9rlxyXG4gICAgICAgICAgICBzZXR0aW5nID0ge1xyXG4gICAgICAgICAgICAgICAgaXNRdWFuTGVpRGEgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNoZWNrcyA6IFtbXCIwXCIsXCIwXCIsXCI1NlwiXSxbXCIxXCIsXCIwXCIsXCI4XCJdLFtcIjJcIixcIjBcIixcIjEwXCJdLFtcIjJcIixcIjBcIixcIjFcIl0sW1wiM1wiLFwiMFwiLFwiMVwiXSxbXCI0XCIsXCIwXCIsXCI1XCJdXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm9vbVNldHRpbmcgPSBzZXR0aW5nXHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihjYy5Ub2dnbGVHcm91cClcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGdyb3Vwc1tpXS50b2dnbGVJdGVtc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChzZXR0aW5nLmNoZWNrc1tpXVsxXSlcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsrailcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaXRlbXNbal0uaXNDaGVja2VkID0gaiA9PSBpbmRleFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucXVhbmxlaWRhVG9nZ2xlLmlzQ2hlY2tlZCA9IHNldHRpbmcuaXNRdWFuTGVpRGFcclxuICAgIH0sXHJcblxyXG4gICAgb25DaGVjazpmdW5jdGlvbih0b2dnbGUscGFyYW0pIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSB0b2dnbGUudG9nZ2xlR3JvdXAudG9nZ2xlSXRlbXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9nZ2xlID0gaXRlbXNbaV1cclxuICAgICAgICAgICAgaWYgKHRvZ2dsZS5pc0NoZWNrZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJzID0gcGFyYW0uc3BsaXQoJywnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb29tU2V0dGluZy5jaGVja3NbcGFyc2VJbnQoc3Ryc1swXSldID0gc3Ryc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRvZ2dsZS5ub2RlLmdldENoaWxkQnlOYW1lKCdsYWJlbCcpLmdldENvbXBvbmVudChjYy5SaWNoVGV4dClcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGxhYmVsLnN0cmluZy5yZXBsYWNlKC9cXCNbMC05QS1GYS1mXSovLHRvZ2dsZS5pc0NoZWNrZWQgPyAnI0ZGRkZGRicgOiAnIzg4QTJDMycpXHJcbiAgICAgICAgICAgIGxhYmVsLnN0cmluZyA9IHN0clxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25DaGVja1F1YW5MZWlEYTpmdW5jdGlvbih0b2dnbGUpe1xyXG4gICAgICAgIHRoaXMucm9vbVNldHRpbmcuaXNRdWFuTGVpRGEgPSB0b2dnbGUuaXNDaGVja2VkXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ3JlYXRlUm9vbTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZygnUHVibGljUHJvdG8uQ19HMTNfQ3JlYXRlR2FtZScpXHJcbiAgICAgICAgbXNnLnBsYXlfdHlwZSAgICAgPSBwYXJzZUludCh0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1swXVsyXSlcclxuICAgICAgICBtc2cucm91bmRzICAgICAgICA9IHBhcnNlSW50KHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzFdWzJdKVxyXG4gICAgICAgIG1zZy5wYXlvciAgICAgICAgID0gcGFyc2VJbnQodGhpcy5yb29tU2V0dGluZy5jaGVja3NbMl1bMl0pXHJcbiAgICAgICAgbXNnLmRhX3FpYW5nICAgICAgPSBwYXJzZUludCh0aGlzLnJvb21TZXR0aW5nLmNoZWNrc1szXVsyXSlcclxuICAgICAgICBtc2cueWlfdGlhb19sb25nICA9IHBhcnNlSW50KHRoaXMucm9vbVNldHRpbmcuY2hlY2tzWzRdWzJdKVxyXG4gICAgICAgIG1zZy5wbGF5ZXJfc2l6ZSAgID0gcGFyc2VJbnQodGhpcy5yb29tU2V0dGluZy5jaGVja3NbNV1bMl0pXHJcbiAgICAgICAgbXNnLnF1YW5fbGVpX2RhICAgPSB0aGlzLnJvb21TZXR0aW5nLmlzUXVhbkxlaURhXHJcblxyXG4gICAgICAgIGNjLmxvZyhcIm1zZy55aV90aWFvX2xvbmc6XCIgKyBtc2cueWlfdGlhb19sb25nKVxyXG4gICAgICAgIGNjLmxvZyhcIm1zZy5xdWFuX2xlaV9kYTpcIiArIG1zZy5xdWFuX2xlaV9kYSlcclxuXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICBjYy5kYXRhbWFuYWdlci5zYXZlUm9vbVNldHRpbmcodGhpcy5yb29tU2V0dGluZylcclxuICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgIH0sXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfUm9vbUF0dHI6ZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgaWYgKG1zZy5yb29tX2NvZGUgPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVE9ETzrliJvlu7rlpLHotKVcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIH0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICBidG5DbG9zZTpjYy5CdXR0b24sXHJcbiAgICAgICBidG5Db21maXJlOmNjLkJ1dHRvbixcclxuICAgICAgIHNwQ3Vyc29yOmNjLk5vZGUsXHJcbiAgICAgICBjdXJJbmRleDowXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICB1cGRhdGVDdXJzb3I6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAodGhpcy5jdXJJbmRleCA8IDApIHRoaXMuY3VySW5kZXggPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmN1ckluZGV4IDwgNilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb29tID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdyb29taWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zcEN1cnNvci5wYXJlbnQgPSByb29tLmNoaWxkcmVuW3RoaXMuY3VySW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLnNwQ3Vyc29yLnBvc2l0aW9uID0gY2MucCgwLDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmJ0bkNsb3NlLmludGVyYWN0YWJsZSA9IHRoaXMuaXNmdWxsKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRWYWx1ZTpmdW5jdGlvbihub2RlKXtcclxuICAgICAgICByZXR1cm4gbm9kZS5nZXRDaGlsZEJ5TmFtZSgnbnVtJykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmdcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFJvb21JRDpmdW5jdGlvbigpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJvb20gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoJ3Jvb21pZCcpO1xyXG4gICAgICAgIHZhciBjcyA9IHJvb20uY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGlkcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vbS5jaGlsZHJlbkNvdW50OyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZHNbaV0gPSB0aGlzLmdldFZhbHVlKGNzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlkcy5qb2luKFwiXCIpKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldFZhbHVlOmZ1bmN0aW9uKG5vZGUsc3RyKXtcclxuICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKCdudW0nKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHN0cjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldEN1ckluZGV4VmFsdWU6ZnVuY3Rpb24oc3RyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pc2Z1bGwoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb29tID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdyb29taWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShyb29tLmNoaWxkcmVuW3RoaXMuY3VySW5kZXhdLHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaXNmdWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VySW5kZXggPT0gNjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlc2V0VmFsdWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcm9vbSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSgncm9vbWlkJyk7XHJcbiAgICAgICAgdmFyIGNzID0gcm9vbS5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VySW5kZXg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoY3NbaV0sXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VySW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBkZWxldGVWYWx1ZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1ckluZGV4ID49IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAtLXRoaXMuY3VySW5kZXg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckluZGV4IDwgMCkgdGhpcy5jdXJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VySW5kZXhWYWx1ZShcIlwiKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbnB1dFZhbHVlIDogZnVuY3Rpb24obnVtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzZnVsbCgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJJbmRleFZhbHVlKG51bSk7XHJcbiAgICAgICAgICAgICsrdGhpcy5jdXJJbmRleDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgdmFyIGtleWJvYXJkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKCdrZXlib2FyZCcpO1xyXG4gICAgICAgdmFyIGNzID0ga2V5Ym9hcmQuY2hpbGRyZW47XHJcbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleWJvYXJkLmNoaWxkcmVuQ291bnQ7KytpKVxyXG4gICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYnRuID0gY3NbaV0uZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbik7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgYnRuLm5vZGUub24oJ2NsaWNrJyxmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcImJ0bl9yZXNldFwiKVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2V0VmFsdWUoKTsgICAgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PSBcImJ0bl9kZWxldGVcIilcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuZGVsZXRlVmFsdWUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dFZhbHVlKG5vZGUuZ2V0Q2hpbGRCeU5hbWUoJ251bScpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ0bkNsb3NlLmludGVyYWN0YWJsZSA9IHRoaXMuaXNmdWxsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2xpY2tfYnRuQ2xvc2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbmNsaWNrX2J0bkNvbWZpcmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKCdQdWJsaWNQcm90by5DX0cxM19KaW9uR2FtZScpXHJcbiAgICAgICAgbXNnLnJvb21faWQgPSB0aGlzLmdldFJvb21JRCgpXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICBjb25zb2xlLmxvZygncmVxdWlyZSBqb2luIHJvb206JyArIG1zZy5yb29tX2lkKTtcclxuICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYnRuV1hMb2dpbjpjYy5CdXR0b24sXHJcbiAgICAgICAgYnRuR3Vlc3RMb2dpbjpjYy5CdXR0b25cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBsb2NrVUk6ZnVuY3Rpb24oYkxvY2spe1xyXG4gICAgICAgIHZhciBpbnRlcmFjdGFibGUgPSAhYkxvY2tcclxuICAgICAgICB0aGlzLmJ0bldYTG9naW4uaW50ZXJhY3RhYmxlID0gaW50ZXJhY3RhYmxlXHJcbiAgICAgICAgdGhpcy5idG5HdWVzdExvZ2luLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vVE866L2s6I+K6IqxIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgbG9naW46ZnVuY3Rpb24odHlwZSl7XHJcbiAgICAgICAgIHRoaXMubG9ja1VJKHRydWUpXHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLmNvbm5lY3QoY2MuY29uZmlnbWFuYWdlci5zZXJ2ZXJJUCwgY2MuY29uZmlnbWFuYWdlci5zZXJ2ZXJQb3J0LCBmdW5jdGlvbihvayl7XHJcbiAgICAgICAgICAgaWYgKG9rKVxyXG4gICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgY2MubG9nKCdjb25uZWN0ZWQhJyk7XHJcbiAgICAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIubG9naW4odHlwZSlcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgc2VsZi5sb2NrVUkoZmFsc2UpXHJcbiAgICAgICAgICAgICAgIGNjLmxvZygnY29ubmVjdCBmYWlsIScpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vd2VjaGF0IGxvZ2luXHJcbiAgICBvbkNsaWNrX2J0bldYTG9naW46ZnVuY3Rpb24oZXZlbnQpe1xyXG5cclxuICAgICAgICB0aGlzLmxvZ2luKDApXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvL+i/lOWbnuWNj+iuriBcclxuICAgIFB1YmxpY1Byb3RvX1NfTG9naW5SZXQ6ZnVuY3Rpb24obXNnKXtcclxuICAgICAgICB0aGlzLmxvY2tVSShmYWxzZSlcclxuICAgICAgICBpZiAobXNnLnJldF9jb2RlID09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5pbW1hbmFnZXIuaW5pdCgpXHJcblxyXG4gICAgICAgICAgICBjYy5kYXRhbWFuYWdlci5tYWluUGxheWVyRGF0YS5jdWlkID0gbXNnLmN1aWQ7XHJcbiAgICAgICAgICAgIGNjLnNjZW5lbWFuYWdlci5sb2FkTWFpblNjZW5lKClcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY2MubG9nKCdsb2dpbiBmYWlsIScpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uTWVzc2FnZUVycm9yOmZ1bmN0aW9uKGVycm9yaWQpe1xyXG4gICAgICAgIHRoaXMubG9ja1VJKGZhbHNlKVxyXG4gICAgfSxcclxuXHJcbiAgICAvL2d1ZXN0IGxvZ2luXHJcbiAgICBvbkNsaWNrX2J0bkd1ZXN0TG9naW4gOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubG9naW4oMSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBmdW5jTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIG5hbWVMYWJlbDogY2MuTGFiZWxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNjLmxvZyhcIm5hbWUgPSBcIiArIGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLm5pY2tfbmFtZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lTGFiZWwuc3RyaW5nID0gY2MuZGF0YW1hbmFnZXIubWFpblBsYXllckRhdGEubmlja19uYW1lO1xyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5QkdNKCdIYWxsX0JnJylcclxuICAgICAgICB0aGlzLl9zdXBlcigpXHJcbiAgICAgICAgY2MuZ2FtZW1hbmFnZXIuZ2FtZVN0YXJ0KClcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5mdW5jTm9kZS5zY2FsZVkgPSB0aGlzLmZ1bmNOb2RlLndpZHRoLyA4NDAuMDtcclxuICAgIH0sXHJcblxyXG4gICAgbG9nOiBmdW5jdGlvbihzdHIpe1xyXG4gICAgICAgIGNjLmxvZyhzdHIpXHJcbiAgICB9LFxyXG5cclxuICAgIG9wZW5MaWFueGlSb29tOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIGFjdGlvbjEgPSBjYy5zZXF1ZW5jZShjYy5kZWxheVRpbWUoMSksIGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCxwYXJhbSl7dGhpcy5sb2coXCIx56eS5ZCO5pi+56S6XCIpfSkpXHJcbiAgICAgICAgdmFyIGFjdGlvbjIgPSBjYy5zZXF1ZW5jZShjYy5kZWxheVRpbWUoMiksIGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCxwYXJhbSl7dGhpcy5sb2coXCIy56eS5ZCO5pi+56S6XCIpfSkpXHJcbiAgICAgICAgdmFyIGFjdGlvbjMgPSBjYy5zZXF1ZW5jZShjYy5kZWxheVRpbWUoMyksIGNjLmNhbGxGdW5jKGZ1bmN0aW9uKHRhcmdldCxwYXJhbSl7dGhpcy5sb2coXCIz56eS5ZCO5pi+56S6XCIpfSkpXHJcbiAgICAgICAgKi9cclxuICAgICAgICB2YXIgYWN0ID0gY2Muc2VxdWVuY2UoY2MuZGVsYXlUaW1lKDEpLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQsIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5sb2codGFyZ2V0Lm5hbWUsIGRhdGEubmFtZSlcclxuICAgICAgICB9LCB0aGlzLm5vZGUsIHRoaXMubm9kZS5wYXJlbnQpKVxyXG4gICAgICAgIHRoaXMubm9kZS5ydW5BY3Rpb24oYWN0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgbXNnVGV4dDpjYy5MYWJlbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWVzc2FnZTpmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICB0aGlzLm1zZ1RleHQuc3RyaW5nID0gbXNnXHJcbiAgICB9LFxyXG5cclxuICAgIHNldENhbGw6ZnVuY3Rpb24oY2FsbCkge1xyXG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGxcclxuICAgIH0sXHJcblxyXG4gICAgb25Pa2V5OmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJyZXF1aXJlKCdVSVBhbmVsJylcclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MudWlwYW5lbCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYnRuQ2xvc2U6Y2MuQnV0dG9uXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5DbG9zZUNsaWNrZWQ6ZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiaWYgKGNjLnVpcGFuZWwgPT0gdW5kZWZpbmVkKVxyXG57XHJcbiAgICBjYy5sb2coJ3VpcGFuZWwgaW5pdCcpXHJcbiAgICBjYy51aXBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuICAgICAgICBwcm9wZXJ0aWVzOntcclxuICAgICAgICAgICAgYmdPcGFxdWU6MjAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3RvcjpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmlzTW9kZWwgPSB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRWaXNpYmxlOmZ1bmN0aW9uKGJWaXNpYmxlKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGJWaXNpYmxlXHJcbiAgICAgICAgICAgIGlmIChiVmlzaWJsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25IaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIG9uQ3JlYXRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTW9kZWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgICAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoJ0d1aS9Nb2RhbEJnJyxmdW5jdGlvbihlcnIscHJlZmFiKXtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gY2MuaW5zdGFudGlhdGUocHJlZmFiKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcucGFyZW50ID0gc2VsZi5ub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZy5zZXRTaWJsaW5nSW5kZXgoMClcclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coJ3NlbGYuYmcub3BhY2l0eTonICsgc2VsZi5iZy5vcGFjaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcub3BhY2l0eSA9IHNlbGYuYmdPcGFxdWVcclxuICAgICAgICAgICAgICAgICAgICBjYy5sb2coJ3NlbGYuYmcub3BhY2l0eTonICsgc2VsZi5iZy5vcGFjaXR5KVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vblRvdWNoQmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb25JbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvblRvdWNoQmc6ZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBvbkNsb3NlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJnLm9mZihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9TVEFSVClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgb25TaG93OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgb25IaWRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgY2xvc2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY2MubG9nKFwiY2xvc2VcIilcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5jbG9zZSh0aGlzKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG9wZW5VSTpmdW5jdGlvbihldmVudCxuYW1lKXtcclxuICAgICAgICAgICAgY2MuZ3VpbWFuYWdlci5vcGVuKG5hbWUpIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd09yT3BlblVJOmZ1bmN0aW9uKGV2ZW50LG5hbWUpe1xyXG4gICAgICAgICAgICBjYy5ndWltYW5hZ2VyLnNob3dPck9wZW5VSShuYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VsZWN0OmZ1bmN0aW9uKHBhcmVudE5vZGUsaW5kZXgpe1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSBwYXJlbnROb2RlLmNoaWxkcmVuQ291bnRcclxuICAgICAgICAgICAgdmFyIGNzID0gcGFyZW50Tm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNzW2ldLmFjdGl2ZSA9IGkgPT0gaW5kZXhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIG9yaWdpblBva2VyOiBjYy5Ob2RlLFxyXG4gICAgICAgIG1vdmVQb2tlcjogY2MuTm9kZSxcclxuICAgICAgICBwcmVmYWJIZWFkSWNvbjogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyU29ydDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyTGlzdDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHByZWZhYlBva2VyRmxvcDogY2MuUHJlZmFiLFxyXG4gICAgICAgIHJvb21OdW06Y2MuTGFiZWwsXHJcbiAgICAgICAgbXlIZWFkSWNvbjogY2MuTm9kZSxcclxuICAgICAgICBzdGFydEFuaW1hdGlvbjogY2MuTm9kZSxcclxuICAgICAgICByZWNvcmRCdG46Y2MuTm9kZSxcclxuICAgICAgICByZWNvcmRQYW5lbDpjYy5Ob2RlLFxyXG5cclxuICAgICAgICBfcG9rZXJMaXN0OiBudWxsLFxyXG4gICAgICAgIF9oZWFkSWNvbnM6IG51bGwsXHJcbiAgICAgICAgX3Bva2VyRmxvcHM6IG51bGwsXHJcbiAgICAgICAgX2N1clNodWZmbGVJZHg6MCxcclxuICAgICAgICBfcGxheWVySGVhZHM6IG51bGxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkNyZWF0ZTogZnVuY3Rpb24gKCkgeyAgICBcclxuICAgICAgICB0aGlzLl9wb2tlckxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgdGhpcy5idWJibGVQcmVmYWIgPSBjYy5sb2FkZXIubG9hZFJlcygnR3VpL1dpZGdldC9DaGF0QnViYmxlJyxmdW5jdGlvbihlcnIscHJlZmFiKXtcclxuICAgICAgICAgICAgc2VsZi5idWJibGVQcmVmYWIgPSBwcmVmYWJcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLnJlY29yZEJ0bi5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9TVEFSVCwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgc2VsZi5vblN0YXJ0UmVjb3JkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRCdG4ub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfTU9WRSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgc2VsZi5vbkNhbmNlbFJlY29yZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVjb3JkQnRuLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0VORCwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgc2VsZi5vblN0b3BSZWNvcmQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yb29tTnVtLnN0cmluZyA9IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5yb29tX2lkO1xyXG4gICAgICAgIHRoaXMuaW5pdFJvb20oY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemUpO1xyXG4gICAgICAgIHRoaXMub25QbGF5ZXJJblJvb20oY2MuZ2FtZW1hbmFnZXIuX3BsYXllcnMpO1xyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5wbGF5QkdNKCdHYW1lX0JnJylcclxuICAgICAgICB0aGlzLl9zdXBlcigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsb3NlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICh0aGlzLmJ1YmJsZVByZWZhYilcclxuICAgICAgICAgICAgY2MubG9hZGVyLnJlbGVhc2VBc3NldCh0aGlzLmJ1YmJsZVByZWZhYilcclxuICAgICAgICBjYy5nYW1lbWFuYWdlci5nYW1lT3ZlcigpO1xyXG4gICAgICAgIHRoaXMuX3N1cGVyKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRSb29tOiBmdW5jdGlvbihwbGF5ZXJOdW0pe1xyXG4gICAgICAgIGlmKHBsYXllck51bSA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYocGxheWVyTnVtID09IDEpXHJcbiAgICAgICAgICAgIHBsYXllck51bSA9IDI7XHJcblxyXG4gICAgICAgIGNjLmxvZyhcImluaXQgcm9vbSwgcGFseWVyIG51bWJlciA9IFwiICsgcGxheWVyTnVtKTtcclxuICAgICAgICBpZihwbGF5ZXJOdW0gPD0gMSB8fCBwbGF5ZXJOdW0gPiA1KXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy/njqnlrrblpLTlg49cclxuICAgICAgICB0aGlzLl9wbGF5ZXJIZWFkcyA9IFtdO1xyXG4gICAgICAgIHZhciBwb3MgPSBjYy5jb25maWdtYW5hZ2VyLmhlYWRJY29uUG9zW3BsYXllck51bS0yXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGxheWVyTnVtLTE7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBoZWFkID0gY2MuaW5zdGFudGlhdGUodGhpcy5wcmVmYWJIZWFkSWNvbik7XHJcbiAgICAgICAgICAgIGhlYWQucGFyZW50ID0gdGhpcy5ub2RlO1xyXG4gICAgICAgICAgICBoZWFkLnBvc2l0aW9uID0gcG9zW2ldO1xyXG4gICAgICAgICAgICAvL2hlYWQuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXllckhlYWRzLnB1c2goaGVhZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL+WPkeeJjOWbvueJh1xyXG4gICAgICAgIHRoaXMuX3Bva2VyTGlzdCA9IFtdO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2Vyc1wiKVxyXG4gICAgICAgIHRoaXMuX3Bva2VyTGlzdC5wdXNoKHBhcmVudE5vZGUuY2hpbGRyZW5bMF0pXHJcbiAgICAgICAgcG9zID0gY2MuY29uZmlnbWFuYWdlci5oZWFkSWNvblBvc1twbGF5ZXJOdW0tMl07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBsYXllck51bS0xOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgcG9rZXJsaXN0ID0gY2MuaW5zdGFudGlhdGUodGhpcy5wcmVmYWJQb2tlckxpc3QpXHJcbiAgICAgICAgICAgIHBva2VybGlzdC5wYXJlbnQgPSBwYXJlbnROb2RlXHJcbiAgICAgICAgICAgIHBva2VybGlzdC5wb3NpdGlvbiA9IHBvc1tpXVxyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckxpc3QucHVzaChwb2tlcmxpc3QpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL+avlOeJjFxyXG4gICAgICAgIHRoaXMuX3Bva2VyRmxvcHMgPSBbXSAvL+ivpeaVsOe7hOWMheaLrOiHquW3sVxyXG4gICAgICAgIHZhciBmbG9wUGFyZW50ID0gY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyRmxvcHNcIilcclxuICAgICAgICB0aGlzLl9wb2tlckZsb3BzLnB1c2goZmxvcFBhcmVudC5jaGlsZHJlblswXSkgICAvL+iHquW3seeahFxyXG4gICAgICAgIHBvcyA9IGNjLmNvbmZpZ21hbmFnZXIuaGVhZEljb25Qb3NbcGxheWVyTnVtLTJdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwbGF5ZXJOdW0tMTsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHBva2VyRmxvcCA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiUG9rZXJGbG9wKVxyXG4gICAgICAgICAgICBwb2tlckZsb3AucGFyZW50ID0gZmxvcFBhcmVudFxyXG4gICAgICAgICAgICBwb2tlckZsb3AucG9zaXRpb24gPSBjYy52Mihwb3NbaV0ueCwgcG9zW2ldLnkrMjAwKVxyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckZsb3BzLnB1c2gocG9rZXJGbG9wKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoTmV3TWF0Y2hTdGF0ZSgpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v5paw55qE5LiA5bGA5byA5aeL5Yi35paw5pWw5o2uXHJcbiAgICByZWZyZXNoTmV3TWF0Y2hTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJMaXN0Lmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wb2tlckxpc3RbaV1cclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckxpc3RcIikucmVzZXRTdGF0ZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICBub2RlLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKS5yZXNldFN0YXRlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2Vyc1wiKS5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIGNjLmZpbmQoXCJVSVBva2VyR2FtZS9Qb2tlckZsb3BzXCIpLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIF9yZWZyZXNoSGVhZEluZm86IGZ1bmN0aW9uKG5vZGUsIGRhdGEpe1xyXG4gICAgICAgIGlmKG5vZGUgPT0gbnVsbCApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGljb24gPSBub2RlLmdldENoaWxkQnlOYW1lKFwiaWNvblwiKVxyXG4gICAgICAgIHZhciBkZWZpY29uID0gbm9kZS5nZXRDaGlsZEJ5TmFtZShcImRlZmF1bHRcIilcclxuXHJcbiAgICAgICAgaWYoZGF0YSA9PSBudWxsIHx8IHBhcnNlSW50KGRhdGEuY3VpZCkgPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGljb24uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRlZmljb24uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWNvbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBkZWZpY29uLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgbm9kZS5jdWlkID0gZGF0YS5jdWlkXHJcblxyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBpY29uLmdldENoaWxkQnlOYW1lKFwibmFtZVwiKVxyXG4gICAgICAgICAgICBpZihsYWJlbCAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGxhYmVsLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb2luID0gaWNvbi5nZXRDaGlsZEJ5TmFtZShcImNvaW5udW1cIilcclxuICAgICAgICAgICAgaWYoY29pbiAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGNvaW4uZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSAwOyAvL2RhdGEubW9uZXkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlID0gaWNvbi5nZXRDaGlsZEJ5TmFtZShcInlpemh1bmJlaVwiKVxyXG4gICAgICAgICAgICBpZihwcmVwYXJlICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgcHJlcGFyZS5hY3RpdmUgPSAoZGF0YS5zdGF0dXMgPT0gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/njqnlrrblpLTlg49cclxuICAgICAgICAgICAgdmFyIGljb24gPSBpY29uLmdldENoaWxkQnlOYW1lKFwiaGVhZElDT05cIilcclxuICAgICAgICAgICAgaWYoaWNvbiAhPSBudWxsKXtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEhlYWRlciA6IGZ1bmN0aW9uKGN1aWQpIHtcclxuICAgICAgICBpZiAodGhpcy5teUhlYWRJY29uLmN1aWQgJiYgY3VpZC5lcSh0aGlzLm15SGVhZEljb24uY3VpZCkpIHJldHVybiB0aGlzLm15SGVhZEljb25cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BsYXllckhlYWRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX3BsYXllckhlYWRzW2ldXHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIgJiYgaGVhZGVyLmN1aWQgJiYgY3VpZC5lcShoZWFkZXIuY3VpZCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGbG9wOiBmdW5jdGlvbihjdWlkKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBmbG9wID0gdGhpcy5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICBpZihmbG9wICYmIGZsb3AuY3VpZCAmJiBjdWlkLmVxKGZsb3AuY3VpZCkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsb3BcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICBvblBsYXllckluUm9vbTogZnVuY3Rpb24ocGxheWVyc2RhdGEpe1xyXG5cclxuICAgICAgICAvL+acieaXtuWAmeS8muWHuueOsOi/m+WFpeaIv+mXtO+8jGluaXRSb29t6L+Y5pyq6LCD55SoXHJcbiAgICAgICAgaWYodGhpcy5fcGxheWVySGVhZHMgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFJvb20oY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MubG9nKFwib25QbGF5ZXJJblJvb20gbGVuZ3RoID0gXCIgKyBwbGF5ZXJzZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgaWYocGxheWVyc2RhdGEubGVuZ3RoID09IDApeyBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNvcnRkYXRhID0gW107XHJcbiAgICAgICAgdmFyIHNlbGZJZHggPSAwO1xyXG4gICAgICAgIHZhciBzZWxmRGF0YSA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwbGF5ZXJzZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHBhcnNlSW50KHBsYXllcnNkYXRhW2ldLmN1aWQpID09IHBhcnNlSW50KHNlbGZEYXRhLmN1aWQpKXtcclxuICAgICAgICAgICAgICAgIHNlbGZJZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgLy9jYy5maW5kKFwiVUlQb2tlckdhbWUvc3RhcnRCdG5cIikuYWN0aXZlID0gKHBsYXllcnNkYXRhW2ldLnN0YXR1cyA9PSAwKTtcclxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIuaIkeeahOeKtuaAge+8miBcIiArIHBsYXllcnNkYXRhW2ldLnN0YXR1cylcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEJ0biA9IGNjLmZpbmQoXCJVSVBva2VyR2FtZS9zdGFydEJ0blwiKVxyXG4gICAgICAgICAgICAgICAgc3RhcnRCdG4uYWN0aXZlID0gKHBsYXllcnNkYXRhW2ldLnN0YXR1cyA8IDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaEhlYWRJbmZvKHRoaXMubXlIZWFkSWNvbiwgcGxheWVyc2RhdGFbaV0pXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2tlckZsb3BzWzBdLmN1aWQgPSBwbGF5ZXJzZGF0YVtpXS5jdWlkXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGkgPSBzZWxmSWR4ICsgMTsgaSA8IHBsYXllcnNkYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgc29ydGRhdGEucHVzaChwbGF5ZXJzZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmSWR4OyArK2kpe1xyXG4gICAgICAgICAgICBzb3J0ZGF0YS5wdXNoKHBsYXllcnNkYXRhW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICBmb3IoIDsgaSA8IHNvcnRkYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wbGF5ZXJIZWFkc1tpXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaEhlYWRJbmZvKG5vZGUsIHNvcnRkYXRhW2ldKVxyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckZsb3BzW2krMV0uY3VpZCA9IHNvcnRkYXRhW2ldLmN1aWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciggOyBpIDwgdGhpcy5fcGxheWVySGVhZHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3BsYXllckhlYWRzW2ldXHJcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hIZWFkSW5mbyhub2RlLCBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9rZXJGbG9wc1tpKzFdLmN1aWQgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzaG93Q2hhdCA6IGZ1bmN0aW9uKGN1aWQsY29udGVudCkge1xyXG4gICAgICAgIGNjLmxvZyhjdWlkKVxyXG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmdldEhlYWRlcihjdWlkKVxyXG4gICAgICAgIGlmIChoZWFkZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5sb2coXCJ0aGlzLmJ1YmJsZVByZWZhYjpcIiArIHRoaXMuYnViYmxlUHJlZmFiKVxyXG4gICAgICAgICAgICBpZiAoIWhlYWRlci5idWJibGUgJiYgdGhpcy5idWJibGVQcmVmYWIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlci5idWJibGUgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLmJ1YmJsZVByZWZhYilcclxuICAgICAgICAgICAgICAgIGhlYWRlci5idWJibGUucGFyZW50ID0gY2MuZGlyZWN0b3IuZ2V0U2NlbmUoKVxyXG5cclxuICAgICAgICAgICAgICAgIGhlYWRlci5idWJibGUucG9zaXRpb24gPSBoZWFkZXIuY29udmVydFRvV29ybGRTcGFjZSAoY2MucCgwLDApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIuYnViYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVsbGVyID0gaGVhZGVyLmJ1YmJsZS5nZXRDb21wb25lbnQoXCJDaGF0QnViYmxlXCIpXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVsbGVyLnNob3dUZXh0KGNvbnRlbnQuZGF0YV90ZXh0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudC50eXBlID09IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVsbGVyLnNob3dGYWNlKGNvbnRlbnQuZGF0YV9pbnQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NoZWR1bGVyID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIudW5zY2hlZHVsZUFsbEZvclRhcmdldChidWxsZXIpXHJcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxlci5ub2RlLmRlc3Ryb3koKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuYnViYmxlID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sYnVsbGVyLDAsMCwzLGZhbHNlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iBiuWkqea2iOaBr1xyXG4gICAgUHVibGljUHJvdG9fU19DaGF0IDogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgdGhpcy5zaG93Q2hhdChtc2cuY3VpZCxtc2cuY29udGVudClcclxuICAgIH0sXHJcblxyXG4gICAgZ2l2ZXVwIDogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coXCJQdWJsaWNQcm90by5DX0cxM19HaXZlVXBcIilcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG4gICAgICAgIGV2ZW50LnRhcmdldC5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGlja1NldEJ0bjogZnVuY3Rpb24oKXtcclxuICAgIH0sXHJcblxyXG4gICAgUHVibGljUHJvdG9fU19HMTNfUGxheWVyUXVpdGVkIDogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIGNjLnNjZW5lbWFuYWdlci5sb2FkTWFpblNjZW5lKClcclxuICAgIH0sXHJcblxyXG4gICAgLy/lvIDlp4vmlrDnmoTkuIDlsYBcclxuICAgIG5ld01hdGNoU3RhcnQ6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaE5ld01hdGNoU3RhdGUoKVxyXG5cclxuICAgICAgICB2YXIgYWN0aW9uID0gY2Muc2VxdWVuY2UoY2MuZGVsYXlUaW1lKDMpLCBjYy5jYWxsRnVuYyhmdW5jdGlvbih0YXJnZXQscGFyYW0pe1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRhcmdldC5nZXRDb21wb25lbnQoXCJVSVBva2VyR2FtZVwiKVxyXG4gICAgICAgICAgICBzZWxmLnN0YXJ0QW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLmZhcGFpKClcclxuICAgICAgICB9LCB0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm5vZGUucnVuQWN0aW9uKGFjdGlvbilcclxuICAgIH0sXHJcblxyXG4gICAgY2xpY2tTdGFydEJ0bjogZnVuY3Rpb24oKXtcclxuLy8gICAgICAgIHRoaXMubmV3TWF0Y2hTdGFydCgpXHJcbi8qXHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2tlckZsb3BzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wb2tlckZsb3BzW2ldXHJcbiAgICAgICAgICAgIHZhciBjb21wb25ldCA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpXHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChjb21wb25ldC50b3BGbG9wQWN0aW9uKGNvbXBvbmV0KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2tlckZsb3BzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9wb2tlckZsb3BzW2ldXHJcbiAgICAgICAgICAgIHZhciBjb21wb25ldCA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiUG9rZXJGbG9wXCIpXHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChjb21wb25ldC5taWRkbGVGbG9wQWN0aW9uKGNvbXBvbmV0KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9rZXJGbG9wcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcG9rZXJGbG9wc1tpXVxyXG4gICAgICAgICAgICB2YXIgY29tcG9uZXQgPSBub2RlLmdldENvbXBvbmVudChcIlBva2VyRmxvcFwiKVxyXG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goY29tcG9uZXQuYm90dG9tRmxvcEFjdGlvbihjb21wb25ldCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm5vZGUucnVuQWN0aW9uKGNjLnNlcXVlbmNlKGFjdGlvbnMpKVxyXG4qL1xyXG4vKlxyXG5cclxuICAgICAgICAgICAgLy/miZPlvIDpgInniYznlYzpnaJcclxuICAgICAgICAgICAgdmFyIHBva2VyU29ydCA9IGNjLmluc3RhbnRpYXRlKHRoaXMucHJlZmFiUG9rZXJTb3J0KTtcclxuICAgICAgICAgICAgcG9rZXJTb3J0LnBhcmVudCA9IHRoaXMubm9kZTtcclxuICAgICAgICAgICAgcG9rZXJTb3J0LnBvc2l0aW9uID0gY2MudjIoMCwgMCk7IFxyXG4gICAgICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLy/lj5HpgIHlh4blpIfmtojmga9cclxuICAgICAgICBjYy5maW5kKFwiVUlQb2tlckdhbWUvc3RhcnRCdG5cIikuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG1zZyA9IGNjLm5ldG1hbmFnZXIubXNnKCdQdWJsaWNQcm90by5DX0cxM19SZWFkeUZsYWcnKVxyXG4gICAgICAgIG1zZy5yZWFkeSA9IHRydWVcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmFwYWk6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2Vyc1wiKS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2tlci5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubW92ZVBva2VyLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGFuaU5hbWUgPSBcImFjX2NhcmRtb3ZlXCIrY2MuZ2FtZW1hbmFnZXIucm9vbV9pbmZvLmF0dHIucGxheWVyX3NpemVcclxuICAgICAgICBjYy5sb2coXCLmkq3mlL7liqjnlLvvvJogXCIsIGFuaU5hbWUpXHJcbiAgICAgICAgdGhpcy5tb3ZlUG9rZXIuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikucGxheShhbmlOYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIGNhcmRsaXN0ID0gdGhpcy5fcG9rZXJMaXN0WzBdXHJcbiAgICAgICAgdmFyIHBva2VycyA9IGNjLmdhbWVtYW5hZ2VyLmdldEN1ck1hdGhQb2tlcnMoKVxyXG4gICAgICAgIGNjLmxvZyhcImNhcmRsaXN0LmNoaWxkcmVuQ291bnQgPSBcIiArIGNhcmRsaXN0LmNoaWxkcmVuQ291bnQpXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNhcmRsaXN0LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBjYXJkID0gY2FyZGxpc3QuY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgdmFyIHZhbCA9IHBva2Vyc1tpXVxyXG4gICAgICAgICAgICAvL2NjLmxvZyhcInBva2VyIHZhbHVlICBcIiArIHZhbClcclxuICAgICAgICAgICAgY2MuUG9rZXJVdGlsLnJlcGxhY2VQb2tlclNwcml0ZSh2YWwsIGNhcmQpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WPkeeJjGV2ZW5057uT5p2f5omT5byAUG9rZXJTb3J06YCJ54mM55WM6Z2iXHJcbiAgICBvbkFuaW1Db21wbGV0ZWQ6IGZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICBpZihpbmRleCA8IDEgfHwgaW5kZXggPiA1KXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFtpbmRleCwgdGhpcy5fY3VyU2h1ZmZsZUlkeCwgdGhpcy5fcG9rZXJMaXN0W2luZGV4LTFdLmNoaWxkcmVuQ291bnQgXSk7XHJcbiAgICAgICAgdGhpcy5fcG9rZXJMaXN0W2luZGV4LTFdLmNoaWxkcmVuW3RoaXMuX2N1clNodWZmbGVJZHhdLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmKGluZGV4ID09IGNjLmdhbWVtYW5hZ2VyLnJvb21faW5mby5hdHRyLnBsYXllcl9zaXplKXtcclxuICAgICAgICAgICAgdGhpcy5fY3VyU2h1ZmZsZUlkeCsrO1xyXG4gICAgICAgICAgICB2YXIgYW5pTmFtZSA9IFwiYWNfY2FyZG1vdmVcIitjYy5nYW1lbWFuYWdlci5yb29tX2luZm8uYXR0ci5wbGF5ZXJfc2l6ZVxyXG4gICAgICAgICAgICB0aGlzLm1vdmVQb2tlci5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKS5wbGF5KGFuaU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLl9jdXJTaHVmZmxlSWR4ID49IDEyKXtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlUG9rZXIuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikuc3RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVQb2tlci5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5Qb2tlci5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8v5omT5byA6YCJ54mM55WM6Z2iXHJcbiAgICAgICAgICAgIHZhciBwb2tlclNvcnQgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnByZWZhYlBva2VyU29ydCk7XHJcbiAgICAgICAgICAgIC8vdmFyIHBva2VyU29ydCA9IGNjLmd1aW1hbmFnZXIub3BlbihcIlBva2VyU29ydFwiKVxyXG4gICAgICAgICAgICBwb2tlclNvcnQucGFyZW50ID0gdGhpcy5ub2RlO1xyXG4gICAgICAgICAgICBwb2tlclNvcnQucG9zaXRpb24gPSBjYy52MigwLCAwKTsgXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wb2tlckxpc3RbMF0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNjLmZpbmQoXCJVSVBva2VyR2FtZS9Qb2tlcnNcIikuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgY2MuZmluZChcIlVJUG9rZXJHYW1lL1Bva2VyRmxvcHNcIikuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/mlLbliLDnu5PnrpfniYzmtojmga/vvIzlvIDlp4votbDmr5TniYzmtYHnqItcclxuICAgIFB1YmxpY1Byb3RvX1NfRzEzX0FsbEhhbmRzOiBmdW5jdGlvbihtc2cpe1xyXG4gICAgICAgIGlmKG1zZy5wbGF5ZXJzLmxlbmd0aCAhPSBjYy5nYW1lbWFuYWdlci5yb29tX2luZm8uYXR0ci5wbGF5ZXJfc2l6ZSl7XHJcbiAgICAgICAgICAgIGNjLmxvZyhcIuaUtuWIsOe7k+eul+eJjOaVsOaNrumUmeivr1wiKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGFjdGlvbjEgPSBbXVxyXG4gICAgICAgIHZhciBhY3Rpb24yID0gW11cclxuICAgICAgICB2YXIgYWN0aW9uMyA9IFtdXHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cucGxheWVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBwbGF5ZXJkYXRhID0gbXNnLnBsYXllcltpXVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0RmxvcChwbGF5ZXJkYXRhLmN1aWQpXHJcbiAgICAgICAgICAgIGlmKG5vZGUgJiYgbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIikpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvZW50ID0gbm9kZS5nZXRDb21wb25lbnQoXCJQb2tlckZsb3BcIilcclxuICAgICAgICAgICAgICAgIGNvbXBvZW50LmluaXRQb2tlclZhbHVlcyhwbGF5ZXJkYXRhLmNhcmRzKVxyXG4gICAgICAgICAgICAgICAgYWN0aW9uMS5wdXNoKGNvbXBvZW50LnRvcEZsb3BBY3Rpb24oY29tcG9lbnQpKVxyXG4gICAgICAgICAgICAgICAgYWN0aW9uMi5wdXNoKGNvbXBvZW50Lm1pZGRsZUZsb3BBY3Rpb24oY29tcG9lbnQpKVxyXG4gICAgICAgICAgICAgICAgYWN0aW9uMy5wdXNoKGNvbXBvZW50LmJvdHRvbUZsb3BBY3Rpb24oY29tcG9lbnQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZS5ydW5BY3Rpb24oY2Muc2VxdWVuY2UoYWN0aW9uMSkpXHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BSZWNvcmQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjYy5sb2coJ+e7k+adn+W9lemfsy4uLicpXHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydFJlY29yZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkUGFuZWwuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0UmVjb3JkID0gZmFsc2VcclxuICAgICAgICAgICAgY2MuaW1tYW5hZ2VyLmltLnN0b3BSZWNvcmQoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25TdGFydFJlY29yZCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVjb3JkUGFuZWwuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuaXNTdGFydFJlY29yZCA9IHRydWVcclxuXHJcbiAgICAgICAgY2MubG9nKCflvIDlp4vlvZXpn7MuLi4nKVxyXG4gICAgICAgIGNjLmltbWFuYWdlci5pbS5zdGFydFJlY29yZCgpXHJcbiAgICAgICAgY2MuaW1tYW5hZ2VyLnNldENhbGwoZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8v6ZW/5Lyg5oiQ5YqfXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coXCJQdWJsaWNQcm90by5DX1NlbmRDaGF0XCIpXHJcbiAgICAgICAgICAgIG1zZy50eXBlID0gMlxyXG4gICAgICAgICAgICBjbWQuZGF0YV90ZXh0ID0gZGF0YS51cmxcclxuICAgICAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuXHJcbiAgICAgICAgICAgIGNjLm5ldG1hbmFnZXIuaW0ucGxheUZyb21VcmwoZGF0YS51cmwpXHJcbiAgICAgICAgfSxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAvL+WBnOatouW9leWItlxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ2FuY2VsUmVjb3JkIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkKClcclxuICAgIH0sXHJcblxyXG4gICAgb25TdG9wUmVjb3JkIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkKClcclxuICAgIH0sXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcbiAgICBcclxuICAgIHByb3BlcnRpZXMgOiB7XHJcbiAgICAgICAgbXVzaWNCYXI6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgZWZmZWN0QmFyOmNjLlByb2dyZXNzQmFyLFxyXG4gICAgICAgIG11c2ljU2xpZGVyOmNjLlNsaWRlcixcclxuICAgICAgICBlZmZlY3RTbGlkZXI6Y2MuU2xpZGVyLFxyXG4gICAgICAgIG11c2ljSWNvbjpjYy5Ob2RlLFxyXG4gICAgICAgIGVmZmVjdEljb246Y2MuTm9kZSxcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlSWNvbjogZnVuY3Rpb24oaWNvbk5vZGUsdmFsdWUpIHtcclxuICAgIFx0dGhpcy5zZWxlY3QoaWNvbk5vZGUsdmFsdWUpXHJcbiAgICB9LFxyXG5cclxuICAgIG9uTXVzaWNDaGFuZ2U6ZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICBcdHZhciBwcm9ncmVzcyA9IHRhcmdldC5wcm9ncmVzc1xyXG4gICAgICAgIHRoaXMubXVzaWNCYXIucHJvZ3Jlc3MgPSBwcm9ncmVzc1xyXG4gICAgICAgIGlmIChwcm9ncmVzcyA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICBcdHRoaXMudXBkYXRlSWNvbih0aGlzLm11c2ljSWNvbiwwKVxyXG4gICAgICAgIFx0Ly9jbG9zZSBzb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgIFx0dGhpcy51cGRhdGVJY29uKHRoaXMubXVzaWNJY29uLDEpXHJcbiAgICAgICAgXHQvL1RPRE86b3BlbiBzb3VuZFxyXG4gICAgICAgIFx0Ly9UT0RPOnNldCBzb3VuZCB2b2x1bWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRWZmZWN0Q2hhbmdlOmZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgXHR2YXIgcHJvZ3Jlc3MgPSB0YXJnZXQucHJvZ3Jlc3NcclxuICAgICAgICB0aGlzLmVmZmVjdEJhci5wcm9ncmVzcyA9IHByb2dyZXNzXHJcbiAgICAgICAgaWYgKHByb2dyZXNzID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgIFx0dGhpcy51cGRhdGVJY29uKHRoaXMuZWZmZWN0SWNvbiwwKVxyXG4gICAgICAgIFx0Ly9jbG9zZSBzb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgIFx0dGhpcy51cGRhdGVJY29uKHRoaXMuZWZmZWN0SWNvbiwxKVxyXG4gICAgICAgIFx0Ly9UT0RPOm9wZW4gc291bmRcclxuICAgICAgICBcdC8vVE9ETzpzZXQgc291bmQgdm9sdW1lXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNoYW5nZVVJRDpmdW5jdGlvbigpe1xyXG4gICAgXHR0aGlzLmNsb3NlKClcclxuICAgIFx0Ly9UT0RPOuWIh+aNoui0puWPt1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNdXNpY1BlcjpmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICBcdHRoaXMubXVzaWNTbGlkZXIucHJvZ3Jlc3MgPSBtYXRoLmNsYW1wKHZhbHVlLDAsMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVmZmVjdFBlcjpmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICBcdHRoaXMuZWZmZWN0U2xpZGVyLnByb2dyZXNzID0gbWF0aC5jbGFtcCh2YWx1ZSwwLDEpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsInJlcXVpcmUoJ1VJUGFuZWwnKVxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy51aXBhbmVsLFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIHRpcDpjYy5SaWNoVGV4dCxcclxuICAgICAgIGJ0bnM6Y2MuTm9kZSxcclxuICAgICAgIHZvdGVJdGVtczpjYy5Ob2RlXHJcbiAgICB9LFxyXG5cclxuICAgIG9uU2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSBjYy5nYW1lbWFuYWdlci52b3RlSW5mb1xyXG4gICAgICAgIHRoaXMucmVtYWluX3NlY29uZHMgID0gaW5mby5yZW1haW5fc2Vjb25kc1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKVxyXG4gICAgICAgIHRoaXMudXBkYXRlX3N0YXJ0X3RpbWUgPSBkLmdldFRpbWUoKSAvIDEwMDBcclxuICAgICAgICB0aGlzLnZvdGVTcG9uc29yTmFtZSA9IGNjLmdhbWVtYW5hZ2VyLmdldFBsYXllcihpbmZvLnNwb25zb3IpLm5hbWVcclxuICAgICAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZSgpXHJcbiAgICAgICAgICAgIHZhciBzID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgICAgICBzLnNjaGVkdWxlKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVRpbWUoKVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzLm5vZGUsMSx0aGlzLnJlbWFpbl9zZWNvbmRzLDEsZmFsc2UpXHJcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZSA9IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVm90ZShpbmZvKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25DbG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wVXBkYXRlVGltZSgpXHJcbiAgICAgICAgdGhpcy5fc3VwZXIoKVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUaW1lOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKVxyXG4gICAgICAgIGNjLmxvZygndGhpcy5yZW1haW5fc2Vjb25kczonICsgdGhpcy5yZW1haW5fc2Vjb25kcylcclxuICAgICAgICB2YXIgdGltZSA9IE1hdGgubWF4KDAsTWF0aC5mbG9vcih0aGlzLnJlbWFpbl9zZWNvbmRzIC0gKGQuZ2V0VGltZSgpIC8gMTAwMCAtIHRoaXMudXBkYXRlX3N0YXJ0X3RpbWUpKSlcclxuXHJcbiAgICAgICAgdGhpcy50aXAuc3RyaW5nID0gJzxjb2xvcj0jMDBmZjAwPueOqeWutjxjb2xvcj0jMGZmZmZmPicuY29uY2F0KHRoaXMudm90ZVNwb25zb3JOYW1lLFxyXG4gICAgICAgICc8L2NvbG9yPueUs+ivt+ino+aVo+aIv+mXtCAo5Ymp5L2ZPGNvbG9yPSMwZmZmZmY+JyxTdHJpbmcodGltZSksXHJcbiAgICAgICAgJzwvY29sb3I+56eSLOi2heaXtuacquWQjOaEj+m7mOiupOWQjOaEjyk8L2M+Jyk7XHJcbiAgICAgICAgaWYgKHRpbWUgPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFVwZGF0ZVRpbWUoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RvcFVwZGF0ZVRpbWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBjYy5kaXJlY3Rvci5nZXRTY2hlZHVsZXIoKTtcclxuICAgICAgICAgICAgcy51bnNjaGVkdWxlQWxsRm9yVGFyZ2V0KHRoaXMubm9kZSkgXHJcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZSA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZvdGU6ZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgIC8v5pu05paw5oqV56WoXHJcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52b3RlSXRlbXMuY2hpbGRyZW5Db3VudFxyXG4gICAgICAgIHZhciBjcyA9IHRoaXMudm90ZUl0ZW1zLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBteXVpZCA9IGNjLmRhdGFtYW5hZ2VyLm1haW5QbGF5ZXJEYXRhLmN1aWRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSA8IGluZm8udm90ZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXl1aWQuZXEoaW5mby52b3Rlc1tpXS5jdWlkKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ0bnMuYWN0aXZlID0gaW5mby52b3Rlc1tpXS52b3RlID09IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVm90ZUl0ZW0oY3NbaV0saW5mby52b3Rlc1tpXSlcclxuICAgICAgICAgICAgICAgIGNzW2ldLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNzW2ldLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHZvdGVUb1N0cmluZzogZnVuY3Rpb24odm90ZSkge1xyXG4gICAgICAgIGlmICh2b3RlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxjb2xvcj0jNTk4QkQwPuetieW+heaKleelqDwvYz4nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZvdGUgPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPGNvbG9yPSM2RUQ5MDE+5ZCM5oSPPC9jPidcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmF0ZSA9PSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8Y29sb3I9I2ZmMDAwMD7mi5Lnu508L2M+J1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVm90ZUl0ZW06ZnVuY3Rpb24oaXRlbSxpbmZvKSB7XHJcbiAgICAgICAgdmFyIG5hbWVOb2RlID0gaXRlbS5nZXRDaGlsZEJ5TmFtZSgnbmFtZScpXHJcbiAgICAgICAgdmFyIHN0YXRlTm9kZSA9IGl0ZW0uZ2V0Q2hpbGRCeU5hbWUoJ3N0YXRlJylcclxuICAgICAgICB2YXIgc3RhdGVMYWJlbCA9IHN0YXRlTm9kZS5nZXRDb21wb25lbnQoY2MuUmljaFRleHQpXHJcbiAgICAgICAgbmFtZU5vZGUuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBjYy5nYW1lbWFuYWdlci5nZXRQbGF5ZXIoaW5mby5jdWlkKS5uYW1lXHJcbiAgICAgICAgc3RhdGVMYWJlbC5zdHJpbmcgPSB0aGlzLnZvdGVUb1N0cmluZyhpbmZvLnZvdGUpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnVzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy/mi5Lnu51cclxuICAgICAgICB2YXIgbXNnID0gY2MubmV0bWFuYWdlci5tc2coJ1B1YmxpY1Byb3RvLkNfRzEzX1ZvdGVGb0Fib3J0R2FtZScpXHJcbiAgICAgICAgbXNnLnZvdGUgPSAyXHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5zZW5kKG1zZylcclxuICAgICAgICB0aGlzLmJ0bnMuYWN0aXZlID0gZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgYWdyZWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtc2cgPSBjYy5uZXRtYW5hZ2VyLm1zZygnUHVibGljUHJvdG8uQ19HMTNfVm90ZUZvQWJvcnRHYW1lJylcclxuICAgICAgICBtc2cudm90ZSA9IDFcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnNlbmQobXNnKVxyXG4gICAgICAgIHRoaXMuYnRucy5hY3RpdmUgPSBmYWxzZVxyXG4gICAgfVxyXG4gICAgXHJcbn0pO1xyXG4iLCJcclxucmVxdWlyZSgnVUlQYW5lbCcpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLnVpcGFuZWwsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgd2FpdExhYmVsOmNjLkxhYmVsXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRNZXNzYWdlOmZ1bmN0aW9uKG1zZyl7XHJcbiAgICAgICAgdGhpcy53YWl0TGFiZWwuc3RyaW5nID0gbXNnXHJcbiAgICB9XHJcbn0pO1xyXG4iLCIvKlxyXG4gYnl0ZWJ1ZmZlci5qcyAoYykgMjAxNSBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQmFja2luZyBidWZmZXI6IEFycmF5QnVmZmVyLCBBY2Nlc3NvcjogVWludDhBcnJheVxyXG4gUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9ieXRlYnVmZmVyLmpzIGZvciBkZXRhaWxzXHJcbiovXHJcbihmdW5jdGlvbihrLG0pe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtcImxvbmdcIl0sbSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgcmVxdWlyZSYmXCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGUmJm1vZHVsZSYmbW9kdWxlLmV4cG9ydHMpe3ZhciByPW1vZHVsZSxzO3RyeXtzPXJlcXVpcmUoXCJsb25nXCIpfWNhdGNoKHUpe31zPW0ocyk7ci5leHBvcnRzPXN9ZWxzZShrLmRjb2RlSU89ay5kY29kZUlPfHx7fSkuQnl0ZUJ1ZmZlcj1tKGsuZGNvZGVJTy5Mb25nKX0pKHRoaXMsZnVuY3Rpb24oayl7ZnVuY3Rpb24gbShhKXt2YXIgYj0wO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBiPGEubGVuZ3RoP2EuY2hhckNvZGVBdChiKyspOm51bGx9fWZ1bmN0aW9uIHIoKXt2YXIgYT1bXSxiPVtdO3JldHVybiBmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBiLmpvaW4oXCJcIikrdy5hcHBseShTdHJpbmcsYSk7MTAyNDxhLmxlbmd0aCtcclxuYXJndW1lbnRzLmxlbmd0aCYmKGIucHVzaCh3LmFwcGx5KFN0cmluZyxhKSksYS5sZW5ndGg9MCk7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYSxhcmd1bWVudHMpfX1mdW5jdGlvbiBzKGEsYixjLGQsZil7dmFyIGw7bD04KmYtZC0xO3ZhciBnPSgxPDxsKS0xLGU9Zz4+MSxoPS03O2Y9Yz9mLTE6MDt2YXIgaz1jPy0xOjEscD1hW2IrZl07Zis9aztjPXAmKDE8PC1oKS0xO3A+Pj0taDtmb3IoaCs9bDswPGg7Yz0yNTYqYythW2IrZl0sZis9ayxoLT04KTtsPWMmKDE8PC1oKS0xO2M+Pj0taDtmb3IoaCs9ZDswPGg7bD0yNTYqbCthW2IrZl0sZis9ayxoLT04KTtpZigwPT09YyljPTEtZTtlbHNle2lmKGM9PT1nKXJldHVybiBsP05hTjpJbmZpbml0eSoocD8tMToxKTtsKz1NYXRoLnBvdygyLGQpO2MtPWV9cmV0dXJuKHA/LTE6MSkqbCpNYXRoLnBvdygyLGMtZCl9ZnVuY3Rpb24gdShhLGIsYyxkLGYsbCl7dmFyIGcsZT04KmwtZi0xLGg9KDE8PGUpLTEsaz1oPj4xLHA9MjM9PT1mP1xyXG5NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7bD1kPzA6bC0xO3ZhciBtPWQ/MTotMSxuPTA+Ynx8MD09PWImJjA+MS9iPzE6MDtiPU1hdGguYWJzKGIpO2lzTmFOKGIpfHxJbmZpbml0eT09PWI/KGI9aXNOYU4oYik/MTowLGQ9aCk6KGQ9TWF0aC5mbG9vcihNYXRoLmxvZyhiKS9NYXRoLkxOMiksMT5iKihnPU1hdGgucG93KDIsLWQpKSYmKGQtLSxnKj0yKSxiPTE8PWQraz9iK3AvZzpiK3AqTWF0aC5wb3coMiwxLWspLDI8PWIqZyYmKGQrKyxnLz0yKSxkK2s+PWg/KGI9MCxkPWgpOjE8PWQraz8oYj0oYipnLTEpKk1hdGgucG93KDIsZiksZCs9ayk6KGI9YipNYXRoLnBvdygyLGstMSkqTWF0aC5wb3coMixmKSxkPTApKTtmb3IoOzg8PWY7YVtjK2xdPWImMjU1LGwrPW0sYi89MjU2LGYtPTgpO2Q9ZDw8ZnxiO2ZvcihlKz1mOzA8ZTthW2MrbF09ZCYyNTUsbCs9bSxkLz0yNTYsZS09OCk7YVtjK2wtbV18PTEyOCpufXZhciBoPWZ1bmN0aW9uKGEsYixjKXtcInVuZGVmaW5lZFwiPT09XHJcbnR5cGVvZiBhJiYoYT1oLkRFRkFVTFRfQ0FQQUNJVFkpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9aC5ERUZBVUxUX0VORElBTik7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz1oLkRFRkFVTFRfTk9BU1NFUlQpO2lmKCFjKXthfD0wO2lmKDA+YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eVwiKTtiPSEhYjtjPSEhY310aGlzLmJ1ZmZlcj0wPT09YT92Om5ldyBBcnJheUJ1ZmZlcihhKTt0aGlzLnZpZXc9MD09PWE/bnVsbDpuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7dGhpcy5vZmZzZXQ9MDt0aGlzLm1hcmtlZE9mZnNldD0tMTt0aGlzLmxpbWl0PWE7dGhpcy5saXR0bGVFbmRpYW49Yjt0aGlzLm5vQXNzZXJ0PWN9O2guVkVSU0lPTj1cIjUuMC4xXCI7aC5MSVRUTEVfRU5ESUFOPSEwO2guQklHX0VORElBTj0hMTtoLkRFRkFVTFRfQ0FQQUNJVFk9MTY7aC5ERUZBVUxUX0VORElBTj1oLkJJR19FTkRJQU47aC5ERUZBVUxUX05PQVNTRVJUPSExO2guTG9uZz1rfHxcclxubnVsbDt2YXIgZT1oLnByb3RvdHlwZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9faXNCeXRlQnVmZmVyX19cIix7dmFsdWU6ITAsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITF9KTt2YXIgdj1uZXcgQXJyYXlCdWZmZXIoMCksdz1TdHJpbmcuZnJvbUNoYXJDb2RlO2guYWNjZXNzb3I9ZnVuY3Rpb24oKXtyZXR1cm4gVWludDhBcnJheX07aC5hbGxvY2F0ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBoKGEsYixjKX07aC5jb25jYXQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJzdHJpbmdcIiE9PXR5cGVvZiBiKWQ9YyxjPWIsYj12b2lkIDA7Zm9yKHZhciBmPTAsbD0wLGc9YS5sZW5ndGgsZTtsPGc7KytsKWguaXNCeXRlQnVmZmVyKGFbbF0pfHwoYVtsXT1oLndyYXAoYVtsXSxiKSksZT1hW2xdLmxpbWl0LWFbbF0ub2Zmc2V0LDA8ZSYmKGYrPWUpO2lmKDA9PT1mKXJldHVybiBuZXcgaCgwLGMsZCk7Yj1uZXcgaChmLGMsZCk7Zm9yKGw9XHJcbjA7bDxnOyljPWFbbCsrXSxlPWMubGltaXQtYy5vZmZzZXQsMD49ZXx8KGIudmlldy5zZXQoYy52aWV3LnN1YmFycmF5KGMub2Zmc2V0LGMubGltaXQpLGIub2Zmc2V0KSxiLm9mZnNldCs9ZSk7Yi5saW1pdD1iLm9mZnNldDtiLm9mZnNldD0wO3JldHVybiBifTtoLmlzQnl0ZUJ1ZmZlcj1mdW5jdGlvbihhKXtyZXR1cm4hMD09PShhJiZhLl9faXNCeXRlQnVmZmVyX18pfTtoLnR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXlCdWZmZXJ9O2gud3JhcD1mdW5jdGlvbihhLGIsYyxkKXtcInN0cmluZ1wiIT09dHlwZW9mIGImJihkPWMsYz1iLGI9dm9pZCAwKTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpc3dpdGNoKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9XCJ1dGY4XCIpLGIpe2Nhc2UgXCJiYXNlNjRcIjpyZXR1cm4gaC5mcm9tQmFzZTY0KGEsYyk7Y2FzZSBcImhleFwiOnJldHVybiBoLmZyb21IZXgoYSxjKTtjYXNlIFwiYmluYXJ5XCI6cmV0dXJuIGguZnJvbUJpbmFyeShhLGMpO2Nhc2UgXCJ1dGY4XCI6cmV0dXJuIGguZnJvbVVURjgoYSxcclxuYyk7Y2FzZSBcImRlYnVnXCI6cmV0dXJuIGguZnJvbURlYnVnKGEsYyk7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitiKTt9aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtpZihoLmlzQnl0ZUJ1ZmZlcihhKSlyZXR1cm4gYj1lLmNsb25lLmNhbGwoYSksYi5tYXJrZWRPZmZzZXQ9LTEsYjtpZihhIGluc3RhbmNlb2YgVWludDhBcnJheSliPW5ldyBoKDAsYyxkKSwwPGEubGVuZ3RoJiYoYi5idWZmZXI9YS5idWZmZXIsYi5vZmZzZXQ9YS5ieXRlT2Zmc2V0LGIubGltaXQ9YS5ieXRlT2Zmc2V0K2EuYnl0ZUxlbmd0aCxiLnZpZXc9bmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIpKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciliPW5ldyBoKDAsYyxkKSwwPGEuYnl0ZUxlbmd0aCYmKGIuYnVmZmVyPWEsYi5vZmZzZXQ9MCxiLmxpbWl0PWEuYnl0ZUxlbmd0aCxiLnZpZXc9MDxcclxuYS5ieXRlTGVuZ3RoP25ldyBVaW50OEFycmF5KGEpOm51bGwpO2Vsc2UgaWYoXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpKWZvcihiPW5ldyBoKGEubGVuZ3RoLGMsZCksYi5saW1pdD1hLmxlbmd0aCxjPTA7YzxhLmxlbmd0aDsrK2MpYi52aWV3W2NdPWFbY107ZWxzZSB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtyZXR1cm4gYn07ZS53cml0ZUJpdFNldD1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKCEoYSBpbnN0YW5jZW9mIEFycmF5KSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIEJpdFNldDogTm90IGFuIGFycmF5XCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD5cclxudGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZD1iLGY9YS5sZW5ndGgsZT1mPj4zLGc9MCxoO2ZvcihiKz10aGlzLndyaXRlVmFyaW50MzIoZixiKTtlLS07KWg9ISFhW2crK10mMXwoISFhW2crK10mMSk8PDF8KCEhYVtnKytdJjEpPDwyfCghIWFbZysrXSYxKTw8M3woISFhW2crK10mMSk8PDR8KCEhYVtnKytdJjEpPDw1fCghIWFbZysrXSYxKTw8NnwoISFhW2crK10mMSk8PDcsdGhpcy53cml0ZUJ5dGUoaCxiKyspO2lmKGc8Zil7Zm9yKGg9ZT0wO2c8ZjspaHw9KCEhYVtnKytdJjEpPDxlKys7dGhpcy53cml0ZUJ5dGUoaCxiKyspfXJldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZH07ZS5yZWFkQml0U2V0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7dmFyIGM9dGhpcy5yZWFkVmFyaW50MzIoYSksXHJcbmQ9Yy52YWx1ZSxmPWQ+PjMsZT0wLGc9W107Zm9yKGErPWMubGVuZ3RoO2YtLTspYz10aGlzLnJlYWRCeXRlKGErKyksZ1tlKytdPSEhKGMmMSksZ1tlKytdPSEhKGMmMiksZ1tlKytdPSEhKGMmNCksZ1tlKytdPSEhKGMmOCksZ1tlKytdPSEhKGMmMTYpLGdbZSsrXT0hIShjJjMyKSxnW2UrK109ISEoYyY2NCksZ1tlKytdPSEhKGMmMTI4KTtpZihlPGQpZm9yKGY9MCxjPXRoaXMucmVhZEJ5dGUoYSsrKTtlPGQ7KWdbZSsrXT0hIShjPj5mKysmMSk7YiYmKHRoaXMub2Zmc2V0PWEpO3JldHVybiBnfTtlLnJlYWRCeXRlcz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrYT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitcclxuYitcIiAoK1wiK2ErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZD10aGlzLnNsaWNlKGIsYithKTtjJiYodGhpcy5vZmZzZXQrPWEpO3JldHVybiBkfTtlLndyaXRlQnl0ZXM9ZS5hcHBlbmQ7ZS53cml0ZUludDg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxufWIrPTE7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7dGhpcy52aWV3W2ItMV09YTtjJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiB0aGlzfTtlLndyaXRlQnl0ZT1lLndyaXRlSW50ODtlLnJlYWRJbnQ4PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3W2FdOzEyOD09PShhJjEyOCkmJihhPS0oMjU1LWErMSkpO2ImJih0aGlzLm9mZnNldCs9XHJcbjEpO3JldHVybiBhfTtlLnJlYWRCeXRlPWUucmVhZEludDg7ZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9MTt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtcclxudGhpcy52aWV3W2ItMV09YTtjJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiB0aGlzfTtlLndyaXRlVUludDg9ZS53cml0ZVVpbnQ4O2UucmVhZFVpbnQ4PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3W2FdO2ImJih0aGlzLm9mZnNldCs9MSk7cmV0dXJuIGF9O2UucmVhZFVJbnQ4PWUucmVhZFVpbnQ4O2Uud3JpdGVJbnQxNj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtcclxuYyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9Mjt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtiLT0yO3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXdbYisxXT0oYSY2NTI4MCk+Pj44LHRoaXMudmlld1tiXT1hJjI1NSk6KHRoaXMudmlld1tiXT0oYSY2NTI4MCk+Pj5cclxuOCx0aGlzLnZpZXdbYisxXT1hJjI1NSk7YyYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gdGhpc307ZS53cml0ZVNob3J0PWUud3JpdGVJbnQxNjtlLnJlYWRJbnQxNj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wO3RoaXMubGl0dGxlRW5kaWFuPyhjPXRoaXMudmlld1thXSxjfD10aGlzLnZpZXdbYSsxXTw8OCk6KGM9dGhpcy52aWV3W2FdPDw4LGN8PXRoaXMudmlld1thKzFdKTszMjc2OD09PShjJjMyNzY4KSYmXHJcbihjPS0oNjU1MzUtYysxKSk7YiYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gY307ZS5yZWFkU2hvcnQ9ZS5yZWFkSW50MTY7ZS53cml0ZVVpbnQxNj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTI7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuYj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO2ItPTI7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiKzFdPShhJjY1MjgwKT4+PjgsdGhpcy52aWV3W2JdPWEmMjU1KToodGhpcy52aWV3W2JdPShhJjY1MjgwKT4+PjgsdGhpcy52aWV3W2IrMV09YSYyNTUpO2MmJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIHRoaXN9O2Uud3JpdGVVSW50MTY9ZS53cml0ZVVpbnQxNjtlLnJlYWRVaW50MTY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsyPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsyKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxufXZhciBjPTA7dGhpcy5saXR0bGVFbmRpYW4/KGM9dGhpcy52aWV3W2FdLGN8PXRoaXMudmlld1thKzFdPDw4KTooYz10aGlzLnZpZXdbYV08PDgsY3w9dGhpcy52aWV3W2ErMV0pO2ImJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIGN9O2UucmVhZFVJbnQxNj1lLnJlYWRVaW50MTY7ZS53cml0ZUludDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitcclxuYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz00O3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO2ItPTQ7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiKzNdPWE+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09YT4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1hPj4+OCYyNTUsdGhpcy52aWV3W2JdPWEmMjU1KToodGhpcy52aWV3W2JdPWE+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09YT4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1hPj4+OCYyNTUsdGhpcy52aWV3W2IrM109YSYyNTUpO2MmJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIHRoaXN9O2Uud3JpdGVJbnQ9ZS53cml0ZUludDMyO2UucmVhZEludDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElXHJcbjEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wO3RoaXMubGl0dGxlRW5kaWFuPyhjPXRoaXMudmlld1thKzJdPDwxNixjfD10aGlzLnZpZXdbYSsxXTw8OCxjfD10aGlzLnZpZXdbYV0sYys9dGhpcy52aWV3W2ErM108PDI0Pj4+MCk6KGM9dGhpcy52aWV3W2ErMV08PDE2LGN8PXRoaXMudmlld1thKzJdPDw4LGN8PXRoaXMudmlld1thKzNdLGMrPXRoaXMudmlld1thXTw8MjQ+Pj4wKTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBjfDB9O2UucmVhZEludD1lLnJlYWRJbnQzMjtlLndyaXRlVWludDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtcclxuaWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTQ7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7Yi09NDt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3W2IrM109YT4+PjI0JjI1NSx0aGlzLnZpZXdbYisyXT1hPj4+MTYmMjU1LHRoaXMudmlld1tiKzFdPWE+Pj44JjI1NSx0aGlzLnZpZXdbYl09XHJcbmEmMjU1KToodGhpcy52aWV3W2JdPWE+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09YT4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1hPj4+OCYyNTUsdGhpcy52aWV3W2IrM109YSYyNTUpO2MmJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIHRoaXN9O2Uud3JpdGVVSW50MzI9ZS53cml0ZVVpbnQzMjtlLnJlYWRVaW50MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MDt0aGlzLmxpdHRsZUVuZGlhbj8oYz10aGlzLnZpZXdbYStcclxuMl08PDE2LGN8PXRoaXMudmlld1thKzFdPDw4LGN8PXRoaXMudmlld1thXSxjKz10aGlzLnZpZXdbYSszXTw8MjQ+Pj4wKTooYz10aGlzLnZpZXdbYSsxXTw8MTYsY3w9dGhpcy52aWV3W2ErMl08PDgsY3w9dGhpcy52aWV3W2ErM10sYys9dGhpcy52aWV3W2FdPDwyND4+PjApO2ImJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIGN9O2UucmVhZFVJbnQzMj1lLnJlYWRVaW50MzI7ayYmKGUud3JpdGVJbnQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWsuZnJvbU51bWJlcihhKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlhPWsuZnJvbVN0cmluZyhhKTtlbHNlIGlmKCEoYSYmYSBpbnN0YW5jZW9mIGspKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO2lmKFwibnVtYmVyXCIhPT1cclxudHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31cIm51bWJlclwiPT09dHlwZW9mIGE/YT1rLmZyb21OdW1iZXIoYSk6XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1rLmZyb21TdHJpbmcoYSkpO2IrPTg7dmFyIGQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmQmJnRoaXMucmVzaXplKChkKj0yKT5iP2Q6Yik7Yi09ODt2YXIgZD1hLmxvdyxmPWEuaGlnaDt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3W2IrM109ZD4+PjI0JjI1NSx0aGlzLnZpZXdbYisyXT1kPj4+MTYmMjU1LHRoaXMudmlld1tiKzFdPWQ+Pj44JjI1NSx0aGlzLnZpZXdbYl09ZCYyNTUsYis9NCx0aGlzLnZpZXdbYiszXT1cclxuZj4+PjI0JjI1NSx0aGlzLnZpZXdbYisyXT1mPj4+MTYmMjU1LHRoaXMudmlld1tiKzFdPWY+Pj44JjI1NSx0aGlzLnZpZXdbYl09ZiYyNTUpOih0aGlzLnZpZXdbYl09Zj4+PjI0JjI1NSx0aGlzLnZpZXdbYisxXT1mPj4+MTYmMjU1LHRoaXMudmlld1tiKzJdPWY+Pj44JjI1NSx0aGlzLnZpZXdbYiszXT1mJjI1NSxiKz00LHRoaXMudmlld1tiXT1kPj4+MjQmMjU1LHRoaXMudmlld1tiKzFdPWQ+Pj4xNiYyNTUsdGhpcy52aWV3W2IrMl09ZD4+PjgmMjU1LHRoaXMudmlld1tiKzNdPWQmMjU1KTtjJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiB0aGlzfSxlLndyaXRlTG9uZz1lLndyaXRlSW50NjQsZS5yZWFkSW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7XHJcbmE+Pj49MDtpZigwPmF8fGErOD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrOCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPTAsZD0wO3RoaXMubGl0dGxlRW5kaWFuPyhjPXRoaXMudmlld1thKzJdPDwxNixjfD10aGlzLnZpZXdbYSsxXTw8OCxjfD10aGlzLnZpZXdbYV0sYys9dGhpcy52aWV3W2ErM108PDI0Pj4+MCxhKz00LGQ9dGhpcy52aWV3W2ErMl08PDE2LGR8PXRoaXMudmlld1thKzFdPDw4LGR8PXRoaXMudmlld1thXSxkKz10aGlzLnZpZXdbYSszXTw8MjQ+Pj4wKTooZD10aGlzLnZpZXdbYSsxXTw8MTYsZHw9dGhpcy52aWV3W2ErMl08PDgsZHw9dGhpcy52aWV3W2ErM10sZCs9dGhpcy52aWV3W2FdPDwyND4+PjAsYSs9NCxjPXRoaXMudmlld1thKzFdPDwxNixjfD10aGlzLnZpZXdbYSsyXTw8OCxjfD10aGlzLnZpZXdbYSszXSxjKz10aGlzLnZpZXdbYV08PDI0Pj4+MCk7XHJcbmE9bmV3IGsoYyxkLCExKTtiJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiBhfSxlLnJlYWRMb25nPWUucmVhZEludDY0LGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpYT1rLmZyb21OdW1iZXIoYSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpYT1rLmZyb21TdHJpbmcoYSk7ZWxzZSBpZighKGEmJmEgaW5zdGFuY2VvZiBrKSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrXHJcbmIrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9ay5mcm9tTnVtYmVyKGEpOlwic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9ay5mcm9tU3RyaW5nKGEpKTtiKz04O3ZhciBkPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5kJiZ0aGlzLnJlc2l6ZSgoZCo9Mik+Yj9kOmIpO2ItPTg7dmFyIGQ9YS5sb3csZj1hLmhpZ2g7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlld1tiKzNdPWQ+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09ZD4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1kPj4+OCYyNTUsdGhpcy52aWV3W2JdPWQmMjU1LGIrPTQsdGhpcy52aWV3W2IrM109Zj4+PjI0JjI1NSx0aGlzLnZpZXdbYisyXT1mPj4+MTYmMjU1LHRoaXMudmlld1tiKzFdPWY+Pj44JjI1NSx0aGlzLnZpZXdbYl09ZiYyNTUpOih0aGlzLnZpZXdbYl09Zj4+PjI0JjI1NSx0aGlzLnZpZXdbYisxXT1mPj4+MTYmMjU1LHRoaXMudmlld1tiKzJdPWY+Pj44JjI1NSxcclxudGhpcy52aWV3W2IrM109ZiYyNTUsYis9NCx0aGlzLnZpZXdbYl09ZD4+PjI0JjI1NSx0aGlzLnZpZXdbYisxXT1kPj4+MTYmMjU1LHRoaXMudmlld1tiKzJdPWQ+Pj44JjI1NSx0aGlzLnZpZXdbYiszXT1kJjI1NSk7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc30sZS53cml0ZVVJbnQ2ND1lLndyaXRlVWludDY0LGUucmVhZFVpbnQ2ND1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wLGQ9MDt0aGlzLmxpdHRsZUVuZGlhbj9cclxuKGM9dGhpcy52aWV3W2ErMl08PDE2LGN8PXRoaXMudmlld1thKzFdPDw4LGN8PXRoaXMudmlld1thXSxjKz10aGlzLnZpZXdbYSszXTw8MjQ+Pj4wLGErPTQsZD10aGlzLnZpZXdbYSsyXTw8MTYsZHw9dGhpcy52aWV3W2ErMV08PDgsZHw9dGhpcy52aWV3W2FdLGQrPXRoaXMudmlld1thKzNdPDwyND4+PjApOihkPXRoaXMudmlld1thKzFdPDwxNixkfD10aGlzLnZpZXdbYSsyXTw8OCxkfD10aGlzLnZpZXdbYSszXSxkKz10aGlzLnZpZXdbYV08PDI0Pj4+MCxhKz00LGM9dGhpcy52aWV3W2ErMV08PDE2LGN8PXRoaXMudmlld1thKzJdPDw4LGN8PXRoaXMudmlld1thKzNdLGMrPXRoaXMudmlld1thXTw8MjQ+Pj4wKTthPW5ldyBrKGMsZCwhMCk7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX0sZS5yZWFkVUludDY0PWUucmVhZFVpbnQ2NCk7ZS53cml0ZUZsb2F0MzI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09XHJcbnR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhIG51bWJlcilcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9NDt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTt1KHRoaXMudmlldyxhLGItNCx0aGlzLmxpdHRsZUVuZGlhbiwyMyw0KTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtlLndyaXRlRmxvYXQ9ZS53cml0ZUZsb2F0MzI7ZS5yZWFkRmxvYXQzMj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmXHJcbihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT1zKHRoaXMudmlldyxhLHRoaXMubGl0dGxlRW5kaWFuLDIzLDQpO2ImJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIGF9O2UucmVhZEZsb2F0PWUucmVhZEZsb2F0MzI7ZS53cml0ZUZsb2F0NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuaWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9ODt2YXIgZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTt1KHRoaXMudmlldyxhLGItOCx0aGlzLmxpdHRsZUVuZGlhbiw1Miw4KTtjJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiB0aGlzfTtlLndyaXRlRG91YmxlPWUud3JpdGVGbG9hdDY0O2UucmVhZEZsb2F0NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09XHJcbmElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErOD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrOCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9cyh0aGlzLnZpZXcsYSx0aGlzLmxpdHRsZUVuZGlhbiw1Miw4KTtiJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiBhfTtlLnJlYWREb3VibGU9ZS5yZWFkRmxvYXQ2NDtoLk1BWF9WQVJJTlQzMl9CWVRFUz01O2guY2FsY3VsYXRlVmFyaW50MzI9ZnVuY3Rpb24oYSl7YT4+Pj0wO3JldHVybiAxMjg+YT8xOjE2Mzg0PmE/MjoyMDk3MTUyPmE/MzoyNjg0MzU0NTY+YT80OjV9O2guemlnWmFnRW5jb2RlMzI9ZnVuY3Rpb24oYSl7cmV0dXJuKChhfD0wKTw8MV5hPj4zMSk+Pj4wfTtoLnppZ1phZ0RlY29kZTMyPWZ1bmN0aW9uKGEpe3JldHVybiBhPj4+MV4tKGEmXHJcbjEpfDB9O2Uud3JpdGVWYXJpbnQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZD1oLmNhbGN1bGF0ZVZhcmludDMyKGEpLGY7Yis9ZDtmPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5mJiZ0aGlzLnJlc2l6ZSgoZio9Mik+Yj9mOmIpO1xyXG5iLT1kO2ZvcihhPj4+PTA7MTI4PD1hOylmPWEmMTI3fDEyOCx0aGlzLnZpZXdbYisrXT1mLGE+Pj49Nzt0aGlzLnZpZXdbYisrXT1hO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmR9O2Uud3JpdGVWYXJpbnQzMlppZ1phZz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLndyaXRlVmFyaW50MzIoaC56aWdaYWdFbmNvZGUzMihhKSxiKX07ZS5yZWFkVmFyaW50MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxufXZhciBjPTAsZD0wLGY7ZG97aWYoIXRoaXMubm9Bc3NlcnQmJmE+dGhpcy5saW1pdCl0aHJvdyBhPUVycm9yKFwiVHJ1bmNhdGVkXCIpLGEudHJ1bmNhdGVkPSEwLGE7Zj10aGlzLnZpZXdbYSsrXTs1PmMmJihkfD0oZiYxMjcpPDw3KmMpOysrY313aGlsZSgwIT09KGYmMTI4KSk7ZHw9MDtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxkKTp7dmFsdWU6ZCxsZW5ndGg6Y319O2UucmVhZFZhcmludDMyWmlnWmFnPWZ1bmN0aW9uKGEpe2E9dGhpcy5yZWFkVmFyaW50MzIoYSk7XCJvYmplY3RcIj09PXR5cGVvZiBhP2EudmFsdWU9aC56aWdaYWdEZWNvZGUzMihhLnZhbHVlKTphPWguemlnWmFnRGVjb2RlMzIoYSk7cmV0dXJuIGF9O2smJihoLk1BWF9WQVJJTlQ2NF9CWVRFUz0xMCxoLmNhbGN1bGF0ZVZhcmludDY0PWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9hPWsuZnJvbU51bWJlcihhKTpcInN0cmluZ1wiPT09dHlwZW9mIGEmJihhPWsuZnJvbVN0cmluZyhhKSk7dmFyIGI9YS50b0ludCgpPj4+XHJcbjAsYz1hLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKT4+PjA7YT1hLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKT4+PjA7cmV0dXJuIDA9PWE/MD09Yz8xNjM4ND5iPzEyOD5iPzE6MjoyMDk3MTUyPmI/Mzo0OjE2Mzg0PmM/MTI4PmM/NTo2OjIwOTcxNTI+Yz83Ojg6MTI4PmE/OToxMH0saC56aWdaYWdFbmNvZGU2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGE/YT1rLmZyb21OdW1iZXIoYSwhMSk6XCJzdHJpbmdcIj09PXR5cGVvZiBhP2E9ay5mcm9tU3RyaW5nKGEsITEpOiExIT09YS51bnNpZ25lZCYmKGE9YS50b1NpZ25lZCgpKTtyZXR1cm4gYS5zaGlmdExlZnQoMSkueG9yKGEuc2hpZnRSaWdodCg2MykpLnRvVW5zaWduZWQoKX0saC56aWdaYWdEZWNvZGU2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGE/YT1rLmZyb21OdW1iZXIoYSwhMSk6XCJzdHJpbmdcIj09PXR5cGVvZiBhP2E9ay5mcm9tU3RyaW5nKGEsITEpOiExIT09YS51bnNpZ25lZCYmXHJcbihhPWEudG9TaWduZWQoKSk7cmV0dXJuIGEuc2hpZnRSaWdodFVuc2lnbmVkKDEpLnhvcihhLmFuZChrLk9ORSkudG9TaWduZWQoKS5uZWdhdGUoKSkudG9TaWduZWQoKX0sZS53cml0ZVZhcmludDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKWE9ay5mcm9tTnVtYmVyKGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWE9ay5mcm9tU3RyaW5nKGEpO2Vsc2UgaWYoIShhJiZhIGluc3RhbmNlb2YgaykpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK1xyXG5iK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fVwibnVtYmVyXCI9PT10eXBlb2YgYT9hPWsuZnJvbU51bWJlcihhLCExKTpcInN0cmluZ1wiPT09dHlwZW9mIGE/YT1rLmZyb21TdHJpbmcoYSwhMSk6ITEhPT1hLnVuc2lnbmVkJiYoYT1hLnRvU2lnbmVkKCkpO3ZhciBkPWguY2FsY3VsYXRlVmFyaW50NjQoYSksZj1hLnRvSW50KCk+Pj4wLGU9YS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCk+Pj4wLGc9YS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCk+Pj4wO2IrPWQ7dmFyIHQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPnQmJnRoaXMucmVzaXplKCh0Kj0yKT5iP3Q6Yik7Yi09ZDtzd2l0Y2goZCl7Y2FzZSAxMDp0aGlzLnZpZXdbYis5XT1nPj4+NyYxO2Nhc2UgOTp0aGlzLnZpZXdbYis4XT05IT09ZD9nfDEyODpnJjEyNztjYXNlIDg6dGhpcy52aWV3W2IrN109OCE9PWQ/ZT4+PjIxfDEyODplPj4+MjEmMTI3O2Nhc2UgNzp0aGlzLnZpZXdbYis2XT1cclxuNyE9PWQ/ZT4+PjE0fDEyODplPj4+MTQmMTI3O2Nhc2UgNjp0aGlzLnZpZXdbYis1XT02IT09ZD9lPj4+N3wxMjg6ZT4+PjcmMTI3O2Nhc2UgNTp0aGlzLnZpZXdbYis0XT01IT09ZD9lfDEyODplJjEyNztjYXNlIDQ6dGhpcy52aWV3W2IrM109NCE9PWQ/Zj4+PjIxfDEyODpmPj4+MjEmMTI3O2Nhc2UgMzp0aGlzLnZpZXdbYisyXT0zIT09ZD9mPj4+MTR8MTI4OmY+Pj4xNCYxMjc7Y2FzZSAyOnRoaXMudmlld1tiKzFdPTIhPT1kP2Y+Pj43fDEyODpmPj4+NyYxMjc7Y2FzZSAxOnRoaXMudmlld1tiXT0xIT09ZD9mfDEyODpmJjEyN31yZXR1cm4gYz8odGhpcy5vZmZzZXQrPWQsdGhpcyk6ZH0sZS53cml0ZVZhcmludDY0WmlnWmFnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMud3JpdGVWYXJpbnQ2NChoLnppZ1phZ0VuY29kZTY0KGEpLGIpfSxlLnJlYWRWYXJpbnQ2ND1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09XHJcbnR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9YSxkPTAsZj0wLGU9MCxnPTAsZz10aGlzLnZpZXdbYSsrXSxkPWcmMTI3O2lmKGcmMTI4JiYoZz10aGlzLnZpZXdbYSsrXSxkfD0oZyYxMjcpPDw3LGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxkfD0oZyYxMjcpPDwxNCxnJjEyOHx8dGhpcy5ub0Fzc2VydCYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBnKSYmKGc9dGhpcy52aWV3W2ErK10sZHw9KGcmMTI3KTw8MjEsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykmJihnPXRoaXMudmlld1thKytdLFxyXG5mPWcmMTI3LGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxmfD0oZyYxMjcpPDw3LGcmMTI4fHx0aGlzLm5vQXNzZXJ0JiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcpJiYoZz10aGlzLnZpZXdbYSsrXSxmfD0oZyYxMjcpPDwxNCxnJjEyOHx8dGhpcy5ub0Fzc2VydCYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBnKSYmKGc9dGhpcy52aWV3W2ErK10sZnw9KGcmMTI3KTw8MjEsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykmJihnPXRoaXMudmlld1thKytdLGU9ZyYxMjcsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykmJihnPXRoaXMudmlld1thKytdLGV8PShnJjEyNyk8PDcsZyYxMjh8fHRoaXMubm9Bc3NlcnQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgZykpdGhyb3cgRXJyb3IoXCJCdWZmZXIgb3ZlcnJ1blwiKTtkPWsuZnJvbUJpdHMoZHxmPDwyOCxmPj4+NHxcclxuZTw8MjQsITEpO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGQpOnt2YWx1ZTpkLGxlbmd0aDphLWN9fSxlLnJlYWRWYXJpbnQ2NFppZ1phZz1mdW5jdGlvbihhKXsoYT10aGlzLnJlYWRWYXJpbnQ2NChhKSkmJmEudmFsdWUgaW5zdGFuY2VvZiBrP2EudmFsdWU9aC56aWdaYWdEZWNvZGU2NChhLnZhbHVlKTphPWguemlnWmFnRGVjb2RlNjQoYSk7cmV0dXJuIGF9KTtlLndyaXRlQ1N0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7dmFyIGQsZj1hLmxlbmd0aDtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7Zm9yKGQ9MDtkPGY7KytkKWlmKDA9PT1hLmNoYXJDb2RlQXQoZCkpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBOVUxMLWNoYXJhY3RlcnNcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHxcclxuMCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWY9bi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpKVsxXTtiKz1mKzE7ZD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZCYmdGhpcy5yZXNpemUoKGQqPTIpPmI/ZDpiKTtiLT1mKzE7bi5lbmNvZGVVVEYxNnRvVVRGOChtKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlld1tiKytdPWF9LmJpbmQodGhpcykpO3RoaXMudmlld1tiKytdPTA7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Zn07ZS5yZWFkQ1N0cmluZz1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09XHJcbnR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9YSxkLGY9LTE7bi5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpe2lmKDA9PT1mKXJldHVybiBudWxsO2lmKGE+PXRoaXMubGltaXQpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIithK1wiIDwgXCIrdGhpcy5saW1pdCk7Zj10aGlzLnZpZXdbYSsrXTtyZXR1cm4gMD09PWY/bnVsbDpmfS5iaW5kKHRoaXMpLGQ9cigpLCEwKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxkKCkpOntzdHJpbmc6ZCgpLGxlbmd0aDphLWN9fTtlLndyaXRlSVN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVxyXG5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZD1iLGY7Zj1uLmNhbGN1bGF0ZVVURjE2YXNVVEY4KG0oYSksdGhpcy5ub0Fzc2VydClbMV07Yis9NCtmO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO2ItPTQrZjt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3W2IrXHJcbjNdPWY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMl09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisxXT1mPj4+OCYyNTUsdGhpcy52aWV3W2JdPWYmMjU1KToodGhpcy52aWV3W2JdPWY+Pj4yNCYyNTUsdGhpcy52aWV3W2IrMV09Zj4+PjE2JjI1NSx0aGlzLnZpZXdbYisyXT1mPj4+OCYyNTUsdGhpcy52aWV3W2IrM109ZiYyNTUpO2IrPTQ7bi5lbmNvZGVVVEYxNnRvVVRGOChtKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlld1tiKytdPWF9LmJpbmQodGhpcykpO2lmKGIhPT1kKzQrZil0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2IrXCIgPT0gXCIrKGIrNCtmKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1kfTtlLnJlYWRJU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXHJcbmErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz1hLGQ9dGhpcy5yZWFkVWludDMyKGEpLGQ9dGhpcy5yZWFkVVRGOFN0cmluZyhkLGguTUVUUklDU19CWVRFUyxhKz00KTthKz1kLmxlbmd0aDtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxkLnN0cmluZyk6e3N0cmluZzpkLnN0cmluZyxsZW5ndGg6YS1jfX07aC5NRVRSSUNTX0NIQVJTPVwiY1wiO2guTUVUUklDU19CWVRFUz1cImJcIjtlLndyaXRlVVRGOFN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXHJcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZCxmPWI7ZD1uLmNhbGN1bGF0ZVVURjE2YXNVVEY4KG0oYSkpWzFdO2IrPWQ7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7Yi09ZDtuLmVuY29kZVVURjE2dG9VVEY4KG0oYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3W2IrK109YX0uYmluZCh0aGlzKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1mfTtlLndyaXRlU3RyaW5nPWUud3JpdGVVVEY4U3RyaW5nO2guY2FsY3VsYXRlVVRGOENoYXJzPWZ1bmN0aW9uKGEpe3JldHVybiBuLmNhbGN1bGF0ZVVURjE2YXNVVEY4KG0oYSkpWzBdfTtoLmNhbGN1bGF0ZVVURjhCeXRlcz1mdW5jdGlvbihhKXtyZXR1cm4gbi5jYWxjdWxhdGVVVEYxNmFzVVRGOChtKGEpKVsxXX07XHJcbmguY2FsY3VsYXRlU3RyaW5nPWguY2FsY3VsYXRlVVRGOEJ5dGVzO2UucmVhZFVURjhTdHJpbmc9ZnVuY3Rpb24oYSxiLGMpe1wibnVtYmVyXCI9PT10eXBlb2YgYiYmKGM9YixiPXZvaWQgMCk7dmFyIGQ9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2QmJihjPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPWguTUVUUklDU19DSEFSUyk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIitcclxudGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBmPTAsZT1jLGc7aWYoYj09PWguTUVUUklDU19DSEFSUyl7Zz1yKCk7bi5kZWNvZGVVVEY4KGZ1bmN0aW9uKCl7cmV0dXJuIGY8YSYmYzx0aGlzLmxpbWl0P3RoaXMudmlld1tjKytdOm51bGx9LmJpbmQodGhpcyksZnVuY3Rpb24oYSl7KytmO24uVVRGOHRvVVRGMTYoYSxnKX0pO2lmKGYhPT1hKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrZitcIiA9PSBcIithKTtyZXR1cm4gZD8odGhpcy5vZmZzZXQ9YyxnKCkpOntzdHJpbmc6ZygpLGxlbmd0aDpjLWV9fWlmKGI9PT1oLk1FVFJJQ1NfQllURVMpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjK2E+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrXHJcbmMrXCIgKCtcIithK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGs9YythO24uZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKXtyZXR1cm4gYzxrP3RoaXMudmlld1tjKytdOm51bGx9LmJpbmQodGhpcyksZz1yKCksdGhpcy5ub0Fzc2VydCk7aWYoYyE9PWspdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitjK1wiID09IFwiK2spO3JldHVybiBkPyh0aGlzLm9mZnNldD1jLGcoKSk6e3N0cmluZzpnKCksbGVuZ3RoOmMtZX19dGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0cmljczogXCIrYik7fTtlLnJlYWRTdHJpbmc9ZS5yZWFkVVRGOFN0cmluZztlLndyaXRlVlN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG5pZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZD1iLGYsZTtmPW4uY2FsY3VsYXRlVVRGMTZhc1VURjgobShhKSx0aGlzLm5vQXNzZXJ0KVsxXTtlPWguY2FsY3VsYXRlVmFyaW50MzIoZik7Yis9ZStmO3ZhciBnPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5nJiZ0aGlzLnJlc2l6ZSgoZyo9Mik+Yj9nOmIpO2ItPWUrZjtiKz10aGlzLndyaXRlVmFyaW50MzIoZixiKTtuLmVuY29kZVVURjE2dG9VVEY4KG0oYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3W2IrK109YX0uYmluZCh0aGlzKSk7aWYoYiE9PWQrZitlKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrXHJcbmIrXCIgPT0gXCIrKGIrZitlKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1kfTtlLnJlYWRWU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPWEsZD10aGlzLnJlYWRWYXJpbnQzMihhKSxkPXRoaXMucmVhZFVURjhTdHJpbmcoZC52YWx1ZSxoLk1FVFJJQ1NfQllURVMsYSs9ZC5sZW5ndGgpO2ErPWQubGVuZ3RoO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGQuc3RyaW5nKTp7c3RyaW5nOmQuc3RyaW5nLFxyXG5sZW5ndGg6YS1jfX07ZS5hcHBlbmQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYnx8XCJzdHJpbmdcIiE9PXR5cGVvZiBiKWM9YixiPXZvaWQgMDt2YXIgZD1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGM7ZCYmKGM9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYytcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hIGluc3RhbmNlb2YgaHx8KGE9aC53cmFwKGEsYikpO2I9YS5saW1pdC1hLm9mZnNldDtpZigwPj1iKXJldHVybiB0aGlzO2MrPWI7dmFyIGY9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtjPmYmJnRoaXMucmVzaXplKChmKj0yKT5cclxuYz9mOmMpO2MtPWI7dGhpcy52aWV3LnNldChhLnZpZXcuc3ViYXJyYXkoYS5vZmZzZXQsYS5saW1pdCksYyk7YS5vZmZzZXQrPWI7ZCYmKHRoaXMub2Zmc2V0Kz1iKTtyZXR1cm4gdGhpc307ZS5hcHBlbmRUbz1mdW5jdGlvbihhLGIpe2EuYXBwZW5kKHRoaXMsYik7cmV0dXJuIHRoaXN9O2UuYXNzZXJ0PWZ1bmN0aW9uKGEpe3RoaXMubm9Bc3NlcnQ9IWE7cmV0dXJuIHRoaXN9O2UuY2FwYWNpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aH07ZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMub2Zmc2V0PTA7dGhpcy5saW1pdD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO3RoaXMubWFya2VkT2Zmc2V0PS0xO3JldHVybiB0aGlzfTtlLmNsb25lPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBoKDAsdGhpcy5saXR0bGVFbmRpYW4sdGhpcy5ub0Fzc2VydCk7YT8oYi5idWZmZXI9bmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpLGIudmlldz1uZXcgVWludDhBcnJheShiLmJ1ZmZlcikpOlxyXG4oYi5idWZmZXI9dGhpcy5idWZmZXIsYi52aWV3PXRoaXMudmlldyk7Yi5vZmZzZXQ9dGhpcy5vZmZzZXQ7Yi5tYXJrZWRPZmZzZXQ9dGhpcy5tYXJrZWRPZmZzZXQ7Yi5saW1pdD10aGlzLmxpbWl0O3JldHVybiBifTtlLmNvbXBhY3Q9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitcclxuYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoMD09PWEmJmI9PT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXJldHVybiB0aGlzO3ZhciBjPWItYTtpZigwPT09YylyZXR1cm4gdGhpcy5idWZmZXI9dix0aGlzLnZpZXc9bnVsbCwwPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0LT1hKSx0aGlzLmxpbWl0PXRoaXMub2Zmc2V0PTAsdGhpczt2YXIgZD1uZXcgQXJyYXlCdWZmZXIoYyksZj1uZXcgVWludDhBcnJheShkKTtmLnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoYSxiKSk7dGhpcy5idWZmZXI9ZDt0aGlzLnZpZXc9ZjswPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0LT1hKTt0aGlzLm9mZnNldD0wO3RoaXMubGltaXQ9YztyZXR1cm4gdGhpc307ZS5jb3B5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxyXG50eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGE9PT1iKXJldHVybiBuZXcgaCgwLHRoaXMubGl0dGxlRW5kaWFuLHRoaXMubm9Bc3NlcnQpO3ZhciBjPWItYSxkPW5ldyBoKGMsdGhpcy5saXR0bGVFbmRpYW4sdGhpcy5ub0Fzc2VydCk7ZC5vZmZzZXQ9MDtkLmxpbWl0PWM7MDw9ZC5tYXJrZWRPZmZzZXQmJihkLm1hcmtlZE9mZnNldC09YSk7dGhpcy5jb3B5VG8oZCwwLGEsYik7cmV0dXJuIGR9O2UuY29weVRvPWZ1bmN0aW9uKGEsXHJcbmIsYyxkKXt2YXIgZixlO2lmKCF0aGlzLm5vQXNzZXJ0JiYhaC5pc0J5dGVCdWZmZXIoYSkpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQ6IE5vdCBhIEJ5dGVCdWZmZXJcIik7Yj0oZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGIpP2Eub2Zmc2V0OmJ8MDtjPShmPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYyk/dGhpcy5vZmZzZXQ6Y3wwO2Q9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBkP3RoaXMubGltaXQ6ZHwwO2lmKDA+Ynx8Yj5hLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldCByYW5nZTogMCA8PSBcIitiK1wiIDw9IFwiK2EuYnVmZmVyLmJ5dGVMZW5ndGgpO2lmKDA+Y3x8ZD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHNvdXJjZSByYW5nZTogMCA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO3ZhciBnPWQtYztpZigwPT09ZylyZXR1cm4gYTthLmVuc3VyZUNhcGFjaXR5KGIrZyk7XHJcbmEudmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KGMsZCksYik7ZiYmKHRoaXMub2Zmc2V0Kz1nKTtlJiYoYS5vZmZzZXQrPWcpO3JldHVybiB0aGlzfTtlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7cmV0dXJuIGI8YT90aGlzLnJlc2l6ZSgoYio9Mik+YT9iOmEpOnRoaXN9O2UuZmlsbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2QmJihiPXRoaXMub2Zmc2V0KTtcInN0cmluZ1wiPT09dHlwZW9mIGEmJjA8YS5sZW5ndGgmJihhPWEuY2hhckNvZGVBdCgwKSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD1cclxuMDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yz4+Pj0wO2lmKDA+Ynx8Yj5jfHxjPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYitcIiA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihiPj1jKXJldHVybiB0aGlzO2Zvcig7YjxjOyl0aGlzLnZpZXdbYisrXT1hO2QmJih0aGlzLm9mZnNldD1iKTtyZXR1cm4gdGhpc307ZS5mbGlwPWZ1bmN0aW9uKCl7dGhpcy5saW1pdD10aGlzLm9mZnNldDt0aGlzLm9mZnNldD0wO3JldHVybiB0aGlzfTtlLm1hcms9ZnVuY3Rpb24oYSl7YT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/dGhpcy5vZmZzZXQ6YTtcclxuaWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXRoaXMubWFya2VkT2Zmc2V0PWE7cmV0dXJuIHRoaXN9O2Uub3JkZXI9ZnVuY3Rpb24oYSl7aWYoIXRoaXMubm9Bc3NlcnQmJlwiYm9vbGVhblwiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsaXR0bGVFbmRpYW46IE5vdCBhIGJvb2xlYW5cIik7dGhpcy5saXR0bGVFbmRpYW49ISFhO3JldHVybiB0aGlzfTtlLkxFPWZ1bmN0aW9uKGEpe3RoaXMubGl0dGxlRW5kaWFuPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYT8hIWE6ITA7cmV0dXJuIHRoaXN9O2UuQkU9ZnVuY3Rpb24oYSl7dGhpcy5saXR0bGVFbmRpYW49XHJcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgYT8hYTohMTtyZXR1cm4gdGhpc307ZS5wcmVwZW5kPWZ1bmN0aW9uKGEsYixjKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYiljPWIsYj12b2lkIDA7dmFyIGQ9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2QmJihjPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YSBpbnN0YW5jZW9mIGh8fChhPWgud3JhcChhLGIpKTtiPWEubGltaXQtYS5vZmZzZXQ7aWYoMD49YilyZXR1cm4gdGhpczt2YXIgZj1iLWM7aWYoMDxmKXt2YXIgZT1uZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCtcclxuZiksZz1uZXcgVWludDhBcnJheShlKTtnLnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoYyx0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSxiKTt0aGlzLmJ1ZmZlcj1lO3RoaXMudmlldz1nO3RoaXMub2Zmc2V0Kz1mOzA8PXRoaXMubWFya2VkT2Zmc2V0JiYodGhpcy5tYXJrZWRPZmZzZXQrPWYpO3RoaXMubGltaXQrPWY7Yys9Zn1lbHNlIG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTt0aGlzLnZpZXcuc2V0KGEudmlldy5zdWJhcnJheShhLm9mZnNldCxhLmxpbWl0KSxjLWIpO2Eub2Zmc2V0PWEubGltaXQ7ZCYmKHRoaXMub2Zmc2V0LT1iKTtyZXR1cm4gdGhpc307ZS5wcmVwZW5kVG89ZnVuY3Rpb24oYSxiKXthLnByZXBlbmQodGhpcyxiKTtyZXR1cm4gdGhpc307ZS5wcmludERlYnVnPWZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiYoYT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTthKHRoaXMudG9TdHJpbmcoKStcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIitcclxudGhpcy50b0RlYnVnKCEwKSl9O2UucmVtYWluaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGltaXQtdGhpcy5vZmZzZXR9O2UucmVzZXQ9ZnVuY3Rpb24oKXswPD10aGlzLm1hcmtlZE9mZnNldD8odGhpcy5vZmZzZXQ9dGhpcy5tYXJrZWRPZmZzZXQsdGhpcy5tYXJrZWRPZmZzZXQ9LTEpOnRoaXMub2Zmc2V0PTA7cmV0dXJuIHRoaXN9O2UucmVzaXplPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoMD5hKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2EpO31pZih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoPGEpe2E9bmV3IEFycmF5QnVmZmVyKGEpO3ZhciBiPW5ldyBVaW50OEFycmF5KGEpO2Iuc2V0KHRoaXMudmlldyk7dGhpcy5idWZmZXI9YTt0aGlzLnZpZXc9Yn1yZXR1cm4gdGhpc307XHJcbmUucmV2ZXJzZT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGE9PT1iKXJldHVybiB0aGlzO0FycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcy52aWV3LnN1YmFycmF5KGEsYikpO3JldHVybiB0aGlzfTtcclxuZS5za2lwPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wfXZhciBiPXRoaXMub2Zmc2V0K2E7aWYoIXRoaXMubm9Bc3NlcnQmJigwPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiAwIDw9IFwiK3RoaXMub2Zmc2V0K1wiICsgXCIrYStcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt0aGlzLm9mZnNldD1iO3JldHVybiB0aGlzfTtlLnNsaWNlPWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xyXG5hPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPXRoaXMuY2xvbmUoKTtjLm9mZnNldD1hO2MubGltaXQ9YjtyZXR1cm4gY307ZS50b0J1ZmZlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm9mZnNldCxjPXRoaXMubGltaXQ7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpbWl0OiBOb3QgYW4gaW50ZWdlclwiKTtcclxuYz4+Pj0wO2lmKDA+Ynx8Yj5jfHxjPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYitcIiA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZighYSYmMD09PWImJmM9PT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXJldHVybiB0aGlzLmJ1ZmZlcjtpZihiPT09YylyZXR1cm4gdjthPW5ldyBBcnJheUJ1ZmZlcihjLWIpOyhuZXcgVWludDhBcnJheShhKSkuc2V0KChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGIsYyksMCk7cmV0dXJuIGF9O2UudG9BcnJheUJ1ZmZlcj1lLnRvQnVmZmVyO2UudG9TdHJpbmc9ZnVuY3Rpb24oYSxiLGMpe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm5cIkJ5dGVCdWZmZXJBQihvZmZzZXQ9XCIrdGhpcy5vZmZzZXQrXCIsbWFya2VkT2Zmc2V0PVwiK3RoaXMubWFya2VkT2Zmc2V0K1wiLGxpbWl0PVwiK3RoaXMubGltaXQrXCIsY2FwYWNpdHk9XCIrdGhpcy5jYXBhY2l0eSgpK1xyXG5cIilcIjtcIm51bWJlclwiPT09dHlwZW9mIGEmJihjPWI9YT1cInV0ZjhcIik7c3dpdGNoKGEpe2Nhc2UgXCJ1dGY4XCI6cmV0dXJuIHRoaXMudG9VVEY4KGIsYyk7Y2FzZSBcImJhc2U2NFwiOnJldHVybiB0aGlzLnRvQmFzZTY0KGIsYyk7Y2FzZSBcImhleFwiOnJldHVybiB0aGlzLnRvSGV4KGIsYyk7Y2FzZSBcImJpbmFyeVwiOnJldHVybiB0aGlzLnRvQmluYXJ5KGIsYyk7Y2FzZSBcImRlYnVnXCI6cmV0dXJuIHRoaXMudG9EZWJ1ZygpO2Nhc2UgXCJjb2x1bW5zXCI6cmV0dXJuIHRoaXMudG9Db2x1bW5zKCk7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIithKTt9fTt2YXIgeD1mdW5jdGlvbigpe2Zvcih2YXIgYT17fSxiPVs2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLFxyXG4xMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw0Myw0N10sYz1bXSxkPTAsZj1iLmxlbmd0aDtkPGY7KytkKWNbYltkXV09ZDthLmVuY29kZT1mdW5jdGlvbihhLGMpe2Zvcih2YXIgZCxmO251bGwhPT0oZD1hKCkpOyljKGJbZD4+MiY2M10pLGY9KGQmMyk8PDQsbnVsbCE9PShkPWEoKSk/KGZ8PWQ+PjQmMTUsYyhiWyhmfGQ+PjQmMTUpJjYzXSksZj0oZCYxNSk8PDIsbnVsbCE9PShkPWEoKSk/KGMoYlsoZnxkPj42JjMpJjYzXSksYyhiW2QmNjNdKSk6KGMoYltmJjYzXSksYyg2MSkpKTooYyhiW2YmNjNdKSxjKDYxKSxjKDYxKSl9O2EuZGVjb2RlPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gZChhKXt0aHJvdyBFcnJvcihcIklsbGVnYWwgY2hhcmFjdGVyIGNvZGU6IFwiK2EpO31mb3IodmFyIGYsZSxoO251bGwhPT0oZj1hKCkpOylpZihlPWNbZl0sXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlJiZkKGYpLG51bGwhPT0oZj1hKCkpJiZcclxuKGg9Y1tmXSxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGgmJmQoZiksYihlPDwyPj4+MHwoaCY0OCk+PjQpLG51bGwhPT0oZj1hKCkpKSl7ZT1jW2ZdO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZSlpZig2MT09PWYpYnJlYWs7ZWxzZSBkKGYpO2IoKGgmMTUpPDw0Pj4+MHwoZSY2MCk+PjIpO2lmKG51bGwhPT0oZj1hKCkpKXtoPWNbZl07aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBoKWlmKDYxPT09ZilicmVhaztlbHNlIGQoZik7YigoZSYzKTw8Nj4+PjB8aCl9fX07YS50ZXN0PWZ1bmN0aW9uKGEpe3JldHVybi9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KGEpfTtyZXR1cm4gYX0oKTtlLnRvQmFzZTY0PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTthfD0wO2J8PTA7aWYoMD5hfHxiPnRoaXMuY2FwYWNpdHl8fFxyXG5hPmIpdGhyb3cgUmFuZ2VFcnJvcihcImJlZ2luLCBlbmRcIik7dmFyIGM7eC5lbmNvZGUoZnVuY3Rpb24oKXtyZXR1cm4gYTxiP3RoaXMudmlld1thKytdOm51bGx9LmJpbmQodGhpcyksYz1yKCkpO3JldHVybiBjKCl9O2guZnJvbUJhc2U2ND1mdW5jdGlvbihhLGIpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBUeXBlRXJyb3IoXCJzdHJcIik7dmFyIGM9bmV3IGgoYS5sZW5ndGgvNCozLGIpLGQ9MDt4LmRlY29kZShtKGEpLGZ1bmN0aW9uKGEpe2Mudmlld1tkKytdPWF9KTtjLmxpbWl0PWQ7cmV0dXJuIGN9O2guYnRvYT1mdW5jdGlvbihhKXtyZXR1cm4gaC5mcm9tQmluYXJ5KGEpLnRvQmFzZTY0KCl9O2guYXRvYj1mdW5jdGlvbihhKXtyZXR1cm4gaC5mcm9tQmFzZTY0KGEpLnRvQmluYXJ5KCl9O2UudG9CaW5hcnk9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO1xyXG5hfD0wO2J8PTA7aWYoMD5hfHxiPnRoaXMuY2FwYWNpdHkoKXx8YT5iKXRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO2lmKGE9PT1iKXJldHVyblwiXCI7Zm9yKHZhciBjPVtdLGQ9W107YTxiOyljLnB1c2godGhpcy52aWV3W2ErK10pLDEwMjQ8PWMubGVuZ3RoJiYoZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGMpKSxjPVtdKTtyZXR1cm4gZC5qb2luKFwiXCIpK1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGMpfTtoLmZyb21CaW5hcnk9ZnVuY3Rpb24oYSxiKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGgsZixlPW5ldyBoKGQsYik7YzxkOyl7Zj1hLmNoYXJDb2RlQXQoYyk7aWYoMjU1PGYpdGhyb3cgUmFuZ2VFcnJvcihcImlsbGVnYWwgY2hhciBjb2RlOiBcIitmKTtlLnZpZXdbYysrXT1mfWUubGltaXQ9ZDtyZXR1cm4gZX07ZS50b0RlYnVnPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cclxuLTEsYz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLGQsZj1cIlwiLGU9XCJcIixnPVwiXCI7YjxjOyl7LTEhPT1iJiYoZD10aGlzLnZpZXdbYl0sZj0xNj5kP2YrKFwiMFwiK2QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpOmYrZC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxhJiYoZSs9MzI8ZCYmMTI3PmQ/U3RyaW5nLmZyb21DaGFyQ29kZShkKTpcIi5cIikpOysrYjtpZihhJiYwPGImJjA9PT1iJTE2JiZiIT09Yyl7Zm9yKDs1MT5mLmxlbmd0aDspZis9XCIgXCI7Zys9ZitlK1wiXFxuXCI7Zj1lPVwiXCJ9Zj1iPT09dGhpcy5vZmZzZXQmJmI9PT10aGlzLmxpbWl0P2YrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIiFcIjpcInxcIik6Yj09PXRoaXMub2Zmc2V0P2YrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIltcIjpcIjxcIik6Yj09PXRoaXMubGltaXQ/ZisoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiXVwiOlwiPlwiKTpmKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCInXCI6YXx8MCE9PWImJmIhPT1jP1wiIFwiOlwiXCIpfWlmKGEmJlwiIFwiIT09XHJcbmYpe2Zvcig7NTE+Zi5sZW5ndGg7KWYrPVwiIFwiO2crPWYrZStcIlxcblwifXJldHVybiBhP2c6Zn07aC5mcm9tRGVidWc9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEubGVuZ3RoO2I9bmV3IGgoKGQrMSkvM3wwLGIsYyk7Zm9yKHZhciBmPTAsZT0wLGcsaz0hMSxtPSExLG49ITEscD0hMSxxPSExO2Y8ZDspe3N3aXRjaChnPWEuY2hhckF0KGYrKykpe2Nhc2UgXCIhXCI6aWYoIWMpe2lmKG18fG58fHApe3E9ITA7YnJlYWt9bT1uPXA9ITB9Yi5vZmZzZXQ9Yi5tYXJrZWRPZmZzZXQ9Yi5saW1pdD1lO2s9ITE7YnJlYWs7Y2FzZSBcInxcIjppZighYyl7aWYobXx8cCl7cT0hMDticmVha31tPXA9ITB9Yi5vZmZzZXQ9Yi5saW1pdD1lO2s9ITE7YnJlYWs7Y2FzZSBcIltcIjppZighYyl7aWYobXx8bil7cT0hMDticmVha31tPW49ITB9Yi5vZmZzZXQ9Yi5tYXJrZWRPZmZzZXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCI8XCI6aWYoIWMpe2lmKG0pe3E9ITA7YnJlYWt9bT0hMH1iLm9mZnNldD1lO2s9ITE7YnJlYWs7Y2FzZSBcIl1cIjppZighYyl7aWYocHx8XHJcbm4pe3E9ITA7YnJlYWt9cD1uPSEwfWIubGltaXQ9Yi5tYXJrZWRPZmZzZXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCI+XCI6aWYoIWMpe2lmKHApe3E9ITA7YnJlYWt9cD0hMH1iLmxpbWl0PWU7az0hMTticmVhaztjYXNlIFwiJ1wiOmlmKCFjKXtpZihuKXtxPSEwO2JyZWFrfW49ITB9Yi5tYXJrZWRPZmZzZXQ9ZTtrPSExO2JyZWFrO2Nhc2UgXCIgXCI6az0hMTticmVhaztkZWZhdWx0OmlmKCFjJiZrKXtxPSEwO2JyZWFrfWc9cGFyc2VJbnQoZythLmNoYXJBdChmKyspLDE2KTtpZighYyYmKGlzTmFOKGcpfHwwPmd8fDI1NTxnKSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7Yi52aWV3W2UrK109ZztrPSEwfWlmKHEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2YpO31pZighYyl7aWYoIW18fCFwKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBNaXNzaW5nIG9mZnNldCBvciBsaW1pdFwiKTtcclxuaWYoZTxiLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIrZStcIiA8IFwiK2QpO31yZXR1cm4gYn07ZS50b0hleD1mdW5jdGlvbihhLGIpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3RoaXMub2Zmc2V0OmE7Yj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI/dGhpcy5saW1pdDpiO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK1xyXG50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Zm9yKHZhciBjPUFycmF5KGItYSksZDthPGI7KWQ9dGhpcy52aWV3W2ErK10sMTY+ZD9jLnB1c2goXCIwXCIsZC50b1N0cmluZygxNikpOmMucHVzaChkLnRvU3RyaW5nKDE2KSk7cmV0dXJuIGMuam9pbihcIlwiKX07aC5mcm9tSGV4PWZ1bmN0aW9uKGEsYixjKXtpZighYyl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoMCE9PWEubGVuZ3RoJTIpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO312YXIgZD1hLmxlbmd0aDtiPW5ldyBoKGQvMnwwLGIpO2Zvcih2YXIgZixlPTAsZz0wO2U8ZDtlKz0yKXtmPXBhcnNlSW50KGEuc3Vic3RyaW5nKGUsZSsyKSwxNik7aWYoIWMmJighaXNGaW5pdGUoZil8fDA+Znx8MjU1PGYpKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBub24taGV4IGNoYXJhY3RlcnNcIik7XHJcbmIudmlld1tnKytdPWZ9Yi5saW1pdD1nO3JldHVybiBifTt2YXIgbj1mdW5jdGlvbigpe3ZhciBhPXtNQVhfQ09ERVBPSU5UOjExMTQxMTEsZW5jb2RlVVRGODpmdW5jdGlvbihhLGMpe3ZhciBkPW51bGw7XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoZD1hLGE9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pO2Zvcig7bnVsbCE9PWR8fG51bGwhPT0oZD1hKCkpOykxMjg+ZD9jKGQmMTI3KTooMjA0OD5kP2MoZD4+NiYzMXwxOTIpOig2NTUzNj5kP2MoZD4+MTImMTV8MjI0KTooYyhkPj4xOCY3fDI0MCksYyhkPj4xMiY2M3wxMjgpKSxjKGQ+PjYmNjN8MTI4KSksYyhkJjYzfDEyOCkpLGQ9bnVsbH0sZGVjb2RlVVRGODpmdW5jdGlvbihhLGMpe2Zvcih2YXIgZCxmLGUsZyxoPWZ1bmN0aW9uKGEpe2E9YS5zbGljZSgwLGEuaW5kZXhPZihudWxsKSk7dmFyIGI9RXJyb3IoYS50b1N0cmluZygpKTtiLm5hbWU9XCJUcnVuY2F0ZWRFcnJvclwiO2IuYnl0ZXM9YTt0aHJvdyBiO307bnVsbCE9PShkPWEoKSk7KWlmKDA9PT1cclxuKGQmMTI4KSljKGQpO2Vsc2UgaWYoMTkyPT09KGQmMjI0KSludWxsPT09KGY9YSgpKSYmaChbZCxmXSksYygoZCYzMSk8PDZ8ZiY2Myk7ZWxzZSBpZigyMjQ9PT0oZCYyNDApKW51bGwhPT0oZj1hKCkpJiZudWxsIT09KGU9YSgpKXx8aChbZCxmLGVdKSxjKChkJjE1KTw8MTJ8KGYmNjMpPDw2fGUmNjMpO2Vsc2UgaWYoMjQwPT09KGQmMjQ4KSludWxsIT09KGY9YSgpKSYmbnVsbCE9PShlPWEoKSkmJm51bGwhPT0oZz1hKCkpfHxoKFtkLGYsZSxnXSksYygoZCY3KTw8MTh8KGYmNjMpPDwxMnwoZSY2Myk8PDZ8ZyY2Myk7ZWxzZSB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzdGFydGluZyBieXRlOiBcIitkKTt9LFVURjE2dG9VVEY4OmZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBkLGU9bnVsbDtudWxsIT09KGQ9bnVsbCE9PWU/ZTphKCkpOyk1NTI5Njw9ZCYmNTczNDM+PWQmJm51bGwhPT0oZT1hKCkpJiY1NjMyMDw9ZSYmNTczNDM+PWU/KGMoMTAyNCooZC01NTI5NikrZS01NjMyMCs2NTUzNiksXHJcbmU9bnVsbCk6YyhkKTtudWxsIT09ZSYmYyhlKX0sVVRGOHRvVVRGMTY6ZnVuY3Rpb24oYSxjKXt2YXIgZD1udWxsO1wibnVtYmVyXCI9PT10eXBlb2YgYSYmKGQ9YSxhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9KTtmb3IoO251bGwhPT1kfHxudWxsIT09KGQ9YSgpKTspNjU1MzU+PWQ/YyhkKTooZC09NjU1MzYsYygoZD4+MTApKzU1Mjk2KSxjKGQlMTAyNCs1NjMyMCkpLGQ9bnVsbH0sZW5jb2RlVVRGMTZ0b1VURjg6ZnVuY3Rpb24oYixjKXthLlVURjE2dG9VVEY4KGIsZnVuY3Rpb24oYil7YS5lbmNvZGVVVEY4KGIsYyl9KX0sZGVjb2RlVVRGOHRvVVRGMTY6ZnVuY3Rpb24oYixjKXthLmRlY29kZVVURjgoYixmdW5jdGlvbihiKXthLlVURjh0b1VURjE2KGIsYyl9KX0sY2FsY3VsYXRlQ29kZVBvaW50OmZ1bmN0aW9uKGEpe3JldHVybiAxMjg+YT8xOjIwNDg+YT8yOjY1NTM2PmE/Mzo0fSxjYWxjdWxhdGVVVEY4OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYyxkPTA7bnVsbCE9PShjPWEoKSk7KWQrPVxyXG4xMjg+Yz8xOjIwNDg+Yz8yOjY1NTM2PmM/Mzo0O3JldHVybiBkfSxjYWxjdWxhdGVVVEYxNmFzVVRGODpmdW5jdGlvbihiKXt2YXIgYz0wLGQ9MDthLlVURjE2dG9VVEY4KGIsZnVuY3Rpb24oYSl7KytjO2QrPTEyOD5hPzE6MjA0OD5hPzI6NjU1MzY+YT8zOjR9KTtyZXR1cm5bYyxkXX19O3JldHVybiBhfSgpO2UudG9VVEY4PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK1xyXG5hK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjO3RyeXtuLmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCl7cmV0dXJuIGE8Yj90aGlzLnZpZXdbYSsrXTpudWxsfS5iaW5kKHRoaXMpLGM9cigpKX1jYXRjaChkKXtpZihhIT09Yil0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2ErXCIgIT0gXCIrYik7fXJldHVybiBjKCl9O2guZnJvbVVURjg9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjJiZcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTt2YXIgZD1uZXcgaChuLmNhbGN1bGF0ZVVURjE2YXNVVEY4KG0oYSksITApWzFdLGIsYyksZT0wO24uZW5jb2RlVVRGMTZ0b1VURjgobShhKSxmdW5jdGlvbihhKXtkLnZpZXdbZSsrXT1hfSk7ZC5saW1pdD1lO3JldHVybiBkfTtyZXR1cm4gaH0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2MubG9nKFwib25sb2FkIGJlZ2luXCIpXHJcblxyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIuaW5pdCgpO1xyXG4gICAgICAgIGNjLm5ldG1hbmFnZXIucmVnaXN0ZXJIYW5kbGVyKGNjLmRhdGFtYW5hZ2VyKTtcclxuICAgICAgICBjYy5uZXRtYW5hZ2VyLnJlZ2lzdGVySGFuZGxlcihjYy5nYW1lbWFuYWdlcik7XHJcbiAgICAgICAgY2MubmV0bWFuYWdlci5yZWdpc3RlckhhbmRsZXIoY2MuZ3VpbWFuYWdlcik7XHJcblxyXG4gICAgICAgIGNjLmF1ZGlvbWFuYWdlci5pbml0KClcclxuXHJcbiAgICAgICAgY2Muc2NlbmVtYW5hZ2VyLmxvYWRMb2dpblNjZW5lKCk7XHJcbiAgICAgICAgY2MubG9nKCdvbmxvYWQnKVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBsb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiTG9uZ1wiXSA9IGZhY3RvcnkoKTtcclxuXHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4gICAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbiAgICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4gICAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbiAgICAvL1xyXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4gICAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuICAgIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuICAgIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIC8vXHJcbiAgICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuICAgIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gICAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIC8qIGlzIGNvbXBhdGlibGUgKi8gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHZhbC51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuT05FID0gT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgICAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICAgICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICAgICAgcmVzID0gWkVSTztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTG9uZztcclxufSk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBwcm90b2J1Zi5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJieXRlYnVmZmVyXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKSwgdHJ1ZSk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJQcm90b0J1ZlwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJ5dGVCdWZmZXJcIl0pO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oQnl0ZUJ1ZmZlciwgaXNDb21tb25KUykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgUHJvdG9CdWYgbmFtZXNwYWNlLlxyXG4gICAgICogQGV4cG9ydHMgUHJvdG9CdWZcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgdmFyIFByb3RvQnVmID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKG5ldzogQnl0ZUJ1ZmZlciwgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuQnl0ZUJ1ZmZlciA9IEJ5dGVCdWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzogTG9uZywgLi4uWypdKX1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTG9uZyA9IEJ5dGVCdWZmZXIuTG9uZyB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdG9CdWYuanMgdmVyc2lvbi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuVkVSU0lPTiA9IFwiNS4wLjFcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmUgdHlwZXMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYXJpbnQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml4ZWQgNjQgYml0cyB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExlbmd0aCBkZWxpbWl0ZWQgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSA9IDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmQgZ3JvdXAgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVkIDMyIGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMiA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYWNrYWJsZSB3aXJlIHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0LFxyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHlwZXMuXHJcbiAgICAgKiBAZGljdFxyXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyLCBkZWZhdWx0VmFsdWU6ICp9Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5UWVBFUyA9IHtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXHJcbiAgICAgICAgXCJpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidWludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJ1aW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ludDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwidWludDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5VWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzaW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNpbnQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJib29sXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJib29sXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkb3VibGVcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImRvdWJsZVwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdHJpbmdcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0sXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJieXRlc1wiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwgLy8gb3ZlcnJpZGRlbiBpbiB0aGUgY29kZSwgbXVzdCBiZSBhIHVuaXF1ZSBpbnN0YW5jZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMixcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAgUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuVVpFUk8gOiB1bmRlZmluZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ZpeGVkNjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInNmaXhlZDY0XCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZsb2F0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJlbnVtXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJlbnVtXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm1lc3NhZ2VcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ3JvdXBcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVAsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZCBtYXAga2V5IHR5cGVzLlxyXG4gICAgICogQHR5cGUgeyFBcnJheS48IU9iamVjdC48c3RyaW5nLHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXIsIGRlZmF1bHRWYWx1ZTogKn0+Pn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NQVBfS0VZX1RZUEVTID0gW1xyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXVxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gZmllbGQgaWQuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLklEX01JTiA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIGZpZWxkIGlkLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5JRF9NQVggPSAweDFGRkZGRkZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgZmllbGQgbmFtZXMgd2lsbCBiZSBjb252ZXJ0ZWQgZnJvbSB1bmRlcnNjb3JlIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UuIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiAgTXVzdCBiZSBzZXQgcHJpb3IgdG8gcGFyc2luZy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIG1lc3NhZ2VzIGFyZSBwb3B1bGF0ZWQgd2l0aCAoc2V0WCwgc2V0X3gpIGFjY2Vzc29ycyBmb3IgZWFjaCBmaWVsZC4gVGhpcyBjYW4gYmUgZGlzYWJsZWQgYnlcclxuICAgICAqICBzZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCBwcmlvciB0byBidWlsZGluZyBtZXNzYWdlcy5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZUFjY2Vzc29ycyA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlcyBhcmUgcG9wdWxhdGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMgaWYgYSBmaWVsZCBpcyBub3QgcHJlc2VudCBvbiB0aGUgd2lyZS4gVG8gZGlzYWJsZVxyXG4gICAgICogIHRoaXMgYmVoYXZpb3IsIHNldCB0aGlzIHNldHRpbmcgdG8gYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5wb3B1bGF0ZURlZmF1bHRzID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5VdGlsXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlV0aWwgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3RvQnVmIHV0aWxpdGllcy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5VdGlsXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBVdGlsID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZsYWcgaWYgcnVubmluZyBpbiBub2RlIG9yIG5vdC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbC5JU19OT0RFID0gISEoXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzKycnID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIXByb2Nlc3NbJ2Jyb3dzZXInXVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gTm8gZGVwZW5kZW5jaWVzIHBsZWFzZSwgcmVmOiBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL3htbGh0dHAuaHRtbFxyXG4gICAgICAgICAgICB2YXIgWE1MSHR0cEZhY3RvcmllcyA9IFtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKX0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P1hNTEh0dHBSZXF1ZXN0fSAqL1xyXG4gICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wO2k8WE1MSHR0cEZhY3Rvcmllcy5sZW5ndGg7aSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkgeyB4aHIgPSBYTUxIdHRwRmFjdG9yaWVzW2ldKCk7IH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXhocilcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHhocjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGZXRjaGVzIGEgcmVzb3VyY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUmVzb3VyY2UgcGF0aFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIHJlc291cmNlJ3MgY29udGVudHMuIElmIG9taXR0ZWQgdGhlIHJlc291cmNlIHdpbGxcclxuICAgICAgICAgKiAgIGJlIGZldGNoZWQgc3luY2hyb25vdXNseS4gSWYgdGhlIHJlcXVlc3QgZmFpbGVkLCBjb250ZW50cyB3aWxsIGJlIG51bGwuXHJcbiAgICAgICAgICogQHJldHVybiB7P3N0cmluZ3x1bmRlZmluZWR9IFJlc291cmNlIGNvbnRlbnRzIGlmIGNhbGxiYWNrIGlzIG9taXR0ZWQgKG51bGwgaWYgdGhlIHJlcXVlc3QgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWQuXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWwuZmV0Y2ggPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChVdGlsLklTX05PREUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIrZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhociA9IFV0aWwuWEhSKCk7XHJcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgY2FsbGJhY2sgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8geGhyLnNldFJlcXVlc3RIZWFkZXIoJ1VzZXItQWdlbnQnLCAnWE1MSFRUUC8xLjAnKTtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIHJlbW90ZSAqLyB4aHIuc3RhdHVzID09IDIwMCB8fCAvKiBsb2NhbCAqLyAoeGhyLnN0YXR1cyA9PSAwICYmIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlsLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXyhbYS16QS1aXSkvZywgZnVuY3Rpb24gKCQwLCAkMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBVdGlsO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhbmd1YWdlIGV4cHJlc3Npb25zLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywhUmVnRXhwPn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTGFuZyA9IHtcclxuXHJcbiAgICAgICAgLy8gQ2hhcmFjdGVycyBhbHdheXMgZW5kaW5nIGEgc3RhdGVtZW50XHJcbiAgICAgICAgREVMSU06IC9bXFxzXFx7XFx9PTs6XFxbXFxdLCdcIlxcKFxcKTw+XS9nLFxyXG5cclxuICAgICAgICAvLyBGaWVsZCBydWxlc1xyXG4gICAgICAgIFJVTEU6IC9eKD86cmVxdWlyZWR8b3B0aW9uYWx8cmVwZWF0ZWR8bWFwKSQvLFxyXG5cclxuICAgICAgICAvLyBGaWVsZCB0eXBlc1xyXG4gICAgICAgIFRZUEU6IC9eKD86ZG91YmxlfGZsb2F0fGludDMyfHVpbnQzMnxzaW50MzJ8aW50NjR8dWludDY0fHNpbnQ2NHxmaXhlZDMyfHNmaXhlZDMyfGZpeGVkNjR8c2ZpeGVkNjR8Ym9vbHxzdHJpbmd8Ynl0ZXMpJC8sXHJcblxyXG4gICAgICAgIC8vIE5hbWVzXHJcbiAgICAgICAgTkFNRTogL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXHJcblxyXG4gICAgICAgIC8vIFR5cGUgZGVmaW5pdGlvbnNcclxuICAgICAgICBUWVBFREVGOiAvXlthLXpBLVpdW2EtekEtWl8wLTldKiQvLFxyXG5cclxuICAgICAgICAvLyBUeXBlIHJlZmVyZW5jZXNcclxuICAgICAgICBUWVBFUkVGOiAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSskLyxcclxuXHJcbiAgICAgICAgLy8gRnVsbHkgcXVhbGlmaWVkIHR5cGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIEZRVFlQRVJFRjogL14oPzpcXC5bYS16QS1aXVthLXpBLVpfMC05XSopKyQvLFxyXG5cclxuICAgICAgICAvLyBBbGwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUjogL14tPyg/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddK3woWzAtOV0qKFxcLlswLTldKik/KFtFZV1bKy1dP1swLTldKyk/KXxpbmZ8bmFuKSQvLFxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfREVDOiAvXig/OlsxLTldWzAtOV0qfDApJC8sXHJcblxyXG4gICAgICAgIC8vIEhleGFkZWNpbWFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfSEVYOiAvXjBbeFhdWzAtOWEtZkEtRl0rJC8sXHJcblxyXG4gICAgICAgIC8vIE9jdGFsIG51bWJlcnNcclxuICAgICAgICBOVU1CRVJfT0NUOiAvXjBbMC03XSskLyxcclxuXHJcbiAgICAgICAgLy8gRmxvYXRpbmcgcG9pbnQgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9GTFQ6IC9eKFswLTldKihcXC5bMC05XSopPyhbRWVdWystXT9bMC05XSspP3xpbmZ8bmFuKSQvLFxyXG5cclxuICAgICAgICAvLyBCb29sZWFuc1xyXG4gICAgICAgIEJPT0w6IC9eKD86dHJ1ZXxmYWxzZSkkL2ksXHJcblxyXG4gICAgICAgIC8vIElkIG51bWJlcnNcclxuICAgICAgICBJRDogL14oPzpbMS05XVswLTldKnwwfDBbeFhdWzAtOWEtZkEtRl0rfDBbMC03XSspJC8sXHJcblxyXG4gICAgICAgIC8vIE5lZ2F0aXZlIGlkIG51bWJlcnMgKGVudW0gdmFsdWVzKVxyXG4gICAgICAgIE5FR0lEOiAvXlxcLT8oPzpbMS05XVswLTldKnwwfDBbeFhdWzAtOWEtZkEtRl0rfDBbMC03XSspJC8sXHJcblxyXG4gICAgICAgIC8vIFdoaXRlc3BhY2VzXHJcbiAgICAgICAgV0hJVEVTUEFDRTogL1xccy8sXHJcblxyXG4gICAgICAgIC8vIEFsbCBzdHJpbmdzXHJcbiAgICAgICAgU1RSSU5HOiAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKXwoPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZyxcclxuXHJcbiAgICAgICAgLy8gRG91YmxlIHF1b3RlZCBzdHJpbmdzXHJcbiAgICAgICAgU1RSSU5HX0RROiAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKS9nLFxyXG5cclxuICAgICAgICAvLyBTaW5nbGUgcXVvdGVkIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkdfU1E6IC8oPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5Eb3RQcm90byA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZykge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVdGlsaXRpZXMgdG8gcGFyc2UgLnByb3RvIGZpbGVzLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEb3RQcm90byA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRva2VuaXplci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJcclxuICAgICAgICAgKiBAY2xhc3MgcHJvdG90eXBlIHRva2VuaXplclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byBQcm90byB0byB0b2tlbml6ZVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihwcm90bykge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNvdXJjZSB0byBwYXJzZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBwcm90bytcIlwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgaW5kZXguXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgbGluZS5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5saW5lID0gMTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUb2tlbiBzdGFjay5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9wZW5pbmcgY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IHN0cmluZyByZWFkLCBpZiBhbnkuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc3RyaW5nT3BlbiA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG9rZW5pemVyUHJvdG90eXBlID0gVG9rZW5pemVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSBzdHJpbmcgYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5fcmVhZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLl9zdHJpbmdPcGVuID09PSAnXCInXHJcbiAgICAgICAgICAgICAgICA/IExhbmcuU1RSSU5HX0RRXHJcbiAgICAgICAgICAgICAgICA6IExhbmcuU1RSSU5HX1NRO1xyXG4gICAgICAgICAgICByZS5sYXN0SW5kZXggPSB0aGlzLmluZGV4IC0gMTsgLy8gSW5jbHVkZSB0aGUgb3BlbiBxdW90ZVxyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHRoaXMuc291cmNlKTtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW50ZXJtaW5hdGVkIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlLmxhc3RJbmRleDtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuX3N0cmluZ09wZW4pO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJpbmdPcGVuID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzIGJ5IG9uZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUb2tlbiBvciBgbnVsbGAgb24gRU9GXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmluZ09wZW4gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcGVhdCxcclxuICAgICAgICAgICAgICAgIHByZXYsXHJcbiAgICAgICAgICAgICAgICBuZXh0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCB3aGl0ZSBzcGFjZXNcclxuICAgICAgICAgICAgICAgIHdoaWxlIChMYW5nLldISVRFU1BBQ0UudGVzdChuZXh0ID0gdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykgeyAvLyBMaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnNvdXJjZS5jaGFyQXQoKyt0aGlzLmluZGV4KSAhPT0gJ1xcbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobmV4dCA9IHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSkgPT09ICcqJykgeyAvKiBCbG9jayAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmluZGV4ID09PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgIT09ICcqJyB8fCBuZXh0ICE9PSAnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnLyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICBMYW5nLkRFTElNLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IExhbmcuREVMSU0udGVzdCh0aGlzLnNvdXJjZS5jaGFyQXQoZW5kKyspKTtcclxuICAgICAgICAgICAgaWYgKCFkZWxpbSlcclxuICAgICAgICAgICAgICAgIHdoaWxlKGVuZCA8IHRoaXMuc291cmNlLmxlbmd0aCAmJiAhTGFuZy5ERUxJTS50ZXN0KHRoaXMuc291cmNlLmNoYXJBdChlbmQpKSlcclxuICAgICAgICAgICAgICAgICAgICArK2VuZDtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggPSBlbmQpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09IFwiJ1wiKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nT3BlbiA9IHRva2VuO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbMF07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2tpcHMgYSBzcGVjaWZpYyB0b2tlbiBhbmQgdGhyb3dzIGlmIGl0IGRpZmZlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBhY3R1YWwgdG9rZW4gZGlmZmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCAnXCIrYWN0dWFsK1wiJywgJ1wiK2V4cGVjdGVkK1wiJyBleHBlY3RlZFwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbWl0cyBhbiBvcHRpb25hbCB0b2tlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgb3B0aW9uYWwgdG9rZW5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB0b2tlbiBleGlzdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2tlbml6ZXJQcm90b3R5cGUub21pdCA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJUb2tlbml6ZXIoaW5kZXgvbGVuZ3RoKVwiXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJUb2tlbml6ZXIgKFwiK3RoaXMuaW5kZXgrXCIvXCIrdGhpcy5zb3VyY2UubGVuZ3RoK1wiIGF0IGxpbmUgXCIrdGhpcy5saW5lK1wiKVwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRG90UHJvdG8uVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFBhcnNlci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXJcclxuICAgICAgICAgKiBAY2xhc3MgcHJvdG90eXBlIHBhcnNlclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRva2VuaXplci5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudG4gPSBuZXcgVG9rZW5pemVyKHNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBwYXJzaW5nIHByb3RvMyBvciBub3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wcm90bzMgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQYXJzZXJQcm90b3R5cGUgPSBQYXJzZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgdGhlIHNvdXJjZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9wTGV2ZWwgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJbUk9PVF1cIiwgLy8gdGVtcG9yYXJ5XHJcbiAgICAgICAgICAgICAgICBcInBhY2thZ2VcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImVudW1zXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpbXBvcnRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgXCJzZXJ2aWNlc1wiOiBbXVxyXG4gICAgICAgICAgICAgICAgLy8gXCJzeW50YXhcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIGhlYWQgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2VhaztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZCB8fCB0b3BMZXZlbFtcInBhY2thZ2VcIl0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdwYWNrYWdlJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcGFja2FnZSBuYW1lOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFtcInBhY2thZ2VcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5leHBlY3RlZCAnaW1wb3J0J1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicHVibGljXCIgfHwgKHdlYWsgPSB0b2tlbiA9PT0gXCJ3ZWFrXCIpKSAvLyB0b2tlbiBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuX3JlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspIC8vIGltcG9ydCBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxbXCJpbXBvcnRzXCJdLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bnRheCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdzeW50YXgnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodG9wTGV2ZWxbXCJzeW50YXhcIl0gPSB0aGlzLl9yZWFkU3RyaW5nKCkpID09PSBcInByb3RvM1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG8zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UodG9wTGV2ZWwsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFbnVtKHRvcExldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvcHRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24odG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlKHRvcExldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdleHRlbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQodG9wTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgJ1wiICsgdG9rZW4gKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIlBhcnNlIGVycm9yIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIiArIGUubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRvcExldmVsW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvcExldmVsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzb3VyY2UpLnBhcnNlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gQ29udmVyc2lvbiAtLS0tLS1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBudW1lcmljYWwgc3RyaW5nIHRvIGFuIGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG1heUJlTmVnYXRpdmVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1rSWQodmFsdWUsIG1heUJlTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gLTEsXHJcbiAgICAgICAgICAgICAgICBzaWduID0gMTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PSAnLScpIHtcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUl9ERUMudGVzdCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMSksIDgpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgaWQgdmFsdWU6IFwiICsgKHNpZ24gPCAwID8gJy0nIDogJycpICsgdmFsdWUpO1xyXG4gICAgICAgICAgICBpZCA9IChzaWduKmlkKXwwOyAvLyBGb3JjZSB0byAzMmJpdFxyXG4gICAgICAgICAgICBpZiAoIW1heUJlTmVnYXRpdmUgJiYgaWQgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGlkIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBudW1lcmljYWwgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1rTnVtYmVyKHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IDE7XHJcbiAgICAgICAgICAgIGlmICh2YWwuY2hhckF0KDApID09ICctJykge1xyXG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVJfREVDLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsLCAxMCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0hFWC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsLnN1YnN0cmluZygxKSwgOCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ2luZicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPT09ICduYW4nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfRkxULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbnVtYmVyIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0tLSBSZWFkaW5nIC0tLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHN0cmluZy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgIGRlbGltO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBkZWxpbSA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGltICE9PSBcIidcIiAmJiBkZWxpbSAhPT0gJ1wiJylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc3RyaW5nIGRlbGltaXRlcjogXCIrZGVsaW0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoZGVsaW0pO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09ICdcIicpOyAvLyBtdWx0aSBsaW5lP1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtYXlCZVR5cGVSZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfGJvb2xlYW58c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9yZWFkVmFsdWUgPSBmdW5jdGlvbihtYXlCZVR5cGVSZWYpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5wZWVrKCksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnXCInIHx8IHRva2VuID09PSBcIidcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVIudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWtOdW1iZXIodG9rZW4pO1xyXG4gICAgICAgICAgICBpZiAoTGFuZy5CT09MLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0b2tlbi50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpO1xyXG4gICAgICAgICAgICBpZiAobWF5QmVUeXBlUmVmICYmIExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHZhbHVlOiBcIit0b2tlbik7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIFBhcnNpbmcgY29uc3RydWN0cyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYSBuYW1lc3BhY2Ugb3B0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNMaXN0XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlT3B0aW9uID0gZnVuY3Rpb24ocGFyZW50LCBpc0xpc3QpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCksXHJcbiAgICAgICAgICAgICAgICBjdXN0b20gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGFsbG93IG9wdGlvbnMgb2YgdGhlIGZvcm0gZ29vZ2xlLnByb3RvYnVmLiogc2luY2UgdGhleSB3aWxsIGp1c3QgZ2V0IGlnbm9yZWQgYW55d2F5c1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCEvZ29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QodG9rZW4pKSAvLyBGSVhNRTogV2h5IHNob3VsZCB0aGF0IG5vdCBiZSBhIHZhbGlkIHR5cGVyZWY/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9wdGlvbiBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgIGlmIChjdXN0b20pIHsgLy8gKG15X21ldGhvZF9vcHRpb24pLmZvbywgKG15X21ldGhvZF9vcHRpb24pLCBzb21lX21ldGhvZF9vcHRpb24sIChmb28ubXlfb3B0aW9uKS5iYXJcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnKScpO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9ICcoJytuYW1lKycpJztcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5GUVRZUEVSRUYudGVzdCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPScpO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNMaXN0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuIG9wdGlvbiBvbiB0aGUgc3BlY2lmaWVkIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb24ob3B0aW9ucywgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW25hbWVdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9uc1tuYW1lXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IFsgb3B0aW9uc1tuYW1lXSBdO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXS5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGFuIG9wdGlvbiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlT3B0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gJ3snKSB7IC8vIFBsYWluIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50W1wib3B0aW9uc1wiXSwgbmFtZSwgdGhpcy5fcmVhZFZhbHVlKHRydWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gQWdncmVnYXRlIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9wdGlvbiBuYW1lOiBcIiArIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50bi5vbWl0KFwiOlwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudFtcIm9wdGlvbnNcIl0sIG5hbWUgKyBcIi5cIiArIHRva2VuLCB0aGlzLl9yZWFkVmFsdWUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIHNlcnZpY2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZVNlcnZpY2UgPSBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHNlcnZpY2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICB2YXIgc3ZjID0ge1xyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBcInJwY1wiOiB7fSxcclxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihzdmMpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdycGMnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU2VydmljZVJQQyhzdmMpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBzZXJ2aWNlIHRva2VuOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgcGFyZW50W1wic2VydmljZXNcIl0ucHVzaChzdmMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhIFJQQyBzZXJ2aWNlIGRlZmluaXRpb24gb2YgdGhlIGZvcm0gWydycGMnLCBuYW1lLCAocmVxdWVzdCksICdyZXR1cm5zJywgKHJlc3BvbnNlKV0uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBzdmMgU2VydmljZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlU2VydmljZVJQQyA9IGZ1bmN0aW9uKHN2Yykge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwicnBjXCIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBycGMgc2VydmljZSBtZXRob2QgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0ge1xyXG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0XCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBcInJlcXVlc3Rfc3RyZWFtXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJyZXNwb25zZV9zdHJlYW1cIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge31cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiKFwiKTtcclxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgPT09IFwic3RyZWFtXCIpIHtcclxuICAgICAgICAgICAgICBtZXRob2RbXCJyZXF1ZXN0X3N0cmVhbVwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBycGMgc2VydmljZSByZXF1ZXN0IHR5cGU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgbWV0aG9kW1wicmVxdWVzdFwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIpXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSAhPT0gXCJyZXR1cm5zXCIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcnBjIHNlcnZpY2UgcmVxdWVzdCB0eXBlIGRlbGltaXRlcjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIoXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gXCJzdHJlYW1cIikge1xyXG4gICAgICAgICAgICAgIG1ldGhvZFtcInJlc3BvbnNlX3N0cmVhbVwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXRob2RbXCJyZXNwb25zZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIpXCIpO1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICd7Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09ICdvcHRpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIHRva2VuOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudG4ub21pdChcIjtcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmNbdHlwZV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgc3ZjW3R5cGVdID0ge307XHJcbiAgICAgICAgICAgIHN2Y1t0eXBlXVtuYW1lXSA9IG1ldGhvZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYSBtZXNzYWdlIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3Q9fSBmbGQgRmllbGQgZGVmaW5pdGlvbiBpZiB0aGlzIGlzIGEgZ3JvdXBcclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlID0gZnVuY3Rpb24ocGFyZW50LCBmbGQpIHtcclxuICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSAhIWZsZCxcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwiZmllbGRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJlbnVtc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge30sXHJcbiAgICAgICAgICAgICAgICBcInNlcnZpY2VzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvbmVvZnNcIjoge31cclxuICAgICAgICAgICAgICAgIC8vIFwiZXh0ZW5zaW9uc1wiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgXCIrKGlzR3JvdXAgPyBcImdyb3VwXCIgOiBcIm1lc3NhZ2VcIikrXCIgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICBtc2dbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgZmxkW1wiaWRcIl0gPSBta0lkKHRoaXMudG4ubmV4dCgpKTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcImlzR3JvdXBcIl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1snICYmIGZsZClcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGZsZCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChtc2csIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9uZW9mXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlT25lT2YobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImVudW1cIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0obXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1lc3NhZ2VcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1zZyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJzZXJ2aWNlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlKG1zZyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJleHRlbnNpb25zXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5oYXNPd25Qcm9wZXJ0eShcImV4dGVuc2lvbnNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IG1zZ1tcImV4dGVuc2lvbnNcIl0uY29uY2F0KHRoaXMuX3BhcnNlRXh0ZW5zaW9uUmFuZ2VzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IHRoaXMuX3BhcnNlRXh0ZW5zaW9uUmFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwicmVzZXJ2ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlnbm9yZWQoKTsgLy8gVE9ET1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZXh0ZW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQobXNnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBydWxlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIHRva2VuOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcclxuICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChtc2cpO1xyXG4gICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyBhbiBpZ25vcmVkIHN0YXRlbWVudC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VJZ25vcmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRuLnBlZWsoKSAhPT0gJzsnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBGaWVsZCBydWxlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEZpZWxkIHR5cGUgaWYgYWxyZWFkeSBrbm93biAobmV2ZXIga25vd24gZm9yIG1hcHMpXHJcbiAgICAgICAgICogQHJldHVybnMgeyFPYmplY3R9IEZpZWxkIGRlc2NyaXB0b3JcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihtc2csIHJ1bGUsIHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKCFMYW5nLlJVTEUudGVzdChydWxlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIHJ1bGU6IFwiK3J1bGUpO1xyXG4gICAgICAgICAgICB2YXIgZmxkID0ge1xyXG4gICAgICAgICAgICAgICAgXCJydWxlXCI6IHJ1bGUsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgaWYgKHJ1bGUgPT09IFwibWFwXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0eXBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPCcpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodG9rZW4pICYmICFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG1lc3NhZ2UgZmllbGQgdHlwZTogXCIgKyB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJrZXl0eXBlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoJywnKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkOiBcIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPicpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIG5hbWU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZmxkW1wibmFtZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcImlkXCJdID0gbWtJZCh0aGlzLnRuLm5leHQoKSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMoZmxkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcgPyB0eXBlIDogdGhpcy50bi5uZXh0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcIkEgW2xlZ2FjeV0gZ3JvdXAgc2ltcGx5IGNvbWJpbmVzIGEgbmVzdGVkIG1lc3NhZ2UgdHlwZSBhbmQgYSBmaWVsZCBpbnRvIGEgc2luZ2xlIGRlY2xhcmF0aW9uLiBJbiB5b3VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSwgeW91IGNhbiB0cmVhdCB0aGlzIG1lc3NhZ2UganVzdCBhcyBpZiBpdCBoYWQgYSBSZXN1bHQgdHlwZSBmaWVsZCBjYWxsZWQgcmVzdWx0ICh0aGUgbGF0dGVyIG5hbWUgaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXItY2FzZSBzbyB0aGF0IGl0IGRvZXMgbm90IGNvbmZsaWN0IHdpdGggdGhlIGZvcm1lcikuXCJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JwID0gdGhpcy5fcGFyc2VNZXNzYWdlKG1zZywgZmxkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9eW0EtWl0vLnRlc3QoZ3JwW1wibmFtZVwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdpbGxlZ2FsIGdyb3VwIG5hbWU6ICcrZ3JwW1wibmFtZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IGdycFtcIm5hbWVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1wibmFtZVwiXSA9IGdycFtcIm5hbWVcIl0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodHlwZSkgJiYgIUxhbmcuVFlQRVJFRi50ZXN0KHR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCB0eXBlOiBcIiArIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIG5hbWU6IFwiICsgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcImlkXCJdID0gbWtJZCh0aGlzLnRuLm5leHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwiW1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9ucyhmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXS5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbGQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBvbmVvZi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlT25lT2YgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9uZW9mIG5hbWU6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbixcclxuICAgICAgICAgICAgICAgIGZsZDtcclxuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSBcIn1cIikge1xyXG4gICAgICAgICAgICAgICAgZmxkID0gdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcIm9uZW9mXCJdID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZsZFtcImlkXCJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBtc2dbXCJvbmVvZnNcIl1bbmFtZV0gPSBmaWVsZHM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGEgc2V0IG9mIGZpZWxkIG9wdGlvbiBkZWZpbml0aW9ucy5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlRmllbGRPcHRpb25zID0gZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIltcIik7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ucGVlaygpKSAhPT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIixcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihmbGQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgYW4gZW51bS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VFbnVtID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIHZhciBlbm0gPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBuYW1lOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIGVubVtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gJ30nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oZW5tKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbmFtZTogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIj1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IG1rSWQodGhpcy50bi5uZXh0KCksIHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJbXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKHsgXCJvcHRpb25zXCI6IHt9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5tW1widmFsdWVzXCJdLnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBtc2dbXCJlbnVtc1wiXS5wdXNoKGVubSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGV4dGVuc2lvbiAvIHJlc2VydmVkIHJhbmdlcy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUFycmF5LjwhQXJyYXkuPG51bWJlcj4+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZUV4dGVuc2lvblJhbmdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIHZhciB0b2tlbixcclxuICAgICAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWluXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFByb3RvQnVmLklEX01JTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWF4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFByb3RvQnVmLklEX01BWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBta051bWJlcih0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG4ucGVlaygpICE9PSBcInRvXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy50bi5vbWl0KFwiLFwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2VzIGFuIGV4dGVuZCBibG9jay5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlRXh0ZW5kID0gZnVuY3Rpb24ocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmQgcmVmZXJlbmNlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgIHZhciBleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBcInJlZlwiOiB0b2tlbixcclxuICAgICAgICAgICAgICAgIFwiZmllbGRzXCI6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XHJcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBydWxlOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQoZXh0LCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmQgdG9rZW46IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBwYXJlbnRbXCJtZXNzYWdlc1wiXS5wdXNoKGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gR2VuZXJhbCAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGFyc2VyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlBhcnNlciBhdCBsaW5lIFwiK3RoaXMudG4ubGluZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERvdFByb3RvLlBhcnNlciA9IFBhcnNlcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIERvdFByb3RvO1xyXG5cclxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlJlZmxlY3QgPSAoZnVuY3Rpb24oUHJvdG9CdWYpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlcy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWZsZWN0ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBSZWZsZWN0IGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gcGFyZW50IFBhcmVudCBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRlciByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuQnVpbGRlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JqZWN0IG5hbWUgaW4gbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlQucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRQcm90b3R5cGUgPSBULnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gRnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgb2YgXCIuUEFUSC5UTy5USElTXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHB0ciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHB0ci5uYW1lK1wiLlwiK25hbWU7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUmVmbGVjdCBvYmplY3QgKGl0cyBmdWxseSBxdWFsaWZpZWQgbmFtZSkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUNsYXNzIFNldCB0byB0cnVlIHRvIGluY2x1ZGUgdGhlIGNsYXNzIG5hbWUuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbmNsdWRlQ2xhc3MgPyB0aGlzLmNsYXNzTmFtZSArIFwiIFwiIDogXCJcIikgKyB0aGlzLmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGlzIHR5cGUuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgdHlwZSBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBiZSBidWlsdCBkaXJlY3RseVwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuVCA9IFQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgTmFtZXNwYWNlIHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgTmFtZXNwYWNlIG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZHJlbiBpbnNpZGUgdGhlIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIChlLmcuLCBwcm90bzIgb3IgcHJvdG8zKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCBcInByb3RvMlwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmFtZXNwYWNlUHJvdG90eXBlID0gTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lc3BhY2UncyBjaGlsZHJlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuVD19IHR5cGUgRmlsdGVyIHR5cGUgKHJldHVybnMgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZSBvbmx5KS4gRGVmYXVsdHMgdG8gbnVsbCAoYWxsIGNoaWxkcmVuKS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBjaGlsZCBDaGlsZFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY2hpbGQgY2Fubm90IGJlIGFkZGVkIChkdXBsaWNhdGUpXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKG90aGVyID0gdGhpcy5nZXRDaGlsZChjaGlsZC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkICYmIG90aGVyLm5hbWUgIT09IG90aGVyLm9yaWdpbmFsTmFtZSAmJiB0aGlzLmdldENoaWxkKG90aGVyLm9yaWdpbmFsTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIubmFtZSA9IG90aGVyLm9yaWdpbmFsTmFtZTsgLy8gUmV2ZXJ0IHByZXZpb3VzIGZpcnN0IChlZmZlY3RpdmVseSBrZWVwcyBib3RoIG9yaWdpbmFscylcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChjaGlsZC5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjaGlsZC5vcmlnaW5hbE5hbWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgbmFtZSBpbiBuYW1lc3BhY2UgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGQubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgY2hpbGQgYnkgaXRzIG5hbWUgb3IgaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gVGhlIGNoaWxkIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9ySWQgPT09ICdudW1iZXInID8gJ2lkJyA6ICduYW1lJztcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT09IG5hbWVPcklkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlcyBhIHJlZmxlY3Qgb2JqZWN0IGluc2lkZSBvZiB0aGlzIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IHFuIFF1YWxpZmllZCBuYW1lIHRvIHJlc29sdmVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IFRoZSByZXNvbHZlZCB0eXBlIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSB0eXBlb2YgcW4gPT09ICdzdHJpbmcnID8gcW4uc3BsaXQoXCIuXCIpIDogcW4sXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0W2ldID09PSBcIlwiKSB7IC8vIEZ1bGx5IHF1YWxpZmllZCBuYW1lLCBlLmcuIFwiLk15Lk1lc3NhZ2UnXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCB8fCAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5UKSB8fCAoZXhjbHVkZU5vbk5hbWVzcGFjZSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gY2hpbGQ7IGkrKztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBwYXJ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlIHNlYXJjaCB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlc29sdmUocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChwdHIgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwdHI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBpZiBhbnksIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVH0gdCBSZWZsZWN0aW9uIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb3IsIGlmIHRoZXJlIGlzIG5vbmUsIHRoZSBmcW5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLnFuID0gZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IFtdLCBwdHIgPSB0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnVuc2hpZnQocHRyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9PSBudWxsKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbGVuPTE7IGxlbiA8PSBwYXJ0Lmxlbmd0aDsgbGVuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBxbiA9IHBhcnQuc2xpY2UocGFydC5sZW5ndGgtbGVuKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ID09PSB0aGlzLnJlc29sdmUocW4sIHQgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFuLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0LmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLEZ1bmN0aW9ufE9iamVjdD59IFJ1bnRpbWUgbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgdmFyIG5zID0ge307XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1jaGlsZHJlbi5sZW5ndGgsIGNoaWxkOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICBuc1tjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBuYW1lc3BhY2UncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZE9wdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0ID0ge30sXHJcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPWtleXMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW9ucyBhcmUgbm90IHJlc29sdmVkLCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAodmFsIGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb3B0W2tleV0gPSB2YWwuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBvcHRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFJldHVybnMgdGhlIG9wdGlvbiB2YWx1ZSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBhbGwgb3B0aW9ucyBhcmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9uc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnNbbmFtZV0gOiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0Lk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbGVtZW50IGltcGxlbWVudGF0aW9uIHRoYXQgY2hlY2tzIGFuZCBjb252ZXJ0cyB2YWx1ZXMgZm9yIGFcclxuICAgICAgICAgKiBwYXJ0aWN1bGFyIGZpZWxkIHR5cGUsIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW4gRWxlbWVudCByZXByZXNlbnRzIGEgc2luZ2xlIHZhbHVlOiBlaXRoZXIgdGhlIHZhbHVlIG9mIGEgc2luZ3VsYXIgZmllbGQsXHJcbiAgICAgICAgICogb3IgYSB2YWx1ZSBjb250YWluZWQgaW4gb25lIGVudHJ5IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwIGZpZWxkLiBUaGlzXHJcbiAgICAgICAgICogY2xhc3MgZG9lcyBub3QgaW1wbGVtZW50IHRoZXNlIGhpZ2hlci1sZXZlbCBjb25jZXB0czsgaXQgb25seSBlbmNhcHN1bGF0ZXNcclxuICAgICAgICAgKiB0aGUgbG93LWxldmVsIHR5cGVjaGVja2luZyBhbmQgY29udmVyc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19IHR5cGUgUmVzb2x2ZWQgZGF0YSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH0gcmVzb2x2ZWRUeXBlIFJlc29sdmVkIHR5cGUsIGlmIHJlbGV2YW50XHJcbiAgICAgICAgICogKGUuZy4gc3VibWVzc2FnZSBmaWVsZCkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc01hcEtleSBJcyB0aGlzIGVsZW1lbnQgYSBNYXAga2V5PyBUaGUgdmFsdWUgd2lsbCBiZVxyXG4gICAgICAgICAqIGNvbnZlcnRlZCB0byBzdHJpbmcgZm9ybSBpZiBzby5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ludGF4IFN5bnRheCBsZXZlbCBvZiBkZWZpbmluZyBtZXNzYWdlIHR5cGUsIGUuZy4sXHJcbiAgICAgICAgICogcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoaXMgZWxlbWVudCAoZm9yIGVycm9yXHJcbiAgICAgICAgICogbWVzc2FnZXMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCByZXNvbHZlZFR5cGUsIGlzTWFwS2V5LCBzeW50YXgsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IHR5cGUsIGFzIGEgc3RyaW5nIChlLmcuLCBpbnQzMikuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCB0eXBlIHJlZmVyZW5jZSB0byBzdWJtZXNzYWdlIG9yIGVudW0gZGVmaW5pdGlvbiwgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IHJlc29sdmVkVHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGlzIGEgbWFwIGtleS5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzTWFwS2V5ID0gaXNNYXBLZXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIG9mIGRlZmluaW5nIG1lc3NhZ2UgdHlwZSwgZS5nLiwgcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgdGhpcyBlbGVtZW50IChmb3IgZXJyb3IgbWVzc2FnZXMpXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTWFwS2V5ICYmIFByb3RvQnVmLk1BUF9LRVlfVFlQRVMuaW5kZXhPZih0eXBlKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbWFwIGtleSB0eXBlOiBcIiArIHR5cGUubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyBhIChuZXcpIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fSBGaWVsZCB0eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IERlZmF1bHQgdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0RlZmF1bHQodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFByb3RvQnVmLlRZUEVTW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUuZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZGVmYXVsdCB2YWx1ZSBmb3IgdHlwZSBcIit0eXBlLm5hbWUrXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBmaWVsZCBpbiBwcm90bzMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gdGhlIGZpZWxkIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUgPSBta0RlZmF1bHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2VzIGEgTG9uZyBmcm9tIGEgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAqICBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubG93ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUuaGlnaCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnVuc2lnbmVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lIHx8ICcnKSArICh0aGlzLmlzTWFwS2V5ID8gJ21hcCcgOiAndmFsdWUnKSArICcgZWxlbWVudCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBzZXQgZm9yIGFuIGVsZW1lbnQgb2YgdGhpcyB0eXBlIChzaW5ndWxhclxyXG4gICAgICAgICAqIGZpZWxkIG9yIG9uZSBlbGVtZW50IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwKS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gVmVyaWZpZWQsIG1heWJlIGFkanVzdGVkLCB2YWx1ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHZlcmlmaWVkIGZvciB0aGlzIGVsZW1lbnQgc2xvdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3NlbGYudG9TdHJpbmcodHJ1ZSkrXCIgb2YgdHlwZSBcIitzZWxmLnR5cGUubmFtZStcIjogXCIrdmFsK1wiIChcIittc2crXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5zaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAodmFsdWUgPT09IHZhbHVlICYmIHZhbHVlICUgMSAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZXMgTG9uZy5qc1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWtMb25nKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgbnVtYmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiK3ZhbHVlOyAvLyBDb252ZXJ0IFN0cmluZyBvYmplY3QgdG8gc3RyaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci53cmFwKHZhbHVlLCBcImJhc2U2NFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc29sdmVkVHlwZS5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXS5uYW1lID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzW2ldLmlkID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSAncHJvdG8zJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm90bzM6IGp1c3QgbWFrZSBzdXJlIGl0J3MgYW4gaW50ZWdlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDQyOTQ5NjcyOTUgfHwgdmFsdWUgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGluIHJhbmdlIGZvciB1aW50MzJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvMiByZXF1aXJlcyBlbnVtIHZhbHVlcyB0byBiZSB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh2YWx1ZSwgXCJub3QgYSB2YWxpZCBlbnVtIHZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlzbWF0Y2hlZCB0eXBlOiBDb252ZXJ0IHRvIG9iamVjdCAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy9pc3N1ZXMvMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGxldCdzIHRyeSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gYSBrZXktdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlZFR5cGUuY2xhenopKHZhbHVlKTsgLy8gTWF5IHRocm93IGZvciBhIGh1bmRyZWQgb2YgcmVhc29uc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmRlZmluZWQgdHlwZSBcIit0aGlzLnR5cGUrXCIpXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgb24gdGhlIHdpcmUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS5jYWxjdWxhdGVMZW5ndGggPSBmdW5jdGlvbihpZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gMDsgLy8gTm90aGluZyB0byBlbmNvZGVcclxuICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxyXG4gICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSkgOiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUucmVtYWluaW5nKCkpICsgdmFsdWUucmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKChpZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgRmllbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZW5jb2RlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmVuY29kZVZhbHVlID0gZnVuY3Rpb24oaWQsIHZhbHVlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gYnVmZmVyOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91IHVzZSBpbnQzMiBvciBpbnQ2NCBhcyB0aGUgdHlwZSBmb3IgYSBuZWdhdGl2ZSBudW1iZXIsIHRoZSByZXN1bHRpbmcgdmFyaW50IGlzIGFsd2F5cyB0ZW4gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb25nIOKAkyBpdCBpcywgZWZmZWN0aXZlbHksIHRyZWF0ZWQgbGlrZSBhIHZlcnkgbGFyZ2UgdW5zaWduZWQgaW50ZWdlci5cIiAoc2VlICMxMjIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzJaaWdaYWcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgYXMtaXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NFppZ1phZyh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCBzaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJvb2xcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnID8gMCA6ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVlN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUucmVtYWluaW5nKCkrXCIgYnl0ZXMgcmVtYWluaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2T2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJiKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKGlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgb25lIGVsZW1lbnQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFRoZSBmaWVsZCB3aXJlIHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIGZpZWxkIG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm4geyp9IERlY29kZWQgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCB3aXJlVHlwZSwgaWQpIHtcclxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlICE9IHRoaXMudHlwZS53aXJlVHlwZSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB3aXJlIHR5cGUgZm9yIGVsZW1lbnRcIik7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzJaaWdaYWcoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgMzJiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRJbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKS50b1Vuc2lnbmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0WmlnWmFnKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIDY0Yml0IHNpZ25lZFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlICh2YXJpbnQpXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIEJ1aWxkZXIuTWVzc2FnZSNzZXQgd2lsbCBhbHJlYWR5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEZsb2F0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVlN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuY2xvbmUoKTsgLy8gT2Zmc2V0IGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubGltaXQgPSB2YWx1ZS5vZmZzZXQrbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCBuQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCAtMSwgaWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgZGVjb2RlIHR5cGVcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIHRoZSBjYW5vbmljYWwgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTGVnYWwgb25seSB3aGVuIGlzTWFwS2V5IGlzIHRydWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS52YWx1ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFwS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInZhbHVlRnJvbVN0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShwYXJzZUludChzdHIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTG9uZy1iYXNlZCBmaWVsZHMgc3VwcG9ydCBjb252ZXJzaW9ucyBmcm9tIHN0cmluZyBhbHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5VmFsdWUoc3RyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT09IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShzdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgdmFsdWUgZnJvbSB0aGUgY2Fub25pY2FsIGVsZW1lbnQgdHlwZSB0byBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHNob3VsZCBiZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZUZyb21TdHJpbmcodmFsdWVUb1N0cmluZyh2YWwpKWAgcmV0dXJuc1xyXG4gICAgICAgICAqIGEgdmFsdWUgZXF1aXZhbGVudCB0byBgdmVyaWZ5VmFsdWUodmFsKWAgZm9yIGV2ZXJ5IGxlZ2FsIHZhbHVlIG9mIGB2YWxgXHJcbiAgICAgICAgICogYWNjb3JkaW5nIHRvIHRoaXMgZWxlbWVudCB0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtYXkgYmUgdXNlZCB3aGVuIHRoZSBlbGVtZW50IG11c3QgYmUgc3RvcmVkIG9yIHVzZWQgYXMgYSBzdHJpbmcsXHJcbiAgICAgICAgICogZS5nLiwgYXMgYSBtYXAga2V5IG9uIGFuIE9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIExlZ2FsIG9ubHkgd2hlbiBpc01hcEtleSBpcyB0cnVlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyBmb3JtIG9mIHRoZSB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidmFsdWVUb1N0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoXCJiaW5hcnlcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbGVtZW50ID0gRWxlbWVudDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcGFyZW50IFBhcmVudCBtZXNzYWdlIG9yIG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzR3JvdXAgYHRydWVgIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXAsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTWVzc2FnZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuc2lvbnMgcmFuZ2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVudGltZSBtZXNzYWdlIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzpQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UpfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pc0dyb3VwID0gISFpc0dyb3VwO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjYWNoZWQgY29sbGVjdGlvbnMgYXJlIHVzZWQgdG8gZWZmaWNpZW50bHkgaXRlcmF0ZSBvdmVyIG9yIGxvb2sgdXAgZmllbGRzIHdoZW4gZGVjb2RpbmcuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FjaGVkIGZpZWxkcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9BcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlZCBmaWVsZHMgYnkgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxudW1iZXIsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/T2JqZWN0LjxzdHJpbmcsIVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeU5hbWUgPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1lc3NhZ2VQcm90b3R5cGUgPSBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gTWVzc2FnZSBjbGFzc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcnVudGltZSBNZXNzYWdlIGNsYXNzIGluIGl0cyBvd24gc2NvcGVcclxuICAgICAgICAgICAgdmFyIGNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvbmVvZnMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQGNsYXNzIEJhcmVib25lIG9mIGFsbCBydW50aW1lIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj58c3RyaW5nfSB2YWx1ZXMgUHJlc2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFyX2FyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHZpcnR1YWwgb25lb2YgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1vbmVvZnMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvbmVvZnNbaV0ubmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBmaWVsZHMgYW5kIHNldCBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wLCBrPWZpZWxkcy5sZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5yZXBlYXRlZCA/IFtdIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZC5tYXAgPyBuZXcgUHJvdG9CdWYuTWFwKGZpZWxkKSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpZWxkLnJlcXVpcmVkIHx8IFQuc3ludGF4ID09PSAncHJvdG8zJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHZhbHVlcyAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IF9hbm90aGVyXyBNZXNzYWdlICovICh0eXBlb2YgdmFsdWVzLmVuY29kZSAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZXMgaW5zdGFuY2VvZiBNZXNzYWdlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgcmVwZWF0ZWQgZmllbGQgKi8gIUFycmF5LmlzQXJyYXkodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgTWFwICovICEodmFsdWVzIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgQnl0ZUJ1ZmZlciAqLyAhQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBMb25nICovICEoUHJvdG9CdWYuTG9uZyAmJiB2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5Mb25nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYXJndW1lbnRzLCBpbiBkZWNsYXJhdGlvbiBvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTAsIGs9YXJndW1lbnRzLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUgPSBhcmd1bWVudHNbaV0pICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCB2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlUHJvdG90eXBlID0gTWVzc2FnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpOyAvLyBNYXkgdGhyb3cgaWYgaXQncyBhbiBlbnVtIG9yIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIHJlcGVhdGVkIGZpZWxkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGFkZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS4kYWRkID0gTWVzc2FnZVByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IU9iamVjdC48c3RyaW5nLCo+fSBrZXlPck9iaiBTdHJpbmcga2V5IG9yIHBsYWluIG9iamVjdCBob2xkaW5nIG11bHRpcGxlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoKnxib29sZWFuKT19IHZhbHVlIFZhbHVlIHRvIHNldCBpZiBrZXkgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgZm9yIGFuIGFjdHVhbCBmaWVsZCAvIHByb3BlciB2YWx1ZSB0eXBlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5T3JPYmosIHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlPck9iaiAmJiB0eXBlb2Yga2V5T3JPYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQXNzZXJ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlrZXkgaW4ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5T3JPYmouaGFzT3duUHJvcGVydHkoaWtleSkgJiYgdHlwZW9mICh2YWx1ZSA9IGtleU9yT2JqW2lrZXldKSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGlrZXksIHZhbHVlLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5T3JPYmpdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5T3JPYmorXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXlPck9iaitcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gKHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5T3JPYmpdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdOyAvLyBWaXJ0dWFsIGZpZWxkIHJlZmVyZW5jZXMgY3VycmVudGx5IHNldCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQub25lb2YubmFtZV0gPSBmaWVsZC5uYW1lOyAvLyBQb2ludCB2aXJ0dWFsIGZpZWxkIGF0IHRoaXMgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvKiB2YWx1ZSA9PT0gbnVsbCAmJiAqL2N1cnJlbnRGaWVsZCA9PT0ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gbnVsbDsgLy8gQ2xlYXIgdmlydHVhbCBmaWVsZCAoY3VycmVudCBmaWVsZCBleHBsaWNpdGx5IGNsZWFyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIGZvciBbQGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHNldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygqfGJvb2xlYW4pPX0gdmFsdWUgVmFsdWUgdG8gc2V0IGlmIGtleSBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLiRzZXQgPSBNZXNzYWdlUHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuJGdldCA9IE1lc3NhZ2VQcm90b3R5cGUuZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHNldHRlcnMgZm9yIGV4dGVuc2lvbiBmaWVsZHMgYXMgdGhlc2UgYXJlIG5hbWVkIGJ5IHRoZWlyIGZxblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChULmJ1aWxkZXIub3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0W1NvbWVWYWx1ZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhfW2EtekEtWl0pL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnXycsJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lID0gTmFtZS5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV0gRklYTUU6IERvIHdlIHJlYWxseSBuZWVkIHRoZXNlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgZmllbGQncyB1bmJvdW5kIHNldHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBmaWVsZCdzIHVuYm91bmQgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwic2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJzZXRcIitOYW1lXSA9IHNldHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcInNldF9cIituYW1lKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBhbm90aGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgdGhlIHZhbHVlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wic2V0X1wiK25hbWVdID0gc2V0dGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwiZ2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wiZ2V0XCIrTmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFQuZ2V0Q2hpbGQoXCJnZXRfXCIrbmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJnZXRfXCIrbmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW4tL2RlY29kaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRlbmNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9WZXJpZnkgV2hldGhlciB0byBub3QgdmVyaWZ5IGZpZWxkIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ5dGVCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBhIEJ5dGVCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVmVyaWZ5ID0gYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFQuZW5jb2RlKHRoaXMsIGJ1ZmZlci5MRSgpLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOZXcgPyBidWZmZXIuZmxpcCgpIDogYnVmZmVyKS5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHNwZWNpZmllZCBkYXRhIHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gZGF0YSBEYXRhIHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShkYXRhKS5lbmNvZGUoYnVmZmVyLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBlbmMsIG5vVmVyaWZ5KS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoZW5jLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9BcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9BcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlUHJvdG90eXBlLmVuY29kZUFCO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQsIG5vdCBydW5uaW5nIHVuZGVyIG5vZGUuanMgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICogIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0J1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CYXNlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgYmFzZTY0IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlNjQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICogIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9IZXhcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3Qgb3IgZmllbGQgdmFsdWUgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNsb25lXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmFyeUFzQmFzZTY0IFdoZXRoZXIgdG8gaW5jbHVkZSBiaW5hcnkgZGF0YSBhcyBiYXNlNjQgc3RyaW5ncyBvciBhcyBhIGJ1ZmZlciBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UPX0gcmVzb2x2ZWRUeXBlIFRoZSByZXNvbHZlZCBmaWVsZCB0eXBlIGlmIGEgZmllbGRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBDbG9uZWQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xvbmVSYXcob2JqLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIHJlc29sdmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBlbnVtIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFR5cGUgJiYgcmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFByb3RvQnVmLlJlZmxlY3QuRW51bS5nZXROYW1lKHJlc29sdmVkVHlwZS5vYmplY3QsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzLXRocm91Z2ggc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bGwuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBCeXRlQnVmZmVycyB0byByYXcgYnVmZmVyIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeUFzQmFzZTY0ID8gb2JqLnRvQmFzZTY0KCkgOiBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IExvbmdzIHRvIHByb3BlciBvYmplY3RzIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZy5pc0xvbmcob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdzQXNTdHJpbmdzID8gb2JqLnRvU3RyaW5nKCkgOiBQcm90b0J1Zi5Mb25nLmZyb21WYWx1ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2tdID0gY2xvbmVSYXcodiwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzLCByZXNvbHZlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbWFwcyB0byBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXQgPSBvYmouZW50cmllcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gaXQubmV4dCgpOyAhZS5kb25lOyBlID0gaXQubmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbb2JqLmtleUVsZW0udmFsdWVUb1N0cmluZyhlLnZhbHVlWzBdKV0gPSBjbG9uZVJhdyhlLnZhbHVlWzFdLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIG9iai52YWx1ZUVsZW0ucmVzb2x2ZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iai4kdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIChmaWVsZCA9IHR5cGUuZ2V0Q2hpbGQoaSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIGZpZWxkLnJlc29sdmVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlJ3MgcmF3IHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBiaW5hcnlBc0Jhc2U2NCBXaGV0aGVyIHRvIGluY2x1ZGUgYmluYXJ5IGRhdGEgYXMgYmFzZTY0IHN0cmluZ3MgaW5zdGVhZCBvZiBCdWZmZXJzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvbmdzQXNTdHJpbmdzIFdoZXRoZXIgdG8gZW5jb2RlIGxvbmdzIGFzIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWJpbmFyeUFzQmFzZTY0LCAhIWxvbmdzQXNTdHJpbmdzLCB0aGlzLiR0eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZSB0byBKU09OLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVKU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVJhdyh0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJpbmFyeS1hcy1iYXNlNjQgKi8gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsb25ncy1hcy1zdHJpbmdzICovIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSByZW1haW5pZyBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIGxlbmd0aCwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMgPSBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuTEUoKSwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgdmFyaW50MzIgbGVuZ3RoLWRlbGltaXRlZCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIgb3Igc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhQnVmZmVyfHN0cmluZ30gYnVmZmVyIEJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2Ugb3IgYG51bGxgIGlmIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGF2YWlsYWJsZSB5ZXRcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyLCBlbmMgPyBlbmMgOiBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcik7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmID0gYnVmZmVyLm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IG9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuc2xpY2UoYnVmZmVyLm9mZnNldCwgYnVmZmVyLm9mZnNldCArIGxlbikuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlNjQgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUhleCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiaGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUpTT05cclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcclxuICAgICAgICAgICAgICAgICAqIG1pc3NpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlSlNPTiA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShKU09OLnBhcnNlKHN0cikpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVdGlsaXR5XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIi5GdWxseS5RdWFsaWZpZWQuTWVzc2FnZU5hbWVcIlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLiRvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uc1M7IC8vIGNjIG5lZWRzIHRoaXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuJHR5cGVcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJHR5cGVTO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UsICckb3B0aW9ucycsIHsgXCJ2YWx1ZVwiOiBULmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IE1lc3NhZ2VbXCIkb3B0aW9uc1wiXSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZVByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgIH0pKFByb3RvQnVmLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXRpYyBlbnVtcyBhbmQgcHJvdG90eXBlZCBzdWItbWVzc2FnZXMgLyBjYWNoZWQgY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGk8azsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbnVtIHx8IGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZSB8fCBjaGlsZCBpbnN0YW5jZW9mIFNlcnZpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhenouaGFzT3duUHJvcGVydHkoY2hpbGQubmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBvdmVycmlkZSBzdGF0aWMgcHJvcGVydHkgJ1wiK2NoaWxkLm5hbWUrXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXp6W2NoaWxkLm5hbWVdID0gY2hpbGQuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmJ1aWxkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzLnB1c2goY2hpbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWRbY2hpbGQuaWRdID0gY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lW2NoaWxkLm5hbWVdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5PbmVPZikgJiYgIShjaGlsZCBpbnN0YW5jZW9mIEV4dGVuc2lvbikpIC8vIE5vdCBidWlsdFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMuY2hpbGRyZW5baV0udG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6eiA9IGNsYXp6O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgYSBydW50aW1lIG1lc3NhZ2UncyBjb250ZW50cyB0byB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gd3JpdGUgdG9cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub1ZlcmlmeSBXaGV0aGVyIHRvIG5vdCB2ZXJpZnkgZmllbGQgdmFsdWVzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZyBvciB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBmb3IgYW5vdGhlciByZWFzb25cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihtZXNzYWdlLCBidWZmZXIsIG5vVmVyaWZ5KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZE1pc3NpbmcgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmllbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoLCB2YWw7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuX2ZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2VbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVxdWlyZWQgJiYgdmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRNaXNzaW5nID0gZmllbGQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5lbmNvZGUobm9WZXJpZnkgPyB2YWwgOiBmaWVsZC52ZXJpZnlWYWx1ZSh2YWwpLCBidWZmZXIsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWVsZE1pc3NpbmcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZE1pc3NpbmcpO1xyXG4gICAgICAgICAgICAgICAgZXJyW1wiZW5jb2RlZFwiXSA9IGJ1ZmZlcjsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICB0aHJvdyhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbj0wLCBpPTAsIGs9dGhpcy5fZmllbGRzLmxlbmd0aCwgZmllbGQsIHZhbDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gbWVzc2FnZVtmaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSBmaWVsZC5jYWxjdWxhdGUodmFsLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTa2lwcyBhbGwgZGF0YSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZ3JvdXAgaGFzIGJlZW4gcmVhY2hlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRJZCBFeHBlY3RlZCBHUk9VUEVORCBpZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IGJ1ZiBCeXRlQnVmZmVyXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBhIHZhbHVlIGFzIGJlZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiB0aGUgZW5kIGhhcyBiZWVuIHJlYWNoZWRcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgd2Fzbid0IHBvc3NpYmxlIHRvIGZpbmQgdGhlIGVuZCBvZiB0aGUgZ3JvdXAgKGJ1ZmZlciBvdmVycnVuIG9yIGVuZCB0YWcgbWlzbWF0Y2gpXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gc2tpcFRpbGxHcm91cEVuZChleHBlY3RlZElkLCBidWYpIHtcclxuICAgICAgICAgICAgdmFyIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKSwgLy8gVGhyb3dzIG9uIE9PQlxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3LFxyXG4gICAgICAgICAgICAgICAgaWQgPSB0YWcgPj4+IDM7XHJcbiAgICAgICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZG8gdGFnID0gYnVmLnJlYWRVaW50OCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGFnICYgMHg4MCkgPT09IDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKTsgLy8gcmVhZHMgdGhlIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gdGFnOyAgICAgICAgLy8gc2tpcHMgbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGV4cGVjdGVkSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBHUk9VUEVORCBhZnRlciB1bmtub3duIGdyb3VwOiBcIitpZCtcIiAoXCIrZXhwZWN0ZWRJZCtcIiBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBpbiB1bmtub3duIGdyb3VwIFwiK2V4cGVjdGVkSWQrXCI6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYW4gZW5jb2RlZCBtZXNzYWdlIGFuZCByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHJlbWFpbmluZyBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZXhwZWN0ZWRHcm91cEVuZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbGVuZ3RoLCBleHBlY3RlZEdyb3VwRW5kSWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgKHRoaXMuY2xhenopKCksXHJcbiAgICAgICAgICAgICAgICB0YWcsIHdpcmVUeXBlLCBpZCwgZmllbGQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgc3RhcnQrbGVuZ3RoIHx8IChsZW5ndGggPT09IC0xICYmIGJ1ZmZlci5yZW1haW5pbmcoKSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0YWcgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gZXhwZWN0ZWRHcm91cEVuZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgPSB0aGlzLl9maWVsZHNCeUlkW2lkXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIm1lc3NhZ2VzIGNyZWF0ZWQgYnkgeW91ciBuZXcgY29kZSBjYW4gYmUgcGFyc2VkIGJ5IHlvdXIgb2xkIGNvZGU6IG9sZCBiaW5hcmllcyBzaW1wbHkgaWdub3JlIHRoZSBuZXcgZmllbGQgd2hlbiBwYXJzaW5nLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1ZmZlcikpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIHVua25vd24gZmllbGQgXCIraWQrXCIgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIiNkZWNvZGU6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0ucHVzaChmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcikpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5dmFsID0gZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXS5zZXQoa2V5dmFsWzBdLCBrZXl2YWxbMV0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSBtc2dbZmllbGQub25lb2YubmFtZV07IC8vIFZpcnR1YWwgZmllbGQgcmVmZXJlbmNlcyBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2N1cnJlbnRGaWVsZF0gPSBudWxsOyAvLyBDbGVhciBjdXJyZW50bHkgc2V0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5vbmVvZi5uYW1lXSA9IGZpZWxkLm5hbWU7IC8vIFBvaW50IHZpcnR1YWwgZmllbGQgYXQgdGhpcyBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudCBhbmQgc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25hbCBmaWVsZHMgdGhhdCBhcmUgbm90XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9maWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnW2ZpZWxkLm5hbWVdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSBcInByb3RvM1wiKSB7IC8vIFByb3RvMyBzZXRzIGRlZmF1bHQgdmFsdWVzIGJ5IHNwZWNpZmljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiOiBcIiArIGZpZWxkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJbXCJkZWNvZGVkXCJdID0gbXNnOyAvLyBTdGlsbCBleHBvc2Ugd2hhdCB3ZSBnb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFByb3RvQnVmLnBvcHVsYXRlRGVmYXVsdHMgJiYgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBGaWVsZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IGtleXR5cGUgS2V5IGRhdGEgdHlwZSwgaWYgYW55LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZj19IG9uZW9mIEVuY2xvc2luZyBPbmVPZlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEZpZWxkID0gZnVuY3Rpb24oYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwga2V5dHlwZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMsIG9uZW9mLCBzeW50YXgpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2UuRmllbGRcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcXVpcmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PT0gXCJyZXF1aXJlZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVwZWF0ZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBtYXAgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gcnVsZSA9PT0gXCJtYXBcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIGtleSB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWZcclxuICAgICAgICAgICAgICogdHlwZSBpZiByZXNvbHZlZC4gVmFsaWQgb25seSBpZiB0aGlzLm1hcCA9PT0gdHJ1ZSwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn18bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlUeXBlID0ga2V5dHlwZSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgdHlwZS4gVHlwZSByZWZlcmVuY2Ugc3RyaW5nIGlmIHVucmVzb2x2ZWQsIHByb3RvYnVmIHR5cGUgaWZcclxuICAgICAgICAgICAgICogcmVzb2x2ZWQuIEluIGEgbWFwIGZpZWxkLCB0aGlzIGlzIHRoZSB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHR5cGUgcmVmZXJlbmNlIGluc2lkZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVHxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIG1lc3NhZ2UgZmllbGQgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqIEBkaWN0XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NpbmcgT25lT2YuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9uZW9mID0gb25lb2YgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCAncHJvdG8yJztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IHRoaXMubmFtZTsgLy8gVXNlZCB0byByZXZlcnQgY2FtZWxjYXNlIHRyYW5zZm9ybWF0aW9uIG9uIG5hbWluZyBjb2xsaXNpb25zXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCBpbXBsZW1lbnRhdGlvbi4gQ3JlYXRlZCBpbiBidWlsZCgpIGFmdGVyIHR5cGVzIGFyZSByZXNvbHZlZC5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLkVsZW1lbnR9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2V5IGVsZW1lbnQgaW1wbGVtZW50YXRpb24sIGZvciBtYXAgZmllbGRzLiBDcmVhdGVkIGluIGJ1aWxkKCkgYWZ0ZXJcclxuICAgICAgICAgICAgICogdHlwZXMgYXJlIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuRWxlbWVudH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkZXIub3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gJiYgISh0aGlzIGluc3RhbmNlb2YgTWVzc2FnZS5FeHRlbnNpb25GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBQcm90b0J1Zi5VdGlsLnRvQ2FtZWxDYXNlKHRoaXMubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRmllbGRQcm90b3R5cGUgPSBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBmaWVsZC5cclxuICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcy50eXBlLCB0aGlzLnJlc29sdmVkVHlwZSwgZmFsc2UsIHRoaXMuc3ludGF4LCB0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQgPSBuZXcgRWxlbWVudCh0aGlzLmtleVR5cGUsIHVuZGVmaW5lZCwgdHJ1ZSwgdGhpcy5zeW50YXgsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbiBwcm90bzMsIGZpZWxkcyBkbyBub3QgaGF2ZSBmaWVsZCBwcmVzZW5jZSwgYW5kIGV2ZXJ5IGZpZWxkIGlzIHNldCB0b1xyXG4gICAgICAgICAgICAvLyBpdHMgdHlwZSdzIGRlZmF1bHQgdmFsdWUgKFwiXCIsIDAsIDAuMCwgb3IgZmFsc2UpLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmICF0aGlzLnJlcGVhdGVkICYmICF0aGlzLm1hcClcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkZWZhdWx0IHZhbHVlcyBhcmUgcHJlc2VudCB3aGVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNbJ2RlZmF1bHQnXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodGhpcy5vcHRpb25zWydkZWZhdWx0J10pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIHNldCBmb3IgdGhpcyBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgdmFsdWUgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgKiBAcmV0dXJuIHsqfSBWZXJpZmllZCwgbWF5YmUgYWRqdXN0ZWQsIHZhbHVlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0IGZvciB0aGlzIGZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICBza2lwUmVwZWF0ZWQgPSBza2lwUmVwZWF0ZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCh2YWwsIG1zZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIitzZWxmLnRvU3RyaW5nKHRydWUpK1wiIG9mIHR5cGUgXCIrc2VsZi50eXBlLm5hbWUrXCI6IFwiK3ZhbCtcIiAoXCIrbXNnK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsgLy8gTlVMTCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZWRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmIHRoaXMudHlwZSAhPT0gUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInByb3RvMyBmaWVsZCB3aXRob3V0IGZpZWxkIHByZXNlbmNlIGNhbm5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkICYmICFza2lwUmVwZWF0ZWQpIHsgLy8gUmVwZWF0ZWQgdmFsdWVzIGFzIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLmVsZW1lbnQudmVyaWZ5VmFsdWUodmFsdWVbaV0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwICYmICFza2lwUmVwZWF0ZWQpIHsgLy8gTWFwIHZhbHVlcyBhcyBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhIE1hcCwgYXR0ZW1wdCB0byBjb252ZXJ0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIFByb3RvQnVmLk1hcCBvciByYXcgb2JqZWN0IGZvciBtYXAgZmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvdG9CdWYuTWFwKHRoaXMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFsbCBub24tcmVwZWF0ZWQgZmllbGRzIGV4cGVjdCBubyBhcnJheVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0ZWQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJubyBhcnJheSBleHBlY3RlZFwiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmVyaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZmllbGQgd2lsbCBoYXZlIGEgcHJlc2VuY2Ugb24gdGhlIHdpcmUgZ2l2ZW4gaXRzXHJcbiAgICAgICAgICogdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWZXJpZmllZCBmaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaWVsZCB3aWxsIGJlIHByZXNlbnQgb24gdGhlIHdpcmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWVsZFByb3RvdHlwZS5oYXNXaXJlUHJlc2VuY2UgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggIT09ICdwcm90bzMnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uZW9mICYmIG1lc3NhZ2VbdGhpcy5vbmVvZi5uYW1lXSA9PT0gdGhpcy5uYW1lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sb3cgIT09IDAgfHwgdmFsdWUuaGlnaCAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAuMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucmVtYWluaW5nKCkgPiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIGZpZWxkIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmVyaWZpZWQgZmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBlbmNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBidWZmZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBVbnJlc29sdmVkIHR5cGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7IC8vIE9wdGlvbmFsIG9taXR0ZWRcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJPbmx5IHJlcGVhdGVkIGZpZWxkcyBvZiBwcmltaXRpdmUgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCwgb3IgNjQtYml0IHdpcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlcykgY2FuIGJlIGRlY2xhcmVkICdwYWNrZWQnLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiQWxsIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmllbGQgYXJlIHBhY2tlZCBpbnRvIGEgc2luZ2xlIGtleS12YWx1ZSBwYWlyIHdpdGggd2lyZSB0eXBlIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGxlbmd0aC1kZWxpbWl0ZWQpLiBFYWNoIGVsZW1lbnQgaXMgZW5jb2RlZCB0aGUgc2FtZSB3YXkgaXQgd291bGQgYmUgbm9ybWFsbHksIGV4Y2VwdCB3aXRob3V0IGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFnIHByZWNlZGluZyBpdC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmVuc3VyZUNhcGFjaXR5KGJ1ZmZlci5vZmZzZXQgKz0gMSk7IC8vIFdlIGRvIG5vdCBrbm93IHRoZSBsZW5ndGggeWV0LCBzbyBsZXQncyBhc3N1bWUgYSB2YXJpbnQgb2YgbGVuZ3RoIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldDsgLy8gUmVtZW1iZXIgd2hlcmUgdGhlIGNvbnRlbnRzIGJlZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmVuY29kZVZhbHVlKHRoaXMuaWQsIHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLm9mZnNldC1zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmludExlbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHsgLy8gV2UgbmVlZCB0byBtb3ZlIHRoZSBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKHN0YXJ0LCBidWZmZXIub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHZhcmludExlbi0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIobGVuLCBzdGFydC12YXJpbnRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91ciBtZXNzYWdlIGRlZmluaXRpb24gaGFzIHJlcGVhdGVkIGVsZW1lbnRzICh3aXRob3V0IHRoZSBbcGFja2VkPXRydWVdIG9wdGlvbiksIHRoZSBlbmNvZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgaGFzIHplcm8gb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2l0aCB0aGUgc2FtZSB0YWcgbnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWVbaV0sIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIG91dCBlYWNoIG1hcCBlbnRyeSBhcyBhIHN1Ym1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2YWwsIGtleSwgbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHN1Ym1lc3NhZ2UgKGtleSwgdmFsKSBwYWlyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5RWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMSwga2V5KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCgyIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDIsIHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJtZXNzYWdlIHdpdGggd2lyZSB0eXBlIG9mIGxlbmd0aC1kZWxpbWl0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihsZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBrZXkgYW5kIHZhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuZW5jb2RlVmFsdWUoMSwga2V5LCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigoMiA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSgyLCB2YWwsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1dpcmVQcmVzZW5jZSh2YWx1ZSwgbWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGZpZWxkJ3MgdmFsdWUgb24gdGhlIG5ldHdvcmsgbGV2ZWwuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWVsZFByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBVbnJlc29sdmVkIHR5cGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBPcHRpb25hbCBvbWl0dGVkXHJcbiAgICAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG5pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiYgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUy5pbmRleE9mKHRoaXMudHlwZS53aXJlVHlwZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSArPSB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKHRoaXMuaWQsIHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG5pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBuaTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgodGhpcy5pZCwgdmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIG1hcCBlbnRyeSBiZWNvbWVzIGEgc3VibWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5LCBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgc3VibWVzc2FnZSAoa2V5LCB2YWwpIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMSA8PCAzKSB8IHRoaXMua2V5VHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgxLCBrZXkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMiwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXaXJlUHJlc2VuY2UodmFsdWUsIG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCh0aGlzLmlkLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIExlYWRpbmcgd2lyZSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBSZXBlYXRlZCBXaGV0aGVyIHRvIHNraXAgdGhlIHJlcGVhdGVkIGNoZWNrIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZTogYXJyYXkgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMsIFtrZXksIHZhbHVlXSBmb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICBtYXAgZmllbGRzLCBvciBhbiBpbmRpdmlkdWFsIHZhbHVlIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHdpcmVUeXBlLCBidWZmZXIsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGV4cGVjdCB3aXJlVHlwZSB0byBtYXRjaCB0aGUgdW5kZXJseWluZyB0eXBlJ3Mgd2lyZVR5cGUgdW5sZXNzIHdlIHNlZVxyXG4gICAgICAgICAgICAvLyBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZCwgb3IgdW5sZXNzIHRoaXMgaXMgYSBtYXAgZmllbGQuXHJcbiAgICAgICAgICAgIHZhciB3aXJlVHlwZU9LID1cclxuICAgICAgICAgICAgICAgICghdGhpcy5tYXAgJiYgd2lyZVR5cGUgPT0gdGhpcy50eXBlLndpcmVUeXBlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFza2lwUmVwZWF0ZWQgJiYgdGhpcy5yZXBlYXRlZCAmJiB0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiZcclxuICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLm1hcCAmJiB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgIGlmICghd2lyZVR5cGVPSylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIGZpZWxkIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlK1wiIChcIit0aGlzLnR5cGUud2lyZVR5cGUrXCIgZXhwZWN0ZWQpXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSAmJiB0aGlzLnJlcGVhdGVkICYmIHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIub2Zmc2V0ICsgbkJ5dGVzOyAvLyBMaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLm9mZnNldCA8IG5CeXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZWNvZGUodGhpcy50eXBlLndpcmVUeXBlLCBidWZmZXIsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB2YWx1ZSBvdGhlcndpc2UuLi5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIG1hcHMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvbmUgKGtleSwgdmFsdWUpIHN1Ym1lc3NhZ2UsIGFuZCByZXR1cm4gW2tleSwgdmFsdWVdXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLmtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgb2YgYnl0ZXMgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK25CeXRlcytcIiByZXF1aXJlZCBidXQgZ290IG9ubHkgXCIrYnVmZmVyLnJlbWFpbmluZygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBzdWItYnVmZmVyIG9mIHRoaXMga2V5L3ZhbHVlIHN1Ym1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHZhciBtc2didWYgPSBidWZmZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIG1zZ2J1Zi5saW1pdCA9IG1zZ2J1Zi5vZmZzZXQgKyBuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobXNnYnVmLnJlbWFpbmluZygpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBtc2didWYucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlFbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZWxlbWVudC5kZWNvZGUobXNnYnVmLCB3aXJlVHlwZSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB0YWcgaW4gbWFwIGZpZWxkIGtleS92YWx1ZSBzdWJtZXNzYWdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2luZ3VsYXIgYW5kIG5vbi1wYWNrZWQgcmVwZWF0ZWQgZmllbGQgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmRlY29kZShidWZmZXIsIHdpcmVUeXBlLCB0aGlzLmlkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCA9IEZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgRXh0ZW5zaW9uRmllbGQuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFeHRlbnNpb25GaWVsZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIEZpZWxkLmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgLyoga2V5dHlwZSA9ICovIG51bGwsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbnNpb24gcmVmZXJlbmNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9ufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIEZpZWxkXHJcbiAgICAgICAgRXh0ZW5zaW9uRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA9IEV4dGVuc2lvbkZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgT25lT2YuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZU9mIG5hbWVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgT25lT2YgPSBmdW5jdGlvbihidWlsZGVyLCBtZXNzYWdlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBtZXNzYWdlLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQ+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuT25lT2ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLk9uZU9mID0gT25lT2Y7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRW51bS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IFJlZmxlY3Qgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgRW51bSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBzeW50YXggVGhlIHN5bnRheCBsZXZlbCAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVudW0gPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJ1bnRpbWUgZW51bSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fG51bGx9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgbmFtZSBvZiBhbiBlbnVtIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuRW51bX0gZW5tIFJ1bnRpbWUgZW51bVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBFbnVtIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgez9zdHJpbmd9IE5hbWUgb3IgYG51bGxgIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW0uZ2V0TmFtZSA9IGZ1bmN0aW9uKGVubSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbm0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGtleTsgaTxrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVubVtrZXkgPSBrZXlzW2ldXSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRW51bVByb3RvdHlwZSA9IEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoaXMgZW51bSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYnVpbGQgV2hldGhlciB0byByZWJ1aWxkIG9yIG5vdCwgZGVmYXVsdHMgdG8gZmFsc2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW1Qcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdCAmJiAhcmVidWlsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdDtcclxuICAgICAgICAgICAgdmFyIGVubSA9IG5ldyBQcm90b0J1Zi5CdWlsZGVyLkVudW0oKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oRW51bS5WYWx1ZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz12YWx1ZXMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGVubVt2YWx1ZXNbaV1bJ25hbWUnXV0gPSB2YWx1ZXNbaV1bJ2lkJ107XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW5tLCAnJG9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0aGlzLmJ1aWxkT3B0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID0gZW5tO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbnVtID0gRW51bTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtIFZhbHVlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkVudW19IGVubSBFbnVtIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZhbHVlID0gZnVuY3Rpb24oYnVpbGRlciwgZW5tLCBuYW1lLCBpZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgZW5tLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtLlZhbHVlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIGVudW0gdmFsdWUgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICBWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LkVudW0uVmFsdWUgPSBWYWx1ZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXh0ZW5zaW9uIChmaWVsZCkuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb25cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkfSBmaWVsZCBFeHRlbnNpb24gZmllbGRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRXh0ZW5zaW9uID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lLCBmaWVsZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbmRlZCBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgIEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcnZpY2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSByb290IFJvb3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHJvb3QsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgYnVpbGRlciwgcm9vdCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWx0IHJ1bnRpbWUgc2VydmljZSBjbGFzcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlKX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNlcnZpY2VQcm90b3R5cGUgPSBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgc2VydmljZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90XHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFNlcnZpY2UgY2xhc3NcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNlcnZpY2VQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xheno7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJ1bnRpbWUgU2VydmljZSBjbGFzcyBpbiBpdHMgb3duIHNjb3BlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgU2VydmljZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKT19IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uIHJlY2VpdmluZyB0aGUgbWV0aG9kIG5hbWUgYW5kIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgc2VydmljZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJwY0ltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2VydmljZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjcnBjSW1wbFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHshZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGwgfHwgZnVuY3Rpb24obmFtZSwgbXNnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgYSB1c2VyIGhhcyB0byBpbXBsZW1lbnQ6IEEgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSwgdGhlIGFjdHVhbCBtZXNzYWdlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgKHR5cGUgY2hlY2tlZCkgYW5kIHRoZSBjYWxsYmFjayB0aGF0J3MgZWl0aGVyIHByb3ZpZGVkIHdpdGggdGhlIGVycm9yIGFzIGl0cyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBvciBudWxsIGFuZCB0aGUgYWN0dWFsIHJlc3BvbnNlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy93aWtpL1NlcnZpY2VzXCIpKSwgMCk7IC8vIE11c3QgYmUgYXN5bmMhXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBTZXJ2aWNlUHJvdG90eXBlID0gU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGdpdmVuIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5bTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBpbnN0YW5jZSdzIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNbTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8Qnl0ZUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nKT0pfSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmdcclxuICAgICAgICAgICAgICAgICAqICB0aGUgZXJyb3IgaWYgYW55IGFuZCB0aGUgcmVzcG9uc2UgZWl0aGVyIGFzIGEgcHJlLXBhcnNlZCBtZXNzYWdlIG9yIGFzIGl0cyByYXcgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJwYyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cnBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmljZSNNZXRob2QobWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2VQcm90b3R5cGVbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBnaXZlbiBhcyBhIGJ1ZmZlciwgZGVjb2RlIHRoZSByZXF1ZXN0LiBXaWxsIHRocm93IGEgVHlwZUVycm9yIGlmIG5vdCBhIHZhbGlkIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY2xhenouZGVjb2RlKEJ5dGVCdWZmZXIud3JhcChyZXEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcSA9PT0gbnVsbCB8fCB0eXBlb2YgcmVxICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGFyZ3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IG5ldyBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eihyZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbChtZXRob2QuZnFuKCksIHJlcSwgZnVuY3Rpb24oZXJyLCByZXMpIHsgLy8gQXNzdW1lcyB0aGF0IHRoaXMgaXMgcHJvcGVybHkgYXN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2FsZXNjZSB0byBlbXB0eSBzdHJpbmcgd2hlbiBzZXJ2aWNlIHJlc3BvbnNlIGhhcyBlbXB0eSBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZXMgPSBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenouZGVjb2RlKHJlcyk7IH0gY2F0Y2ggKG5vdEFCdWZmZXIpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJJbGxlZ2FsIHJlc3BvbnNlIHR5cGUgcmVjZWl2ZWQgaW4gc2VydmljZSBtZXRob2QgXCIrIFQubmFtZStcIiNcIittZXRob2QubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgZXJyKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2aWNlLk1ldGhvZChycGNJbXBsLCBtZXNzYWdlLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihycGNJbXBsLCByZXEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VydmljZShycGNJbXBsKVttZXRob2QubmFtZV0ocmVxLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBtZXRob2QuYnVpbGRPcHQoKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlUHJvdG90eXBlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVttZXRob2QubmFtZV1bXCIkb3B0aW9uc1wiXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KShycGNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNlcnZpY2Ugb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS4kb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnNTOyAvLyBjYyBuZWVkcyB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjJG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICRvcHRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLiR0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlUztcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSMkdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciAkdHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBULmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbXCIkb3B0aW9uc1wiXSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VydmljZTtcclxuXHJcbiAgICAgICAgICAgIH0pKFByb3RvQnVmLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuU2VydmljZSA9IFNlcnZpY2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic3RyYWN0IHNlcnZpY2UgbWV0aG9kLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlfSBzdmMgU2VydmljZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBNZXRob2QgPSBmdW5jdGlvbihidWlsZGVyLCBzdmMsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHN2YywgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5NZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBNZXRob2RQcm90b3R5cGUgPSBNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbWV0aG9kJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kI2J1aWxkT3B0XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWV0aG9kUHJvdG90eXBlLmJ1aWxkT3B0ID0gTmFtZXNwYWNlUHJvdG90eXBlLmJ1aWxkT3B0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LlNlcnZpY2UuTWV0aG9kID0gTWV0aG9kO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSUEMgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBSZXNwb25zZSBtZXNzYWdlIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVlc3Rfc3RyZWFtIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZXNwb25zZV9zdHJlYW0gV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUlBDTWV0aG9kID0gZnVuY3Rpb24oYnVpbGRlciwgc3ZjLCBuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcmVxdWVzdF9zdHJlYW0sIHJlc3BvbnNlX3N0cmVhbSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBNZXRob2QuY2FsbCh0aGlzLCBidWlsZGVyLCBzdmMsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlNlcnZpY2UuUlBDTWV0aG9kXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVxdWVzdCBtZXNzYWdlIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE5hbWUgPSByZXF1ZXN0O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZU5hbWUgPSByZXNwb25zZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdF9zdHJlYW07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlU3RyZWFtID0gcmVzcG9uc2Vfc3RyZWFtO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHJlcXVlc3QgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIG1lc3NhZ2UgdHlwZS5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRXh0ZW5kcyBNZXRob2RcclxuICAgICAgICBSUENNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXRob2QucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCA9IFJQQ01ldGhvZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Q7XHJcblxyXG4gICAgfSkoUHJvdG9CdWYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuQnVpbGRlciA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZywgUmVmbGVjdCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ1aWxkZXIuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICAgICAqIEBjbGFzcyBQcm92aWRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBidWlsZCBwcm90b2NvbCBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJ1aWxkZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubnMgPSBuZXcgUmVmbGVjdC5OYW1lc3BhY2UodGhpcywgbnVsbCwgXCJcIik7IC8vIEdsb2JhbCBuYW1lc3BhY2VcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UgcG9pbnRlci5cclxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgYnVpbGRpbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfE9iamVjdD58bnVsbH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmlsZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbXBvcnQgcm9vdCBvdmVycmlkZS5cclxuICAgICAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJ1aWxkZXJQcm90b3R5cGUgPSBCdWlsZGVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gRGVmaW5pdGlvbiB0ZXN0cyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzTWVzc2FnZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgZG8gbm90IGNvbnRhaW4gdmFsdWVzIChlbnVtKSBvciBycGMgbWV0aG9kcyAoc2VydmljZSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkZWZbXCJycGNcIl0gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgbWVzc2FnZSBmaWVsZC5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2UgZmllbGRzIHJlcXVpcmUgYSBzdHJpbmcgcnVsZSwgbmFtZSBhbmQgdHlwZSBhbmQgYW4gaWRcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJydWxlXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInR5cGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJpZFwiXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYW4gZW51bS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzRW51bSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gRW51bXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gPT09ICd1bmRlZmluZWQnIHx8ICFBcnJheS5pc0FycmF5KGRlZltcInZhbHVlc1wiXSkgfHwgZGVmW1widmFsdWVzXCJdLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhIHNlcnZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5pc1NlcnZpY2UgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgLy8gU2VydmljZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lIGFuZCBhbiBycGMgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ29iamVjdCcgfHwgIWRlZltcInJwY1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhbiBleHRlbmRlZCBtZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5pc0V4dGVuZCA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIHJxdWlyZSBhIHN0cmluZyByZWZcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJyZWZcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBCdWlsZGluZyAtLS0tLVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIHBvaW50ZXIgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5ucztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBhIG5hbWVzcGFjZSBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgcGxhY2VzIHRoZSBwb2ludGVyIG9uIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2VcclxuICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KG5hbWVzcGFjZSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbmFtZXNwYWNlOiBcIituYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICBuYW1lc3BhY2Uuc3BsaXQoXCIuXCIpLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5zID0gdGhpcy5wdHIuZ2V0Q2hpbGQocGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnMgPT09IG51bGwpIC8vIEtlZXAgZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChucyA9IG5ldyBSZWZsZWN0Lk5hbWVzcGFjZSh0aGlzLCB0aGlzLnB0ciwgcGFydCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBucztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhlIHNwZWNpZmllZCBkZWZpbml0aW9ucyBhdCB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjwhT2JqZWN0Pn0gZGVmcyBNZXNzYWdlcywgZW51bXMgb3Igc2VydmljZXMgdG8gY3JlYXRlXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgbWVzc2FnZSBkZWZpbml0aW9uIGlzIGludmFsaWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZWZzKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmcylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVmcykpXHJcbiAgICAgICAgICAgICAgICBkZWZzID0gW2RlZnNdO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBkZWZzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEl0J3MgcXVpdGUgaGFyZCB0byBrZWVwIHRyYWNrIG9mIHNjb3BlcyBhbmQgbWVtb3J5IGhlcmUsIHNvIGxldCdzIGRvIHRoaXMgaXRlcmF0aXZlbHkuXHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtkZWZzXTtcclxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVmcykpIC8vIFN0YWNrIGFsd2F5cyBjb250YWlucyBlbnRpcmUgbmFtZXNwYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGEgdmFsaWQgbmFtZXNwYWNlOiBcIitKU09OLnN0cmluZ2lmeShkZWZzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRlZnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzLnNoaWZ0KCk7IC8vIE5hbWVzcGFjZXMgYWx3YXlzIGNvbnRhaW4gYW4gYXJyYXkgb2YgbWVzc2FnZXMsIGVudW1zIGFuZCBzZXJ2aWNlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnVpbGRlci5pc01lc3NhZ2UoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gbmV3IFJlZmxlY3QuTWVzc2FnZSh0aGlzLCB0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSwgZGVmW1wiaXNHcm91cFwiXSwgZGVmW1wic3ludGF4XCJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBPbmVPZnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZW9mcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wib25lb2ZzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmW1wib25lb2ZzXCJdKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQob25lb2ZzW25hbWVdID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5PbmVPZih0aGlzLCBvYmosIG5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZmllbGRzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZmllbGRzXCJdLmZvckVhY2goZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5nZXRDaGlsZChmbGRbXCJpZFwiXXwwKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgb3IgaW52YWxpZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxkW1wib3B0aW9uc1wiXSAmJiB0eXBlb2YgZmxkW1wib3B0aW9uc1wiXSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBvcHRpb25zIGluIFwiK29iai5uYW1lK1wiI1wiK2ZsZFtcIm5hbWVcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmVvZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGRbXCJvbmVvZlwiXSA9PT0gJ3N0cmluZycgJiYgIShvbmVvZiA9IG9uZW9mc1tmbGRbXCJvbmVvZlwiXV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb25lb2YgaW4gXCIrb2JqLm5hbWUrXCIjXCIrZmxkW1wibmFtZVwiXStcIjogXCIrZmxkW1wib25lb2ZcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZCA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQodGhpcywgb2JqLCBmbGRbXCJydWxlXCJdLCBmbGRbXCJrZXl0eXBlXCJdLCBmbGRbXCJ0eXBlXCJdLCBmbGRbXCJuYW1lXCJdLCBmbGRbXCJpZFwiXSwgZmxkW1wib3B0aW9uc1wiXSwgb25lb2YsIGRlZltcInN5bnRheFwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZW9mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVvZi5maWVsZHMucHVzaChmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChmbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGNoaWxkcmVuIHRvIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJPYmogPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImVudW1zXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZW51bXNcIl0uZm9yRWFjaChmdW5jdGlvbihlbm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChlbm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJtZXNzYWdlc1wiXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcIm1lc3NhZ2VzXCJdLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2gobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wic2VydmljZXNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJzZXJ2aWNlc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKHN2Yykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKHN2Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBleHRlbnNpb24gcmFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJleHRlbnNpb25zXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImV4dGVuc2lvbnNcIl1bMF0gPT09ICdudW1iZXInKSAvLyBwcmUgNS4wLjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFsgZGVmW1wiZXh0ZW5zaW9uc1wiXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zID0gZGVmW1wiZXh0ZW5zaW9uc1wiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9uIHRvcCBvZiBjdXJyZW50IG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViT2JqLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZGVmcyk7IC8vIFB1c2ggdGhlIGN1cnJlbnQgbGV2ZWwgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcyA9IHN1Yk9iajsgLy8gQ29udGludWUgcHJvY2Vzc2luZyBzdWIgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG9iajsgLy8gQW5kIG1vdmUgdGhlIHBvaW50ZXIgdG8gdGhpcyBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNFbnVtKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LkVudW0odGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0sIGRlZltcInN5bnRheFwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcInZhbHVlc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0LkVudW0uVmFsdWUodGhpcywgb2JqLCB2YWxbXCJuYW1lXCJdLCB2YWxbXCJpZFwiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzU2VydmljZShkZWYpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5TZXJ2aWNlKHRoaXMsIHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmW1wicnBjXCJdKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdGQgPSBkZWZbXCJycGNcIl1bbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuU2VydmljZS5SUENNZXRob2QodGhpcywgb2JqLCBuYW1lLCBtdGRbXCJyZXF1ZXN0XCJdLCBtdGRbXCJyZXNwb25zZVwiXSwgISFtdGRbXCJyZXF1ZXN0X3N0cmVhbVwiXSwgISFtdGRbXCJyZXNwb25zZV9zdHJlYW1cIl0sIG10ZFtcIm9wdGlvbnNcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc0V4dGVuZChkZWYpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLnB0ci5yZXNvbHZlKGRlZltcInJlZlwiXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcImZpZWxkc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGZsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZ2V0Q2hpbGQoZmxkWydpZCddfDApICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBleHRlbmRlZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmaWVsZCBpZCBpcyBhbGxvd2VkIHRvIGJlIGV4dGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5leHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxkW1wiaWRcIl0gPj0gcmFuZ2VbMF0gJiYgZmxkW1wiaWRcIl0gPD0gcmFuZ2VbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBleHRlbmRlZCBmaWVsZCBpZCBpbiBcIitvYmoubmFtZStcIjogXCIrZmxkWydpZCddK1wiIChub3Qgd2l0aGluIHZhbGlkIHJhbmdlcylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZXh0ZW5zaW9uIGZpZWxkIG5hbWVzIHRvIGNhbWVsIGNhc2Ugbm90YXRpb24gaWYgdGhlIG92ZXJyaWRlIGlzIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZmxkW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFByb3RvQnVmLlV0aWwudG9DYW1lbENhc2UobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlICMxNjE6IEV4dGVuc2lvbnMgdXNlIHRoZWlyIGZ1bGx5IHF1YWxpZmllZCBuYW1lIGFzIHRoZWlyIHJ1bnRpbWUga2V5IGFuZC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQodGhpcywgb2JqLCBmbGRbXCJydWxlXCJdLCBmbGRbXCJ0eXBlXCJdLCB0aGlzLnB0ci5mcW4oKSsnLicrbmFtZSwgZmxkW1wiaWRcIl0sIGZsZFtcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmFyZSBhZGRlZCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgbmFtZXNwYWNlIGFzIGFuIGV4dGVuc2lvbiB3aGljaCBpcyB1c2VkIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmluZyB0aGVpciB0eXBlIGxhdGVyIG9uICh0aGUgZXh0ZW5zaW9uIGFsd2F5cyBrZWVwcyB0aGUgb3JpZ2luYWwgbmFtZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbmFtaW5nIGNvbGxpc2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dCA9IG5ldyBSZWZsZWN0LkV4dGVuc2lvbih0aGlzLCB0aGlzLnB0ciwgZmxkW1wibmFtZVwiXSwgZmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmV4dGVuc2lvbiA9IGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIS9cXC4/Z29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QoZGVmW1wicmVmXCJdKSkgLy8gU2lsZW50bHkgc2tpcCBpbnRlcm5hbCBleHRlbnNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImV4dGVuZGVkIG1lc3NhZ2UgXCIrZGVmW1wicmVmXCJdK1wiIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgYSB2YWxpZCBkZWZpbml0aW9uOiBcIitKU09OLnN0cmluZ2lmeShkZWYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgZ29lcyBoZXJlXHJcbiAgICAgICAgICAgICAgICBkZWZzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5wdHIucGFyZW50OyAvLyBOYW1lc3BhY2UgZG9uZSwgY29udGludWUgYXQgcGFyZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlOyAvLyBSZXF1aXJlIHJlLXJlc29sdmVcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BhZ2F0ZXMgc3ludGF4IHRvIGFsbCBjaGlsZHJlbi5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IHBhcmVudFxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVN5bnRheChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFsnbWVzc2FnZXMnXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50WydtZXNzYWdlcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFtcInN5bnRheFwiXSA9IHBhcmVudFtcInN5bnRheFwiXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVTeW50YXgoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudFsnZW51bXMnXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50WydlbnVtcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFtcInN5bnRheFwiXSA9IHBhcmVudFtcInN5bnRheFwiXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBvcnRzIGFub3RoZXIgZGVmaW5pdGlvbiBpbnRvIHRoaXMgYnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIFBhcnNlZCBpbXBvcnRcclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBJbXBvcnRlZCBmaWxlIG5hbWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gb3IgZmlsZSBjYW5ub3QgYmUgaW1wb3J0ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZVtcImltcG9ydFwiXSA9IGZ1bmN0aW9uKGpzb24sIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxpbSA9ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBza2lwIGR1cGxpY2F0ZSBpbXBvcnRzXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLklTX05PREUpXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZXF1aXJlKFwicGF0aFwiKVsncmVzb2x2ZSddKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlc1tmaWxlbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7IC8vIE9iamVjdCB3aXRoIHJvb3QsIGZpbGUuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBmaWxlbmFtZS5yb290O1xyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gcmVxdWlyZShcInBhdGhcIilbJ3Jlc29sdmUnXShyb290KTtcclxuICAgICAgICAgICAgICAgIGlmIChyb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuZmlsZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gcm9vdCArIGRlbGltICsgZmlsZW5hbWUuZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlc1tmbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbXBvcnQgaW1wb3J0c1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25bJ2ltcG9ydHMnXSAmJiBqc29uWydpbXBvcnRzJ10ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydFJvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRSb290ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gSWYgYW4gaW1wb3J0IHJvb3QgaXMgc3BlY2lmaWVkLCBvdmVycmlkZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBmaWxlbmFtZVtcInJvb3RcIl07IHJlc2V0Um9vdCA9IHRydWU7IC8vIC4uLiBhbmQgcmVzZXQgYWZ0ZXJ3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZVtcImZpbGVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydFJvb3QuaW5kZXhPZihcIlxcXFxcIikgPj0gMCB8fCBmaWxlbmFtZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICdcXFxcJztcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0Um9vdCkgLy8gSWYgaW1wb3J0IHJvb3QgaXMgb3ZlcnJpZGRlbiwgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIE90aGVyd2lzZSBjb21wdXRlIGZyb20gZmlsZW5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCIvXCIpID49IDApIHsgLy8gVW5peFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogL2ZpbGUucHJvdG8gKi8gaW1wb3J0Um9vdCA9PT0gXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gXCIvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMCkgeyAvLyBXaW5kb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXFteXFxcXF0qJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSAnXFxcXCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8anNvblsnaW1wb3J0cyddLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uWydpbXBvcnRzJ11baV0gPT09ICdzdHJpbmcnKSB7IC8vIEltcG9ydCBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0Um9vdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiY2Fubm90IGRldGVybWluZSBpbXBvcnQgcm9vdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydEZpbGVuYW1lID0ganNvblsnaW1wb3J0cyddW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0RmlsZW5hbWUgPT09IFwiZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBOb3QgbmVlZGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRSb290ICsgZGVsaW0gKyBpbXBvcnRGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbaW1wb3J0RmlsZW5hbWVdID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEFscmVhZHkgaW1wb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5wcm90byQvaS50ZXN0KGltcG9ydEZpbGVuYW1lKSAmJiAhUHJvdG9CdWYuRG90UHJvdG8pICAgICAgIC8vIElmIHRoaXMgaXMgYSBsaWdodCBidWlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRGaWxlbmFtZS5yZXBsYWNlKC9cXC5wcm90byQvLCBcIi5qc29uXCIpOyAvLyBhbHdheXMgbG9hZCB0aGUgSlNPTiBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2goaW1wb3J0RmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImZhaWxlZCB0byBpbXBvcnQgJ1wiK2ltcG9ydEZpbGVuYW1lK1wiJyBpbiAnXCIrZmlsZW5hbWUrXCInOiBmaWxlIG5vdCBmb3VuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5qc29uJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpKSAvLyBBbHdheXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oSlNPTi5wYXJzZShjb250ZW50cytcIlwiKSwgaW1wb3J0RmlsZW5hbWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucGFyc2UoY29udGVudHMpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBJbXBvcnQgc3RydWN0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZW5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9cXC4oXFx3KykkLy50ZXN0KGZpbGVuYW1lKSkgLy8gV2l0aCBleHRlbnNpb246IEFwcGVuZCBfaW1wb3J0TiB0byB0aGUgbmFtZSBwb3J0aW9uIHRvIG1ha2UgaXQgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUucmVwbGFjZSgvXiguKylcXC4oXFx3KykkLywgZnVuY3Rpb24oJDAsICQxLCAkMikgeyByZXR1cm4gJDErXCJfaW1wb3J0XCIraStcIi5cIiskMjsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIFdpdGhvdXQgZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gbWFrZSBpdCB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZStcIl9pbXBvcnRcIitpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNldFJvb3QpIC8vIFJlc2V0IGltcG9ydCByb290IG92ZXJyaWRlIHdoZW4gYWxsIGltcG9ydHMgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbXBvcnQgc3RydWN0dXJlc1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSk7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydzeW50YXgnXSlcclxuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVN5bnRheChqc29uKTtcclxuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLnB0cjtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ29wdGlvbnMnXSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb25bJ29wdGlvbnMnXSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLm9wdGlvbnNba2V5XSA9IGpzb25bJ29wdGlvbnMnXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydtZXNzYWdlcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnbWVzc2FnZXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydlbnVtcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZW51bXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydzZXJ2aWNlcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnc2VydmljZXMnXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydleHRlbmRzJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydleHRlbmRzJ10pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlcyBhbGwgbmFtZXNwYWNlIG9iamVjdHMuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjYW5ub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc29sdmUgYWxsIHJlZmxlY3RlZCBvYmplY3RzXHJcbiAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ciA9PSBudWxsIHx8IHR5cGVvZiB0aGlzLnB0ci50eXBlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBEb25lIChhbHJlYWR5IHJlc29sdmVkKVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpIHsgLy8gUmVzb2x2ZSBjaGlsZHJlblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucHRyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSB7IC8vIFJlc29sdmUgdHlwZVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodGhpcy5wdHIudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRoaXMucHRyLnR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9ICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA/IHRoaXMucHRyLmV4dGVuc2lvbi5wYXJlbnQgOiB0aGlzLnB0ci5wYXJlbnQpLnJlc29sdmUodGhpcy5wdHIudHlwZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuRW51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIuc3ludGF4ID09PSAncHJvdG8zJyAmJiByZXMuc3ludGF4ICE9PSAncHJvdG8zJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwicHJvdG8zIG1lc3NhZ2UgY2Fubm90IHJlZmVyZW5jZSBwcm90bzIgZW51bVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gcmVzLmlzR3JvdXAgPyBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdIDogUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSBQcm90b0J1Zi5UWVBFU1t0aGlzLnB0ci50eXBlXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbWFwIGZpZWxkLCBhbHNvIHJlc29sdmUgdGhlIGtleSB0eXBlLiBUaGUga2V5IHR5cGUgY2FuIGJlIG9ubHkgYSBudW1lcmljLCBzdHJpbmcsIG9yIGJvb2wgdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4sIG5vIGVudW1zIG9yIG1lc3NhZ2VzKSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGFnYWluc3QgdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodGhpcy5wdHIua2V5VHlwZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBrZXkgdHlwZSBmb3IgbWFwIGZpZWxkIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci5rZXlUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5rZXlUeXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIua2V5VHlwZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnB0ci5wYXJlbnQucmVzb2x2ZSh0aGlzLnB0ci5yZXF1ZXN0TmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlcXVlc3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlcXVlc3RUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlc3BvbnNlTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlc3BvbnNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYXMgbm90aGluZyBlbHNlIGlzIGltcGxlbWVudGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHNlcnZpY2UgdHlwZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZikgJiYgLy8gTm90IGJ1aWx0XHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb24pICYmIC8vIE5vdCBidWlsdFxyXG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZSkgLy8gQnVpbHQgaW4gZW51bVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb2JqZWN0IGluIG5hbWVzcGFjZTogXCIrdHlwZW9mKHRoaXMucHRyKStcIjogXCIrdGhpcy5wdHIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhlIHByb3RvY29sLiBUaGlzIHdpbGwgZmlyc3QgdHJ5IHRvIHJlc29sdmUgYWxsIGRlZmluaXRpb25zIGFuZCwgaWYgdGhpcyBoYXMgYmVlbiBzdWNjZXNzZnVsLFxyXG4gICAgICAgICAqIHJldHVybiB0aGUgYnVpbHQgcGFja2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pPX0gcGF0aCBTcGVjaWZpZXMgd2hhdCB0byByZXR1cm4uIElmIG9taXR0ZWQsIHRoZSBlbnRpcmUgbmFtZXNwYWNlIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHR5cGUgY291bGQgbm90IGJlIHJlc29sdmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQWxsKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQgPT09IG51bGwpIC8vIChSZS0pQnVpbGRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5ucy5idWlsZCgpO1xyXG4gICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gcGF0aC5zcGxpdChcIi5cIikgOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yZXN1bHQ7IC8vIEJ1aWxkIG5hbWVzcGFjZSBwb2ludGVyIChubyBoYXNDaGlsZCBldGMuKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFydC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChwdHJbcGFydFtpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyW3BhcnRbaV1dO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW1pbGFyIHRvIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyI2J1aWxkfSwgYnV0IGxvb2tzIHVwIHRoZSBpbnRlcm5hbCByZWZsZWN0aW9uIGRlc2NyaXB0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lpbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMgbGlrZSBmaWVsZHMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJucyB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gUmVmbGVjdGlvbiBkZXNjcmlwdG9yIG9yIGBudWxsYCBpZiBub3QgZm91bmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHBhdGgsIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPyB0aGlzLm5zLnJlc29sdmUocGF0aCwgZXhjbHVkZU5vbk5hbWVzcGFjZSkgOiB0aGlzLm5zO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJCdWlsZGVyXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJCdWlsZGVyXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gQmFzZSBjbGFzc2VzIC0tLS0tXHJcbiAgICAgICAgLy8gRXhpc3QgZm9yIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYmVpbmcgYWJsZSB0byBcIi4uLiBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVwiIGV0Yy5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuTWVzc2FnZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLkVudW1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLkVudW0gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5TZXJ2aWNlID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEJ1aWxkZXI7XHJcblxyXG4gICAgfSkoUHJvdG9CdWYsIFByb3RvQnVmLkxhbmcsIFByb3RvQnVmLlJlZmxlY3QpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLk1hcFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NYXAgPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFJlZmxlY3QpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNYXAuIEEgTWFwIGlzIGEgY29udGFpbmVyIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgbWFwXHJcbiAgICAgICAgICogZmllbGRzIG9uIG1lc3NhZ2Ugb2JqZWN0cy4gSXQgY2xvc2VseSBmb2xsb3dzIHRoZSBFUzYgTWFwIEFQSTsgaG93ZXZlcixcclxuICAgICAgICAgKiBpdCBpcyBkaXN0aW5jdCBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBleHRlcm5hbCBwb2x5ZmlsbHMgb3JcclxuICAgICAgICAgKiBvbiBFUzYgaXRzZWxmLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuTWFwXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH0gZmllbGQgTWFwIGZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IGNvbnRlbnRzIEluaXRpYWwgY29udGVudHNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTWFwID0gZnVuY3Rpb24oZmllbGQsIGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghZmllbGQubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJmaWVsZCBpcyBub3QgYSBtYXBcIik7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZpZWxkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtYXAuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8ga2V5IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FbGVtZW50fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC5rZXlUeXBlLCBudWxsLCB0cnVlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnQgaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRWxlbWVudH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC50eXBlLCBmaWVsZC5yZXNvbHZlZFR5cGUsIGZhbHNlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVybmFsIG1hcDogc3RvcmVzIG1hcHBpbmcgb2YgKHN0cmluZyBmb3JtIG9mIGtleSkgLT4gKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgICAqIHBhaXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFdlIHByb3ZpZGUgbWFwIHNlbWFudGljcyBmb3IgYXJiaXRyYXJ5IGtleSB0eXBlcywgYnV0IHdlIGJ1aWxkIG9uIHRvcFxyXG4gICAgICAgICAgICAgKiBvZiBhbiBPYmplY3QsIHdoaWNoIGhhcyBvbmx5IHN0cmluZyBrZXlzLiBJbiBvcmRlciB0byBhdm9pZCB0aGUgbmVlZFxyXG4gICAgICAgICAgICAgKiB0byBjb252ZXJ0IGEgc3RyaW5nIGtleSBiYWNrIHRvIGl0cyBuYXRpdmUgdHlwZSBpbiBtYW55IHNpdHVhdGlvbnMsXHJcbiAgICAgICAgICAgICAqIHdlIHN0b3JlIHRoZSBuYXRpdmUga2V5IHZhbHVlIGFsb25nc2lkZSB0aGUgdmFsdWUuIFRodXMsIHdlIG9ubHkgbmVlZFxyXG4gICAgICAgICAgICAgKiBhIG9uZS13YXkgbWFwcGluZyBmcm9tIGEga2V5IHR5cGUgdG8gaXRzIHN0cmluZyBmb3JtIHRoYXQgZ3VhcmFudGVlc1xyXG4gICAgICAgICAgICAgKiB1bmlxdWVuZXNzIGFuZCBlcXVhbGl0eSAoaS5lLiwgc3RyKEsxKSA9PT0gc3RyKEsyKSBpZiBhbmQgb25seSBpZiBLMVxyXG4gICAgICAgICAgICAgKiA9PT0gSzIpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHtrZXk6ICosIHZhbHVlOiAqfT59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApLmxlbmd0aDsgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgaW5pdGlhbCBjb250ZW50cyBmcm9tIGEgcmF3IG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUVsZW0udmFsdWVGcm9tU3RyaW5nKGtleXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlRWxlbS52ZXJpZnlWYWx1ZShjb250ZW50c1trZXlzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcoa2V5KV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleToga2V5LCB2YWx1ZTogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGVscGVyOiByZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciBhbiBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyIHRoZSBhcnJheVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBhbiBpdGVyYXRvclxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5SXRlcmF0b3IoYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IGFyci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYXJyW2lkeCsrXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBtYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHBhcnRpY3VsYXIga2V5IGZyb20gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBhbnkgZW50cnkgd2l0aCB0aGlzIGtleSB3YXMgZGVsZXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICB2YXIgaGFkS2V5ID0ga2V5VmFsdWUgaW4gdGhpcy5tYXA7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXlWYWx1ZV07XHJcbiAgICAgICAgICAgIHJldHVybiBoYWRLZXk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIFtrZXksIHZhbHVlXSBwYWlycyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpdGVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKFsoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLmtleSwgZW50cnkudmFsdWVdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5SXRlcmF0b3IoZW50cmllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIGtleXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaXRlcmF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc3RyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKHRoaXMubWFwW3N0cktleXNbaV1dLmtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKGtleXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB2YWx1ZXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH0gVGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLm1hcFtzdHJLZXlzW2ldXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKHZhbHVlcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRlcmF0ZXMgb3ZlciBlbnRyaWVzIGluIHRoZSBtYXAsIGNhbGxpbmcgYSBmdW5jdGlvbiBvbiBlYWNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczoqLCAqLCAqLCAqKX0gY2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHZhbHVlLCBrZXksIGFuZCBtYXAgYXJndW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gdGhpc0FyZyBUaGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCAoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYSBrZXkgaW4gdGhlIG1hcCB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5NYXB9IFRoZSBtYXAgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KTtcclxuICAgICAgICAgICAgdmFyIHZhbFZhbHVlID0gdGhpcy52YWx1ZUVsZW0udmVyaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFt0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyhrZXlWYWx1ZSldID1cclxuICAgICAgICAgICAgICAgIHsga2V5OiBrZXlWYWx1ZSwgdmFsdWU6IHZhbFZhbHVlIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBUaGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGtleSBub3QgcHJlc2VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICBpZiAoIShrZXlWYWx1ZSBpbiB0aGlzLm1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5VmFsdWVdLnZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUga2V5IGlzIHByZXNlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChrZXlWYWx1ZSBpbiB0aGlzLm1hcCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5SZWZsZWN0KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5wcm90byBzdHJpbmcgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gLnByb3RvIGZpbGUgY29udGVudHNcclxuICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkUHJvdG8gPSBmdW5jdGlvbihwcm90bywgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcixcclxuICAgICAgICAgICAgYnVpbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gUHJvdG9CdWYubG9hZEpzb24oUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnBhcnNlKHByb3RvKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLnByb3RvIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIC5wcm90byBmaWxlIGNvbnRlbnRzXHJcbiAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZyk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLnByb3RvRnJvbVN0cmluZyA9IFByb3RvQnVmLmxvYWRQcm90bzsgLy8gTGVnYWN5XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBwcm90byBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrLCBidWlsZGVyKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIGJ1aWxkZXIgPSBjYWxsYmFjayxcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBmaWxlXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRQcm90byhjb250ZW50cywgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSAucHJvdG8gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvRmlsZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8gcHJvdG8gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYucHJvdG9Gcm9tRmlsZSA9IFByb3RvQnVmLmxvYWRQcm90b0ZpbGU7IC8vIExlZ2FjeVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgZW1wdHkgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIEJ1aWxkZXIgb3B0aW9ucywgZGVmYXVsdHMgdG8gZ2xvYmFsIG9wdGlvbnMgc2V0IG9uIFByb3RvQnVmXHJcbiAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5uZXdCdWlsZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBvcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSA9IFByb3RvQnVmLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbJ3BvcHVsYXRlQWNjZXNzb3JzJ10gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBvcHRpb25zWydwb3B1bGF0ZUFjY2Vzc29ycyddID0gUHJvdG9CdWYucG9wdWxhdGVBY2Nlc3NvcnM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5CdWlsZGVyKG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgLmpzb24gZGVmaW5pdGlvbiBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7ISp8c3RyaW5nfSBqc29uIEpTT04gZGVmaW5pdGlvblxyXG4gICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRKc29uID0gZnVuY3Rpb24oanNvbiwgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcixcclxuICAgICAgICAgICAgYnVpbGRlciA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFidWlsZGVyIHx8IHR5cGVvZiBidWlsZGVyICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgYnVpbGRlciA9IFByb3RvQnVmLm5ld0J1aWxkZXIoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICBidWlsZGVyW1wiaW1wb3J0XCJdKGpzb24sIGZpbGVuYW1lKTtcclxuICAgICAgICBidWlsZGVyLnJlc29sdmVBbGwoKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5qc29uIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3whe3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBqc29uIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLmxvYWRKc29uRmlsZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBjYWxsYmFjaywgYnVpbGRlcikge1xyXG4gICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICBlbHNlIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnID8gZmlsZW5hbWUgOiBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdLCBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZmlsZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZEpzb24oSlNPTi5wYXJzZShjb250ZW50cyksIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb3RvQnVmO1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==